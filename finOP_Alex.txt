OPCODES DONE BY ALEX:

*-----------------------------------------------------------
* Title      :	Motorola 68k Disassembler
* Written by :  Abdul Hakim, David Trinh, Alexander Auxier
* Date       :
* Description:
*-----------------------------------------------------------
CR          EQU     $0D     
LF          EQU     $0A
  
test_start  EQU     $00003000   ; defined starting address
test_end    EQU     $00003009   ; defined ending address
     
zero        EQU     $00         ; defined hex value 0
one         EQU     $01         ; defined hex value 1 
two         EQU     $02         ; defined hex value 2
three       EQU     $03         ; defined hex value 3
four        EQU     $04         ; defined hex value 4
five        EQU     $05         ; defined hex value 5
six         EQU     $06         ; defined hex value 6
seven       EQU     $07
eight       EQU     $08         ; defined hex value 8
nine        EQU     $09         ; defined hex value 9
eleven      EQU     $0B         ; defined hex value 11
twelve      EQU     $0C         ; defined hex value 12
thirteen    EQU     $0D         ; defined hex value 13
fourteen    EQU     $0E         ; defined hex value 14

s1B         EQU     %0000       ; byte size 1 
s1W         EQU     %0001       ; word size 1
s1L         EQU     %0010       ; long size 1

s2W         EQU     %0000       ; word size 2
s2L         EQU     %0001       ; long size 2

s3B         EQU     %0001       ; byte size 3
s3W         EQU     %0011       ; word size 3
s3L         EQU     %0010       ; long size 3

addMatchDn  EQU     %0000       ; Address Mode Data Register
addMatchAn  EQU     %0001       ; Address Mode Address Register
addMatchAd  EQU     %0010       ; Address Mode Address
addMatchPi  EQU     %0011       ; Address Mode with PostIncrement
addMatchPd  EQU     %0100       ; Address Mode with PreDecrement
addMatchDi  EQU     %0111       ; Address Mode for Word, Long, or Immediate 

reg0        EQU     %0000       ; register 0
reg1        EQU     %0001       ; register 1
reg2        EQU     %0010       ; register 2
reg3        EQU     %0011       ; register 3
reg4        EQU     %0100       ; register 4
reg5        EQU     %0101       ; register 5
reg6        EQU     %0110       ; register 6
reg7        EQU     %0111       ; register 7

firstNib    EQU     $F0
secNib      EQU     $0F
             
            ORG    $1000
START:                                  ; first instruction of program
      
        MOVEA.L     #test_start, A0     ; load starting address
        MOVEA.L     #test_end, A2       ; load ending address
          
LOOP    CLR         D1                  ; clear out D1
        CLR         D2                  ; clear out D2
        CMPA.L      A2, A0              ; compare starting and ending addresses
        BGT         endProg             ; if A0 > A1, we've finished, end program
        MOVE.B      (A0)+, D1           ; load byte to D1 and increment A0 to next byte
        MOVE.B      D1, D2              ; copy byte to D2 for manipulation
        ASR.L       #four, D2           ; get first nibble in D2
        
        CMP.B       #zero, D2           ; compare with 0
        BEQ         braZero             ; branch out to zero method
        CMP.B       #one, D2            ; compare with 1
        BEQ         braOne              ; branch out to one method
        CMP.B       #two, D2            ; compare with 2    
        BEQ         braTwo              ; branch out to two method
        CMP.B       #three, D2          ; compare with 3
        BEQ         braThree            ; branch out to three method
        CMP.B       #four, D2           ; compare with 4
        BEQ         braFour             ; branch out to four method
        CMP.B       #five, D2           ; compare with 5
        BEQ         braFive             ; branch out to five method
        CMP.B       #six, D2            ; compare with 6
        BEQ         braSix              ; branch out to six method
        CMP.B       #eight, D2          ; compare with 8
        BEQ         braEight            ; branch out to eight method
        CMP.B       #nine, D2           ; compare with 9
        BEQ         braNine             ; branch out to nine method
        CMP.B       #eleven, D2         ; compare with 11
        BEQ         braEleven           ; branch out to eleven method
        CMP.B       #twelve, D2         ; compare with 12
        BEQ         braTwelve           ; branch out to twelve method
        CMP.B       #thirteen, D2       ; compare with 13
        BEQ         braThirteen         ; branch out to thirteen method
        CMP.B       #fourteen, D2       ; compare with 14
        BEQ         braFourteen         ; branch out to fourteen method
        BRA         loop

braZero CLR         D2                  ; first nibble is 0, 3 opcodes are possible 
        MOVE.B      D1, D2              ; clear out D2 and copy D1 back in
        AND.B       #secNib, D2             ; set first nibble to 0
 
        CMP.B       #zero, D2           ; compare second nibble to 0
        BEQ         opORI               ; branch to ORI method
        CMP.B       #twelve, D2         ; compare second nibble to 12
        BEQ         opCMPI              ; branch to CMPI method
        CMP.B       #eight,D2           ; Test for static BCLR
        BEQ         opBCLR
        AND         #one,D2            ; Sets all bits to 0 except for first bit if it is 1
        CMP.B       #one,D2          ; if it is one then there is a chance it is dynamic BCLR
        BEQ         opDynBCLR
        BRA         printInvalid
        
        
braOne  BRA         opMOVEB             ; we know that there is only one opcode that is MOVE.B

braTwo  BRA         opMOVEL             ; there are two opCodes available, MOVE.L, or MOVEA.L

braThree                                ; there are two opCodes available, MOVE.W, or MOVEA.W

        BRA         opMOVEW

braFour CLR         D2                  ; first nibble is 4, 5 opcodes are possible 
        MOVE.B      D1, D2              ; clear out D2 and copy D1 back in
        AND.B       #secNib, D2             ; set first nibble to 0
 
        CMP.B       #four, D2           ; compare second nibble to 4
        BEQ         opNEG               ; branch to NEG method
        CMP.B       #fourteen, D2       ; compare second nibble to E
        BEQ         opRTSJSR            ; branch to JSR or RTS method
        BRA         opMOVEMLEA          ; otherwise, branch to MOVEM or LEA method

braFive BRA         opSUBQ              ; we know that there is only one opcode that is SUBQ

braSix  CLR         D2                  ; first nibble is 6, 5 opcodes are possible 
        MOVE.B      D1, D2              ; clear out D2 and copy D1 back in
        AND.B       #$0F, D2             ; set first nibble to 0
 
        CMP.B       #zero, D2           ; compare second nibble to 0
        BEQ         opBRA               ; branch to BRA method
        CMP.B       #five, D2           ; compare second nibble to 5
        BEQ         opBCS               ; branch to BCS method
        CMP.B       #eight, D2          ; compare second nibble to 8
        BEQ         opBVC               ; branch to BCS method
        CMP.B       #twelve, D2         ; compare second nibble to 12
        BEQ         opBGE               ; branch to BGE method
        BRA         opBLT               ; otherwise, branch to BLT method

braEight								; there are two opCodes available DIVS, or OR
			CLR 	D2
			ASL		#8,D1
			MOVE.B	(A0)+,D1
			MOVE.W	D1,D2
			ASR		#six,D2
			AND		#$07,D2
			CMP.B	#seven,D2
			BEQ		opDIVS				; If bits 8 - 6 are equal to 7, we have DIVS
			BRA		opOR				; else opcode is OR

braNine BRA         opSUB               ; we know that there is only one opcode that is SUB

braEleven   							; there are two opCodes available EOR, or CMP
			CLR 	D2
			ASL		#8,D1
			MOVE.B	(A0)+,D1
			MOVE.W	D1,D2
			ASR		#six,D2
			AND		#$07,D2
			CMP.B	#three,D2
			BLT		opCMP				; If opmode bits are less than 3, we have CMP
			BRA		opEOR				; Else its EOR
			

braTwelve   BRA     opMULS              ; we know that there is only one opcode that is MULS    
  
braThirteen ; there are two opCodes available ADD, or ADDA

braFourteen CLR         D2                  ; first nibble is E, 5 opcodes are possible 
            MOVE.B      D1, D2              ; clear out D2 and copy D1 back in
            AND.B       $0F, D2             ; set first nibble to 0
 
            CMP.B       #zero, D2           ; compare second nibble to 0
            BEQ         opASR               ; branch to ASR method
            CMP.B       #one, D2            ; compare second nibble to 1
            BEQ         opASL               ; branch to ASL method
            CMP.B       #two, D2            ; compare second nibble to 2
            BEQ         opLSR               ; branch to LSR method
            CMP.B       #three, D2          ; compare second nibble to 3
            BEQ         opLSL               ; branch to LSL method
            CMP.B       #six, D2            ; compare second nibble to 6
            BEQ         opROR               ; branch to ROR method
            BRA         opROL               ; otherwise, branch to ROL method
			
			
			
		***********************************************************************************************************
*
*				OR OPCODE
*
***********************************************************************************************************

opOR		LEA			ORmatch,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			CLR			D2
			; These are for EA to Dn direction
			CMP.B		#zero,D2
			BEQ			opORB				; Byte in opmode
			CMP.B		#one,D2
			BEQ			opORW				; Word in opmode
			CMP.B		#two,D2
			BEQ			opORL				; Long in opmode
			
			; These are for Dn to EA direction
			CMP.B		#four,D2
			BEQ			opORB				; Byte in opmode
			CMP.B		#five,D2
			BEQ			opORW				; Word in opmode
			CMP.B		#six,D2
			BEQ			opORL				; Long in opmode
			
opORB		LEA			dispByte,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			LEA         space, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			

			MOVE.B		D1,D2
			ASR			#3,D2
			AND			#$07,D2
			MOVE.B		D1,D3
			AND			#$07,D3
			JSR			printEA			; Determines the "left" operand register
			
			LEA         comma, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			
			CLR			D2
			MOVE.W		D1,D3
			ASR			#eight,D3
			ASR			#one,D3
			AND			#$07,D3
			JSR			printEA
			
			LEA			newLine,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			BRA			LOOP
			
			
opORW		LEA			dispWord,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			LEA         space, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			
			CLR			D2
			MOVE.B		D1,D2
			ASR			#3,D2
			AND			#$07,D2
			MOVE.B		D1,D3
			AND			#$07,D3
			JSR			printEA			; Determines the "left" operand register
			
			LEA         comma, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			
			CLR			D2
			MOVE.W		D1,D3
			ASR			#eight,D3
			ASR			#one,D3
			AND			#$07,D3
			JSR			printEA
			
			LEA			newLine,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			BRA			LOOP
			
opORL		LEA			dispLong,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			LEA         space, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			
			MOVE.B		D1,D2
			ASR			#3,D2
			AND			#$07,D2
			MOVE.B		D1,D3
			AND			#$07,D3
			JSR			printEA			; Determines the "left" operand register
			
			LEA         comma, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			
			CLR			D2
			MOVE.W		D1,D3
			ASR			#eight,D3
			ASR			#one,D3
			AND			#$07,D3
			JSR			printEA
			
			LEA			newLine,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			BRA			LOOP			; trap call
			
			BRA			LOOP			; DOUBLE CHECK THIS AGAIN AFTER MORE TESTING ALEX
			
***********************************************************************************************************
*
*				DIVS OPCODE
*
***********************************************************************************************************

opDIVS		LEA		DIVSmatch,A1
			MOVE.B	#14,D0
			TRAP	#15
			
			LEA         space, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			
			MOVE.B		D1,D2
			ASR			#3,D2
			AND			#$07,D2
			MOVE.B		D1,D3
			AND			#$07,D3
			JSR			printEA
			
			LEA         comma, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			
			CLR			D2
			MOVE.W		D1,D3
			ASR			#eight,D3
			ASR			#one,D3
			AND			#$07,D3
			JSR			printEA
			
			LEA			newLine,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			BRA			LOOP
	
			BRA		LOOP
			
**********************************************************************************************************
*
*				EOR OPCODE
*
***********************************************************************************************************

opEOR		LEA 		EORmatch,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			CLR			D2
			
			MOVE.B		D1,D2
			ASR			#seven,D2			; Move bits 7 places over to find opmode
			AND			#$07,D2
			CMP.B		#five,D2
			BLT			opEORB				; Byte in opmode
			CMP.B		#five,D2
			BEQ			opEORW				; Word in opmode
			CMP.B		#five,D2
			BGT			opEORL				; Long in opmode
			
opEORB		LEA			dispByte,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			LEA         space, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			
			CLR			D2
			CLR			D3
			MOVE.W		D1,D3
			ASR			#eight,D3
			ASR			#one,D3
			AND			#$07,D3
			JSR			printEA
			
			LEA         comma, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			
			CLR			D2
			CLR			D3
			MOVE.B		D1,D2
			ASR			#three,D2
			AND			#seven,D2
			MOVE.B		D1,D3
			AND			#$07,D3
			JSR			printEA			; Determines the "left" operand register
			
			LEA			newLine,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			BRA			LOOP
			
			
opEORW		LEA			dispWord,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			LEA         space, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			
			CLR			D2
			CLR			D3
			MOVE.W		D1,D3
			ASR			#eight,D3
			ASR			#one,D3
			AND			#$07,D3
			JSR			printEA
			
			LEA         comma, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			
			CLR			D2
			CLR			D3
			MOVE.B		D1,D2
			ASR			#three,D2
			AND			#seven,D2
			MOVE.B		D1,D3
			AND			#$07,D3
			JSR			printEA			; Determines the "left" operand register
			
			LEA			newLine,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			BRA			LOOP
			
opEORL		LEA			dispLong,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			LEA         space, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			
			CLR			D2
			CLR			D3
			MOVE.W		D1,D3
			ASR			#eight,D3
			ASR			#one,D3
			AND			#$07,D3
			JSR			printEA
			
			LEA         comma, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			
			CLR			D2
			CLR			D3
			MOVE.B		D1,D2
			ASR			#three,D2
			AND			#seven,D2
			MOVE.B		D1,D3
			AND			#$07,D3
			JSR			printEA			; Determines the "left" operand register
			
			LEA			newLine,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			BRA			LOOP			; trap call
			

***********************************************************************************************************
*
*				CMP OPCODE
*
***********************************************************************************************************

opCMP		LEA			CMPmatch,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			CLR			D2
			
			MOVE.B		D1,D2
			ASR			#six,D2			; Move bits 7 places over to find opmode
			AND			#$07,D2
			CMP.B		#zero,D2
			BEQ			opCMPB				; Byte in opmode
			CMP.B		#one,D2
			BEQ			opCMPW				; Word in opmode
			CMP.B		#two,D2
			BEQ			opCMPL				; Long in opmode
			
			BRA			printInvalid		; Incorrect input

opCMPB		LEA			dispByte,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			LEA         space, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			
			MOVE.B		D1,D2
			ASR			#3,D2
			AND			#$07,D2
			MOVE.B		D1,D3
			AND			#$07,D3
			JSR			printEA			; Determines the "left" operand register
			
			LEA         comma, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			
			CLR			D2
			MOVE.W		D1,D3
			ASR			#eight,D3
			ASR			#one,D3
			AND			#$07,D3
			JSR			printEA
			
			LEA			newLine,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			BRA			LOOP
			
opCMPW		LEA			dispWord,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			LEA         space, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			
			MOVE.B		D1,D2
			ASR			#3,D2
			AND			#$07,D2
			MOVE.B		D1,D3
			AND			#$07,D3
			JSR			printEA			; Determines the "left" operand register
			
			LEA         comma, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			
			CLR			D2
			MOVE.W		D1,D3
			ASR			#eight,D3
			ASR			#one,D3
			AND			#$07,D3
			JSR			printEA
			
			LEA			newLine,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			BRA			LOOP

opCMPL		LEA			dispLong,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			LEA         space, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			
			MOVE.B		D1,D2
			ASR			#3,D2
			AND			#$07,D2
			MOVE.B		D1,D3
			AND			#$07,D3
			JSR			printEA			; Determines the "left" operand register
			
			LEA         comma, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			
			CLR			D2
			MOVE.W		D1,D3
			ASR			#eight,D3
			ASR			#one,D3
			AND			#$07,D3
			JSR			printEA
			
			LEA			newLine,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			BRA			LOOP

***********************************************************************************************************
*
*				SUB OPCODE
*
***********************************************************************************************************

opSUB   	LEA         SUBmatch, A1        ; we know that the opcode will be SUB, so load A1 to print message
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
		
		
			ASL			#eight,D1
			MOVE.B		(A0)+,D1
			CLR			D2
			
			MOVE.W		D1,D2
			ASR			#six,D2			; Move bits 7 places over to find opmode
			AND			#seven,D2
			
			; These are for DN - EA
			CMP.B		#zero,D2
			BEQ			opSUBB				; Byte in opmode
			CMP.B		#one,D2
			BEQ			opSUBW				; Word in opmode
			CMP.B		#two,D2
			BEQ			opSUBL				; Long in opmode
			
			; These are for EA - DN
			CMP.B		#four,D2
			BEQ			opSUBB				; Byte in opmode
			CMP.B		#five,D2
			BEQ			opSUBW				; Word in opmode
			CMP.B		#six,D2
			BEQ			opSUBL				; Long in opmode
			
opSUBB		LEA			dispByte,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			LEA         space, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call			
			
			MOVE.B		D1,D2
			ASR			#3,D2
			AND			#$07,D2
			MOVE.W		D1,D3
			AND			#$07,D3
			JSR			printEA			; Determines the "left" operand register
			
			LEA         comma, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			
			CLR			D2
			MOVE.W		D1,D3
			ASR			#eight,D3
			ASR			#one,D3
			AND			#$07,D3
			JSR			printEA
			
			LEA			newLine,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			BRA			LOOP
			
			
opSUBW		LEA			dispWord,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			LEA         space, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call			
			
			MOVE.B		D1,D2
			ASR			#3,D2
			AND			#$07,D2
			MOVE.W		D1,D3
			AND			#$07,D3
			JSR			printEA			; Determines the "left" operand register
			
			LEA         comma, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			
			CLR			D2
			MOVE.W		D1,D3
			ASR			#eight,D3
			ASR			#one,D3
			AND			#$07,D3
			JSR			printEA
			
			LEA			newLine,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			BRA			LOOP
			
opSUBL		LEA			dispLong,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			LEA         space, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call			
			
			MOVE.B		D1,D2
			ASR			#3,D2
			AND			#$07,D2
			MOVE.W		D1,D3
			AND			#$07,D3
			JSR			printEA			; Determines the "left" operand register
			
			LEA         comma, A1           ; Display space
			MOVE.B      #14, D0             ; command for trap call to display message
			TRAP        #15                 ; trap call
			
			CLR			D2
			MOVE.W		D1,D3
			ASR			#eight,D3
			ASR			#one,D3
			AND			#$07,D3
			JSR			printEA
			
			LEA			newLine,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			BRA			LOOP
			
			
			
***********************************************************************************************************
*
*				BRA OPCODE
*
***********************************************************************************************************
			
opBRA   LEA         BRAmatch, A1        ; we know that the opcode will be BRA, so load A1 to print message
        MOVE.B      #14, D0             ; command for trap call to display message
        TRAP        #15                 ; trap call
		
		CLR			D2
		CLR			D3		

		LEA			space,A1
		MOVE.B		#14,D0
		TRAP		#15
		
		MOVE.B		#seven,D2
		MOVE.B		(A0)+,D1
		JSR			printEA
		
        LEA         newLine, A1           ; create new line
        MOVE.B      #14, D0             ; command for trap call to display message
        TRAP        #15                 ; trap call

		BRA			LOOP
		
		
opBCS   LEA         BCSmatch, A1        ; we know that the opcode will be BCS, so load A1 to print message
        MOVE.B      #14, D0             ; command for trap call to display message
        TRAP        #15                 ; trap call
		
		CLR			D2
		CLR			D3		

		LEA			space,A1
		MOVE.B		#14,D0
		TRAP		#15
		
		MOVE.B		#seven,D2
		MOVE.B		(A0)+,D1
		JSR			printEA
		
        LEA         newLine, A1           ; create new line
        MOVE.B      #14, D0             ; command for trap call to display message
        TRAP        #15                 ; trap call

opBVC   LEA         BVCmatch, A1        ; we know that the opcode will be BVC, so load A1 to print message
        MOVE.B      #14, D0             ; command for trap call to display message
        TRAP        #15                 ; trap call
		
		CLR			D2
		CLR			D3		

		LEA			space,A1
		MOVE.B		#14,D0
		TRAP		#15
		
		MOVE.B		#seven,D2
		MOVE.B		(A0)+,D1
		JSR			printEA
		
        LEA         newLine, A1           ; create new line
        MOVE.B      #14, D0             ; command for trap call to display message
        TRAP        #15                 ; trap call

opBGE   LEA         BGEmatch, A1        ; we know that the opcode will be BGE, so load A1 to print message
        MOVE.B      #14, D0             ; command for trap call to display message
        TRAP        #15                 ; trap call
		
		CLR			D2
		CLR			D3		

		LEA			space,A1
		MOVE.B		#14,D0
		TRAP		#15
		
		MOVE.B		#seven,D2
		MOVE.B		(A0)+,D1
		JSR			printEA
		
        LEA         newLine, A1           ; create new line
        MOVE.B      #14, D0             ; command for trap call to display message
        TRAP        #15                 ; trap call

opBLT   LEA         BLTmatch, A1        ; we know that the opcode will be BLT, so load A1 to print message
        MOVE.B      #14, D0             ; command for trap call to display message
        TRAP        #15                 ; trap call
		
		CLR			D2
		CLR			D3		

		LEA			space,A1
		MOVE.B		#14,D0
		TRAP		#15
		
		MOVE.B		#seven,D2
		MOVE.B		(A0)+,D1
		JSR			printEA
		
        LEA         newLine, A1           ; create new line
        MOVE.B      #14, D0             ; command for trap call to display message
        TRAP        #15                 ; trap call
		
		
		***********************************************************************************************************
*
*				SUBQ OPCODE
*
***********************************************************************************************************

opSUBQ      
            LEA         SUBQmatch, A1       ; we know that the opcode will be SUBQ, so load A1 to print message
            MOVE.B      #14, D0             ; command for trap call to display message
            TRAP        #15                 ; trap call
			
			MOVE.B		D1,D2
			ASR			#seven,D2			; Move bits 7 places over to find size
			AND			#$07,D2
			
			; Find size bits
			CMP.B		#zero,D2
			BEQ			opSUBQB				; Byte in size
			CMP.B		#one,D2
			BEQ			opSUBQW				; Word in size
			CMP.B		#two,D2
			BEQ			opSUBQL				; Long in size
			
			
opSUBQB		LEA			dispByte,A1
			MOVE.B		#14,D0
			TRAP		#15	
			
			ASL			#eight,D1
			MOVE.B		(A0)+,D1
			JSR			PrntImm
			
			BRA			LOOP
			
opSUBQW		LEA			dispWord,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			ASL			#eight,D1
			MOVE.B		(A0)+,D1
			JSR			PrntImm
			
			BRA			LOOP
			
opSUBQL		LEA			dispLong,A1
			MOVE.B		#14,D0
			TRAP		#15
			
			ASL			#eight,D1
			MOVE.B		(A0)+,D1
			
			CLR			D6
			MOVE.B		#1,D6
			
			JSR			PrntImm			
			
			BRA			LOOP			; trap call
			
