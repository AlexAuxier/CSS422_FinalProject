00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 11/23/2014 2:13:49 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :
00000000                             3  * Written by :  Abdul Hakim, David Trinh, Alexander Auxier
00000000                             4  * Date       :
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00000000  =0000000D                  7  CR          EQU     $0D     
00000000  =0000000A                  8  LF          EQU     $0A
00000000                             9    
00000000  =00002000                 10  test_start  EQU     $00002000   ; defined starting address
00000000  =00002005                 11  test_end    EQU     $00002005   ; defined ending address
00000000                            12       
00000000  =00000000                 13  zero        EQU     $00         ; defined hex value 0
00000000  =00000001                 14  one         EQU     $01         ; defined hex value 1 
00000000  =00000002                 15  two         EQU     $02         ; defined hex value 2
00000000  =00000003                 16  three       EQU     $03         ; defined hex value 3
00000000  =00000004                 17  four        EQU     $04         ; defined hex value 4
00000000  =00000005                 18  five        EQU     $05         ; defined hex value 5
00000000  =00000006                 19  six         EQU     $06         ; defined hex value 6
00000000  =00000008                 20  eight       EQU     $08         ; defined hex value 8
00000000  =00000009                 21  nine        EQU     $09         ; defined hex value 9
00000000  =0000000B                 22  eleven      EQU     $0B         ; defined hex value 11
00000000  =0000000C                 23  twelve      EQU     $0C         ; defined hex value 12
00000000  =0000000D                 24  thirteen    EQU     $0D         ; defined hex value 13
00000000  =0000000E                 25  fourteen    EQU     $0E         ; defined hex value 14
00000000                            26  
00000000  =00000000                 27  s1B         EQU     %0000       ; byte size 1 
00000000  =00000001                 28  s1W         EQU     %0001       ; word size 1
00000000  =00000002                 29  s1L         EQU     %0010       ; long size 1
00000000                            30  
00000000  =00000000                 31  s2W         EQU     %0000       ; word size 2
00000000  =00000001                 32  s2L         EQU     %0001       ; long size 2
00000000                            33  
00000000  =00000001                 34  s3B         EQU     %0001       ; byte size 3
00000000  =00000003                 35  s3W         EQU     %0011       ; word size 3
00000000  =00000002                 36  s3L         EQU     %0010       ; long size 3
00000000                            37  
00000000  =00000000                 38  addMatchDn  EQU     %0000       ; Address Mode Data Register
00000000  =00000001                 39  addMatchAn  EQU     %0001       ; Address Mode Address Register
00000000  =00000002                 40  addMatchAd  EQU     %0010       ; Address Mode Address
00000000  =00000003                 41  addMatchPi  EQU     %0011       ; Address Mode with PostIncrement
00000000  =00000004                 42  addMatchPd  EQU     %0100       ; Address Mode with PreDecrement
00000000  =00000007                 43  addMatchDi  EQU     %0111       ; Address Mode for Word, Long, or Immediate 
00000000                            44  
00000000  =00000000                 45  reg0        EQU     %0000       ; register 0
00000000  =00000001                 46  reg1        EQU     %0001       ; register 1
00000000  =00000002                 47  reg2        EQU     %0010       ; register 2
00000000  =00000003                 48  reg3        EQU     %0011       ; register 3
00000000  =00000004                 49  reg4        EQU     %0100       ; register 4
00000000  =00000005                 50  reg5        EQU     %0101       ; register 5
00000000  =00000006                 51  reg6        EQU     %0110       ; register 6
00000000  =00000007                 52  reg7        EQU     %0111       ; register 7
00000000                            53               
00001000                            54              ORG    $1000
00001000                            55  START:                                  ; first instruction of program
00001000                            56        
00001000  207C 00002000             57          MOVEA.L     #test_start, A0     ; load starting address
00001006  247C 00002005             58          MOVEA.L     #test_end, A2       ; load ending address
0000100C                            59            
0000100C  4241                      60  LOOP    CLR         D1                  ; clear out D1
0000100E  4242                      61          CLR         D2                  ; clear out D2
00001010  B1CA                      62          CMPA.L      A2, A0              ; compare starting and ending addresses
00001012  6E00 00D2                 63          BGT         endProg             ; if A0 > A1, we've finished, end program
00001016  1218                      64          MOVE.B      (A0)+, D1           ; load byte to D1 and increment A0 to next byte
00001018  1401                      65          MOVE.B      D1, D2              ; copy byte to D2 for manipulation
0000101A  E882                      66          ASR.L       #four, D2           ; get first nibble in D2
0000101C                            67          
0000101C  B43C 0000                 68          CMP.B       #zero, D2           ; compare with 0
00001020  6700 0064                 69          BEQ         braZero             ; branch out to zero method
00001024  B43C 0001                 70          CMP.B       #one, D2            ; compare with 1
00001028  6700 0078                 71          BEQ         braOne              ; branch out to one method
0000102C  B43C 0002                 72          CMP.B       #two, D2            ; compare with 2    
00001030  6700 0070                 73          BEQ         braTwo              ; branch out to two method
00001034  B43C 0003                 74          CMP.B       #three, D2          ; compare with 3
00001038  6700 0068                 75          BEQ         braThree            ; branch out to three method
0000103C  B43C 0004                 76          CMP.B       #four, D2           ; compare with 4
00001040  6700 0060                 77          BEQ         braFour             ; branch out to four method
00001044  B43C 0005                 78          CMP.B       #five, D2           ; compare with 5
00001048  6700 0058                 79          BEQ         braFive             ; branch out to five method
0000104C  B43C 0006                 80          CMP.B       #six, D2            ; compare with 6
00001050  6700 0050                 81          BEQ         braSix              ; branch out to six method
00001054  B43C 0008                 82          CMP.B       #eight, D2          ; compare with 8
00001058  6700 0048                 83          BEQ         braEight            ; branch out to eight method
0000105C  B43C 0009                 84          CMP.B       #nine, D2           ; compare with 9
00001060  6700 0040                 85          BEQ         braNine             ; branch out to nine method
00001064  B43C 000B                 86          CMP.B       #eleven, D2         ; compare with 11
00001068  6700 0038                 87          BEQ         braEleven           ; branch out to eleven method
0000106C  B43C 000C                 88          CMP.B       #twelve, D2         ; compare with 12
00001070  6700 0030                 89          BEQ         braTwelve           ; branch out to twelve method
00001074  B43C 000D                 90          CMP.B       #thirteen, D2       ; compare with 13
00001078  6700 0028                 91          BEQ         braThirteen         ; branch out to thirteen method
0000107C  B43C 000E                 92          CMP.B       #fourteen, D2       ; compare with 14
00001080  6700 0020                 93          BEQ         braFourteen         ; branch out to fourteen method
00001084  6086                      94          BRA         loop
00001086                            95  
00001086  4242                      96  braZero CLR         D2                  ; first nibble is 0, 3 opcodes are possible 
00001088  1401                      97          MOVE.B      D1, D2              ; clear out D2 and copy D1 back in
0000108A  C438 000F                 98          AND.B       $0F, D2             ; set first nibble to 0
0000108E                            99   
0000108E  B43C 0000                100          CMP.B       #zero, D2           ; compare second nibble to 0
00001092  6700 000E                101          BEQ         opORI               ; branch to ORI method
00001096  B43C 000C                102          CMP.B       #twelve, D2         ; compare second nibble to 12
0000109A  6700 002A                103          BEQ         opCMPI              ; branch to CMPI method
0000109E  6000 0036                104          BRA         opBCLR              ; otherwise, branch to BCLR method; I think we should fix this, there are other posibilities
000010A2                           105          
000010A2                           106  braOne
000010A2                           107  braTwo
000010A2                           108  braThree
000010A2                           109  braFour
000010A2                           110  braFive
000010A2                           111  braSix
000010A2                           112  braEight
000010A2                           113  braNine
000010A2                           114  braEleven
000010A2                           115  braTwelve
000010A2                           116  braThirteen
000010A2                           117  braFourteen
000010A2                           118  
000010A2  43F9 000010EE            119  opORI   LEA         ORImatch, A1        ; we know that the opcode will be ORI, so load A1 to print message
000010A8  103C 000E                120          MOVE.B      #14, D0             ; command for trap call to display message
000010AC  4E4F                     121          TRAP        #15                 ; trap call
000010AE                           122        
000010AE  1218                     123          MOVE.B      (A0)+, D1
000010B0  1401                     124          MOVE.B      D1,D2               ; copy data over
000010B2  EC42                     125          ASR         #6,D2               ; shifts 6 bits over to read just the size
000010B4  3602                     126          MOVE        D2,D3
000010B6  4242                     127          CLR         D2
000010B8  1401                     128          MOVE.B      D1,D2
000010BA  E442                     129          ASR         #2,D2
000010BC  C438 000F                130          AND.B       $0F,D2
000010C0  E242                     131          ASR         #1,D2
000010C2                           132          
000010C2                           133          
000010C2  6000 FF48                134          BRA         LOOP                ; go back to the loop
000010C6                           135  
000010C6                           136  opORI0
000010C6                           137  
000010C6                           138           
000010C6  43F9 000010F2            139  opCMPI  LEA         CMPImatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
000010CC  103C 000E                140          MOVE.B      #14, D0             ; command for trap call to display message
000010D0  4E4F                     141          TRAP        #15                 ; trap call
000010D2                           142                  
000010D2  6000 FF38                143          BRA         LOOP                ; go back to the loop
000010D6                           144  
000010D6                           145  
000010D6                           146  
000010D6  43F9 000010F7            147  opBCLR  LEA         BCLRmatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
000010DC  103C 000E                148          MOVE.B      #14, D0             ; command for trap call to display message
000010E0  4E4F                     149          TRAP        #15                 ; trap call
000010E2                           150          
000010E2  6000 FF28                151          BRA         LOOP                ; go back to the loop
000010E6                           152   
000010E6                           153  endPROG    
000010E6                           154  
000010E6  FFFF FFFF                155      SIMHALT                             ; halt simulator
000010EA                           156  
000010EA= 20 0D 0A 00              157  newLine     DC.B    ' ', CR, LF, 0
000010EE                           158  
000010EE= 4F 52 49 00              159  ORImatch    DC.B    'ORI', 0
000010F2= 43 4D 50 49 00           160  CMPImatch   DC.B    'CMPI', 0
000010F7= 42 43 4C 52 00           161  BCLRmatch   DC.B    'BCLR', 0
000010FC                           162   
000010FC= 2E 42 20 20 00           163  dispByte    DC.B    '.B  ', 0
00001101= 2E 57 20 20 00           164  dispWord    DC.B    '.W  ', 0
00001106= 2E 4C 20 20 00           165  dispLong    DC.B    '.L  ', 0
0000110B                           166  
0000110B= 41 30 00                 167  dispA0      DC.B    'A0', 0
0000110E= 41 31 00                 168  dispA1      DC.B    'A1', 0
00001111= 41 32 00                 169  dispA2      DC.B    'A2', 0
00001114= 41 33 00                 170  dispA3      DC.B    'A3', 0
00001117= 41 34 00                 171  dispA4      DC.B    'A4', 0
0000111A= 41 35 00                 172  dispA5      DC.B    'A5', 0
0000111D= 41 36 00                 173  dispA6      DC.B    'A6', 0
00001120= 41 37 00                 174  dispA7      DC.B    'A7', 0
00001123                           175  
00001123                           176  
00001123                           177             END    START                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDMATCHAD          2
ADDMATCHAN          1
ADDMATCHDI          7
ADDMATCHDN          0
ADDMATCHPD          4
ADDMATCHPI          3
BCLRMATCH           10F7
BRAEIGHT            10A2
BRAELEVEN           10A2
BRAFIVE             10A2
BRAFOUR             10A2
BRAFOURTEEN         10A2
BRANINE             10A2
BRAONE              10A2
BRASIX              10A2
BRATHIRTEEN         10A2
BRATHREE            10A2
BRATWELVE           10A2
BRATWO              10A2
BRAZERO             1086
CMPIMATCH           10F2
CR                  D
DISPA0              110B
DISPA1              110E
DISPA2              1111
DISPA3              1114
DISPA4              1117
DISPA5              111A
DISPA6              111D
DISPA7              1120
DISPBYTE            10FC
DISPLONG            1106
DISPWORD            1101
EIGHT               8
ELEVEN              B
ENDPROG             10E6
FIVE                5
FOUR                4
FOURTEEN            E
LF                  A
LOOP                100C
NEWLINE             10EA
NINE                9
ONE                 1
OPBCLR              10D6
OPCMPI              10C6
OPORI               10A2
OPORI0              10C6
ORIMATCH            10EE
REG0                0
REG1                1
REG2                2
REG3                3
REG4                4
REG5                5
REG6                6
REG7                7
S1B                 0
S1L                 2
S1W                 1
S2L                 1
S2W                 0
S3B                 1
S3L                 2
S3W                 3
SIX                 6
START               1000
TEST_END            2005
TEST_START          2000
THIRTEEN            D
THREE               3
TWELVE              C
TWO                 2
ZERO                0
