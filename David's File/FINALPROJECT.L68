00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 11/25/2014 1:57:01 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :
00000000                             3  * Written by :  Abdul Hakim, David Trinh, Alexander Auxier
00000000                             4  * Date       :
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00000000  =0000000D                  7  CR          EQU     $0D     
00000000  =0000000A                  8  LF          EQU     $0A
00000000                             9    
00000000  =00002000                 10  test_start  EQU     $00002000   ; defined starting address
00000000  =00002005                 11  test_end    EQU     $00002005   ; defined ending address
00000000                            12       
00000000  =00000000                 13  zero        EQU     $00         ; defined hex value 0
00000000  =00000001                 14  one         EQU     $01         ; defined hex value 1 
00000000  =00000002                 15  two         EQU     $02         ; defined hex value 2
00000000  =00000003                 16  three       EQU     $03         ; defined hex value 3
00000000  =00000004                 17  four        EQU     $04         ; defined hex value 4
00000000  =00000005                 18  five        EQU     $05         ; defined hex value 5
00000000  =00000006                 19  six         EQU     $06         ; defined hex value 6
00000000  =00000008                 20  eight       EQU     $08         ; defined hex value 8
00000000  =00000009                 21  nine        EQU     $09         ; defined hex value 9
00000000  =0000000B                 22  eleven      EQU     $0B         ; defined hex value 11
00000000  =0000000C                 23  twelve      EQU     $0C         ; defined hex value 12
00000000  =0000000D                 24  thirteen    EQU     $0D         ; defined hex value 13
00000000  =0000000E                 25  fourteen    EQU     $0E         ; defined hex value 14
00000000                            26  
00000000  =00000000                 27  s1B         EQU     %0000       ; byte size 1 
00000000  =00000001                 28  s1W         EQU     %0001       ; word size 1
00000000  =00000002                 29  s1L         EQU     %0010       ; long size 1
00000000                            30  
00000000  =00000000                 31  s2W         EQU     %0000       ; word size 2
00000000  =00000001                 32  s2L         EQU     %0001       ; long size 2
00000000                            33  
00000000  =00000001                 34  s3B         EQU     %0001       ; byte size 3
00000000  =00000003                 35  s3W         EQU     %0011       ; word size 3
00000000  =00000002                 36  s3L         EQU     %0010       ; long size 3
00000000                            37  
00000000  =00000000                 38  addMatchDn  EQU     %0000       ; Address Mode Data Register
00000000  =00000001                 39  addMatchAn  EQU     %0001       ; Address Mode Address Register
00000000  =00000002                 40  addMatchAd  EQU     %0010       ; Address Mode Address
00000000  =00000003                 41  addMatchPi  EQU     %0011       ; Address Mode with PostIncrement
00000000  =00000004                 42  addMatchPd  EQU     %0100       ; Address Mode with PreDecrement
00000000  =00000007                 43  addMatchDi  EQU     %0111       ; Address Mode for Word, Long, or Immediate 
00000000                            44  
00000000  =00000000                 45  reg0        EQU     %0000       ; register 0
00000000  =00000001                 46  reg1        EQU     %0001       ; register 1
00000000  =00000002                 47  reg2        EQU     %0010       ; register 2
00000000  =00000003                 48  reg3        EQU     %0011       ; register 3
00000000  =00000004                 49  reg4        EQU     %0100       ; register 4
00000000  =00000005                 50  reg5        EQU     %0101       ; register 5
00000000  =00000006                 51  reg6        EQU     %0110       ; register 6
00000000  =00000007                 52  reg7        EQU     %0111       ; register 7
00000000                            53               
00001000                            54              ORG    $1000
00001000                            55  START:                                  ; first instruction of program
00001000                            56        
00001000  207C 00002000             57          MOVEA.L     #test_start, A0     ; load starting address
00001006  247C 00002005             58          MOVEA.L     #test_end, A2       ; load ending address
0000100C                            59            
0000100C  4241                      60  LOOP    CLR         D1                  ; clear out D1
0000100E  4242                      61          CLR         D2                  ; clear out D2
00001010  B1CA                      62          CMPA.L      A2, A0              ; compare starting and ending addresses
00001012  6E00 0106                 63          BGT         endProg             ; if A0 > A1, we've finished, end program
00001016  1218                      64          MOVE.B      (A0)+, D1           ; load byte to D1 and increment A0 to next byte
00001018  1401                      65          MOVE.B      D1, D2              ; copy byte to D2 for manipulation
0000101A  E882                      66          ASR.L       #four, D2           ; get first nibble in D2
0000101C                            67          
0000101C  B43C 0000                 68          CMP.B       #zero, D2           ; compare with 0
00001020  6700 0064                 69          BEQ         braZero             ; branch out to zero method
00001024  B43C 0001                 70          CMP.B       #one, D2            ; compare with 1
00001028  6700 0078                 71          BEQ         braOne              ; branch out to one method
0000102C  B43C 0002                 72          CMP.B       #two, D2            ; compare with 2    
00001030  6700 0070                 73          BEQ         braTwo              ; branch out to two method
00001034  B43C 0003                 74          CMP.B       #three, D2          ; compare with 3
00001038  6700 0068                 75          BEQ         braThree            ; branch out to three method
0000103C  B43C 0004                 76          CMP.B       #four, D2           ; compare with 4
00001040  6700 0060                 77          BEQ         braFour             ; branch out to four method
00001044  B43C 0005                 78          CMP.B       #five, D2           ; compare with 5
00001048  6700 0058                 79          BEQ         braFive             ; branch out to five method
0000104C  B43C 0006                 80          CMP.B       #six, D2            ; compare with 6
00001050  6700 0050                 81          BEQ         braSix              ; branch out to six method
00001054  B43C 0008                 82          CMP.B       #eight, D2          ; compare with 8
00001058  6700 0048                 83          BEQ         braEight            ; branch out to eight method
0000105C  B43C 0009                 84          CMP.B       #nine, D2           ; compare with 9
00001060  6700 0040                 85          BEQ         braNine             ; branch out to nine method
00001064  B43C 000B                 86          CMP.B       #eleven, D2         ; compare with 11
00001068  6700 0038                 87          BEQ         braEleven           ; branch out to eleven method
0000106C  B43C 000C                 88          CMP.B       #twelve, D2         ; compare with 12
00001070  6700 0030                 89          BEQ         braTwelve           ; branch out to twelve method
00001074  B43C 000D                 90          CMP.B       #thirteen, D2       ; compare with 13
00001078  6700 0028                 91          BEQ         braThirteen         ; branch out to thirteen method
0000107C  B43C 000E                 92          CMP.B       #fourteen, D2       ; compare with 14
00001080  6700 0020                 93          BEQ         braFourteen         ; branch out to fourteen method
00001084  6086                      94          BRA         loop
00001086                            95  
00001086  4242                      96  braZero CLR         D2                  ; first nibble is 0, 3 opcodes are possible 
00001088  1401                      97          MOVE.B      D1, D2              ; clear out D2 and copy D1 back in
0000108A  C438 000F                 98          AND.B       $0F, D2             ; set first nibble to 0
0000108E                            99   
0000108E  B43C 0000                100          CMP.B       #zero, D2           ; compare second nibble to 0
00001092  6700 000E                101          BEQ         opORI               ; branch to ORI method
00001096  B43C 000C                102          CMP.B       #twelve, D2         ; compare second nibble to 12
0000109A  6700 003A                103          BEQ         opCMPI              ; branch to CMPI method
0000109E  6000 006A                104          BRA         opBCLR              ; otherwise, branch to BCLR method; I think we should fix this, there are other posibilities
000010A2                           105          
000010A2                           106  braOne
000010A2                           107  braTwo
000010A2                           108  braThree
000010A2                           109  braFour
000010A2                           110  braFive
000010A2                           111  braSix
000010A2                           112  braEight
000010A2                           113  braNine
000010A2                           114  braEleven
000010A2                           115  braTwelve
000010A2                           116  braThirteen
000010A2                           117  braFourteen
000010A2                           118  
000010A2  43F9 00001122            119  opORI   LEA         ORImatch, A1        ; we know that the opcode will be ORI, so load A1 to print message
000010A8  103C 000E                120          MOVE.B      #14, D0             ; command for trap call to display message
000010AC  4E4F                     121          TRAP        #15                 ; trap call
000010AE                           122        
000010AE  1218                     123          MOVE.B      (A0)+, D1
000010B0  1401                     124          MOVE.B      D1,D2               ; copy data over
000010B2  EC42                     125          ASR         #6,D2               ; shifts 6 bits over to read just the size        
000010B4  3602                     126          MOVE        D2,D3               ; store size into D3
000010B6  4242                     127          CLR         D2
000010B8                           128          
000010B8  1401                     129          MOVE.B      D1,D2               ; Reload D2 with the same byte to get mode
000010BA  E542                     130          ASL         #two,D2             ; Moving two bits over to isolate and remove the size
000010BC  1802                     131          MOVE.B      D2,D4               ; Move the mode and register to D4 and leave the size
000010BE  4242                     132          CLR         D2                  ; Clear out data register
000010C0  1404                     133          MOVE.B      D4,D2               ; Put data back into D2 with just the mode and register
000010C2  EA42                     134          ASR         #five,D2            ; Shift the register out to get just the mode
000010C4  1802                     135          MOVE.B      D2,D4               ; Store mode into D4
000010C6  4242                     136          CLR         D2
000010C8                           137          
000010C8  1401                     138          MOVE.B      D1,D2               ; Getting the EA register
000010CA  EB42                     139          ASL         #five,D2
000010CC  1A02                     140          MOVE.B      D2,D5               ; Move just the register into D5
000010CE  4242                     141          CLR         D2                  ; Clearing D2 to put data back
000010D0  1405                     142          MOVE.B      D5,D2               ; Putting back the register
000010D2  EA42                     143          ASR         #five,D2            ; Shifting bits in order to read the register
000010D4  1A02                     144          MOVE.B      D2,D5               ; Store register into D5
000010D6                           145          
000010D6                           146  
000010D6                           147           
000010D6  43F9 00001126            148  opCMPI  LEA         CMPImatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
000010DC  103C 000E                149          MOVE.B      #14, D0             ; command for trap call to display message
000010E0  4E4F                     150          TRAP        #15                 ; trap call
000010E2                           151          
000010E2  1218                     152          MOVE.B      (A0)+,D1            ; Load the next byte which contains size, mode, and register into D1    
000010E4  1401                     153          MOVE.B      D1,D2               ; copy data over
000010E6  EC42                     154          ASR         #6,D2               ; shifts 6 bits over to read just the size        
000010E8  3602                     155          MOVE        D2,D3               ; store size into D3
000010EA  4242                     156          CLR         D2
000010EC                           157          
000010EC  1401                     158          MOVE.B      D1,D2               ; Reload D2 with the same byte to get mode
000010EE  E542                     159          ASL         #two,D2             ; Moving two bits over to isolate and remove the size
000010F0  1802                     160          MOVE.B      D2,D4               ; Move the mode and register to D4 and leave the size
000010F2  4242                     161          CLR         D2                  ; Clear out data register
000010F4  1404                     162          MOVE.B      D4,D2               ; Put data back into D2 with just the mode and register
000010F6  EA42                     163          ASR         #five,D2            ; Shift the register out to get just the mode
000010F8  1802                     164          MOVE.B      D2,D4               ; Store mode into D4
000010FA  4242                     165          CLR         D2
000010FC                           166          
000010FC  1401                     167          MOVE.B      D1,D2               ; Getting the EA register
000010FE  EB42                     168          ASL         #five,D2
00001100  1A02                     169          MOVE.B      D2,D5               ; Move just the register into D5
00001102  4242                     170          CLR         D2                  ; Clearing D2 to put data back
00001104  1405                     171          MOVE.B      D5,D2               ; Putting back the register
00001106  EA42                     172          ASR         #five,D2            ; Shifting bits in order to read the register
00001108  1A02                     173          MOVE.B      D2,D5               ; Store register into D5               
0000110A                           174  
0000110A                           175  
0000110A  43F9 0000112B            176  opBCLR  LEA         BCLRmatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
00001110  103C 000E                177          MOVE.B      #14, D0             ; command for trap call to display message
00001114  4E4F                     178          TRAP        #15                 ; trap call
00001116                           179          
00001116  6000 FEF4                180          BRA         LOOP                ; go back to the loop
0000111A                           181   
0000111A                           182  endPROG    
0000111A                           183  
0000111A  FFFF FFFF                184      SIMHALT                             ; halt simulator
0000111E                           185  
0000111E= 20 0D 0A 00              186  newLine     DC.B    ' ', CR, LF, 0
00001122                           187  
00001122= 4F 52 49 00              188  ORImatch    DC.B    'ORI', 0
00001126= 43 4D 50 49 00           189  CMPImatch   DC.B    'CMPI', 0
0000112B= 42 43 4C 52 00           190  BCLRmatch   DC.B    'BCLR', 0
00001130                           191   
00001130= 2E 42 20 20 00           192  dispByte    DC.B    '.B  ', 0
00001135= 2E 57 20 20 00           193  dispWord    DC.B    '.W  ', 0
0000113A= 2E 4C 20 20 00           194  dispLong    DC.B    '.L  ', 0
0000113F                           195  
0000113F= 41 30 00                 196  dispA0      DC.B    'A0', 0
00001142= 41 31 00                 197  dispA1      DC.B    'A1', 0
00001145= 41 32 00                 198  dispA2      DC.B    'A2', 0
00001148= 41 33 00                 199  dispA3      DC.B    'A3', 0
0000114B= 41 34 00                 200  dispA4      DC.B    'A4', 0
0000114E= 41 35 00                 201  dispA5      DC.B    'A5', 0
00001151= 41 36 00                 202  dispA6      DC.B    'A6', 0
00001154= 41 37 00                 203  dispA7      DC.B    'A7', 0
00001157                           204  
00001157                           205  
00001157                           206             END    START                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDMATCHAD          2
ADDMATCHAN          1
ADDMATCHDI          7
ADDMATCHDN          0
ADDMATCHPD          4
ADDMATCHPI          3
BCLRMATCH           112B
BRAEIGHT            10A2
BRAELEVEN           10A2
BRAFIVE             10A2
BRAFOUR             10A2
BRAFOURTEEN         10A2
BRANINE             10A2
BRAONE              10A2
BRASIX              10A2
BRATHIRTEEN         10A2
BRATHREE            10A2
BRATWELVE           10A2
BRATWO              10A2
BRAZERO             1086
CMPIMATCH           1126
CR                  D
DISPA0              113F
DISPA1              1142
DISPA2              1145
DISPA3              1148
DISPA4              114B
DISPA5              114E
DISPA6              1151
DISPA7              1154
DISPBYTE            1130
DISPLONG            113A
DISPWORD            1135
EIGHT               8
ELEVEN              B
ENDPROG             111A
FIVE                5
FOUR                4
FOURTEEN            E
LF                  A
LOOP                100C
NEWLINE             111E
NINE                9
ONE                 1
OPBCLR              110A
OPCMPI              10D6
OPORI               10A2
ORIMATCH            1122
REG0                0
REG1                1
REG2                2
REG3                3
REG4                4
REG5                5
REG6                6
REG7                7
S1B                 0
S1L                 2
S1W                 1
S2L                 1
S2W                 0
S3B                 1
S3L                 2
S3W                 3
SIX                 6
START               1000
TEST_END            2005
TEST_START          2000
THIRTEEN            D
THREE               3
TWELVE              C
TWO                 2
ZERO                0
