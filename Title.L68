00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/12/2014 3:05:40 PM

00000000                             1                                     
00000000                             2      ****       ****  *******     ****    ***      ***
00000000                             3      ****       **** *******    ********  ***     ***
00000000                             4      *****     ***** ***       ***    *** ***    ***
00000000                             5      ******   ****** ***       ***    *** ***   ***
00000000                             6      ******* ******* ***        ********  ***  ***
00000000                             7      *************** *******     ******   ********
00000000                             8      ****  ***  **** ********   ********  ***  ***
00000000                             9      ****   *   **** ***   *** ***    *** ***   ***
00000000                            10      ****       **** ***   *** ***    *** ***    ***
00000000                            11      ****       **** ***   ***  ********  ***     ***
00000000                            12      ****       ****  *******     ****    ***      ***
00000000                            13      
00000000                            14              *********          ********** ****       ****
00000000                            15              ***********      *********    ****       ****
00000000                            16              ***    *****   *********      *****     *****
00000000                            17              ***      **** ********        ******   ******
00000000                            18              ***       *** ************    ******* *******
00000000                            19              ***       *** *************** ***************
00000000                            20              ***       ***    ************ ****  ***  ****
00000000                            21              ***      ***         ******** ****   *   ****
00000000                            22              ***    *****       ********   ****       ****
00000000                            23              ***********      *********    ****       ****
00000000                            24              *********     **********      ****       ****
00000000                            25          
00000000                            26  *-----------------------------------------------------------
00000000                            27  * Title      :  Motorola 68k Instruction Dissassembler (DSM)
00000000                            28  * Written by :  Abdul Hakim, David Trinh, Alexander Auxier
00000000                            29  * Date       :  2014-12-11
00000000                            30  * Description:  Stuff happens
00000000                            31  *-----------------------------------------------------------
00000000  =0000000D                 32  CR          EQU     $0D     
00000000  =0000000A                 33  LF          EQU     $0A
00000000                            34       
00000000  =00000000                 35  zero        EQU     $00                     ; defined hex value 0
00000000  =00000001                 36  one         EQU     $01                     ; defined hex value 1 
00000000  =00000002                 37  two         EQU     $02                     ; defined hex value 2
00000000  =00000003                 38  three       EQU     $03                     ; defined hex value 3
00000000  =00000004                 39  four        EQU     $04                     ; defined hex value 4
00000000  =00000005                 40  five        EQU     $05                     ; defined hex value 5
00000000  =00000006                 41  six         EQU     $06                     ; defined hex value 6
00000000  =00000007                 42  seven       EQU     $07                     ; defined hex value 7
00000000  =00000008                 43  eight       EQU     $08                     ; defined hex value 8
00000000  =00000009                 44  nine        EQU     $09                     ; defined hex value 9
00000000  =0000000B                 45  eleven      EQU     $0B                     ; defined hex value 11
00000000  =0000000C                 46  twelve      EQU     $0C                     ; defined hex value 12
00000000  =0000000D                 47  thirteen    EQU     $0D                     ; defined hex value 13
00000000  =0000000E                 48  fourteen    EQU     $0E                     ; defined hex value 14
00000000                            49  
00000000  =00000000                 50  mask0       EQU     %00000000
00000000  =00000001                 51  mask1       EQU     %00000001
00000000  =00000002                 52  mask2       EQU     %00000010
00000000  =00000004                 53  mask3       EQU     %00000100
00000000  =00000008                 54  mask4       EQU     %00001000
00000000  =00000010                 55  mask5       EQU     %00010000
00000000  =00000020                 56  mask6       EQU     %00100000
00000000  =00000040                 57  mask7       EQU     %01000000
00000000  =00000080                 58  mask8       EQU     %10000000
00000000                            59  
00000000  =00000005                 60  maskA       EQU     %00000101
00000000  =0000000A                 61  maskB       EQU     %00001010
00000000  =00000014                 62  maskC       EQU     %00010100
00000000  =00000028                 63  maskD       EQU     %00101000
00000000  =00000050                 64  maskE       EQU     %01010000
00000000  =000000A0                 65  maskF       EQU     %10100000
00000000                            66  
00000000  =000000F0                 67  firstNib    EQU     $F0
00000000  =0000000F                 68  secNib      EQU     $0F
00000000                            69               
00001000                            70              ORG    $1000
00001000                            71  START: 
00001000                            72  ***********************************************************************************************************
00001000                            73  *
00001000                            74  *                   Dissassembler Start
00001000                            75  *
00001000                            76  ***********************************************************************************************************
00001000                            77              ; Dissassemble Start, obtain addr range
00001000  4EB9 00003C96             78              JSR         displayStart   
00001006                            79              
00001006  43F9 00004186             80              LEA         startingMessage, A1
0000100C  103C 000E                 81              MOVE.B      #14, D0
00001010  4E4F                      82              TRAP        #15    
00001012                            83          
00001012  103C 0002                 84              MOVE.B      #2, D0
00001016  4E4F                      85              TRAP        #15
00001018                            86      
00001018  4EB9 00003B2C             87              JSR         Address
0000101E  2042                      88              MOVEA.L     D2, A0
00001020                            89          
00001020  43F9 000041A8             90              LEA         endingMessage, A1
00001026  103C 000E                 91              MOVE.B      #14, D0
0000102A  4E4F                      92              TRAP        #15    
0000102C                            93      
0000102C  103C 0002                 94              MOVE.B      #2, D0
00001030  4E4F                      95              TRAP        #15
00001032                            96      
00001032  4EB9 00003B2C             97              JSR         Address
00001038  2442                      98              MOVEA.L     D2, A2
0000103A                            99          
0000103A  43F9 000041E7            100              LEA         newline, A1
00001040  103C 000E                101              MOVE.B      #14, D0
00001044  4E4F                     102              TRAP        #15 
00001046                           103            
00001046                           104  ***********************************************************************************************************
00001046                           105  *
00001046                           106  *                   Control Loop
00001046                           107  *
00001046                           108  *       This loop cycles and branches our code by the first nibble of OPCODE binary
00001046                           109  *
00001046                           110  ***********************************************************************************************************
00001046                           111            
00001046  4241                     112  LOOP        CLR         D1                  ; clear out D1
00001048  4242                     113              CLR         D2                  ; clear out D2
0000104A  B1CA                     114              CMPA.L      A2, A0              ; compare starting and ending addresses
0000104C  6E00 2C44                115              BGT         endProg             ; if A0 > A1, we've finished, end program
00001050  3648                     116              MOVEA       A0,A3
00001052  1218                     117              MOVE.B      (A0)+, D1           ; load byte to D1 and increment A0 to next byte
00001054  1401                     118              MOVE.B      D1, D2              ; copy byte to D2 for manipulation
00001056  E882                     119              ASR.L       #four, D2           ; get first nibble in D2
00001058                           120          
00001058  B43C 0000                121              CMP.B       #zero, D2           ; compare with 0
0000105C  6700 0064                122              BEQ         braZero             ; branch out to zero method
00001060  B43C 0001                123              CMP.B       #one, D2            ; compare with 1
00001064  6700 008C                124              BEQ         braOne              ; branch out to one method
00001068  B43C 0002                125              CMP.B       #two, D2            ; compare with 2    
0000106C  6700 0088                126              BEQ         braTwo              ; branch out to two method
00001070  B43C 0003                127              CMP.B       #three, D2          ; compare with 3
00001074  6700 0084                128              BEQ         braThree            ; branch out to three method
00001078  B43C 0004                129              CMP.B       #four, D2           ; compare with 4
0000107C  6700 0080                130              BEQ         braFour             ; branch out to four method
00001080  B43C 0005                131              CMP.B       #five, D2           ; compare with 5
00001084  6700 0094                132              BEQ         braFive             ; branch out to five method
00001088  B43C 0006                133              CMP.B       #six, D2            ; compare with 6
0000108C  6700 0090                134              BEQ         braSix              ; branch out to six method
00001090  B43C 0008                135              CMP.B       #eight, D2          ; compare with 8
00001094  6700 00BC                136              BEQ         braEight            ; branch out to eight method
00001098  B43C 0009                137              CMP.B       #nine, D2           ; compare with 9
0000109C  6700 00CE                138              BEQ         braNine             ; branch out to nine method
000010A0  B43C 000B                139              CMP.B       #eleven, D2         ; compare with 11
000010A4  6700 00CA                140              BEQ         braEleven           ; branch out to eleven method
000010A8  B43C 000C                141              CMP.B       #twelve, D2         ; compare with 12
000010AC  6700 00DC                142              BEQ         braTwelve           ; branch out to twelve method
000010B0  B43C 000D                143              CMP.B       #thirteen, D2       ; compare with 13
000010B4  6700 00D8                144              BEQ         braThirteen         ; branch out to thirteen method
000010B8  B43C 000E                145              CMP.B       #fourteen, D2       ; compare with 14
000010BC  6700 0122                146              BEQ         braFourteen         ; branch out to fourteen method
000010C0  6084                     147              BRA         loop
000010C2                           148  
000010C2                           149  ***********************************************************************************************************
000010C2                           150  *
000010C2                           151  *                   Nibble Branch Section
000010C2                           152  *
000010C2                           153  *       This section decides which nibble goes to the corresponding opcode
000010C2                           154  *
000010C2                           155  *********************************************************************************************************** 
000010C2                           156          
000010C2                           157  braZero     
000010C2  4242                     158              CLR         D2                  ; first nibble is 0, 3 opcodes are possible 
000010C4  1401                     159              MOVE.B      D1, D2              ; clear out D2 and copy D1 back in
000010C6  C43C 000F                160              AND.B       #secNib, D2         ; set first nibble to 0
000010CA                           161  
000010CA  B43C 0000                162              CMP.B       #zero, D2           ; compare second nibble to 0
000010CE  6700 0184                163              BEQ         opORI               ; branch to ORI method
000010D2  B43C 000C                164              CMP.B       #twelve, D2         ; compare second nibble to 12
000010D6  6700 02FC                165              BEQ         opCMPI              ; branch to CMPI method
000010DA  B43C 0008                166              CMP.B       #eight,D2           ; Test for static BCLR
000010DE  6700 047E                167              BEQ         opBCLR
000010E2  C47C 0001                168              AND         #one,D2             ; Sets all bits to 0 except for first bit if it is 1
000010E6  B43C 0001                169              CMP.B       #one,D2             ; if it is one then there is a chance it is dynamic BCLR
000010EA  6700 04D6                170              BEQ         opDynBCLR
000010EE  6000 2B9C                171              BRA         printInvalid
000010F2                           172          
000010F2                           173  braOne      
000010F2  6000 053C                174              BRA         opMOVEB             ; we know that there is only one opcode that is MOVE.B
000010F6                           175  
000010F6                           176  braTwo      
000010F6  6000 05BC                177              BRA         opMOVEL             ; there are two opCodes available, MOVE.L, or MOVEA.L
000010FA                           178  
000010FA                           179  braThree                                    ; there are two opCodes available, MOVE.W, or MOVEA.W
000010FA  6000 06B4                180              BRA         opMOVEW
000010FE                           181  
000010FE  4242                     182  braFour     CLR         D2                  ; first nibble is 4, 5 opcodes are possible 
00001100  1401                     183              MOVE.B      D1, D2              ; clear out D2 and copy D1 back in
00001102  C43C 000F                184              AND.B       #secNib, D2         ; set first nibble to 0
00001106                           185   
00001106  B43C 0004                186              CMP.B       #four, D2           ; compare second nibble to 4
0000110A  6700 079A                187              BEQ         opNEG               ; branch to NEG method
0000110E  B43C 000E                188              CMP.B       #fourteen, D2       ; compare second nibble to E
00001112  6700 0880                189              BEQ         opRTSJSR            ; branch to JSR or RTS method
00001116  6000 08F4                190              BRA         opMOVEMLEA          ; otherwise, branch to MOVEM or LEA method
0000111A                           191  
0000111A                           192  braFive     
0000111A  6000 10BC                193              BRA         opSUBQ              ; we know that there is only one opcode that is SUBQ
0000111E                           194  
0000111E                           195  braSix      
0000111E  4242                     196              CLR         D2                  ; first nibble is 6, 5 opcodes are possible 
00001120  1401                     197              MOVE.B      D1, D2              ; clear out D2 and copy D1 back in
00001122  C43C 000F                198              AND.B       #$0F, D2             ; set first nibble to 0
00001126                           199   
00001126  B43C 0000                200              CMP.B       #zero, D2           ; compare second nibble to 0
0000112A  6700 0F94                201              BEQ         opBRA               ; branch to BRA method
0000112E  B43C 0005                202              CMP.B       #five, D2           ; compare second nibble to 5
00001132  6700 0FC4                203              BEQ         opBCS               ; branch to BCS method
00001136  B43C 0008                204              CMP.B       #eight, D2          ; compare second nibble to 8
0000113A  6700 0FF4                205              BEQ         opBVC               ; branch to BCS method
0000113E  B43C 000C                206              CMP.B       #twelve, D2         ; compare second nibble to 12
00001142  6700 1024                207              BEQ         opBGE               ; branch to BGE method
00001146  B43C 000D                208              CMP.B       #thirteen,D2        ; compare second nibble to 13
0000114A  6700 1054                209              BEQ         opBLT               ; branch to BLT method
0000114E  6000 2B3C                210              BRA         printInvalid        ; found an un-supported opcode
00001152                           211  
00001152                           212  braEight                                    ; there are two opCodes available DIVS, or OR
00001152  4242                     213              CLR         D2                  ; clear D2 for use
00001154  E141                     214              ASL         #8,D1               ; Shift by eight 
00001156  1218                     215              MOVE.B      (A0)+,D1            ; Move the instruction byte into D1
00001158  3401                     216              MOVE.W      D1,D2               ; Load D2 with the word from D1
0000115A  EC42                     217              ASR         #six,D2             ; Shift by 6 to find second nibble
0000115C  C47C 0007                218              AND         #$07,D2             ; AND by 7 to remove unwanted bits
00001160  B43C 0007                219              CMP.B       #seven,D2           ; Compare second nibble to 7
00001164  6700 0B1A                220              BEQ         opDIVS              ; If bits 8 - 6 are equal to 7, we have DIVS
00001168  6000 09C8                221              BRA         opOR                ; else opcode is OR
0000116C                           222  
0000116C                           223  braNine     
0000116C  6000 0DFA                224              BRA         opSUB               ; we know that there is only one opcode that is SUB
00001170                           225  
00001170                           226  braEleven                                   ; there are two opCodes available EOR, or CMP
00001170  4242                     227              CLR         D2                  ; clear D2 for use
00001172  E141                     228              ASL         #8,D1               ; Shift by eight for
00001174  1218                     229              MOVE.B      (A0)+,D1            ; Re-load the instruction byte into D1
00001176  3401                     230              MOVE.W      D1,D2               ; Move the word into D2 for the comparison
00001178  EC42                     231              ASR         #six,D2             ; Shift by 6 to find second nibble
0000117A  C47C 0007                232              AND         #$07,D2             ; AND by 7 to remove unwanted bits
0000117E  B43C 0003                233              CMP.B       #three,D2           ; Compare second nibble to 3
00001182  6D00 0CA4                234              BLT         opCMP               ; If opmode bits are less than 3, we have CMP
00001186  6E00 0B52                235              BGT         opEOR               ; Else its EOR
0000118A                           236  
0000118A                           237  braTwelve   
0000118A  6000 10C4                238              BRA         opMULS              ; we know that there is only one opcode that is MULS    
0000118E                           239    
0000118E                           240  braThirteen 
0000118E  E141                     241              ASL         #eight, D1          ; we need the whole word to compare between add and adda, so move over the current byte 
00001190  1218                     242              MOVE.B      (A0)+, D1           ; load the remaining byte to D1
00001192                           243              
00001192  4242                     244              CLR         D2                  ; clear D2
00001194  3401                     245              MOVE.W      D1, D2              ; copy opcode to D2
00001196  EC42                     246              ASR         #six, D2            ; shift the bits right to get size and type
00001198  C47C 0007                247              AND         #seven,D2           ; clear out all but first 3 bits
0000119C                           248              
0000119C  B43C 0000                249              CMP.B       #zero,D2            ; compare 0 to D2
000011A0  6700 1112                250              BEQ         opADDB              ; we know its ADDB
000011A4  B43C 0001                251              CMP.B       #one, D2            ; compare 1 to D2
000011A8  6700 1176                252              BEQ         opADDW              ; we know its ADDW
000011AC  B43C 0002                253              CMP.B       #two, D2            ; compare 2 to D2
000011B0  6700 11DA                254              BEQ         opADDL              ; we know its ADDL
000011B4  B43C 0003                255              CMP.B       #three, D2          ; compare 3 to D2
000011B8  6700 1246                256              BEQ         opADDAW             ; we know its ADDAW
000011BC  B43C 0004                257              CMP.B       #four, D2           ; compare 4 to D2
000011C0  6700 10F2                258              BEQ         opADDB              ; we know its ADDB
000011C4  B43C 0005                259              CMP.B       #five, D2           ; compare 5 to D2
000011C8  6700 1156                260              BEQ         opADDW              ; we know its ADDW
000011CC  B43C 0006                261              CMP.B       #six, D2            ; compare 6 to D2
000011D0  6700 11BA                262              BEQ         opADDL              ; we know its ADDL
000011D4  B43C 0007                263              CMP.B       #seven, D2          ; compare 7 to D2
000011D8  6700 1296                264              BEQ         opADDAL             ; we know its ADDAL
000011DC  6000 2AAE                265              BRA         printInvalid        ; invalid opcode
000011E0                           266               
000011E0                           267  braFourteen 
000011E0  E141                     268              ASL.W       #eight,D1           ; we need the whole word to compare between add and adda, so move over the current byte
000011E2  1218                     269              MOVE.B      (A0)+, D1           ; load the remaining byte to D1
000011E4                           270              
000011E4  4242                     271              CLR         D2                  ; clear D2
000011E6  3401                     272              MOVE.W      D1, D2              ; copy opcode to D2
000011E8  EC42                     273              ASR         #six, D2            ; shift the bits right to get size
000011EA  C47C 0003                274              AND         #03,D2
000011EE                           275          
000011EE  B43C 0003                276              CMP.B       #three, D2          ; if the size is three, we are shifting memory
000011F2  6700 0006                277              BEQ         memShifts           ; go to memory shift
000011F6  6000 0040                278              BRA         regShifts           ; else go to register shift
000011FA                           279  
000011FA                           280  memShifts   
000011FA  4242                     281              CLR         D2             
000011FC  3401                     282              MOVE.W      D1, D2              ; clear out D2 and copy D1 back in
000011FE  E082                     283              ASR.L       #eight,D2           ; move to get first byte back
00001200  C47C 000F                284              AND         #secNib, D2         ; set first nibble to 0
00001204                           285   
00001204  B43C 0000                286              CMP.B       #zero, D2           ; compare second nibble to 0
00001208  6700 1322                287              BEQ         opASR               ; branch to ASR method
0000120C  B43C 0001                288              CMP.B       #one, D2            ; compare second nibble to 1
00001210  6700 12CE                289              BEQ         opASL               ; branch to ASL method
00001214  B43C 0002                290              CMP.B       #two, D2            ; compare second nibble to 2
00001218  6700 13AA                291              BEQ         opLSR               ; branch to LSR method
0000121C  B43C 0003                292              CMP.B       #three, D2          ; compare second nibble to 3
00001220  6700 1356                293              BEQ         opLSL               ; branch to LSL method
00001224  B43C 0006                294              CMP.B       #six, D2            ; compare second nibble to 6
00001228  6700 1432                295              BEQ         opROR               ; branch to ROR method
0000122C  B43C 0007                296              CMP.B       #seven, D2          ; compare second nibble to 7
00001230  6700 13DE                297              BEQ         opROL               ; branch to ROL method
00001234  6000 2A56                298              BRA         printInvalid        ; otherwise, invalid
00001238                           299              
00001238                           300  regShifts   
00001238  B43C 0000                301              CMP.B       #zero, D2           ; if size is 0, we are shifting a byte
0000123C  6700 146A                302              BEQ         memSB               ; branch to register shift byte
00001240  B43C 0001                303              CMP.B       #one, D2            ; if size is 1, we are shifting a word
00001244  6700 16EC                304              BEQ         memSW               ; branch to register shift word
00001248  B43C 0002                305              CMP.B       #two, D2            ; if size is 1, we are shifting a long
0000124C  6700 196E                306              BEQ         memSL               ; branch to register shift long
00001250  6000 2A3A                307              BRA         printInvalid        ; otherwise, invalid
00001254                           308              
00001254                           309  ***********************************************************************************************************
00001254                           310  *
00001254                           311  *                   ORI OPCODE
00001254                           312  *       ORI starts out with size branching. Will compare sizes and branch to appropriate size.
00001254                           313  *       Once size is found, code will print out ORI and continue to find mode and register and print it out
00001254                           314  *
00001254                           315  ***********************************************************************************************************
00001254                           316  
00001254                           317  opORI       
00001254  1218                     318              MOVE.B      (A0)+, D1
00001256  1401                     319              MOVE.B      D1,D2               ; copy data over
00001258  EC42                     320              ASR         #6,D2               ; shifts 6 bits over to read just the size        
0000125A  B43C 0000                321              CMP.B       #zero,D2            ; Size is 0, must be byte
0000125E  6700 0016                322              BEQ         opORIB              ; Branch to ORIB to print and deal with the byte
00001262  B43C 0001                323              CMP.B       #one,D2             ; Compare size to one
00001266  6700 0080                324              BEQ         opORIW              ; If size is one, then ORI is dealing with a word.
0000126A  B43C 0002                325              CMP.B       #two,D2             ; Compare size to two
0000126E  6700 00F2                326              BEQ         opORIL              ; If size is two then move onto deal with long in opORIL
00001272                           327          
00001272  6000 2A18                328              BRA         printInvalid        ; None matches, invalid code. Branch off.
00001276                           329          
00001276                           330  opORIB      
00001276  43F9 000041FC            331              LEA         ORImatch, A1        ; we know that the opcode will be ORI, so load A1 to print message
0000127C  103C 000E                332              MOVE.B      #14, D0             ; command for trap call to display message
00001280  4E4F                     333              TRAP        #15                 ; trap call
00001282                           334              
00001282  43F9 00004285            335              LEA         dispByte, A1        ; Display byte
00001288  103C 000E                336              MOVE.B      #14, D0             ; command for trap call to display message
0000128C  4E4F                     337              TRAP        #15                 ; trap call
0000128E                           338          
0000128E  43F9 000041EB            339              LEA         space, A1           ; Display space
00001294  103C 000E                340              MOVE.B      #14, D0             ; command for trap call to display message
00001298  4E4F                     341              TRAP        #15                 ; trap call
0000129A                           342          
0000129A  4244                     343              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
0000129C  1801                     344              MOVE.B      D1,D4               ; Move byte over to D4 to use
0000129E  E644                     345              ASR         #three,D4           ; Moves out insignifcant bits to find mode
000012A0  C87C 0007                346              AND         #seven,D4           ; Clear other bits besides mode
000012A4  4245                     347              CLR         D5                  ; Use D5 as temporary register for destination regsiter
000012A6  1A01                     348              MOVE.B      D1,D5               ; Move data over to isolate mode
000012A8  CA7C 0007                349              AND         #seven,D5           ; Isolate the mode
000012AC                           350          
000012AC  4243                     351              CLR         D3                  ; Clear D3 to move register into it
000012AE  4242                     352              CLR         D2                  ; Clear D2 to move mode into it
000012B0  163C 0004                353              MOVE.B      #four,D3            ; Set values to be used in printEA
000012B4  143C 0007                354              MOVE.B      #seven,D2           ; Set values to be used in printEA
000012B8                           355      
000012B8  4EB9 00002F1E            356              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000012BE                           357          
000012BE  43F9 000041F2            358              LEA         comma, A1           ; Display space
000012C4  103C 000E                359              MOVE.B      #14, D0             ; command for trap call to display message
000012C8  4E4F                     360              TRAP        #15                 ; trap call
000012CA                           361          
000012CA  4242                     362              CLR         D2                  ; Clear out D2 to move destination mode in
000012CC  4243                     363              CLR         D3                  ; Clear out D3 to move destintion register in
000012CE  1404                     364              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
000012D0  1605                     365              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA
000012D2                           366          
000012D2  4EB9 00002F1E            367              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000012D8                           368          
000012D8  43F9 000041E7            369              LEA         newLine, A1           ; Display space
000012DE  103C 000E                370              MOVE.B      #14, D0             ; command for trap call to display message
000012E2  4E4F                     371              TRAP        #15                 ; trap call
000012E4                           372          
000012E4  6000 FD60                373              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000012E8                           374          
000012E8                           375  opORIW      
000012E8  324B                     376              MOVE        A3,A1
000012EA  103C 000E                377              MOVE.B      #14,D0
000012EE  4E4F                     378              TRAP        #15
000012F0                           379              
000012F0  43F9 000041FC            380              LEA         ORImatch, A1        ; we know that the opcode will be ORI, so load A1 to print message
000012F6  103C 000E                381              MOVE.B      #14, D0             ; command for trap call to display message
000012FA  4E4F                     382              TRAP        #15                 ; trap call
000012FC                           383              
000012FC  43F9 00004288            384              LEA         dispWord, A1        ; Display byte
00001302  103C 000E                385              MOVE.B      #14, D0             ; command for trap call to display message
00001306  4E4F                     386              TRAP        #15                 ; trap call
00001308                           387          
00001308  43F9 000041EB            388              LEA         space, A1           ; Display space
0000130E  103C 000E                389              MOVE.B      #14, D0             ; command for trap call to display message
00001312  4E4F                     390              TRAP        #15                 ; trap call
00001314                           391          
00001314  4244                     392              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
00001316  1801                     393              MOVE.B      D1,D4               ; Move byte over to D4 to use
00001318  E644                     394              ASR         #three,D4           ; Moves out insignifcant bits to find mode
0000131A  C87C 0007                395              AND         #seven,D4           ; Clear other bits besides mode
0000131E  4245                     396              CLR         D5                  ; Use D5 as temporary register for destination regsiter
00001320  1A01                     397              MOVE.B      D1,D5               ; Move data over to isolate mode
00001322  CA7C 0007                398              AND         #seven,D5           ; Isolate the mode
00001326                           399          
00001326  4243                     400              CLR         D3                  ; Clear D3 to move register into it
00001328  4242                     401              CLR         D2                  ; Clear D2 to move mode into it
0000132A  163C 0004                402              MOVE.B      #four,D3            ; Set values to be used in printEA
0000132E  143C 0007                403              MOVE.B      #seven,D2           ; Set values to be used in printEA
00001332                           404          
00001332  4EB9 00002F1E            405              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001338                           406          
00001338  43F9 000041F2            407              LEA         comma, A1           ; Display space
0000133E  103C 000E                408              MOVE.B      #14, D0             ; command for trap call to display message
00001342  4E4F                     409              TRAP        #15                 ; trap call
00001344                           410          
00001344  4242                     411              CLR         D2                  ; Clear out D2 to move destination mode in
00001346  4243                     412              CLR         D3                  ; Clear out D3 to move destintion register in
00001348  1404                     413              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
0000134A  1605                     414              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA
0000134C                           415                  
0000134C  4EB9 00002F1E            416              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001352                           417          
00001352  43F9 000041E7            418              LEA         newLine, A1           ; Display space
00001358  103C 000E                419              MOVE.B      #14, D0             ; command for trap call to display message
0000135C  4E4F                     420              TRAP        #15                 ; trap call
0000135E                           421          
0000135E  6000 FCE6                422              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001362                           423       
00001362                           424  opORIL      
00001362  43F9 000041FC            425              LEA         ORImatch, A1        ; we know that the opcode will be ORI, so load A1 to print message
00001368  103C 000E                426              MOVE.B      #14, D0             ; command for trap call to display message
0000136C  4E4F                     427              TRAP        #15                 ; trap call
0000136E                           428              
0000136E  43F9 0000428B            429              LEA         dispLong, A1        ; Display byte
00001374  103C 000E                430              MOVE.B      #14, D0             ; command for trap call to display message
00001378  4E4F                     431              TRAP        #15                 ; trap call
0000137A                           432          
0000137A  43F9 000041EB            433              LEA         space, A1           ; Display space
00001380  103C 000E                434              MOVE.B      #14, D0             ; command for trap call to display message
00001384  4E4F                     435              TRAP        #15                 ; trap call
00001386                           436          
00001386  4244                     437              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
00001388  1801                     438              MOVE.B      D1,D4               ; Move byte over to D4 to use
0000138A  E644                     439              ASR         #three,D4           ; Moves out insignifcant bits to find mode
0000138C  C87C 0007                440              AND         #seven,D4           ; Clear other bits besides mode
00001390  4245                     441              CLR         D5                  ; Use D5 as temporary register for destination regsiter
00001392  1A01                     442              MOVE.B      D1,D5               ; Move data over to isolate mode
00001394  CA7C 0007                443              AND         #seven,D5           ; Isolate the mode
00001398                           444          
00001398  4243                     445              CLR         D3                  ; Clear D3 to move register into it
0000139A  4242                     446              CLR         D2                  ; Clear D2 to move mode into it
0000139C  163C 0004                447              MOVE.B      #four,D3            ; Set values to be used in printEA
000013A0  143C 0007                448              MOVE.B      #seven,D2           ; Set values to be used in printEA
000013A4                           449          
000013A4  4EB9 00002F1E            450              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000013AA                           451          
000013AA  4242                     452              CLR         D2                  ; Clear out D2 to move destination mode in
000013AC  4243                     453              CLR         D3                  ; Clear out D3 to move destintion register in
000013AE  1404                     454              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
000013B0  1605                     455              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA
000013B2                           456          
000013B2  43F9 000041F2            457              LEA         comma, A1           ; Display space
000013B8  103C 000E                458              MOVE.B      #14, D0             ; command for trap call to display message
000013BC  4E4F                     459              TRAP        #15                 ; trap call
000013BE                           460          
000013BE  4EB9 00002F1E            461              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000013C4                           462          
000013C4  43F9 000041E7            463              LEA         newLine, A1           ; Display space
000013CA  103C 000E                464              MOVE.B      #14, D0             ; command for trap call to display message
000013CE  4E4F                     465              TRAP        #15                 ; trap call
000013D0                           466          
000013D0  6000 FC74                467              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000013D4                           468          
000013D4                           469  ***********************************************************************************************************
000013D4                           470  *
000013D4                           471  *                   CMPI OPCODE
000013D4                           472  *       This section is dedicated to the compare (CMPI) instruction. Its determined in the control loop
000013D4                           473  *       that the first nibble is 0 for CMPI, and the second nibble is 12.
000013D4                           474  *       The type of CMPI, or the opmode, is used to determined what we output to our console next.
000013D4                           475  *       From that point, we load the correct size/opmode, and then route to the EA subroutine to output
000013D4                           476  *       EA related register information.
000013D4                           477  *       The process for finding the operand register info (EA info) is similar for all opmodes.
000013D4                           478  *
000013D4                           479  ***********************************************************************************************************
000013D4                           480          
000013D4                           481  opCMPI           
000013D4  1218                     482              MOVE.B      (A0)+, D1
000013D6  1401                     483              MOVE.B      D1,D2               ; copy data over
000013D8  EC42                     484              ASR         #6,D2               ; shifts 6 bits over to read just the size        
000013DA  B43C 0000                485              CMP.B       #zero,D2            ; Check if size is 0 which is byte
000013DE  6700 0016                486              BEQ         opCMPIB             ; Moves to CMPIB if it is 0
000013E2  B43C 0001                487              CMP.B       #one,D2             ; Check if size is 0 which is word
000013E6  6700 0080                488              BEQ         opCMPIW             ; Branch to CMPIW
000013EA  B43C 0002                489              CMP.B       #two,D2             ; Check if size is 2 which is long
000013EE  6700 00FC                490              BEQ         opCMPIL             ; Branch to CMPIL
000013F2  6000 21A2                491              BRA         invalid             ; Size is invalid, therefore code is invalid.
000013F6                           492  
000013F6                           493  opCMPIB 
000013F6  43F9 00004200            494              LEA         CMPImatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
000013FC  103C 000E                495              MOVE.B      #14, D0             ; command for trap call to display message
00001400  4E4F                     496              TRAP        #15                 ; trap call
00001402                           497          
00001402  43F9 00004285            498              LEA         dispByte, A1        ; Display byte
00001408  103C 000E                499              MOVE.B      #14, D0             ; command for trap call to display message
0000140C  4E4F                     500              TRAP        #15                 ; trap call
0000140E                           501          
0000140E  43F9 000041EB            502              LEA         space, A1           ; Display space
00001414  103C 000E                503              MOVE.B      #14, D0             ; command for trap call to display message
00001418  4E4F                     504              TRAP        #15                 ; trap call
0000141A                           505          
0000141A  4244                     506              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
0000141C  1801                     507              MOVE.B      D1,D4               ; Move byte over to D4 to use
0000141E  E644                     508              ASR         #three,D4           ; Moves out insignifcant bits to find mode
00001420  C87C 0007                509              AND         #seven,D4           ; Clear other bits besides mode
00001424  4245                     510              CLR         D5                  ; Use D5 as temporary register for destination regsiter
00001426  1A01                     511              MOVE.B      D1,D5               ; Move data over to isolate mode
00001428  CA7C 0007                512              AND         #seven,D5           ; Isolate the mode
0000142C                           513          
0000142C  4243                     514              CLR         D3                  ; Clear D3 to move register into it
0000142E  4242                     515              CLR         D2                  ; Clear D2 to move mode into it
00001430  163C 0004                516              MOVE.B      #four,D3            ; Set values to be used in printEA
00001434  143C 0007                517              MOVE.B      #seven,D2           ; Set values to be used in printEA  
00001438                           518          
00001438  4EB9 00002F1E            519              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000143E                           520              
0000143E  43F9 000041F2            521              LEA         comma, A1           ; Display space
00001444  103C 000E                522              MOVE.B      #14, D0             ; command for trap call to display message
00001448  4E4F                     523              TRAP        #15                 ; trap call
0000144A                           524          
0000144A  4242                     525              CLR         D2                  ; Clear out D2 to move destination mode in
0000144C  4243                     526              CLR         D3                  ; Clear out D3 to move destintion register in
0000144E  1404                     527              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
00001450  1605                     528              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA    
00001452                           529          
00001452  4EB9 00002F1E            530              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001458                           531          
00001458  43F9 000041E7            532              LEA         newLine, A1         ; Display space
0000145E  103C 000E                533              MOVE.B      #14, D0             ; command for trap call to display message
00001462  4E4F                     534              TRAP        #15                 ; trap call
00001464                           535  
00001464  6000 FBE0                536              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001468                           537  
00001468                           538  opCMPIW 
00001468  43F9 00004200            539              LEA         CMPImatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
0000146E  103C 000E                540              MOVE.B      #14, D0             ; command for trap call to display message
00001472  4E4F                     541              TRAP        #15                 ; trap call
00001474                           542          
00001474  43F9 00004288            543              LEA         dispWord, A1        ; Display byte
0000147A  103C 000E                544              MOVE.B      #14, D0             ; command for trap call to display message
0000147E  4E4F                     545              TRAP        #15                 ; trap call
00001480                           546          
00001480  43F9 000041EB            547              LEA         space, A1           ; Display space
00001486  103C 000E                548              MOVE.B      #14, D0             ; command for trap call to display message
0000148A  4E4F                     549              TRAP        #15                 ; trap call
0000148C                           550          
0000148C  4244                     551              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
0000148E  1801                     552              MOVE.B      D1,D4               ; Move byte over to D4 to use
00001490  E644                     553              ASR         #three,D4           ; Moves out insignifcant bits to find mode
00001492  C87C 0007                554              AND         #seven,D4           ; Clear other bits besides mode
00001496  4245                     555              CLR         D5                  ; Use D5 as temporary register for destination regsiter
00001498  1A01                     556              MOVE.B      D1,D5               ; Move data over to isolate mode
0000149A  CA7C 0007                557              AND         #seven,D5           ; Isolate the mode
0000149E                           558          
0000149E  4243                     559              CLR         D3                  ; Clear D3 to move register into it
000014A0  4242                     560              CLR         D2                  ; Clear D2 to move mode into it
000014A2  163C 0004                561              MOVE.B      #four,D3            ; Set values to be used in printEA
000014A6  143C 0007                562              MOVE.B      #seven,D2           ; Set values to be used in printEA      
000014AA                           563          
000014AA  4EB9 00002F1E            564              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000014B0                           565          
000014B0  43F9 000041EE            566              LEA         hashTag, A1         ; Display space
000014B6  103C 000E                567              MOVE.B      #14, D0             ; command for trap call to display message
000014BA  4E4F                     568              TRAP        #15                 ; trap call
000014BC                           569          
000014BC  103C 0003                570              MOVE.B      #3, D0              ; Move 3 into D0 to output
000014C0  4E4F                     571              TRAP        #15                 ; Use TRAP #15 to output the immediate data
000014C2                           572          
000014C2  43F9 000041F2            573              LEA         comma, A1           ; Display space
000014C8  103C 000E                574              MOVE.B      #14, D0             ; command for trap call to display message
000014CC  4E4F                     575              TRAP        #15                 ; trap call
000014CE                           576  
000014CE  4242                     577              CLR         D2                  ; Clear out D2 to move destination mode in
000014D0  4243                     578              CLR         D3                  ; Clear out D3 to move destintion register in
000014D2  1404                     579              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
000014D4  1605                     580              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA    
000014D6                           581          
000014D6  4EB9 00002F1E            582              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000014DC                           583          
000014DC  43F9 000041E7            584              LEA         newLine, A1           ; Display space
000014E2  103C 000E                585              MOVE.B      #14, D0             ; command for trap call to display message
000014E6  4E4F                     586              TRAP        #15                 ; trap call
000014E8  6000 FB5C                587              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000014EC                           588  
000014EC                           589  opCMPIL 
000014EC  43F9 00004200            590              LEA         CMPImatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
000014F2  103C 000E                591              MOVE.B      #14, D0             ; command for trap call to display message
000014F6  4E4F                     592              TRAP        #15                 ; trap call
000014F8                           593          
000014F8  43F9 0000428B            594              LEA         dispLong, A1        ; Display byte
000014FE  103C 000E                595              MOVE.B      #14, D0             ; command for trap call to display message
00001502  4E4F                     596              TRAP        #15                 ; trap call
00001504                           597          
00001504  43F9 000041EB            598              LEA         space, A1           ; Display space
0000150A  103C 000E                599              MOVE.B      #14, D0             ; command for trap call to display message
0000150E  4E4F                     600              TRAP        #15                 ; trap call
00001510                           601              
00001510  4244                     602              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
00001512  1801                     603              MOVE.B      D1,D4               ; Move byte over to D4 to use
00001514  E644                     604              ASR         #three,D4           ; Moves out insignifcant bits to find mode
00001516  C87C 0007                605              AND         #seven,D4           ; Clear other bits besides mode
0000151A  4245                     606              CLR         D5                  ; Use D5 as temporary register for destination regsiter
0000151C  1A01                     607              MOVE.B      D1,D5               ; Move data over to isolate mode
0000151E  CA7C 0007                608              AND         #seven,D5           ; Isolate the mode
00001522                           609          
00001522  4243                     610              CLR         D3                  ; Clear D3 to move register into it
00001524  4242                     611              CLR         D2                  ; Clear D2 to move mode into it
00001526  163C 0004                612              MOVE.B      #four,D3            ; Set values to be used in printEA
0000152A  143C 0007                613              MOVE.B      #seven,D2           ; Set values to be used in printEA  
0000152E                           614          
0000152E  4EB9 00002F1E            615              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001534                           616          
00001534  43F9 000041F2            617              LEA         comma, A1           ; Display space
0000153A  103C 000E                618              MOVE.B      #14, D0             ; command for trap call to display message
0000153E  4E4F                     619              TRAP        #15                 ; trap call
00001540                           620          
00001540  4242                     621              CLR         D2                  ; Clear out D2 to move destination mode in
00001542  4243                     622              CLR         D3                  ; Clear out D3 to move destintion register in
00001544  1404                     623              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
00001546  1605                     624              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA                
00001548                           625          
00001548  4EB9 00002F1E            626              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000154E                           627          
0000154E  43F9 000041E7            628              LEA         newLine, A1         ; Display space
00001554  103C 000E                629              MOVE.B      #14, D0             ; command for trap call to display message
00001558  4E4F                     630              TRAP        #15                 ; trap call
0000155A                           631          
0000155A  6000 FAEA                632              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
0000155E                           633          
0000155E                           634  ***********************************************************************************************************
0000155E                           635  *
0000155E                           636  *                   BCLR OPCODE
0000155E                           637  *       This section is dedicated to the compare BCLR instruction. The first nibble is 0 and the second
0000155E                           638  *       nibble is 2. Once both checks are passed then code goes to print BCLR and its EA.
0000155E                           639  *       
0000155E                           640  ***********************************************************************************************************
0000155E                           641  
0000155E                           642  opBCLR      
0000155E  43F9 00004205            643              LEA         BCLRmatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
00001564  103C 000E                644              MOVE.B      #14, D0             ; command for trap call to display message
00001568  4E4F                     645              TRAP        #15                 ; trap call
0000156A                           646  
0000156A  43F9 000041EB            647              LEA         space, A1           ; Display space
00001570  103C 000E                648              MOVE.B      #14, D0             ; command for trap call to display message
00001574  4E4F                     649              TRAP        #15                 ; trap call
00001576                           650                  
00001576  4242                     651              CLR         D2                  ; Clear data register
00001578  1218                     652              MOVE.B      (A0)+, D1           ; Move byte over to D1 to be used
0000157A  1401                     653              MOVE.B      D1,D2               ; copy data over
0000157C  E642                     654              ASR         #three,D2           ; Shift to the right to remove register
0000157E  C47C 0007                655              AND         #seven,D2           ; Sets other bits to 0 and leave Mode the same
00001582                           656                  
00001582  4243                     657              CLR         D3                  ; Clear D3 so we can move D1 in
00001584  1601                     658              MOVE.B      D1,D3               ; Move othr byte in
00001586  C67C 0007                659              AND         #seven,D3           ; Set everything besides register to 0
0000158A                           660                 
0000158A  4241                     661              CLR         D1                  ; Clear out data register
0000158C  3218                     662              MOVE.W      (A0)+, D1           ; Take in next nibble that contains data
0000158E                           663                 
0000158E                           664                  
0000158E  43F9 000041EE            665              LEA         hashTag, A1         ; Display space
00001594  103C 000E                666              MOVE.B      #14, D0             ; command for trap call to display message
00001598  4E4F                     667              TRAP        #15                 ; trap call
0000159A                           668          
0000159A  103C 0003                669              MOVE.B      #3, D0
0000159E  4E4F                     670              TRAP        #15
000015A0                           671          
000015A0  43F9 000041F2            672              LEA         comma, A1           ; Display space
000015A6  103C 000E                673              MOVE.B      #14, D0             ; command for trap call to display message
000015AA  4E4F                     674              TRAP        #15                 ; trap call
000015AC                           675                  
000015AC  4EB9 00002F1E            676              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000015B2                           677          
000015B2  43F9 000041E7            678              LEA         newLine, A1           ; Display space
000015B8  103C 000E                679              MOVE.B      #14, D0             ; command for trap call to display message
000015BC  4E4F                     680              TRAP        #15                 ; trap call
000015BE                           681                  
000015BE  6000 FA86                682              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits   
000015C2                           683          
000015C2                           684  opDynBCLR       
000015C2  4241                     685              CLR         D1
000015C4  1218                     686              MOVE.B      (A0)+,D1            ; Copy second byte in
000015C6  1601                     687              MOVE.B      D1,D3               ; Will use D4 to store in the source register
000015C8  E243                     688              ASR         #one,D3             ; Shift register over to the end
000015CA  C67C 0007                689              AND         #seven,D3           ; Change all bits except for the register to 0. Source Register is now in D4
000015CE                           690                  
000015CE  1401                     691              MOVE.B      D1,D2
000015D0  EC42                     692              ASR         #six,D2             ; Removing mode and register to check BCLR bits
000015D2  B47C 0002                693              CMP         #two,D2             ; Checking the static bits to make sure it is BCLR
000015D6  6600 26B4                694              BNE         printInvalid        ; If not equal, than this is not BCLR or any other mode we're dealing with
000015DA                           695  
000015DA                           696                  
000015DA  43F9 00004205            697              LEA         BCLRmatch, A1       ; we now know that the opcode will be BCLR, so load A1 to print message
000015E0  103C 000E                698              MOVE.B      #14, D0             ; command for trap call to display message
000015E4  4E4F                     699              TRAP        #15                 ; trap call  
000015E6                           700                  
000015E6  43F9 000041EB            701              LEA         space, A1           ; Display space
000015EC  103C 000E                702              MOVE.B      #14, D0             ; command for trap call to display message
000015F0  4E4F                     703              TRAP        #15                 ; trap call
000015F2                           704                  
000015F2  143C 0000                705              MOVE.B      #zero,D2            ; Move 0 into D2 to print out data register in printEA   
000015F6  4EB9 00002F1E            706              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000015FC                           707                  
000015FC  43F9 000041F2            708              LEA         comma, A1           ; Display space
00001602  103C 000E                709              MOVE.B      #14, D0             ; command for trap call to display message
00001606  4E4F                     710              TRAP        #15                 ; trap call
00001608                           711                
00001608  4242                     712              CLR         D2
0000160A  1401                     713              MOVE.B      D1,D2               ; Using D2 to store EA mode
0000160C  E642                     714              ASR         #three,D2           ; Remove/shift the register out
0000160E  C47C 0007                715              AND         #seven,D2           ; Change all bits except for the mode bits to 0
00001612                           716                  
00001612  4243                     717              CLR         D3                  ; Clearing D3 to avoid mashing data
00001614  1601                     718              MOVE.B      D1,D3               ; Moving byte into D3. Using D3 to store EA register
00001616  C67C 0007                719              AND         #seven,D3           ; Change all bits except for register bits to 0
0000161A                           720              
0000161A  4EB9 00002F1E            721              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001620                           722          
00001620  43F9 000041E7            723              LEA         newLine, A1         ; Display space
00001626  103C 000E                724              MOVE.B      #14, D0             ; command for trap call to display message
0000162A  4E4F                     725              TRAP        #15                 ; trap call            
0000162C                           726  
0000162C                           727  
0000162C  6000 FA18                728              BRA         LOOP                ; go back to the loop   
00001630                           729                  
00001630                           730  ***********************************************************************************************************
00001630                           731  *
00001630                           732  *                   MOVE OPCODE
00001630                           733  *                   MOVEA OPCODE
00001630                           734  *       This section of code is dedication to MOVE and MOVEA opcode instructions. MOVEA is determined by
00001630                           735  *       its static bits at 8, 7, and 6. Once those static bits are confirmed, the code branches off to 
00001630                           736  *       MOVEA, else it continues into MOVE.
00001630                           737  *
00001630                           738  ***********************************************************************************************************
00001630                           739   
00001630                           740  opMOVEB 
00001630  43F9 0000420A            741              LEA         MOVEmatch, A1       ; we know that the opcode will be MOVE.B, so load A1 to print message
00001636  103C 000E                742              MOVE.B      #14, D0             ; command for trap call to display message
0000163A  4E4F                     743              TRAP        #15                 ; trap call
0000163C  43F9 00004285            744              LEA         dispByte, A1        ; display byte
00001642  103C 000E                745              MOVE.B      #14, D0             ; command for trap call to display message
00001646  4E4F                     746              TRAP        #15                 ; trap call
00001648  43F9 000041EB            747              LEA         space, A1           ; create spaces
0000164E  103C 000E                748              MOVE.B      #14, D0             ; command for trap call to display message
00001652  4E4F                     749              TRAP        #15                 ; trap call
00001654                           750          
00001654                           751          
00001654  4245                     752              CLR         D5                  ; Clear D5
00001656  1A01                     753              MOVE.B      D1,D5               ; Copying byte over to D5. Will use D5 to store destination Register
00001658  E245                     754              ASR         #one,D5             ; shifted mode out. Register is now stored into D5
0000165A  CA7C 0007                755              AND         #seven,D5
0000165E                           756          
0000165E  4244                     757              CLR         D4                  ; Clear out D4
00001660  1801                     758              MOVE.B      D1,D4               ; Copy byte over to store destination mode
00001662  C87C 0001                759              AND         #one,D4             ; Set all the other bits to 0, leave the bit for the destination mode alone.
00001666                           760          
00001666  4241                     761              CLR          D1                 ; Clear data register
00001668  4242                     762              CLR          D2                 ; Clear data register
0000166A  1218                     763              MOVE.B      (A0)+,D1            ; Copy byte into D1
0000166C  1401                     764              MOVE.B      D1,D2
0000166E  EC42                     765              ASR         #6,D2               ; Shifts source mode and register out to get destination mode
00001670  D842                     766              ADD         D2,D4               ; Adds the remaining bits to D4
00001672                           767          
00001672  4242                     768              CLR         D2                  ; Clear data register
00001674  1401                     769              MOVE.B      D1,D2               ; Copy new byte over to D2
00001676  E642                     770              ASR         #three,D2           ; Shift source register out
00001678  C47C 0007                771              AND         #seven,D2           ; Set everything to 0 except for the mode
0000167C                           772          
0000167C  4243                     773              CLR         D3                  ; Clear Data register 3
0000167E  1601                     774              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
00001680  C67C 0007                775              AND         #seven,D3           ; Sets up everything to 0 except for the register bits
00001684                           776          
00001684  4EB9 00002F1E            777              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000168A                           778          
0000168A  43F9 000041F2            779              LEA         comma, A1           ; Display space
00001690  103C 000E                780              MOVE.B      #14, D0             ; command for trap call to display message
00001694  4E4F                     781              TRAP        #15                 ; trap call
00001696                           782          
00001696  4242                     783              CLR         D2                  ; Clear data register
00001698  4243                     784              CLR         D3                  ; Clear data register
0000169A  1404                     785              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
0000169C  1605                     786              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
0000169E                           787          
0000169E  4EB9 00002F1E            788              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000016A4                           789          
000016A4  43F9 000041E7            790              LEA         newLine, A1         ; Display space
000016AA  103C 000E                791              MOVE.B      #14, D0             ; command for trap call to display message
000016AE  4E4F                     792              TRAP        #15                 ; trap call            
000016B0                           793  
000016B0  6000 F994                794              BRA         LOOP                ; go back to the loop
000016B4                           795          
000016B4                           796  opMOVEL     
000016B4  4245                     797              CLR         D5                  ; Clear D5
000016B6  1A01                     798              MOVE.B      D1,D5               ; Copying byte over to D5. Will use D5 to store destination Register
000016B8  E245                     799              ASR         #one,D5             ; shifted mode out. Register is now stored into D5
000016BA  CA7C 0007                800              AND         #seven,D5
000016BE                           801          
000016BE  4244                     802              CLR         D4                  ; Clear out D4
000016C0  1801                     803              MOVE.B      D1,D4               ; Copy byte over to store destination mode
000016C2  C87C 0001                804              AND         #one,D4             ; Set all the other bits to 0, leave the bit for the destination mode alone.
000016C6                           805          
000016C6  4241                     806              CLR          D1                 ; Clear data register
000016C8  4242                     807              CLR          D2                 ; Clear data register
000016CA  1218                     808              MOVE.B      (A0)+,D1            ; Copy byte into D1
000016CC  1401                     809              MOVE.B      D1,D2
000016CE  EC42                     810              ASR         #6,D2               ; Shifts source mode and register out to get destination mode
000016D0  D842                     811              ADD         D2,D4               ; Adds the remaining bits to D4
000016D2                           812          
000016D2  B87C 0001                813              CMP         #one,D4             ; Check if it is MOVEA
000016D6  6700 0070                814              BEQ         opMOVEAL            ; If it is, branch off
000016DA                           815              
000016DA  43F9 0000420A            816              LEA         MOVEmatch, A1       ; we know that the opcode will be MOVE.L OR MOVEA.L, so load A1 to print message
000016E0  103C 000E                817              MOVE.B      #14, D0             ; command for trap call to display message
000016E4  4E4F                     818              TRAP        #15                 ; trap call  
000016E6                           819              
000016E6  43F9 0000428B            820              LEA         dispLong,A1         ; Prints out L to display a long
000016EC  103C 000E                821              MOVE.B      #14, D0             ; command for trap call to display message
000016F0  4E4F                     822              TRAP        #15                 ; trap call
000016F2                           823              
000016F2  43F9 000041EB            824              LEA         space, A1           ; create spaces
000016F8  103C 000E                825              MOVE.B      #14, D0             ; command for trap call to display message
000016FC  4E4F                     826              TRAP        #15                 ; trap call
000016FE                           827          
000016FE  4242                     828              CLR         D2                  ; Clear data register
00001700  1401                     829              MOVE.B      D1,D2               ; Copy new byte over to D2
00001702  E642                     830              ASR         #three,D2           ; Shift source register out
00001704  C47C 0007                831              AND         #seven,D2           ; Set everything to 0 except for the mode
00001708                           832          
00001708  4243                     833              CLR         D3                  ; Clear Data register 3
0000170A  1601                     834              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
0000170C  C67C 0007                835              AND         #seven,D3           ; Sets up everything to 0 except for the register bits      
00001710                           836              
00001710  4246                     837              CLR         D6                  ; Clear data register
00001712  1C3C 0001                838              MOVE.B      #1,D6               ; Moves 1 into D6 to be used in printEA to display long
00001716  4EB9 00002F1E            839              JSR         printEA             ; Prints out EA
0000171C  4246                     840              CLR         D6
0000171E                           841              
0000171E  43F9 000041F2            842              LEA         comma, A1           ; Display comma
00001724  103C 000E                843              MOVE.B      #14, D0             ; command for trap call to display message
00001728  4E4F                     844              TRAP        #15                 ; trap call
0000172A                           845          
0000172A  4242                     846              CLR         D2                  ; Clear data register            
0000172C  4243                     847              CLR         D3                  ; Clear data register
0000172E  1404                     848              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
00001730  1605                     849              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
00001732                           850          
00001732  4EB9 00002F1E            851              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001738                           852  
00001738  43F9 000041E7            853              LEA         newLine, A1         ; Display space
0000173E  103C 000E                854              MOVE.B      #14, D0             ; command for trap call to display message
00001742  4E4F                     855              TRAP        #15                 ; trap call            
00001744                           856  
00001744  6000 F900                857              BRA         LOOP                ; go back to the loop
00001748                           858              
00001748                           859  opMOVEAL
00001748  43F9 0000420F            860              LEA         MOVEAmatch,A1       ; MOVEA has been determined. Print out MOVEA
0000174E  103C 000E                861              MOVE.B      #14, D0             ; command for trap call to display message
00001752  4E4F                     862              TRAP        #15                 ; trap call
00001754                           863              
00001754  43F9 0000428B            864              LEA         dispLong,A1         ; Prints out L
0000175A  103C 000E                865              MOVE.B      #14, D0             ; command for trap call to display message
0000175E  4E4F                     866              TRAP        #15                 ; trap call
00001760                           867              
00001760                           868  
00001760  43F9 000041EB            869              LEA         space, A1           ; create spaces
00001766  103C 000E                870              MOVE.B      #14, D0             ; command for trap call to display message
0000176A  4E4F                     871              TRAP        #15                 ; trap call
0000176C                           872              
0000176C  4242                     873              CLR         D2                  ; Clear data register
0000176E  1401                     874              MOVE.B      D1,D2               ; Copy new byte over to D2
00001770  E642                     875              ASR         #three,D2           ; Shift source register out
00001772  C47C 0007                876              AND         #seven,D2           ; Set everything to 0 except for the mode
00001776                           877          
00001776  4243                     878              CLR         D3                  ; Clear Data register 3
00001778  1601                     879              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
0000177A  C67C 0007                880              AND         #seven,D3           ; Sets up everything to 0 except for the register bits    
0000177E                           881              
0000177E  4241                     882              CLR         D1                  ; Clear D1
00001780                           883              
00001780  4EB9 00002F1E            884              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001786                           885              
00001786  43F9 000041F2            886              LEA         comma, A1           ; Display comma
0000178C  103C 000E                887              MOVE.B      #14, D0             ; command for trap call to display message
00001790  4E4F                     888              TRAP        #15                 ; trap call
00001792                           889  
00001792  4242                     890              CLR         D2                  ; Clear data register
00001794  4243                     891              CLR         D3                  ; Clear data register
00001796  1404                     892              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
00001798  1605                     893              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
0000179A                           894          
0000179A  4EB9 00002F1E            895              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000017A0                           896          
000017A0  43F9 000041E7            897              LEA         newLine, A1         ; Display space
000017A6  103C 000E                898              MOVE.B      #14, D0             ; command for trap call to display message
000017AA  4E4F                     899              TRAP        #15                 ; trap call            
000017AC                           900  
000017AC  6000 F898                901              BRA         LOOP                ; go back to the loop
000017B0                           902  
000017B0                           903  opMOVEW
000017B0  4245                     904              CLR         D5                  ; Clear D5
000017B2  1A01                     905              MOVE.B      D1,D5               ; Copying byte over to D5. Will use D5 to store destination Register
000017B4  E245                     906              ASR         #one,D5             ; shifted mode out. Register is now stored into D5
000017B6  CA7C 0007                907              AND         #seven,D5
000017BA                           908          
000017BA  4244                     909              CLR         D4                  ; Clear out D4
000017BC  1801                     910              MOVE.B      D1,D4               ; Copy byte over to store destination mode
000017BE  C87C 0001                911              AND         #one,D4             ; Set all the other bits to 0, leave the bit for the destination mode alone.
000017C2                           912          
000017C2  4241                     913              CLR          D1                 ; Clear data register
000017C4  4242                     914              CLR          D2                 ; Clear data register
000017C6  1218                     915              MOVE.B      (A0)+,D1            ; Copy byte into D1
000017C8  1401                     916              MOVE.B      D1,D2
000017CA  EC42                     917              ASR         #6,D2               ; Shifts source mode and register out to get destination mode
000017CC  D842                     918              ADD         D2,D4               ; Adds the remaining bits to D4
000017CE                           919          
000017CE  B87C 0001                920              CMP         #one,D4             ; Check if it is MOVEA
000017D2  6700 006A                921              BEQ         opMOVEAW            ; If it is, branch off
000017D6                           922              
000017D6  43F9 0000420A            923              LEA         MOVEmatch, A1       ; we know that the opcode will be MOVE.L OR MOVEA.L, so load A1 to print message
000017DC  103C 000E                924              MOVE.B      #14, D0             ; command for trap call to display message
000017E0  4E4F                     925              TRAP        #15                 ; trap call  
000017E2                           926              
000017E2  43F9 00004288            927              LEA         dispWord,A1         ; Prints out a W after the opcode
000017E8  103C 000E                928              MOVE.B      #14, D0             ; command for trap call to display message
000017EC  4E4F                     929              TRAP        #15                 ; trap call
000017EE                           930              
000017EE  43F9 000041EB            931              LEA         space, A1           ; create spaces
000017F4  103C 000E                932              MOVE.B      #14, D0             ; command for trap call to display message
000017F8  4E4F                     933              TRAP        #15                 ; trap call
000017FA                           934          
000017FA  4242                     935              CLR         D2
000017FC  1401                     936              MOVE.B      D1,D2               ; Copy new byte over to D2
000017FE  E642                     937              ASR         #three,D2           ; Shift source register out
00001800  C47C 0007                938              AND         #seven,D2           ; Set everything to 0 except for the mode
00001804                           939          
00001804  4243                     940              CLR         D3                  ; Clear Data register 3
00001806  1601                     941              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
00001808  C67C 0007                942              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
0000180C                           943              
0000180C  4241                     944              CLR         D1                  ; Clear D1
0000180E                           945              
0000180E  4EB9 00002F1E            946              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001814                           947              
00001814  43F9 000041F2            948              LEA         comma, A1           ; Display comma
0000181A  103C 000E                949              MOVE.B      #14, D0             ; command for trap call to display message
0000181E  4E4F                     950              TRAP        #15                 ; trap call
00001820                           951          
00001820  4242                     952              CLR         D2                  ; Clear data register 
00001822  4243                     953              CLR         D3                  ; Clear data register
00001824  1404                     954              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
00001826  1605                     955              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
00001828  4EB9 00002F1E            956              JSR         printEA
0000182E                           957          
0000182E  43F9 000041E7            958              LEA         newLine, A1         ; Display space
00001834  103C 000E                959              MOVE.B      #14, D0             ; command for trap call to display message
00001838  4E4F                     960              TRAP        #15                 ; trap call            
0000183A                           961  
0000183A  6000 F80A                962              BRA         LOOP                ; go back to the loop
0000183E                           963              
0000183E                           964  opMOVEAW  
0000183E  43F9 0000420F            965              LEA         MOVEAmatch,A1       ; Prints out MOVEA
00001844  103C 000E                966              MOVE.B      #14, D0             ; command for trap call to display message
00001848  4E4F                     967              TRAP        #15                 ; trap call
0000184A                           968                  
0000184A  43F9 00004288            969              LEA         dispWord,A1         ; Prints out W
00001850  103C 000E                970              MOVE.B      #14, D0             ; command for trap call to display message
00001854  4E4F                     971              TRAP        #15                 ; trap call
00001856                           972              
00001856  43F9 000041EB            973              LEA         space, A1           ; create spaces
0000185C  103C 000E                974              MOVE.B      #14, D0             ; command for trap call to display message
00001860  4E4F                     975              TRAP        #15                 ; trap call
00001862                           976              
00001862  4242                     977              CLR         D2                  ; Clear data register
00001864  1401                     978              MOVE.B      D1,D2               ; Copy new byte over to D2
00001866  E642                     979              ASR         #three,D2           ; Shift source register out
00001868  C47C 0007                980              AND         #seven,D2           ; Set everything to 0 except for the mode
0000186C                           981          
0000186C  4243                     982              CLR         D3                  ; Clear Data register 3
0000186E  1601                     983              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
00001870  C67C 0007                984              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
00001874                           985              
00001874  4241                     986              CLR         D1                  ; Clear D1      
00001876                           987              
00001876  4EB9 00002F1E            988              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000187C                           989              
0000187C  43F9 000041F2            990              LEA         comma, A1           ; Display comma
00001882  103C 000E                991              MOVE.B      #14, D0             ; command for trap call to display message
00001886  4E4F                     992              TRAP        #15                 ; trap call
00001888                           993  
00001888  4242                     994              CLR         D2                  ; Clear data register
0000188A  4243                     995              CLR         D3                  ; Clear data register
0000188C  1404                     996              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
0000188E  1605                     997              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
00001890                           998          
00001890  4EB9 00002F1E            999              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001896                          1000          
00001896  43F9 000041E7           1001              LEA         newLine, A1         ; Display space
0000189C  103C 000E               1002              MOVE.B      #14, D0             ; command for trap call to display message
000018A0  4E4F                    1003              TRAP        #15                 ; trap call            
000018A2                          1004  
000018A2  6000 F7A2               1005              BRA         LOOP                ; go back to the loop
000018A6                          1006  
000018A6                          1007  ***********************************************************************************************************
000018A6                          1008  *
000018A6                          1009  *                   NEG OPCODE
000018A6                          1010  *       This section is dedicated to the NEG opmode instruction. NEG is determined by the first and
000018A6                          1011  *       the second nibble. The first nibble is 4 and the second nibble is equal to 0. Once that has been
000018A6                          1012  *       determined. NEG is printed out.
000018A6                          1013  ***********************************************************************************************************
000018A6                          1014  
000018A6                          1015  opNEG   
000018A6  43F9 00004215           1016              LEA         NEGmatch, A1        ; we know that the opcode will be NEG, so load A1 to print message
000018AC  103C 000E               1017              MOVE.B      #14, D0             ; command for trap call to display message
000018B0  4E4F                    1018              TRAP        #15                 ; trap call
000018B2                          1019          
000018B2                          1020          
000018B2  1218                    1021              MOVE.B      (A0)+, D1           ; Move data into D1 for use 
000018B4  1401                    1022              MOVE.B      D1,D2               ; copy data over
000018B6  EC42                    1023              ASR         #six,D2             ; Moves six bits over to read the size
000018B8                          1024              
000018B8  B47C 0000               1025              CMP         #zero,D2            ; Compare size
000018BC  6700 0016               1026              BEQ         opNEGB              ; Branch to NEG if size is byte
000018C0  B47C 0001               1027              CMP         #one,D2             ; Compare size with one, 
000018C4  6700 008E               1028              BEQ         opNEGW              ; If equal, size is a word. Branch to NEGW
000018C8  B47C 0002               1029              CMP         #two,D2             ; Compare size with two
000018CC  6700 0046               1030              BEQ         opNEGL              ; If size is two, NEG size is long. Branch to NEGL
000018D0  6000 1CC4               1031              BRA         invalid             ; If size is neither, code is invalid. Branch to deal with invalid code.
000018D4                          1032              
000018D4                          1033  opNEGB
000018D4  43F9 00004285           1034              LEA         dispByte, A1        ; we know that the opcode will be NEG, so load A1 to print message
000018DA  103C 000E               1035              MOVE.B      #14, D0             ; command for trap call to display message
000018DE  4E4F                    1036              TRAP        #15                 ; trap call
000018E0                          1037          
000018E0  43F9 000041EB           1038              LEA         space, A1           ; we know that the opcode will be NEG, so load A1 to print message
000018E6  103C 000E               1039              MOVE.B      #14, D0             ; command for trap call to display message
000018EA  4E4F                    1040              TRAP        #15                 ; trap call
000018EC                          1041          
000018EC  4242                    1042              CLR         D2                  ; Clear Data register 2
000018EE  3401                    1043              MOVE        D1,D2               ; Move byte into D2
000018F0  E642                    1044              ASR         #three,D2           ; Shift mode into place and moves mode into place
000018F2  C47C 0007               1045              AND         #seven,D2           ; Stores mode
000018F6                          1046              
000018F6  4243                    1047              CLR         D3                  ; Clear Data register 3
000018F8  1601                    1048              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
000018FA  C67C 0007               1049              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
000018FE                          1050              
000018FE  4EB9 00002F1E           1051              JSR         printEA
00001904                          1052                  
00001904  43F9 000041E7           1053              LEA         newLine, A1         ; Display space
0000190A  103C 000E               1054              MOVE.B      #14, D0             ; command for trap call to display message
0000190E  4E4F                    1055              TRAP        #15                 ; trap call  
00001910                          1056          
00001910  6000 F734               1057              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001914                          1058  
00001914                          1059  opNEGL
00001914  43F9 0000428B           1060              LEA         dispLong, A1        ; we know that the opcode will be NEG, so load A1 to print message
0000191A  103C 000E               1061              MOVE.B      #14, D0             ; command for trap call to display message
0000191E  4E4F                    1062              TRAP        #15                 ; trap call
00001920                          1063  
00001920  43F9 000041EB           1064              LEA         space, A1           ; we know that the opcode will be NEG, so load A1 to print message
00001926  103C 000E               1065              MOVE.B      #14, D0             ; command for trap call to display message
0000192A  4E4F                    1066              TRAP        #15                 ; trap call
0000192C                          1067                  
0000192C  4242                    1068              CLR         D2                  ; Clear Data register 2
0000192E  3401                    1069              MOVE        D1,D2               ; Move byte into D2
00001930  E642                    1070              ASR         #three,D2           ; Shift mode into place and moves mode into place
00001932  C47C 0007               1071              AND         #seven,D2           ; Stores mode
00001936                          1072          
00001936  4243                    1073              CLR         D3                  ; Clear Data register 3
00001938  1601                    1074              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
0000193A  C67C 0007               1075              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
0000193E                          1076          
0000193E  4EB9 00002F1E           1077              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001944                          1078                      
00001944  43F9 000041E7           1079              LEA         newLine, A1         ; Display space
0000194A  103C 000E               1080              MOVE.B      #14, D0             ; command for trap call to display message
0000194E  4E4F                    1081              TRAP        #15                 ; trap call  
00001950                          1082          
00001950  6000 F6F4               1083              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001954                          1084  
00001954                          1085  opNEGW
00001954  43F9 00004288           1086              LEA         dispWord, A1        ; we know that the opcode will be NEG, so load A1 to print message
0000195A  103C 000E               1087              MOVE.B      #14, D0             ; command for trap call to display message
0000195E  4E4F                    1088              TRAP        #15                 ; trap call
00001960                          1089          
00001960  43F9 000041EB           1090              LEA         space, A1           ; we know that the opcode will be NEG, so load A1 to print message
00001966  103C 000E               1091              MOVE.B      #14, D0             ; command for trap call to display message
0000196A  4E4F                    1092              TRAP        #15                 ; trap call        
0000196C                          1093                  
0000196C  4242                    1094              CLR         D2                  ; Clear Data register 2
0000196E  3401                    1095              MOVE        D1,D2               ; Move byte into D2
00001970  E642                    1096              ASR         #three,D2           ; Shift mode into place and moves mode into place
00001972  C47C 0007               1097              AND         #seven,D2           ; Stores mode
00001976                          1098          
00001976  4243                    1099              CLR         D3                  ; Clear Data register 3
00001978  1601                    1100              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
0000197A  C67C 0007               1101              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
0000197E                          1102          
0000197E  4EB9 00002F1E           1103              JSR         printEA
00001984                          1104              
00001984  43F9 000041E7           1105              LEA         newLine, A1         ; Display space
0000198A  103C 000E               1106              MOVE.B      #14, D0             ; command for trap call to display message
0000198E  4E4F                    1107              TRAP        #15                 ; trap call  
00001990                          1108          
00001990  6000 F6B4               1109              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001994                          1110              
00001994                          1111  ***********************************************************************************************************
00001994                          1112  *
00001994                          1113  *                   RTS_JSR Helper Function
00001994                          1114  *       Compare byte with static bits from JSR and RTS. If data is not equal to either, then data is
00001994                          1115  *       considered an invalid opcode and branches off to invalid.
00001994                          1116  *
00001994                          1117  ***********************************************************************************************************
00001994                          1118  
00001994                          1119  opRTSJSR
00001994  1218                    1120              MOVE.B      (A0)+, D1           ; Move byte into D1 and increment.
00001996                          1121              
00001996  1401                    1122              MOVE.B      D1,D2               ; copy data over
00001998  B47C 0075               1123              CMP         #117,D2             ; 117 is the decimal value of RTS.
0000199C  6700 0052               1124              BEQ         opRTS               ; If equal, branch to RTS to print out.
000019A0                          1125              
000019A0  EC42                    1126              ASR         #six,D2             ; Moving bits over to check if it matches the two static bits in JSR
000019A2  B47C 0002               1127              CMP         #two,D2             ; Checking if it is JSR
000019A6  6700 0006               1128              BEQ         opJSR               ; It is equal, so branch off to opJSR
000019AA                          1129  
000019AA  6000 1BEA               1130              BRA         invalid             ; Branch to invalid to deal with invalid data.
000019AE                          1131              
000019AE                          1132  ***********************************************************************************************************
000019AE                          1133  *
000019AE                          1134  *                   JSR OPCODE
000019AE                          1135  *       This section is dedicated to the JSR opmode instruction. JSR is determined by the 9 static bits.
000019AE                          1136  *       Once the bits have matched the disassembled code, the code passes through and prints out JSR along
000019AE                          1137  *       with its EA.               
000019AE                          1138  *
000019AE                          1139  ***********************************************************************************************************
000019AE                          1140  
000019AE                          1141  opJSR
000019AE  43F9 0000421D           1142              LEA         JSRMatch, A1        ; we know that the opcode will be JSR, so load A1 to print message
000019B4  103C 000E               1143              MOVE.B      #14, D0             ; command for trap call to display message
000019B8  4E4F                    1144              TRAP        #15                 ; trap call
000019BA                          1145              
000019BA  43F9 000041EB           1146              LEA         space, A1           ; we know that the opcode will be NEG, so load A1 to print message
000019C0  103C 000E               1147              MOVE.B      #14, D0             ; command for trap call to display message
000019C4  4E4F                    1148              TRAP        #15                 ; trap call
000019C6                          1149              
000019C6  4242                    1150              CLR         D2                  ; Clearing data register 
000019C8  4243                    1151              CLR         D3                  ; Clearing data register 
000019CA                          1152              
000019CA  1401                    1153              MOVE.B      D1,D2               ; Move D1 data to D2 to find the EA mode
000019CC  E642                    1154              ASR         #three,D2           ; Move mode over to the end in order to read
000019CE  C47C 0007               1155              AND         #seven,D2           ; Set every bit to 0 except for mode bits
000019D2                          1156              
000019D2  4243                    1157              CLR         D3
000019D4  1601                    1158              MOVE.B      D1,D3               ; Move bits over to D3 to find register
000019D6  C67C 0007               1159              AND         #seven,D3           ; Sets every bit to 0 except for register bits
000019DA                          1160              
000019DA  4EB9 00002F1E           1161              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000019E0                          1162              
000019E0  43F9 000041E7           1163              LEA         newLine, A1         ; Display space
000019E6  103C 000E               1164              MOVE.B      #14, D0             ; command for trap call to display message
000019EA  4E4F                    1165              TRAP        #15                 ; trap call  
000019EC                          1166              
000019EC  6000 F658               1167              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000019F0                          1168  
000019F0                          1169  ***********************************************************************************************************
000019F0                          1170  *
000019F0                          1171  *                   RTS OPCODE
000019F0                          1172  *       Function prints out RTS. Does not need to check in here as it is done beforehand. Branches back
000019F0                          1173  *       into loop afterwards.
000019F0                          1174  *
000019F0                          1175  ***********************************************************************************************************
000019F0                          1176  
000019F0                          1177  opRTS
000019F0  43F9 00004219           1178              LEA         RTSMatch, A1        ; we know that the opcode will be RTS, so load A1 to print message
000019F6  103C 000E               1179              MOVE.B      #14, D0             ; command for trap call to display message
000019FA  4E4F                    1180              TRAP        #15                 ; trap call
000019FC                          1181              
000019FC  43F9 000041E7           1182              LEA         newLine, A1         ; Display space
00001A02  103C 000E               1183              MOVE.B      #14, D0             ; command for trap call to display message
00001A06  4E4F                    1184              TRAP        #15                 ; trap call 
00001A08                          1185              
00001A08  6000 F63C               1186              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001A0C                          1187              
00001A0C                          1188  ***********************************************************************************************************
00001A0C                          1189  *
00001A0C                          1190  *                   MOVEM_LEA OPCODE
00001A0C                          1191  *       This part of the code is used to branch to either MOVEM or LEA depending on the second nibble.
00001A0C                          1192  *
00001A0C                          1193  ***********************************************************************************************************
00001A0C                          1194  
00001A0C                          1195  opMOVEMLEA
00001A0C  4242                    1196              CLR         D2                  ; Clear D2
00001A0E  1401                    1197              MOVE.B      D1,D2               ; Copy byte over
00001A10  C47C 000F               1198              AND         #secNib,D2          ; Check only the second nibble
00001A14  B47C 000C               1199              CMP         #twelve,D2          ; Compare the second nibble to twelve
00001A18  6700 000E               1200              BEQ         opMOVEM             ; If it is twelve, then it is MOVEM
00001A1C  B47C 0008               1201              CMP         #eight,D2           ; Compare the second nibble to eight
00001A20  6700 0006               1202              BEQ         opMOVEM             ; If it is eight, then it is also MOVEM
00001A24  6000 008C               1203              BRA         opLEA               ; Otherwise branch to OPLEA and check for invalid in there
00001A28                          1204              
00001A28                          1205  ***********************************************************************************************************
00001A28                          1206  *
00001A28                          1207  *                   MOVEM OPCODE
00001A28                          1208  *       MOVEM has 7 static bits. Before anything is done, static bits are checked and the dr field is stored
00001A28                          1209  *       into D6 to be used later on for specific branching. After the static bits have confirmed this is
00001A28                          1210  *       indeed MOVEM that is being disassembled, the code will print out MOVEM and goes into the subroutine
00001A28                          1211  *       to print out the data and address registers.
00001A28                          1212  *
00001A28                          1213  ***********************************************************************************************************
00001A28                          1214  
00001A28                          1215  opMOVEM            
00001A28  4246                    1216              CLR         D6                  ; Clearing D4 to store dr field
00001A2A  1C01                    1217              MOVE.B      D1,D6               ; Moving byte to find dr field
00001A2C  E446                    1218              ASR         #two,D6             ; Moving dr field to readable spot
00001A2E  CC7C 0001               1219              AND         #one,D6             ; seting everything except dr to 0
00001A32                          1220  
00001A32  4241                    1221              CLR         D1  
00001A34  1218                    1222              MOVE.B      (A0)+, D1           ; Taking in next byte
00001A36                          1223              
00001A36  4245                    1224              CLR         D5
00001A38  1A01                    1225              MOVE.B      D1,D5               ; Using D6 to check if this is indeed MOVEM
00001A3A  EE45                    1226              ASR         #seven,D5
00001A3C  CA7C 0001               1227              AND         #one,D5
00001A40  BA7C 0001               1228              CMP         #one,D5             ; This bit should be one if this is MOVEM
00001A44  6600 1B50               1229              BNE         invalid             ; If this is not 1 then this is not moveM
00001A48  4245                    1230              CLR         D5
00001A4A                          1231              
00001A4A  43F9 00004221           1232              LEA         MOVEMMatch, A1       ; we know that the opcode will be MOVEM, so load A1 to print message
00001A50  103C 000E               1233              MOVE.B      #14, D0             ; command for trap call to display message
00001A54  4E4F                    1234              TRAP        #15                 ; trap call
00001A56                          1235              
00001A56  4245                    1236              CLR         D5                  ; Clearing D5 to store size
00001A58  1A01                    1237              MOVE.B      D1,D5               ; Moving byte that contains bit for size
00001A5A  EC45                    1238              ASR         #six,D5             ; Moving size bit to the very right to read
00001A5C  CA7C 0001               1239              AND         #one,D5             ; Isolating the one bit for size
00001A60                          1240              
00001A60  4242                    1241              CLR         D2                  ; Clear Data register 2
00001A62  3401                    1242              MOVE        D1,D2               ; Move byte into D2
00001A64  E642                    1243              ASR         #three,D2           ; Shift mode into place and moves mode into place
00001A66  C47C 0007               1244              AND         #seven,D2           ; Stores mode
00001A6A                          1245              
00001A6A  4243                    1246              CLR         D3                  ; Storing EA register into D3
00001A6C  1601                    1247              MOVE.B      D1,D3               ; Move bits over to D3 to find register
00001A6E  C67C 0007               1248              AND         #seven,D3           ; Sets every bit to 0 except for register bits
00001A72                          1249              
00001A72  4EB9 000035A0           1250              JSR         MOVEMBRA            ; Jumps to subroutine that prints out the data and address registers
00001A78                          1251              
00001A78  B47C 0003               1252              CMP         #three,D2           ; Checks if this is post increment
00001A7C  6700 0024               1253              BEQ         skipPrintEA         ; If it is, skipping printing EA again, because it is printed already in JSR
00001A80                          1254              
00001A80  43F9 000041F2           1255              LEA         comma, A1           ; Display comma
00001A86  103C 000E               1256              MOVE.B      #14, D0             ; command for trap call to display message
00001A8A  4E4F                    1257              TRAP        #15                 ; trap call
00001A8C                          1258              
00001A8C  4EB9 00002F1E           1259              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001A92                          1260              
00001A92  43F9 000041E7           1261              LEA         newline, A1         ; we know that the opcode will be MOVEM, so load A1 to print message
00001A98  103C 000E               1262              MOVE.B      #14, D0             ; command for trap call to display message
00001A9C  4E4F                    1263              TRAP        #15                 ; trap call            
00001A9E                          1264  
00001A9E  6000 F5A6               1265              BRA         loop                ; Branch back to outer most loop that finds the first four bits
00001AA2                          1266  
00001AA2                          1267  skipPrintEA 
00001AA2  43F9 000041E7           1268              LEA         newline, A1         ; Prints out new line or carraige return
00001AA8  103C 000E               1269              MOVE.B      #14, D0             ; command for trap call to display message
00001AAC  4E4F                    1270              TRAP        #15                 ; trap call            
00001AAE                          1271  
00001AAE  6000 F596               1272              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001AB2                          1273              
00001AB2                          1274  ***********************************************************************************************************
00001AB2                          1275  *
00001AB2                          1276  *               LEA OPCODE
00001AB2                          1277  *
00001AB2                          1278  *       This section is dedicated to the LEA opcode. This is determined that the first nibble is 4 nibbles as
00001AB2                          1279  *       well as the three static nibbles on 8,7, and 6. Once both have been checked, the code prints out
00001AB2                          1280  *       LEA and goes on to print its effective address.
00001AB2                          1281  *
00001AB2                          1282  ***********************************************************************************************************
00001AB2                          1283  
00001AB2                          1284  opLEA
00001AB2  4244                    1285              CLR         D4                  ; Clearing space for source register
00001AB4  1801                    1286              MOVE.B      D1,D4               ; Moving byte to isolate register
00001AB6  E244                    1287              ASR         #one,D4
00001AB8  C87C 0007               1288              AND         #seven,D4           ; Isolated register
00001ABC                          1289  
00001ABC  4245                    1290              CLR         D5                  ; Clearing D5 to check if bits match LEA static bits
00001ABE  1A01                    1291              MOVE.B      D1,D5               ; Stores destination register in temporary data register for later use
00001AC0  CA7C 0001               1292              AND         #one,D5             ; Setting all other bits to one except for mode register
00001AC4  E545                    1293              ASL         #two,D5             ; Shifts the two register bits over to correct spot
00001AC6                          1294              
00001AC6  1218                    1295              MOVE.B      (A0)+, D1           ; Taking in next byte
00001AC8                          1296              
00001AC8  1C01                    1297              MOVE.B      D1,D6               
00001ACA  EC46                    1298              ASR         #six,D6             ; Shifts 6 bits over to move register
00001ACC  DA46                    1299              ADD         D6,D5               ; Add the remaining bits to the register
00001ACE  4246                    1300              CLR         D6                  ; Clear out the temporary register
00001AD0                          1301  
00001AD0  BA7C 0007               1302              CMP         #seven,D5           ; Checks the seven static bits to see if it is LEA
00001AD4  6600 1AC0               1303              BNE         invalid             ; If it is not equal then this is not LEA
00001AD8                          1304              
00001AD8  43F9 00004227           1305              LEA         LEAmatch, A1        ; we know that the opcode will be LEA, so load A1 to print message
00001ADE  103C 000E               1306              MOVE.B      #14, D0             ; command for trap call to display message
00001AE2  4E4F                    1307              TRAP        #15                 ; trap call            
00001AE4                          1308  
00001AE4  43F9 000041EB           1309              LEA         space, A1           ; we know that the opcode will be MOVEM, so load A1 to print message
00001AEA  103C 000E               1310              MOVE.B      #14, D0             ; command for trap call to display message
00001AEE  4E4F                    1311              TRAP        #15                 ; trap call            
00001AF0                          1312              
00001AF0  4242                    1313              CLR         D2                  ; Clear Data register 2
00001AF2  3401                    1314              MOVE        D1,D2               ; Move byte into D2
00001AF4  E642                    1315              ASR         #three,D2           ; Shift mode into place and moves mode into place
00001AF6  C47C 0007               1316              AND         #seven,D2           ; Stores mode
00001AFA                          1317              
00001AFA  4243                    1318              CLR         D3
00001AFC  1601                    1319              MOVE.B      D1,D3               ; Move bits over to D3 to find register
00001AFE  C67C 0007               1320              AND         #seven,D3           ; Sets every bit to 0 except for register bits
00001B02                          1321              
00001B02  4EB9 00002F1E           1322              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001B08                          1323              
00001B08  43F9 000041F2           1324              LEA         comma, A1           ; we know that the opcode will be MOVEM, so load A1 to print message
00001B0E  103C 000E               1325              MOVE.B      #14, D0             ; command for trap call to display message
00001B12  4E4F                    1326              TRAP        #15                 ; trap call            
00001B14                          1327              
00001B14                          1328              
00001B14  4243                    1329              CLR         D3                  ; Clears D3 to move effective address into it
00001B16  1604                    1330              MOVE.B      D4,D3               ; Moves data with EA register
00001B18  143C 0001               1331              MOVE.B      #one,D2             ; Puts 1 into D2 to print an An within printEA
00001B1C                          1332              
00001B1C  4EB9 00002F1E           1333              JSR         printEA             ; Prints out source address
00001B22                          1334              
00001B22  43F9 000041E7           1335              LEA         newline, A1         ; Prints new line
00001B28  103C 000E               1336              MOVE.B      #14, D0             ; command for trap call to display message
00001B2C  4E4F                    1337              TRAP        #15                 ; trap call
00001B2E                          1338  
00001B2E  6000 F516               1339              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits                 
00001B32                          1340  
00001B32                          1341  ***********************************************************************************************************
00001B32                          1342  *
00001B32                          1343  *                   OR OPCODE
00001B32                          1344  *
00001B32                          1345  *       This section is dedicated to the OR opcode. This is determined that the first nibble is 8, and the
00001B32                          1346  *       second nibble is not 7 (or we would have DIVS), we must have OR.
00001B32                          1347  *       OR is varied by the operand direction. We have and EA to Dn, and DN to EA operation.
00001B32                          1348  *       These operand directions determine our opmode, which we use to disassemble.
00001B32                          1349  *
00001B32                          1350  ***********************************************************************************************************
00001B32                          1351              
00001B32                          1352  opOR                                        ; Assumed we found OR, begin disassemble
00001B32  43F9 00004249           1353              LEA         ORmatch,A1          ; Output OR to the IO console
00001B38  103C 000E               1354              MOVE.B      #14,D0              ; Use trap 14
00001B3C  4E4F                    1355              TRAP        #15                 ; Halt for IO
00001B3E                          1356              
00001B3E  E141                    1357              ASL         #eight,D1           ; Shift D1 by eight to find opmode
00001B40  1401                    1358              MOVE.B      D1,D2               ; Load D2 with the resulting byte
00001B42                          1359              
00001B42                          1360              ; These are for EA to Dn direction
00001B42  B43C 0000               1361              CMP.B       #zero,D2            ; Check for a byte
00001B46  6700 002A               1362              BEQ         opORB               ; Byte in opmode
00001B4A  B43C 0001               1363              CMP.B       #one,D2             ; Check for a word
00001B4E  6700 007C               1364              BEQ         opORW               ; Word in opmode
00001B52  B43C 0002               1365              CMP.B       #two,D2             ; Check for a long
00001B56  6700 00CE               1366              BEQ         opORL               ; Long in opmode
00001B5A                          1367              
00001B5A                          1368              ; These are for Dn to EA direction
00001B5A  B43C 0004               1369              CMP.B       #four,D2            ; Check for a byte
00001B5E  6700 0012               1370              BEQ         opORB               ; Byte in opmode
00001B62  B43C 0005               1371              CMP.B       #five,D2            ; Check for a word
00001B66  6700 0064               1372              BEQ         opORW               ; Word in opmode
00001B6A  B43C 0006               1373              CMP.B       #six,D2             ; Check for a long
00001B6E  6700 00B6               1374              BEQ         opORL               ; Long in opmode
00001B72                          1375              
00001B72                          1376  opORB                                       ; Byte determined, find operands from here
00001B72  43F9 00004285           1377              LEA         dispByte,A1         ; Display our byte info
00001B78  103C 000E               1378              MOVE.B      #14,D0              ; Trap #14 for our IO
00001B7C  4E4F                    1379              TRAP        #15                 ; Halt for IO
00001B7E                          1380              
00001B7E  43F9 000041EB           1381              LEA         space, A1           ; Display space
00001B84  103C 000E               1382              MOVE.B      #14, D0             ; command for trap call to display message
00001B88  4E4F                    1383              TRAP        #15                 ; trap call
00001B8A                          1384              
00001B8A                          1385  
00001B8A  1401                    1386              MOVE.B      D1,D2               ; Load D2 again with the byte in D1
00001B8C  E642                    1387              ASR         #3,D2               ; Shift by 3 for finding 1 operand
00001B8E  C47C 0007               1388              AND         #$07,D2             ; AND by 7 to remove extras
00001B92  1601                    1389              MOVE.B      D1,D3               ; Load D3 with more necessary EA info
00001B94  C67C 0007               1390              AND         #$07,D3             ; AND by 7 to remove extra bits
00001B98  4EB9 00002F1E           1391              JSR         printEA             ; Determines the "left" operand register
00001B9E                          1392              
00001B9E  43F9 000041F2           1393              LEA         comma, A1           ; Display space
00001BA4  103C 000E               1394              MOVE.B      #14, D0             ; command for trap call to display message
00001BA8  4E4F                    1395              TRAP        #15                 ; trap call
00001BAA                          1396              
00001BAA  4242                    1397              CLR         D2                  ; Clear D2 for use
00001BAC  3601                    1398              MOVE.W      D1,D3               ; Move our word into D3 for EA use
00001BAE  E043                    1399              ASR         #eight,D3           ; Shift by 8 to isolate EA info
00001BB0  E243                    1400              ASR         #one,D3             ; We need additional shift, so total shifts is by 9
00001BB2  C67C 0007               1401              AND         #$07,D3             ; AND to remove extra data
00001BB6  4EB9 00002F1E           1402              JSR         printEA             ; Redirect to EA subroutine to find EA operand info
00001BBC                          1403              
00001BBC  43F9 000041E7           1404              LEA         newLine,A1          ; Prime a new line for the next instruction
00001BC2  103C 000E               1405              MOVE.B      #14,D0              ; Send it to the console
00001BC6  4E4F                    1406              TRAP        #15                 ; IO halt here
00001BC8                          1407              
00001BC8  6000 F47C               1408              BRA         LOOP                ; Return to control loop to find additional instructions
00001BCC                          1409              
00001BCC                          1410              
00001BCC                          1411  opORW                                       ; Word opmode has been found
00001BCC  43F9 00004288           1412              LEA         dispWord,A1         ; Display our word info
00001BD2  103C 000E               1413              MOVE.B      #14,D0              ; Trap #14 for our IO
00001BD6  4E4F                    1414              TRAP        #15                 ; Halt for IO
00001BD8                          1415              
00001BD8  43F9 000041EB           1416              LEA         space, A1           ; Display space
00001BDE  103C 000E               1417              MOVE.B      #14, D0             ; command for trap call to display message
00001BE2  4E4F                    1418              TRAP        #15                 ; trap call
00001BE4                          1419              
00001BE4                          1420  
00001BE4  1401                    1421              MOVE.B      D1,D2               ; Load D2 again with the byte in D1
00001BE6  E642                    1422              ASR         #3,D2               ; Shift by 3 for finding 1 operand
00001BE8  C47C 0007               1423              AND         #$07,D2             ; AND by 7 to remove extras
00001BEC  1601                    1424              MOVE.B      D1,D3               ; Load D3 with more necessary EA info
00001BEE  C67C 0007               1425              AND         #$07,D3             ; AND by 7 to remove extra bits
00001BF2  4EB9 00002F1E           1426              JSR         printEA             ; Determines the "left" operand register
00001BF8                          1427              
00001BF8  43F9 000041F2           1428              LEA         comma, A1           ; Display space
00001BFE  103C 000E               1429              MOVE.B      #14, D0             ; command for trap call to display message
00001C02  4E4F                    1430              TRAP        #15                 ; trap call
00001C04                          1431              
00001C04  4242                    1432              CLR         D2                  ; Clear D2 for use
00001C06  3601                    1433              MOVE.W      D1,D3               ; Move our word into D3 for EA use
00001C08  E043                    1434              ASR         #eight,D3           ; Shift by 8 to isolate EA info
00001C0A  E243                    1435              ASR         #one,D3             ; We need additional shift, so total shifts is by 9
00001C0C  C67C 0007               1436              AND         #$07,D3             ; AND to remove extra data
00001C10  4EB9 00002F1E           1437              JSR         printEA             ; Redirect to EA subroutine to find EA operand info
00001C16                          1438              
00001C16  43F9 000041E7           1439              LEA         newLine,A1          ; Prime a new line for the next instruction
00001C1C  103C 000E               1440              MOVE.B      #14,D0              ; Send it to the console
00001C20  4E4F                    1441              TRAP        #15                 ; IO halt here
00001C22                          1442              
00001C22  6000 F422               1443              BRA         LOOP                ; Return to control loop to find additional instructions
00001C26                          1444              
00001C26                          1445  opORL                                       ; Long value has been found for OR
00001C26  43F9 0000428B           1446              LEA         dispLong,A1         ; Display our long info
00001C2C  103C 000E               1447              MOVE.B      #14,D0              ; Trap #14 for our IO
00001C30  4E4F                    1448              TRAP        #15                 ; Halt for IO
00001C32                          1449              
00001C32  43F9 000041EB           1450              LEA         space, A1           ; Display space
00001C38  103C 000E               1451              MOVE.B      #14, D0             ; command for trap call to display message
00001C3C  4E4F                    1452              TRAP        #15                 ; trap call
00001C3E                          1453              
00001C3E                          1454  
00001C3E  1401                    1455              MOVE.B      D1,D2               ; Load D2 again with the byte in D1
00001C40  E642                    1456              ASR         #3,D2               ; Shift by 3 for finding 1 operand
00001C42  C47C 0007               1457              AND         #$07,D2             ; AND by 7 to remove extras
00001C46  1601                    1458              MOVE.B      D1,D3               ; Load D3 with more necessary EA info
00001C48  C67C 0007               1459              AND         #$07,D3             ; AND by 7 to remove extra bits
00001C4C  4EB9 00002F1E           1460              JSR         printEA             ; Determines the "left" operand register
00001C52                          1461              
00001C52  43F9 000041F2           1462              LEA         comma, A1           ; Display space
00001C58  103C 000E               1463              MOVE.B      #14, D0             ; command for trap call to display message
00001C5C  4E4F                    1464              TRAP        #15                 ; trap call
00001C5E                          1465              
00001C5E  4242                    1466              CLR         D2                  ; Clear D2 for use
00001C60  3601                    1467              MOVE.W      D1,D3               ; Move our word into D3 for EA use
00001C62  E043                    1468              ASR         #eight,D3           ; Shift by 8 to isolate EA info
00001C64  E243                    1469              ASR         #one,D3             ; We need additional shift, so total shifts is by 9
00001C66  C67C 0007               1470              AND         #$07,D3             ; AND to remove extra data
00001C6A  4EB9 00002F1E           1471              JSR         printEA             ; Redirect to EA subroutine to find EA operand info
00001C70                          1472              
00001C70  43F9 000041E7           1473              LEA         newLine,A1          ; Prime a new line for the next instruction
00001C76  103C 000E               1474              MOVE.B      #14,D0              ; Send it to the console
00001C7A  4E4F                    1475              TRAP        #15                 ; IO halt here
00001C7C                          1476              
00001C7C  6000 F3C8               1477              BRA         LOOP                ; Return to control loop to find additional instructions
00001C80                          1478              
00001C80                          1479  ***********************************************************************************************************
00001C80                          1480  *
00001C80                          1481  *                   DIVS OPCODE
00001C80                          1482  *
00001C80                          1483  *       This section is dedicate to the DIVS instruction, which is determined by a 8 in the first nibble
00001C80                          1484  *       and a 7 in the second nibble of the instruction.
00001C80                          1485  *       DIVSL is not supported, so the following code only accounts for the case of DIVS, which is short
00001C80                          1486  *       instead of a long
00001C80                          1487  *
00001C80                          1488  ***********************************************************************************************************
00001C80                          1489  
00001C80                          1490  opDIVS                                      ; Second nibble determined that the instruction was DIVS
00001C80  43F9 00004244           1491              LEA         DIVSmatch,A1        ; Load DIVS into A1 for output console
00001C86  103C 000E               1492              MOVE.B      #14,D0              ; Get trap task #14 for IO
00001C8A  4E4F                    1493              TRAP        #15                 ; Trap call to halt
00001C8C                          1494              
00001C8C  43F9 000041EB           1495              LEA         space, A1           ; Display space
00001C92  103C 000E               1496              MOVE.B      #14, D0             ; command for trap call to display message
00001C96  4E4F                    1497              TRAP        #15                 ; trap to halt
00001C98                          1498              
00001C98  1401                    1499              MOVE.B      D1,D2               ; Move our byte from D1 to D2 to manipulate
00001C9A  E642                    1500              ASR         #3,D2               ; Shift by 3 to find register
00001C9C  C47C 0007               1501              AND         #$07,D2             ; AND by 7 to clear unnecessary bits
00001CA0  1601                    1502              MOVE.B      D1,D3               ; Load the byte into D3 for EA comparison
00001CA2  C67C 0007               1503              AND         #$07,D3             ; AND by 7 to clear unnecessary bits
00001CA6  4EB9 00002F1E           1504              JSR         printEA             ; Call our EA subroutine to obtain EA bits from instruction
00001CAC                          1505              
00001CAC  43F9 000041F2           1506              LEA         comma, A1           ; Display space
00001CB2  103C 000E               1507              MOVE.B      #14, D0             ; command for trap call to display message
00001CB6  4E4F                    1508              TRAP        #15                 ; trap to halt call
00001CB8                          1509              
00001CB8  4242                    1510              CLR         D2                  ; Clear old data from D2 to avoid errors
00001CBA  3601                    1511              MOVE.W      D1,D3               ; Move word into D3 for EA subroutine
00001CBC  E043                    1512              ASR         #eight,D3           ; Shift by 8 to find to find the remaining EA components
00001CBE  E243                    1513              ASR         #one,D3             ; Additional shift by 1 to get proper bits
00001CC0  C67C 0007               1514              AND         #$07,D3             ; AND to clear unwanted bits
00001CC4  4EB9 00002F1E           1515              JSR         printEA             ; Obtain other operand info
00001CCA                          1516              
00001CCA  43F9 000041E7           1517              LEA         newLine,A1          ; Prepare new line for next instruction
00001CD0  103C 000E               1518              MOVE.B      #14,D0              ; Utilize trap task 14
00001CD4  4E4F                    1519              TRAP        #15                 ; Halt for IO
00001CD6                          1520              
00001CD6  6000 F36E               1521              BRA         LOOP                ; Return to control loop
00001CDA                          1522              
00001CDA                          1523  **********************************************************************************************************
00001CDA                          1524  *
00001CDA                          1525  *                   EOR OPCODE
00001CDA                          1526  *
00001CDA                          1527  *       This sectioon is dedicated to the EOR opcode. We determine this with an 11 in the first nibble, and
00001CDA                          1528  *       a value higher than 3 in the second nibble.
00001CDA                          1529  *       The opmode fields is used to differ this instruction from CMP.
00001CDA                          1530  *       Dissassembly acquires opmode field info, which is similar to size, and to different EA related
00001CDA                          1531  *       operands.
00001CDA                          1532  *
00001CDA                          1533  ***********************************************************************************************************
00001CDA                          1534  
00001CDA                          1535  opEOR                                       ; We found EOR, begin disassembly
00001CDA  43F9 00004250           1536              LEA         EORmatch,A1         ; Load A1 with our EOR output
00001CE0  103C 000E               1537              MOVE.B      #14,D0              ; Prime trap task #14
00001CE4  4E4F                    1538              TRAP        #15                 ; Halt for IO
00001CE6                          1539              
00001CE6  4242                    1540              CLR         D2                  ; Clear D2 for use again
00001CE8                          1541              
00001CE8  1401                    1542              MOVE.B      D1,D2               ; Move byte used in D1 to D2 for opmode check
00001CEA  EE42                    1543              ASR         #seven,D2           ; Move bits 7 places over to find opmode
00001CEC  C47C 0007               1544              AND         #$07,D2             ; AND by 7 to clear extra bits
00001CF0  B43C 0005               1545              CMP.B       #five,D2            ; Check for a byte in opmode
00001CF4  6D00 0012               1546              BLT         opEORB              ; Byte in opmode
00001CF8  B43C 0005               1547              CMP.B       #five,D2            ; Check for a word in opmode
00001CFC  6700 006A               1548              BEQ         opEORW              ; Word in opmode
00001D00  B43C 0005               1549              CMP.B       #five,D2            ; Check for a long in opmode
00001D04  6E00 00C2               1550              BGT         opEORL              ; Long in opmode
00001D08                          1551              
00001D08                          1552  opEORB                                      ; Determine instruction is a byte operation
00001D08  43F9 00004285           1553              LEA         dispByte,A1         ; Send out the byte info for the instruction
00001D0E  103C 000E               1554              MOVE.B      #14,D0              ; Utilize trap task 14
00001D12  4E4F                    1555              TRAP        #15                 ; Halt for IO
00001D14                          1556              
00001D14  43F9 000041EB           1557              LEA         space, A1           ; Display space
00001D1A  103C 000E               1558              MOVE.B      #14, D0             ; command for trap call to display message
00001D1E  4E4F                    1559              TRAP        #15                 ; trap call to halt
00001D20                          1560              
00001D20  4242                    1561              CLR         D2                  ; Clear D2 again for use
00001D22  4243                    1562              CLR         D3                  ; Remove anything from D3
00001D24  3601                    1563              MOVE.W      D1,D3               ; Move word to D3 to find an operand
00001D26  E043                    1564              ASR         #eight,D3           ; Shift by eight to ensure correct portion of instruction
00001D28  E243                    1565              ASR         #one,D3             ; Needs to be shifted by an additional 1
00001D2A  C67C 0007               1566              AND         #$07,D3             ; Clear extra bits 
00001D2E  4EB9 00002F1E           1567              JSR         printEA             ; Use EA subroutine to print operand
00001D34                          1568              
00001D34  43F9 000041F2           1569              LEA         comma, A1           ; Display space
00001D3A  103C 000E               1570              MOVE.B      #14, D0             ; command for trap call to display message
00001D3E  4E4F                    1571              TRAP        #15                 ; trap call
00001D40                          1572              
00001D40  4242                    1573              CLR         D2                  ; Clear D2 again
00001D42  4243                    1574              CLR         D3                  ; Clear D3 again
00001D44  1401                    1575              MOVE.B      D1,D2               ; Move the byte value in D1 to D2 for EA use
00001D46  E642                    1576              ASR         #three,D2           ; Shift by 3 to find EA info
00001D48  C47C 0007               1577              AND         #seven,D2           ; AND by 7 to remove extra bits
00001D4C  1601                    1578              MOVE.B      D1,D3               ; Move byte value from D1 into D3
00001D4E  C67C 0007               1579              AND         #$07,D3             ; AND by 7 for EA subroutine
00001D52  4EB9 00002F1E           1580              JSR         printEA             ; Determines remained operand EA info to print
00001D58                          1581              
00001D58  43F9 000041E7           1582              LEA         newLine,A1          ; Print new line for next instruction
00001D5E  103C 000E               1583              MOVE.B      #14,D0              ; Use trap 14 to output to console
00001D62  4E4F                    1584              TRAP        #15                 ; Halt for IO
00001D64                          1585              
00001D64  6000 F2E0               1586              BRA         LOOP                ; Return to control loop
00001D68                          1587               
00001D68                          1588  opEORW                                      ; Word opmode has been determined
00001D68  43F9 00004288           1589              LEA         dispWord,A1         ; Send out the word info for the instruction
00001D6E  103C 000E               1590              MOVE.B      #14,D0              ; Utilize trap task 14
00001D72  4E4F                    1591              TRAP        #15                 ; Halt for IO
00001D74                          1592              
00001D74  43F9 000041EB           1593              LEA         space, A1           ; Display space
00001D7A  103C 000E               1594              MOVE.B      #14, D0             ; command for trap call to display message
00001D7E  4E4F                    1595              TRAP        #15                 ; trap call to halt
00001D80                          1596              
00001D80  4242                    1597              CLR         D2                  ; Clear D2 again for use
00001D82  4243                    1598              CLR         D3                  ; Remove anything from D3
00001D84  3601                    1599              MOVE.W      D1,D3               ; Move word to D3 to find an operand
00001D86  E043                    1600              ASR         #eight,D3           ; Shift by eight to ensure correct portion of instruction
00001D88  E243                    1601              ASR         #one,D3             ; Needs to be shifted by an additional 1
00001D8A  C67C 0007               1602              AND         #$07,D3             ; Clear extra bits 
00001D8E  4EB9 00002F1E           1603              JSR         printEA             ; Use EA subroutine to print operand
00001D94                          1604              
00001D94  43F9 000041F2           1605              LEA         comma, A1           ; Display space
00001D9A  103C 000E               1606              MOVE.B      #14, D0             ; command for trap call to display message
00001D9E  4E4F                    1607              TRAP        #15                 ; trap call
00001DA0                          1608              
00001DA0  4242                    1609              CLR         D2                  ; Clear D2 again
00001DA2  4243                    1610              CLR         D3                  ; Clear D3 again
00001DA4  1401                    1611              MOVE.B      D1,D2               ; Move the byte value in D1 to D2 for EA use
00001DA6  E642                    1612              ASR         #three,D2           ; Shift by 3 to find EA info
00001DA8  C47C 0007               1613              AND         #seven,D2           ; AND by 7 to remove extra bits
00001DAC  1601                    1614              MOVE.B      D1,D3               ; Move byte value from D1 into D3
00001DAE  C67C 0007               1615              AND         #$07,D3             ; AND by 7 for EA subroutine
00001DB2  4EB9 00002F1E           1616              JSR         printEA             ; Determines remained operand EA info to print
00001DB8                          1617              
00001DB8  43F9 000041E7           1618              LEA         newLine,A1          ; Print new line for next instruction
00001DBE  103C 000E               1619              MOVE.B      #14,D0              ; Use trap 14 to output to console
00001DC2  4E4F                    1620              TRAP        #15                 ; Halt for IO
00001DC4                          1621              
00001DC4  6000 F280               1622              BRA         LOOP                ; Return to control loop
00001DC8                          1623              
00001DC8                          1624  opEORL                                      ; Long has been determined
00001DC8  43F9 0000428B           1625              LEA         dispLong,A1         ; Send out the long word info for the instruction
00001DCE  103C 000E               1626              MOVE.B      #14,D0              ; Utilize trap task 14
00001DD2  4E4F                    1627              TRAP        #15                 ; Halt for IO
00001DD4                          1628              
00001DD4  43F9 000041EB           1629              LEA         space, A1           ; Display space
00001DDA  103C 000E               1630              MOVE.B      #14, D0             ; command for trap call to display message
00001DDE  4E4F                    1631              TRAP        #15                 ; trap call to halt
00001DE0                          1632              
00001DE0  4242                    1633              CLR         D2                  ; Clear D2 again for use
00001DE2  4243                    1634              CLR         D3                  ; Remove anything from D3
00001DE4  3601                    1635              MOVE.W      D1,D3               ; Move word to D3 to find an operand
00001DE6  E043                    1636              ASR         #eight,D3           ; Shift by eight to ensure correct portion of instruction
00001DE8  E243                    1637              ASR         #one,D3             ; Needs to be shifted by an additional 1
00001DEA  C67C 0007               1638              AND         #$07,D3             ; Clear extra bits 
00001DEE  4EB9 00002F1E           1639              JSR         printEA             ; Use EA subroutine to print operand
00001DF4                          1640              
00001DF4  43F9 000041F2           1641              LEA         comma, A1           ; Display space
00001DFA  103C 000E               1642              MOVE.B      #14, D0             ; command for trap call to display message
00001DFE  4E4F                    1643              TRAP        #15                 ; trap call
00001E00                          1644              
00001E00  4242                    1645              CLR         D2                  ; Clear D2 again
00001E02  4243                    1646              CLR         D3                  ; Clear D3 again
00001E04  1401                    1647              MOVE.B      D1,D2               ; Move the byte value in D1 to D2 for EA use
00001E06  E642                    1648              ASR         #three,D2           ; Shift by 3 to find EA info
00001E08  C47C 0007               1649              AND         #seven,D2           ; AND by 7 to remove extra bits
00001E0C  1601                    1650              MOVE.B      D1,D3               ; Move byte value from D1 into D3
00001E0E  C67C 0007               1651              AND         #$07,D3             ; AND by 7 for EA subroutine
00001E12  4EB9 00002F1E           1652              JSR         printEA             ; Determines remained operand EA info to print
00001E18                          1653              
00001E18  43F9 000041E7           1654              LEA         newLine,A1          ; Print new line for next instruction
00001E1E  103C 000E               1655              MOVE.B      #14,D0              ; Use trap 14 to output to console
00001E22  4E4F                    1656              TRAP        #15                 ; Halt for IO
00001E24                          1657              
00001E24  6000 F220               1658              BRA         LOOP                ; Return to the control loop
00001E28                          1659  
00001E28                          1660  ***********************************************************************************************************
00001E28                          1661  *
00001E28                          1662  *                   CMP OPCODE
00001E28                          1663  *
00001E28                          1664  *       This section is dedicated to the compare (CMP) instruction. Its determined in the control loop
00001E28                          1665  *       that the first nibble is 11 for CMP, and the second nibble is 3.
00001E28                          1666  *       The type of CMP, or the opmode, is used to determined what we output to our console next.
00001E28                          1667  *       From that point, we load the correct size/opmode, and then route to the EA subroutine to output
00001E28                          1668  *       EA related register information.
00001E28                          1669  *       The process for finding the operand register info (EA info) is similar for all opmodes.
00001E28                          1670  *
00001E28                          1671  ***********************************************************************************************************
00001E28                          1672  
00001E28                          1673  opCMP       
00001E28  43F9 00004254           1674              LEA         CMPmatch,A1         ; We determined that the opcode is CMP, output to console
00001E2E  103C 000E               1675              MOVE.B      #14,D0              ; Getting trap task #14 ready
00001E32  4E4F                    1676              TRAP        #15                 ; Trap 15 call for IO
00001E34                          1677              
00001E34  4242                    1678              CLR         D2                  ; D2 should be cleared for use later
00001E36                          1679              
00001E36  1401                    1680              MOVE.B      D1,D2               ; Get the next byte to manipulate
00001E38  EC42                    1681              ASR         #six,D2             ; Move bits 7 places over to find opmode
00001E3A  C47C 0007               1682              AND         #$07,D2             ; AND by 7 allows us to compare properly on which opmode we need
00001E3E  B43C 0000               1683              CMP.B       #zero,D2            ; Compare to zero to see if we have a byte
00001E42  6700 0016               1684              BEQ         opCMPB              ; Byte in opmode
00001E46  B43C 0001               1685              CMP.B       #one,D2             ; Compare to one to see if we have a word
00001E4A  6700 0068               1686              BEQ         opCMPW              ; Word in opmode
00001E4E  B43C 0002               1687              CMP.B       #two,D2             ; Compare to two to see if we have a long
00001E52  6700 00BA               1688              BEQ         opCMPL              ; Long in opmode
00001E56                          1689              
00001E56  6000 1E34               1690              BRA         printInvalid        ; Incorrect input
00001E5A                          1691  
00001E5A                          1692  opCMPB                                      ; Known we have CMP.B, find and output operands
00001E5A  43F9 00004285           1693              LEA         dispByte,A1         ; Output the byte component of the instruction
00001E60  103C 000E               1694              MOVE.B      #14,D0              ; Trap task #14 for console out
00001E64  4E4F                    1695              TRAP        #15                 ; Halt for console out
00001E66                          1696              
00001E66  43F9 000041EB           1697              LEA         space, A1           ; Display space for operands
00001E6C  103C 000E               1698              MOVE.B      #14, D0             ; command for trap call to display message
00001E70  4E4F                    1699              TRAP        #15                 ; Console out/halt
00001E72                          1700              
00001E72  1401                    1701              MOVE.B      D1,D2               ; Move the byte for manipulation to D2
00001E74  E642                    1702              ASR         #3,D2               ; Shift right by 3 to find left operand register
00001E76  C47C 0007               1703              AND         #$07,D2             ; AND for comparison later
00001E7A  1601                    1704              MOVE.B      D1,D3               ; Move the byte to D3 for use in our EA subroutine
00001E7C  C67C 0007               1705              AND         #$07,D3             ; AND for comparison in subroutine
00001E80  4EB9 00002F1E           1706              JSR         printEA             ; Use our EA subroutine to determine the left operand register
00001E86                          1707              
00001E86  43F9 000041F2           1708              LEA         comma, A1           ; Display space
00001E8C  103C 000E               1709              MOVE.B      #14, D0             ; command for trap call to display message
00001E90  4E4F                    1710              TRAP        #15                 ; trap call
00001E92                          1711              
00001E92  4242                    1712              CLR         D2                  ; D2 needs to be cleared for use later
00001E94  3601                    1713              MOVE.W      D1,D3               ; Move the entire word in D3 for shifting
00001E96  E043                    1714              ASR         #eight,D3           ; Shift right by 8 to get EA bits from instruction
00001E98  E243                    1715              ASR         #one,D3             ; Shift right once more to move the bits all the way
00001E9A  C67C 0007               1716              AND         #$07,D3             ; AND by 7 to clear unnecessary bits
00001E9E  4EB9 00002F1E           1717              JSR         printEA             ; EA subroutine call to get remaining operand sent to the console
00001EA4                          1718              
00001EA4  43F9 000041E7           1719              LEA         newLine,A1          ; Prime A1 with our new line to output
00001EAA  103C 000E               1720              MOVE.B      #14,D0              ; Prime new line for next instruction
00001EAE  4E4F                    1721              TRAP        #15                 ; Halt for IO
00001EB0                          1722              
00001EB0  6000 F194               1723              BRA         LOOP                ; Return to control loop for next disassembly
00001EB4                          1724              
00001EB4                          1725  opCMPW                                      ; Known we have CMP.W, find and output operands
00001EB4  43F9 00004288           1726              LEA         dispWord,A1         ; Output the byte component of the instruction
00001EBA  103C 000E               1727              MOVE.B      #14,D0              ; Trap task #14 for console out
00001EBE  4E4F                    1728              TRAP        #15                 ; Halt for console out
00001EC0                          1729              
00001EC0  43F9 000041EB           1730              LEA         space, A1           ; Display space for operands
00001EC6  103C 000E               1731              MOVE.B      #14, D0             ; command for trap call to display message
00001ECA  4E4F                    1732              TRAP        #15                 ; Console out/halt
00001ECC                          1733              
00001ECC  1401                    1734              MOVE.B      D1,D2               ; Move the byte for manipulation to D2
00001ECE  E642                    1735              ASR         #3,D2               ; Shift right by 3 to find left operand register
00001ED0  C47C 0007               1736              AND         #$07,D2             ; AND for comparison later
00001ED4  1601                    1737              MOVE.B      D1,D3               ; Move the byte to D3 for use in our EA subroutine
00001ED6  C67C 0007               1738              AND         #$07,D3             ; AND for comparison in subroutine
00001EDA  4EB9 00002F1E           1739              JSR         printEA             ; Use our EA subroutine to determine the left operand register
00001EE0                          1740              
00001EE0  43F9 000041F2           1741              LEA         comma, A1           ; Display space
00001EE6  103C 000E               1742              MOVE.B      #14, D0             ; command for trap call to display message
00001EEA  4E4F                    1743              TRAP        #15                 ; trap call
00001EEC                          1744              
00001EEC  4242                    1745              CLR         D2                  ; D2 needs to be cleared for use later
00001EEE  3601                    1746              MOVE.W      D1,D3               ; Move the entire word in D3 for shifting
00001EF0  E043                    1747              ASR         #eight,D3           ; Shift right by 8 to get EA bits from instruction
00001EF2  E243                    1748              ASR         #one,D3             ; Shift right once more to move the bits all the way
00001EF4  C67C 0007               1749              AND         #$07,D3             ; AND by 7 to clear unnecessary bits
00001EF8  4EB9 00002F1E           1750              JSR         printEA             ; EA subroutine call to get remaining operand sent to the console
00001EFE                          1751              
00001EFE  43F9 000041E7           1752              LEA         newLine,A1          ; Prime A1 with our new line to output
00001F04  103C 000E               1753              MOVE.B      #14,D0              ; Prime new line for next instruction
00001F08  4E4F                    1754              TRAP        #15                 ; Halt for IO
00001F0A                          1755              
00001F0A  6000 F13A               1756              BRA         LOOP                ; Return to control loop for next disassembly
00001F0E                          1757  
00001F0E                          1758  opCMPL                                      ; Known we have CMP.L, find and output operands
00001F0E  43F9 0000428B           1759              LEA         dispLong,A1         ; Output the byte component of the instruction
00001F14  103C 000E               1760              MOVE.B      #14,D0              ; Trap task #14 for console out
00001F18  4E4F                    1761              TRAP        #15                 ; Halt for console out
00001F1A                          1762              
00001F1A  43F9 000041EB           1763              LEA         space, A1           ; Display space for operands
00001F20  103C 000E               1764              MOVE.B      #14, D0             ; command for trap call to display message
00001F24  4E4F                    1765              TRAP        #15                 ; Console out/halt
00001F26                          1766              
00001F26  1401                    1767              MOVE.B      D1,D2               ; Move the byte for manipulation to D2
00001F28  E642                    1768              ASR         #3,D2               ; Shift right by 3 to find left operand register
00001F2A  C47C 0007               1769              AND         #$07,D2             ; AND for comparison later
00001F2E  1601                    1770              MOVE.B      D1,D3               ; Move the byte to D3 for use in our EA subroutine
00001F30  C67C 0007               1771              AND         #$07,D3             ; AND for comparison in subroutine
00001F34  4EB9 00002F1E           1772              JSR         printEA             ; Use our EA subroutine to determine the left operand register
00001F3A                          1773              
00001F3A  43F9 000041F2           1774              LEA         comma, A1           ; Display space
00001F40  103C 000E               1775              MOVE.B      #14, D0             ; command for trap call to display message
00001F44  4E4F                    1776              TRAP        #15                 ; trap call
00001F46                          1777              
00001F46  4242                    1778              CLR         D2                  ; D2 needs to be cleared for use later
00001F48  3601                    1779              MOVE.W      D1,D3               ; Move the entire word in D3 for shifting
00001F4A  E043                    1780              ASR         #eight,D3           ; Shift right by 8 to get EA bits from instruction
00001F4C  E243                    1781              ASR         #one,D3             ; Shift right once more to move the bits all the way
00001F4E  C67C 0007               1782              AND         #$07,D3             ; AND by 7 to clear unnecessary bits
00001F52  4EB9 00002F1E           1783              JSR         printEA             ; EA subroutine call to get remaining operand sent to the console
00001F58                          1784              
00001F58  43F9 000041E7           1785              LEA         newLine,A1          ; Prime A1 with our new line to output
00001F5E  103C 000E               1786              MOVE.B      #14,D0              ; Prime new line for next instruction
00001F62  4E4F                    1787              TRAP        #15                 ; Halt for IO
00001F64                          1788              
00001F64  6000 F0E0               1789              BRA         LOOP                ; Return to control loop for next disassembly
00001F68                          1790  
00001F68                          1791  ***********************************************************************************************************
00001F68                          1792  *
00001F68                          1793  *                   SUB OPCODE
00001F68                          1794  *
00001F68                          1795  *       This section is dedicated to disassembling the SUB opcode. We assume that the first nibble being 9
00001F68                          1796  *       leads us to the SUB opcode.
00001F68                          1797  *       SUB is differed by a operand direction, that being Dn - EA or EA - Dn.
00001F68                          1798  *       These directions are deteremined as an opmode, and doubles up for each byte, long, and word mode.
00001F68                          1799  *
00001F68                          1800  ***********************************************************************************************************
00001F68                          1801  
00001F68                          1802  opSUB                                       ; We assume we found SUB, begin SUB disassemble
00001F68  43F9 0000424C           1803              LEA         SUBmatch, A1        ; Load A1 to print SUB found message
00001F6E  103C 000E               1804              MOVE.B      #14, D0             ; command for trap call to display message
00001F72  4E4F                    1805              TRAP        #15                 ; trap call to halt
00001F74                          1806          
00001F74                          1807          
00001F74  E141                    1808              ASL         #eight,D1           ; Shift D1 to by 8 to find opmode
00001F76  1218                    1809              MOVE.B      (A0)+,D1            ; Reload instruction
00001F78  4242                    1810              CLR         D2                  ; Ensure D2 is clear
00001F7A                          1811              
00001F7A  3401                    1812              MOVE.W      D1,D2               ; Load our word into D2 to manipulate
00001F7C  EC42                    1813              ASR         #six,D2             ; Move bits 7 places over to find opmode
00001F7E  C47C 0007               1814              AND         #seven,D2           ; AND by 7 to remove extra bits
00001F82                          1815              
00001F82                          1816              ; These are for Dn - EA
00001F82  B43C 0000               1817              CMP.B       #zero,D2            ; Check for byte
00001F86  6700 002A               1818              BEQ         opSUBB              ; Byte in opmode
00001F8A  B43C 0001               1819              CMP.B       #one,D2             ; Check for word
00001F8E  6700 007C               1820              BEQ         opSUBW              ; Word in opmode
00001F92  B43C 0002               1821              CMP.B       #two,D2             ; Check for long
00001F96  6700 00CE               1822              BEQ         opSUBL              ; Long in opmode
00001F9A                          1823              
00001F9A                          1824              ; These are for EA - Dn
00001F9A  B43C 0004               1825              CMP.B       #four,D2            ; Check for byte
00001F9E  6700 0012               1826              BEQ         opSUBB              ; Byte in opmode
00001FA2  B43C 0005               1827              CMP.B       #five,D2            ; Check for word
00001FA6  6700 0064               1828              BEQ         opSUBW              ; Word in opmode
00001FAA  B43C 0006               1829              CMP.B       #six,D2             ; Check for long
00001FAE  6700 00B6               1830              BEQ         opSUBL              ; Long in opmode
00001FB2                          1831              
00001FB2                          1832  opSUBB                                      ; Byte has been found, find operands
00001FB2  43F9 00004285           1833              LEA         dispByte,A1         ; Output the byte info to the console
00001FB8  103C 000E               1834              MOVE.B      #14,D0              ; Use trap task 14 for IO
00001FBC  4E4F                    1835              TRAP        #15                 ; Halt for IO
00001FBE                          1836              
00001FBE  43F9 000041EB           1837              LEA         space, A1           ; Display space
00001FC4  103C 000E               1838              MOVE.B      #14, D0             ; command for trap call to display message
00001FC8  4E4F                    1839              TRAP        #15                 ; trap call         
00001FCA                          1840              
00001FCA  1401                    1841              MOVE.B      D1,D2               ; Load D2 with our D1 byte
00001FCC  E642                    1842              ASR         #3,D2               ; Shift by 3 to find an operand
00001FCE  C47C 0007               1843              AND         #$07,D2             ; AND by 7 to remove extra bits
00001FD2  3601                    1844              MOVE.W      D1,D3               ; Load D3 with our word in D1
00001FD4  C67C 0007               1845              AND         #$07,D3             ; AND by 7 to remove extra bits
00001FD8  4EB9 00002F1E           1846              JSR         printEA             ; Use EA subroutine to find an operand
00001FDE                          1847              
00001FDE  43F9 000041F2           1848              LEA         comma, A1           ; Display space
00001FE4  103C 000E               1849              MOVE.B      #14, D0             ; command for trap call to display message
00001FE8  4E4F                    1850              TRAP        #15                 ; trap call
00001FEA                          1851              
00001FEA  4242                    1852              CLR         D2                  ; Empty D2 for use again
00001FEC  3601                    1853              MOVE.W      D1,D3               ; Load the word again into D3
00001FEE  E043                    1854              ASR         #eight,D3           ; Shift by 8 to find other operand
00001FF0  E243                    1855              ASR         #one,D3             ; Requires an additional shift
00001FF2  C67C 0007               1856              AND         #$07,D3             ; AND by 7 to remove extra bits
00001FF6  4EB9 00002F1E           1857              JSR         printEA             ; EA subroutine finds our remaining operand
00001FFC                          1858              
00001FFC  43F9 000041E7           1859              LEA         newLine,A1          ; Ready console with newline
00002002  103C 000E               1860              MOVE.B      #14,D0              ; Trap 14 for output
00002006  4E4F                    1861              TRAP        #15                 ; Halt for IO
00002008                          1862              
00002008  6000 F03C               1863              BRA         LOOP                ; Return to control loop
0000200C                          1864              
0000200C                          1865  opSUBW                                      ; Word has been found, find operands
0000200C  43F9 00004288           1866              LEA         dispWord,A1         ; Output the word info to the console
00002012  103C 000E               1867              MOVE.B      #14,D0              ; Use trap task 14 for IO
00002016  4E4F                    1868              TRAP        #15                 ; Halt for IO
00002018                          1869              
00002018  43F9 000041EB           1870              LEA         space, A1           ; Display space
0000201E  103C 000E               1871              MOVE.B      #14, D0             ; command for trap call to display message
00002022  4E4F                    1872              TRAP        #15                 ; trap call         
00002024                          1873              
00002024  1401                    1874              MOVE.B      D1,D2               ; Load D2 with our D1 byte
00002026  E642                    1875              ASR         #3,D2               ; Shift by 3 to find an operand
00002028  C47C 0007               1876              AND         #$07,D2             ; AND by 7 to remove extra bits
0000202C  3601                    1877              MOVE.W      D1,D3               ; Load D3 with our word in D1
0000202E  C67C 0007               1878              AND         #$07,D3             ; AND by 7 to remove extra bits
00002032  4EB9 00002F1E           1879              JSR         printEA             ; Use EA subroutine to find an operand
00002038                          1880              
00002038  43F9 000041F2           1881              LEA         comma, A1           ; Display space
0000203E  103C 000E               1882              MOVE.B      #14, D0             ; command for trap call to display message
00002042  4E4F                    1883              TRAP        #15                 ; trap call
00002044                          1884              
00002044  4242                    1885              CLR         D2                  ; Empty D2 for use again
00002046  3601                    1886              MOVE.W      D1,D3               ; Load the word again into D3
00002048  E043                    1887              ASR         #eight,D3           ; Shift by 8 to find other operand
0000204A  E243                    1888              ASR         #one,D3             ; Requires an additional shift
0000204C  C67C 0007               1889              AND         #$07,D3             ; AND by 7 to remove extra bits
00002050  4EB9 00002F1E           1890              JSR         printEA             ; EA subroutine finds our remaining operand
00002056                          1891              
00002056  43F9 000041E7           1892              LEA         newLine,A1          ; Ready console with newline
0000205C  103C 000E               1893              MOVE.B      #14,D0              ; Trap 14 for output
00002060  4E4F                    1894              TRAP        #15                 ; Halt for IO
00002062                          1895              
00002062  6000 EFE2               1896              BRA         LOOP                ; Return to control loop
00002066                          1897              
00002066                          1898  opSUBL                                      ; Long has been found, find operands
00002066  43F9 0000428B           1899              LEA         dispLong,A1         ; Output the long info to the console
0000206C  103C 000E               1900              MOVE.B      #14,D0              ; Use trap task 14 for IO
00002070  4E4F                    1901              TRAP        #15                 ; Halt for IO
00002072                          1902              
00002072  43F9 000041EB           1903              LEA         space, A1           ; Display space
00002078  103C 000E               1904              MOVE.B      #14, D0             ; command for trap call to display message
0000207C  4E4F                    1905              TRAP        #15                 ; trap call         
0000207E                          1906              
0000207E  1401                    1907              MOVE.B      D1,D2               ; Load D2 with our D1 byte
00002080  E642                    1908              ASR         #3,D2               ; Shift by 3 to find an operand
00002082  C47C 0007               1909              AND         #$07,D2             ; AND by 7 to remove extra bits
00002086  3601                    1910              MOVE.W      D1,D3               ; Load D3 with our word in D1
00002088  C67C 0007               1911              AND         #$07,D3             ; AND by 7 to remove extra bits
0000208C  4EB9 00002F1E           1912              JSR         printEA             ; Use EA subroutine to find an operand
00002092                          1913              
00002092  43F9 000041F2           1914              LEA         comma, A1           ; Display space
00002098  103C 000E               1915              MOVE.B      #14, D0             ; command for trap call to display message
0000209C  4E4F                    1916              TRAP        #15                 ; trap call
0000209E                          1917              
0000209E  4242                    1918              CLR         D2                  ; Empty D2 for use again
000020A0  3601                    1919              MOVE.W      D1,D3               ; Load the word again into D3
000020A2  E043                    1920              ASR         #eight,D3           ; Shift by 8 to find other operand
000020A4  E243                    1921              ASR         #one,D3             ; Requires an additional shift
000020A6  C67C 0007               1922              AND         #$07,D3             ; AND by 7 to remove extra bits
000020AA  4EB9 00002F1E           1923              JSR         printEA             ; EA subroutine finds our remaining operand
000020B0                          1924              
000020B0  43F9 000041E7           1925              LEA         newLine,A1          ; Ready console with newline
000020B6  103C 000E               1926              MOVE.B      #14,D0              ; Trap 14 for output
000020BA  4E4F                    1927              TRAP        #15                 ; Halt for IO
000020BC                          1928              
000020BC  6000 EF88               1929              BRA         LOOP                ; Return to control loop
000020C0                          1930              
000020C0                          1931  ***********************************************************************************************************
000020C0                          1932  *
000020C0                          1933  *                   BRA OPCODE
000020C0                          1934  *       
000020C0                          1935  *       This section is dedicated to the BRA opcode, which is determined by having six in the first
000020C0                          1936  *       nibble of the instruction, and zero in the second nibble.
000020C0                          1937  *
000020C0                          1938  ***********************************************************************************************************
000020C0                          1939              
000020C0                          1940  opBRA       
000020C0  43F9 00004230           1941              LEA         BRAmatch, A1        ; we know that the opcode will be BRA, so load A1 to print message
000020C6  103C 000E               1942              MOVE.B      #14, D0             ; Prime trap task #14 for output
000020CA  4E4F                    1943              TRAP        #15                 ; trap call to output BRA
000020CC                          1944          
000020CC  4242                    1945              CLR         D2                  ; Data register to needs to be cleared for use again
000020CE  4243                    1946              CLR         D3                  ; Data register to needs to be cleared for use again
000020D0                          1947  
000020D0  43F9 000041EB           1948              LEA         space,A1            ; output a space for the IO console
000020D6  103C 000E               1949              MOVE.B      #14,D0              ; Prime trap task #14 for the output
000020DA  4E4F                    1950              TRAP        #15                 ; Call trap #15 with number 14 for our IO
000020DC                          1951          
000020DC  143C 0007               1952              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
000020E0  1218                    1953              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
000020E2  4EB9 00002F1E           1954              JSR         printEA             ; this method handles the displacement hex values
000020E8                          1955          
000020E8  43F9 000041E7           1956              LEA         newLine, A1         ; create new line for the IO console
000020EE  103C 000E               1957              MOVE.B      #14, D0             ; command for trap call to display message
000020F2  4E4F                    1958              TRAP        #15                 ; trap call ready console for next instruction
000020F4                          1959  
000020F4  6000 EF50               1960              BRA         LOOP                ; return back to our control loop to find next instruction
000020F8                          1961          
000020F8                          1962  ***********************************************************************************************************
000020F8                          1963  *
000020F8                          1964  *                   Bcc OPCODES
000020F8                          1965  *
000020F8                          1966  *       This section is dedicated to the conditional branching opcode. There are varying second nibble
000020F8                          1967  *       values, documented below, with the correspond cc code.
000020F8                          1968  *       BCC is similar to BRA, so we handle it in the same manner.
000020F8                          1969  *
000020F8                          1970  *       Supported cc condition codes:
000020F8                          1971  *           >Carry Clear        = CS        second nibble == 5
000020F8                          1972  *           >Overflow Set       = VC        second nibble == 8
000020F8                          1973  *           >Greater or EqualGE = GE        second nibble == 12
000020F8                          1974  *           >Less Than          = LT        second nibble == 13
000020F8                          1975  *
000020F8                          1976  ***********************************************************************************************************
000020F8                          1977  * CS Conition Code
000020F8                          1978  
000020F8                          1979  opBCS       
000020F8  43F9 00004234           1980              LEA         BCSmatch, A1        ; we know that the opcode will be BCS, so load A1 to print message
000020FE  103C 000E               1981              MOVE.B      #14, D0             ; command for trap call to display message
00002102  4E4F                    1982              TRAP        #15                 ; trap call
00002104                          1983          
00002104  4242                    1984              CLR         D2                  ; Data register to needs to be cleared for use again
00002106  4243                    1985              CLR         D3                  ; Data register to needs to be cleared for use again
00002108                          1986  
00002108  43F9 000041EB           1987              LEA         space,A1            ; output a space for the IO console
0000210E  103C 000E               1988              MOVE.B      #14,D0              ; Prime trap task #14 for the output
00002112  4E4F                    1989              TRAP        #15                 ; Call trap #15 with number 14 for our IO
00002114                          1990          
00002114  143C 0007               1991              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
00002118  1218                    1992              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
0000211A  4EB9 00002F1E           1993              JSR         printEA             ; this method handles the displacement hex values
00002120                          1994          
00002120  43F9 000041E7           1995              LEA         newLine, A1         ; create new line for the IO console
00002126  103C 000E               1996              MOVE.B      #14, D0             ; command for trap call to display message
0000212A  4E4F                    1997              TRAP        #15                 ; trap call ready console for next instruction
0000212C                          1998              
0000212C  6000 EF18               1999              BRA         LOOP                ; return to the control loop for next instruction
00002130                          2000  
00002130                          2001  ***********************************************************************************************************
00002130                          2002  * VC Condition Code
00002130                          2003  
00002130                          2004  opBVC       
00002130  43F9 00004238           2005              LEA         BVCmatch, A1        ; we know that the opcode will be BVC, so load A1 to print message
00002136  103C 000E               2006              MOVE.B      #14, D0             ; command for trap call to display message
0000213A  4E4F                    2007              TRAP        #15                 ; trap call
0000213C                          2008          
0000213C  4242                    2009              CLR         D2                  ; Data register to needs to be cleared for use again
0000213E  4243                    2010              CLR         D3                  ; Data register to needs to be cleared for use again
00002140                          2011  
00002140  43F9 000041EB           2012              LEA         space,A1            ; output a space for the IO console
00002146  103C 000E               2013              MOVE.B      #14,D0              ; Prime trap task #14 for the output
0000214A  4E4F                    2014              TRAP        #15                 ; Call trap #15 with number 14 for our IO
0000214C                          2015          
0000214C  143C 0007               2016              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
00002150  1218                    2017              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
00002152  4EB9 00002F1E           2018              JSR         printEA             ; this method handles the displacement hex values
00002158                          2019          
00002158  43F9 000041E7           2020              LEA         newLine, A1         ; create new line for the IO console
0000215E  103C 000E               2021              MOVE.B      #14, D0             ; command for trap call to display message
00002162  4E4F                    2022              TRAP        #15                 ; trap call ready console for next instruction
00002164                          2023              
00002164  6000 EEE0               2024              BRA         LOOP                ; return to the control loop for next instruction
00002168                          2025  
00002168                          2026  ***********************************************************************************************************
00002168                          2027  * GE Conidtion Code     
00002168                          2028          
00002168                          2029  opBGE       
00002168  43F9 0000423C           2030              LEA         BGEmatch, A1        ; we know that the opcode will be BGE, so load A1 to print message
0000216E  103C 000E               2031              MOVE.B      #14, D0             ; command for trap call to display message
00002172  4E4F                    2032              TRAP        #15                 ; trap call
00002174                          2033          
00002174  4242                    2034              CLR         D2                  ; Data register to needs to be cleared for use again
00002176  4243                    2035              CLR         D3                  ; Data register to needs to be cleared for use again
00002178                          2036  
00002178  43F9 000041EB           2037              LEA         space,A1            ; output a space for the IO console
0000217E  103C 000E               2038              MOVE.B      #14,D0              ; Prime trap task #14 for the output
00002182  4E4F                    2039              TRAP        #15                 ; Call trap #15 with number 14 for our IO
00002184                          2040          
00002184  143C 0007               2041              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
00002188  1218                    2042              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
0000218A  4EB9 00002F1E           2043              JSR         printEA             ; this method handles the displacement hex values
00002190                          2044          
00002190  43F9 000041E7           2045              LEA         newLine, A1         ; create new line for the IO console
00002196  103C 000E               2046              MOVE.B      #14, D0             ; command for trap call to display message
0000219A  4E4F                    2047              TRAP        #15                 ; trap call ready console for next instruction
0000219C                          2048              
0000219C  6000 EEA8               2049              BRA         LOOP                ; return to the control loop for next instruction
000021A0                          2050  
000021A0                          2051  ***********************************************************************************************************
000021A0                          2052  * LT Conditions Code        
000021A0                          2053          
000021A0                          2054  opBLT   
000021A0  43F9 00004240           2055              LEA         BLTmatch, A1        ; we know that the opcode will be BLT, so load A1 to print message
000021A6  103C 000E               2056              MOVE.B      #14, D0             ; command for trap call to display message
000021AA  4E4F                    2057              TRAP        #15                 ; trap call
000021AC                          2058          
000021AC  4242                    2059              CLR         D2                  ; Data register to needs to be cleared for use again
000021AE  4243                    2060              CLR         D3                  ; Data register to needs to be cleared for use again
000021B0                          2061  
000021B0  43F9 000041EB           2062              LEA         space,A1            ; output a space for the IO console
000021B6  103C 000E               2063              MOVE.B      #14,D0              ; Prime trap task #14 for the output
000021BA  4E4F                    2064              TRAP        #15                 ; Call trap #15 with number 14 for our IO
000021BC                          2065          
000021BC  143C 0007               2066              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
000021C0  1218                    2067              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
000021C2  4EB9 00002F1E           2068              JSR         printEA             ; this method handles the displacement hex values
000021C8                          2069          
000021C8  43F9 000041E7           2070              LEA         newLine, A1         ; create new line for the IO console
000021CE  103C 000E               2071              MOVE.B      #14, D0             ; command for trap call to display message
000021D2  4E4F                    2072              TRAP        #15                 ; trap call ready console for next instruction
000021D4                          2073              
000021D4  6000 EE70               2074              BRA         LOOP                ; return to the control loop for next instruction
000021D8                          2075          
000021D8                          2076  ***********************************************************************************************************
000021D8                          2077  *
000021D8                          2078  *               SUBQ OPCODE
000021D8                          2079  *
000021D8                          2080  *       This section is for disassembling the SUBQ instruction, which is determined by a 5 in the first
000021D8                          2081  *       nibble.
000021D8                          2082  *       We assume there is only 1 opcode with 5 in the first nibble.
000021D8                          2083  *       SUBQ utilizes immediate data, so we use an alternate subroutine for operand output.
000021D8                          2084  *       The size field is used to branch to the subvariants of SUBQ, which we determine before hitting the
000021D8                          2085  *       final subroutines.
000021D8                          2086  *
000021D8                          2087  ***********************************************************************************************************
000021D8                          2088  
000021D8                          2089  opSUBQ                                      ; Assumed that we found SUBQ, begin disassemble
000021D8  43F9 0000422B           2090              LEA         SUBQmatch, A1       ; Send out SUBQ message
000021DE  103C 000E               2091              MOVE.B      #14, D0             ; command for trap call to display message
000021E2  4E4F                    2092              TRAP        #15                 ; trap call to halt
000021E4                          2093              
000021E4  E141                    2094              ASL         #eight,D1           ; Shift by 8 to find size bits
000021E6  1218                    2095              MOVE.B      (A0)+,D1            ; Reload D1
000021E8  1401                    2096              MOVE.B      D1,D2               ; Move data in D2 to alter later
000021EA  EE42                    2097              ASR         #seven,D2           ; Move bits 7 places over to find size
000021EC  C47C 0007               2098              AND         #$07,D2             ; AND by 7 to remove uneeded bits
000021F0                          2099              
000021F0                          2100              ; Find size bits
000021F0  B43C 0000               2101              CMP.B       #zero,D2            ; Check for a byte
000021F4  6700 0012               2102              BEQ         opSUBQB             ; Byte in size
000021F8  B43C 0001               2103              CMP.B       #one,D2             ; Check for a word
000021FC  6700 0020               2104              BEQ         opSUBQW             ; Word in size
00002200  B43C 0002               2105              CMP.B       #two,D2             ; Check for a long
00002204  6700 002E               2106              BEQ         opSUBQL             ; Long in size
00002208                          2107              
00002208                          2108  opSUBQB                                     ; Found a byte in size, prepare for JSR
00002208  43F9 00004285           2109              LEA         dispByte,A1         ; Display the byte in the console
0000220E  103C 000E               2110              MOVE.B      #14,D0              ; Trap task 14 for IO
00002212  4E4F                    2111              TRAP        #15                 ; Halt for IO
00002214                          2112            
00002214  4EB9 00002E46           2113              JSR         PrntImm             ; Call immediate data subroutine to handle SUBQ operands
0000221A                          2114              
0000221A  6000 EE2A               2115              BRA         LOOP                ; Return to control loop
0000221E                          2116              
0000221E                          2117  opSUBQW                                     ; Found a word in size, prepare for JSR
0000221E  43F9 00004288           2118              LEA         dispWord,A1         ; Display the word in the console
00002224  103C 000E               2119              MOVE.B      #14,D0              ; Trap task 14 for IO
00002228  4E4F                    2120              TRAP        #15                 ; Halt for IO
0000222A                          2121            
0000222A  4EB9 00002E46           2122              JSR         PrntImm             ; Call immediate data subroutine to handle SUBQ operands
00002230                          2123              
00002230  6000 EE14               2124              BRA         LOOP                ; Return to control loop
00002234                          2125              
00002234                          2126  opSUBQL                                     ; Found a long in size, prepare for JSR
00002234  43F9 0000428B           2127              LEA         dispLong,A1         ; Display the long in the console
0000223A  103C 000E               2128              MOVE.B      #14,D0              ; Trap task 14 for IO
0000223E  4E4F                    2129              TRAP        #15                 ; Halt for IO
00002240                          2130            
00002240  4246                    2131              CLR         D6                  ; In the long size case, we need to ensure D6 is clear for the JSR call
00002242  1C3C 0001               2132              MOVE.B      #1,D6               ; Needed to ensure proper immediate data is output to the console
00002246                          2133            
00002246  4EB9 00002E46           2134              JSR         PrntImm             ; Call immediate data subroutine to handle SUBQ operands
0000224C                          2135              
0000224C  6000 EDF8               2136              BRA         LOOP                ; Return to control loop
00002250                          2137          
00002250                          2138  ***********************************************************************************************************
00002250                          2139  *
00002250                          2140  *                   MULS OPCODE
00002250                          2141  *
00002250                          2142  ***********************************************************************************************************
00002250                          2143  
00002250                          2144  opMULS  
00002250  43F9 00004258           2145              LEA         MULSmatch, A1       ; we know that the opcode will be MULS, so load A1 to print message
00002256  103C 000E               2146              MOVE.B      #14, D0             ; command for trap call to display message
0000225A  4E4F                    2147              TRAP        #15                 ; trap call
0000225C  43F9 000041EB           2148              LEA         space, A1           ; create spaces
00002262  103C 000E               2149              MOVE.B      #14, D0             ; command for trap call to display message
00002266  4E4F                    2150              TRAP        #15                 ; trap call
00002268                          2151          
00002268  E141                    2152              ASL         #eight, D1          ; move D1 over by a byte
0000226A  1218                    2153              MOVE.B      (A0)+, D1           ; copy the next byte into D1
0000226C                          2154          
0000226C  4242                    2155              CLR         D2                  ; clear D2
0000226E  4243                    2156              CLR         D3                  ; clear D3
00002270  1401                    2157              MOVE.B      D1, D2              ; copy the byte from D1 to D2
00002272  E642                    2158              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
00002274  C47C 0007               2159              AND         #seven, D2          ; and D2 to get only first 3 bits
00002278  1601                    2160              MOVE.B      D1, D3              ; copy D1 byte to D3
0000227A  C67C 0007               2161              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
0000227E                          2162          
0000227E  4EB9 00002F1E           2163              JSR         printEA             ; jump to printEA
00002284                          2164          
00002284  43F9 000041F2           2165              LEA         comma, A1           ; create comma
0000228A  103C 000E               2166              MOVE.B      #14, D0             ; command for trap call to display message
0000228E  4E4F                    2167              TRAP        #15                 ; trap call
00002290                          2168  
00002290  4242                    2169              CLR         D2                  ; clear D2 since we know mode should be data register
00002292  4243                    2170              CLR         D3                  ; clear D3
00002294  3601                    2171              MOVE.W      D1, D3              ; Move D1 word to D3
00002296  E043                    2172              ASR         #eight, D3          ; shift D3 by 8 bits
00002298  E243                    2173              ASR         #one, D3            ; shift D3 by 1 bit
0000229A  C67C 0007               2174              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
0000229E                          2175  
0000229E  4EB9 00002F1E           2176              JSR         printEA             ; jump to printEA
000022A4                          2177          
000022A4  43F9 000041E7           2178              LEA         newLine, A1         ; create new line
000022AA  103C 000E               2179              MOVE.B      #14, D0             ; command for trap call to display message
000022AE  4E4F                    2180              TRAP        #15                 ; trap call
000022B0                          2181          
000022B0  6000 ED94               2182              BRA         LOOP                ; branch back to LOOP
000022B4                          2183  
000022B4                          2184  ***********************************************************************************************************
000022B4                          2185  *
000022B4                          2186  *                   ADD OPCODE
000022B4                          2187  *
000022B4                          2188  ***********************************************************************************************************   
000022B4                          2189  
000022B4                          2190  opADDB  
000022B4  43F9 0000425D           2191              LEA         ADDmatch, A1        ; we know that the opcode will be ADD, so load A1 to print message
000022BA  103C 000E               2192              MOVE.B      #14, D0             ; command for trap call to display message
000022BE  4E4F                    2193              TRAP        #15                 ; trap call
000022C0                          2194          
000022C0  43F9 00004285           2195              LEA         dispByte, A1        ; display byte
000022C6  103C 000E               2196              MOVE.B      #14, D0             ; command for trap call to display message
000022CA  4E4F                    2197              TRAP        #15                 ; trap call
000022CC  43F9 000041EB           2198              LEA         space, A1           ; create spaces
000022D2  103C 000E               2199              MOVE.B      #14, D0             ; command for trap call to display message
000022D6  4E4F                    2200              TRAP        #15                 ; trap call
000022D8                          2201          
000022D8  4242                    2202              CLR         D2                  ; clear D2
000022DA  4243                    2203              CLR         D3                  ; clear D3
000022DC  1401                    2204              MOVE.B      D1, D2              ; copy the byte from D1 to D2
000022DE  E642                    2205              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
000022E0  C47C 0007               2206              AND         #seven, D2          ; and D2 to get only first 3 bits
000022E4  1601                    2207              MOVE.B      D1, D3              ; copy D1 byte to D3
000022E6  C67C 0007               2208              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
000022EA                          2209          
000022EA  4EB9 00002F1E           2210              JSR         printEA             ; jump to printEA
000022F0                          2211          
000022F0  43F9 000041F2           2212              LEA         comma, A1           ; create comma
000022F6  103C 000E               2213              MOVE.B      #14, D0             ; command for trap call to display message
000022FA  4E4F                    2214              TRAP        #15                 ; trap call
000022FC                          2215  
000022FC  4242                    2216              CLR         D2                  ; clear D2 since we know mode should be data register
000022FE  4243                    2217              CLR         D3                  ; clear D3
00002300  3601                    2218              MOVE.W      D1, D3              ; Move D1 word to D3
00002302  E043                    2219              ASR         #eight, D3          ; shift D3 by 8 bits
00002304  E243                    2220              ASR         #one, D3            ; shift D3 by 1 bit
00002306  C67C 0007               2221              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
0000230A                          2222  
0000230A  4EB9 00002F1E           2223              JSR         printEA             ; jump to printEA
00002310                          2224          
00002310  43F9 000041E7           2225              LEA         newLine, A1         ; create new line
00002316  103C 000E               2226              MOVE.B      #14, D0             ; command for trap call to display message
0000231A  4E4F                    2227              TRAP        #15                 ; trap call
0000231C                          2228          
0000231C  6000 ED28               2229              BRA         LOOP                ; branch back to LOOP
00002320                          2230          
00002320                          2231  opADDW  
00002320  43F9 0000425D           2232              LEA         ADDmatch, A1        ; we know that the opcode will be ADD, so load A1 to print message
00002326  103C 000E               2233              MOVE.B      #14, D0             ; command for trap call to display message
0000232A  4E4F                    2234              TRAP        #15                 ; trap call
0000232C                          2235  
0000232C  43F9 00004288           2236              LEA         dispWord, A1        ; display word
00002332  103C 000E               2237              MOVE.B      #14, D0             ; command for trap call to display message
00002336  4E4F                    2238              TRAP        #15                 ; trap call
00002338  43F9 000041EB           2239              LEA         space, A1           ; create spaces
0000233E  103C 000E               2240              MOVE.B      #14, D0             ; command for trap call to display message
00002342  4E4F                    2241              TRAP        #15                 ; trap call
00002344                          2242          
00002344  4242                    2243              CLR         D2                  ; clear D2
00002346  4243                    2244              CLR         D3                  ; clear D3
00002348  1401                    2245              MOVE.B      D1, D2              ; copy the byte from D1 to D2
0000234A  E642                    2246              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
0000234C  C47C 0007               2247              AND         #seven, D2          ; and D2 to get only first 3 bits
00002350  1601                    2248              MOVE.B      D1, D3              ; copy D1 byte to D3
00002352  C67C 0007               2249              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
00002356                          2250          
00002356  4EB9 00002F1E           2251              JSR         printEA             ; jump to printEA
0000235C                          2252          
0000235C  43F9 000041F2           2253              LEA         comma, A1           ; create comma
00002362  103C 000E               2254              MOVE.B      #14, D0             ; command for trap call to display message
00002366  4E4F                    2255              TRAP        #15                 ; trap call
00002368                          2256  
00002368  4242                    2257              CLR         D2                  ; clear D2 since we know mode should be data register
0000236A  4243                    2258              CLR         D3                  ; clear D3
0000236C  3601                    2259              MOVE.W      D1, D3              ; Move D1 word to D3
0000236E  E043                    2260              ASR         #eight, D3          ; shift D3 by 8 bits
00002370  E243                    2261              ASR         #one, D3            ; shift D3 by 1 bit
00002372  C67C 0007               2262              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
00002376                          2263  
00002376  4EB9 00002F1E           2264              JSR         printEA             ; jump to printEA
0000237C                          2265          
0000237C  43F9 000041E7           2266              LEA         newLine, A1         ; create new line
00002382  103C 000E               2267              MOVE.B      #14, D0             ; command for trap call to display message
00002386  4E4F                    2268              TRAP        #15                 ; trap call
00002388                          2269          
00002388  6000 ECBC               2270              BRA         LOOP                ; branch back to LOOP
0000238C                          2271          
0000238C                          2272  opADDL  
0000238C  43F9 0000425D           2273              LEA         ADDmatch, A1        ; we know that the opcode will be ADD, so load A1 to print message
00002392  103C 000E               2274              MOVE.B      #14, D0             ; command for trap call to display message
00002396  4E4F                    2275              TRAP        #15                 ; trap call
00002398                          2276          
00002398  43F9 0000428B           2277              LEA         dispLong, A1        ; display long
0000239E  103C 000E               2278              MOVE.B      #14, D0             ; command for trap call to display message
000023A2  4E4F                    2279              TRAP        #15                 ; trap call
000023A4  43F9 000041EB           2280              LEA         space, A1           ; create spaces
000023AA  103C 000E               2281              MOVE.B      #14, D0             ; command for trap call to display message
000023AE  4E4F                    2282              TRAP        #15                 ; trap call
000023B0                          2283          
000023B0  4242                    2284              CLR         D2                  ; clear D2
000023B2  4243                    2285              CLR         D3                  ; clear D3
000023B4  1401                    2286              MOVE.B      D1, D2              ; copy the byte from D1 to D2
000023B6  E642                    2287              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
000023B8  C47C 0007               2288              AND         #seven, D2          ; and D2 to get only first 3 bits
000023BC  1601                    2289              MOVE.B      D1, D3              ; copy D1 byte to D3
000023BE  C67C 0007               2290              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
000023C2                          2291          
000023C2  4246                    2292              CLR         D6                  ; Clear D6
000023C4  1C3C 0001               2293              MOVE.B      #1, D6              ; move 1 to D6 in case source is printing immediate
000023C8                          2294          
000023C8  4EB9 00002F1E           2295              JSR         printEA             ; jump to printEA
000023CE  4246                    2296              CLR         D6                  ; clear D6
000023D0                          2297          
000023D0  43F9 000041F2           2298              LEA         comma, A1           ; create comma
000023D6  103C 000E               2299              MOVE.B      #14, D0             ; command for trap call to display message
000023DA  4E4F                    2300              TRAP        #15                 ; trap call
000023DC                          2301  
000023DC  4242                    2302              CLR         D2                  ; clear D2 since we know mode should be data register
000023DE  4243                    2303              CLR         D3                  ; clear D3
000023E0  3601                    2304              MOVE.W      D1, D3              ; Move D1 word to D3
000023E2  E043                    2305              ASR         #eight, D3          ; shift D3 by 8 bits
000023E4  E243                    2306              ASR         #one, D3            ; shift D3 by 1 bit
000023E6  C67C 0007               2307              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
000023EA                          2308  
000023EA  4EB9 00002F1E           2309              JSR         printEA             ; jump to printEA
000023F0                          2310          
000023F0  43F9 000041E7           2311              LEA         newLine, A1         ; create new line
000023F6  103C 000E               2312              MOVE.B      #14, D0             ; command for trap call to display message
000023FA  4E4F                    2313              TRAP        #15                 ; trap call
000023FC                          2314          
000023FC  6000 EC48               2315              BRA         LOOP                ; branch back to LOOP
00002400                          2316  
00002400                          2317  ***********************************************************************************************************
00002400                          2318  *
00002400                          2319  *                   ADDA OPCODE
00002400                          2320  *
00002400                          2321  *********************************************************************************************************** 
00002400                          2322  
00002400                          2323  opADDAW 
00002400  43F9 00004261           2324              LEA         ADDAmatch, A1       ; we know that the opcode will be ADDA, so load A1 to print message
00002406  103C 000E               2325              MOVE.B      #14, D0             ; command for trap call to display message
0000240A  4E4F                    2326              TRAP        #15                 ; trap call
0000240C                          2327          
0000240C  43F9 00004288           2328              LEA         dispWord, A1        ; display word
00002412  103C 000E               2329              MOVE.B      #14, D0             ; command for trap call to display message
00002416  4E4F                    2330              TRAP        #15                 ; trap call
00002418  43F9 000041EB           2331              LEA         space, A1           ; create spaces
0000241E  103C 000E               2332              MOVE.B      #14, D0             ; command for trap call to display message
00002422  4E4F                    2333              TRAP        #15                 ; trap call
00002424                          2334          
00002424  4242                    2335              CLR         D2                  ; clear D2
00002426  4243                    2336              CLR         D3                  ; clear D3
00002428  1401                    2337              MOVE.B      D1, D2              ; copy the byte from D1 to D2
0000242A  E642                    2338              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
0000242C  C47C 0007               2339              AND         #seven, D2          ; and D2 to get only first 3 bits
00002430  1601                    2340              MOVE.B      D1, D3              ; copy D1 byte to D3
00002432  C67C 0007               2341              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
00002436                          2342          
00002436  4EB9 00002F1E           2343              JSR         printEA             ; jump to printEA 
0000243C                          2344          
0000243C  43F9 000041F2           2345              LEA         comma, A1           ; create comma
00002442  103C 000E               2346              MOVE.B      #14, D0             ; command for trap call to display message
00002446  4E4F                    2347              TRAP        #15                 ; trap call
00002448                          2348  
00002448  4242                    2349              CLR         D2                  ; clear D2 since we know mode should be data register
0000244A  4243                    2350              CLR         D3                  ; clear D3
0000244C  143C 0001               2351              MOVE.B      #one, D2            ; move 1 to D2 since mode should be address
00002450  3601                    2352              MOVE.W      D1, D3              ; Move D1 word to D3
00002452  E043                    2353              ASR         #eight, D3          ; shift D3 by 8 bits
00002454  E243                    2354              ASR         #one, D3            ; shift D3 by 1 bit
00002456  C67C 0007               2355              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
0000245A                          2356  
0000245A  4EB9 00002F1E           2357              JSR         printEA             ; jump to printEA
00002460                          2358          
00002460  43F9 000041E7           2359              LEA         newLine, A1         ; create new line
00002466  103C 000E               2360              MOVE.B      #14, D0             ; command for trap call to display message
0000246A  4E4F                    2361              TRAP        #15                 ; trap call
0000246C                          2362          
0000246C  6000 EBD8               2363              BRA         LOOP                ; branch back to LOOP
00002470                          2364  
00002470                          2365  opADDAL 
00002470  43F9 00004261           2366              LEA         ADDAmatch, A1       ; we know that the opcode will be ADDA, so load A1 to print message
00002476  103C 000E               2367              MOVE.B      #14, D0             ; command for trap call to display message
0000247A  4E4F                    2368              TRAP        #15                 ; trap call
0000247C                          2369  
0000247C  43F9 0000428B           2370              LEA         dispLong, A1        ; display long
00002482  103C 000E               2371              MOVE.B      #14, D0             ; command for trap call to display message
00002486  4E4F                    2372              TRAP        #15                 ; trap call
00002488  43F9 000041EB           2373              LEA         space, A1           ; create spaces
0000248E  103C 000E               2374              MOVE.B      #14, D0             ; command for trap call to display message
00002492  4E4F                    2375              TRAP        #15                 ; trap call
00002494                          2376          
00002494  4242                    2377              CLR         D2                  ; clear D2
00002496  4243                    2378              CLR         D3                  ; clear D3
00002498  1401                    2379              MOVE.B      D1, D2              ; copy the byte from D1 to D2
0000249A  E642                    2380              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
0000249C  C47C 0007               2381              AND         #seven, D2          ; and D2 to get only first 3 bits
000024A0  1601                    2382              MOVE.B      D1, D3              ; copy D1 byte to D3
000024A2  C67C 0007               2383              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
000024A6                          2384          
000024A6  4EB9 00002F1E           2385              JSR         printEA             ; jump to printEA 
000024AC                          2386          
000024AC  43F9 000041F2           2387              LEA         comma, A1           ; create comma
000024B2  103C 000E               2388              MOVE.B      #14, D0             ; command for trap call to display message
000024B6  4E4F                    2389              TRAP        #15                 ; trap call
000024B8                          2390  
000024B8  4242                    2391              CLR         D2                  ; clear D2 since we know mode should be data register
000024BA  4243                    2392              CLR         D3                  ; clear D3
000024BC  143C 0001               2393              MOVE.B      #one, D2            ; move 1 to D2 since mode should be address
000024C0  3601                    2394              MOVE.W      D1, D3              ; Move D1 word to D3
000024C2  E043                    2395              ASR         #eight, D3          ; shift D3 by 8 bits
000024C4  E243                    2396              ASR         #one, D3            ; shift D3 by 1 bit
000024C6  C67C 0007               2397              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
000024CA                          2398  
000024CA  4EB9 00002F1E           2399              JSR         printEA             ; jump to printEA
000024D0                          2400          
000024D0  43F9 000041E7           2401              LEA         newLine, A1         ; create new line
000024D6  103C 000E               2402              MOVE.B      #14, D0             ; command for trap call to display message
000024DA  4E4F                    2403              TRAP        #15                 ; trap call
000024DC                          2404          
000024DC  6000 EB68               2405              BRA         LOOP                ; branch back to LOOP
000024E0                          2406          
000024E0                          2407  ***********************************************************************************************************
000024E0                          2408  *
000024E0                          2409  *                       Shifting OPCODES
000024E0                          2410  *
000024E0                          2411  ***********************************************************************************************************
000024E0                          2412  
000024E0                          2413  opASL       
000024E0  43F9 00004272           2414              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
000024E6  103C 000E               2415              MOVE.B      #14, D0             ; command for trap call to display message
000024EA  4E4F                    2416              TRAP        #15                 ; trap call
000024EC                          2417          
000024EC  43F9 00004288           2418              LEA         dispWord, A1        ; display word
000024F2  103C 000E               2419              MOVE.B      #14, D0             ; command for trap call to display message
000024F6  4E4F                    2420              TRAP        #15                 ; trap call
000024F8                          2421          
000024F8  43F9 000041EB           2422              LEA         space, A1           ; display space 
000024FE  103C 000E               2423              MOVE.B      #14, D0             ; command for trap call to display message
00002502  4E4F                    2424              TRAP        #15                 ; trap call
00002504                          2425          
00002504  4242                    2426              CLR         D2                  ; clear D2
00002506  4243                    2427              CLR         D3                  ; clear D3
00002508  1401                    2428              MOVE.B      D1,D2               ; move byte from D1 to D2
0000250A  1601                    2429              MOVE.B      D1,D3               ; move byte from D1 to D3
0000250C                          2430          
0000250C  E602                    2431              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
0000250E  C47C 0007               2432              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
00002512  C67C 0007               2433              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
00002516                          2434          
00002516  4EB9 00002F1E           2435              JSR         printEA             ; jump to printEA
0000251C                          2436          
0000251C  43F9 000041E7           2437              LEA         newLine, A1         ; Display newLine
00002522  103C 000E               2438              MOVE.B      #14, D0             ; command for trap call to display message
00002526  4E4F                    2439              TRAP        #15                 ; trap call
00002528                          2440          
00002528  6000 EB1C               2441              BRA         LOOP                ; branch back to LOOP
0000252C                          2442  
0000252C                          2443  opASR   
0000252C  43F9 0000426E           2444              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002532  103C 000E               2445              MOVE.B      #14, D0             ; command for trap call to display message
00002536  4E4F                    2446              TRAP        #15                 ; trap call
00002538                          2447          
00002538  43F9 00004288           2448              LEA         dispWord, A1        ; display word
0000253E  103C 000E               2449              MOVE.B      #14, D0             ; command for trap call to display message
00002542  4E4F                    2450              TRAP        #15                 ; trap call
00002544                          2451          
00002544  43F9 000041EB           2452              LEA         space, A1           ; display space 
0000254A  103C 000E               2453              MOVE.B      #14, D0             ; command for trap call to display message
0000254E  4E4F                    2454              TRAP        #15                 ; trap call
00002550                          2455          
00002550  4242                    2456              CLR         D2                  ; clear D2
00002552  4243                    2457              CLR         D3                  ; clear D3
00002554  1401                    2458              MOVE.B      D1,D2               ; move byte from D1 to D2
00002556  1601                    2459              MOVE.B      D1,D3               ; move byte from D1 to D3
00002558                          2460          
00002558  E602                    2461              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
0000255A  C47C 0007               2462              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
0000255E  C67C 0007               2463              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
00002562                          2464          
00002562  4EB9 00002F1E           2465              JSR         printEA             ; jump to printEA
00002568                          2466          
00002568  43F9 000041E7           2467              LEA         newLine, A1         ; Display newLine
0000256E  103C 000E               2468              MOVE.B      #14, D0             ; command for trap call to display message
00002572  4E4F                    2469              TRAP        #15                 ; trap call
00002574                          2470          
00002574  6000 EAD0               2471              BRA         LOOP                ; branch back to LOOP
00002578                          2472  
00002578                          2473  opLSL       
00002578  43F9 0000426A           2474              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
0000257E  103C 000E               2475              MOVE.B      #14, D0             ; command for trap call to display message
00002582  4E4F                    2476              TRAP        #15                 ; trap call
00002584                          2477              
00002584  43F9 00004288           2478              LEA         dispWord, A1        ; display word
0000258A  103C 000E               2479              MOVE.B      #14, D0             ; command for trap call to display message
0000258E  4E4F                    2480              TRAP        #15                 ; trap call
00002590                          2481          
00002590  43F9 000041EB           2482              LEA         space, A1           ; display space 
00002596  103C 000E               2483              MOVE.B      #14, D0             ; command for trap call to display message
0000259A  4E4F                    2484              TRAP        #15                 ; trap call
0000259C                          2485          
0000259C  4242                    2486              CLR         D2                  ; clear D2
0000259E  4243                    2487              CLR         D3                  ; clear D3
000025A0  1401                    2488              MOVE.B      D1,D2               ; move byte from D1 to D2
000025A2  1601                    2489              MOVE.B      D1,D3               ; move byte from D1 to D3
000025A4                          2490          
000025A4  E602                    2491              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
000025A6  C47C 0007               2492              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
000025AA  C67C 0007               2493              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
000025AE                          2494          
000025AE  4EB9 00002F1E           2495              JSR         printEA             ; jump to printEA
000025B4                          2496          
000025B4  43F9 000041E7           2497              LEA         newLine, A1         ; Display newLine
000025BA  103C 000E               2498              MOVE.B      #14, D0             ; command for trap call to display message
000025BE  4E4F                    2499              TRAP        #15                 ; trap call
000025C0                          2500          
000025C0  6000 EA84               2501              BRA         LOOP                ; branch back to LOOP
000025C4                          2502  
000025C4                          2503  opLSR   
000025C4  43F9 00004266           2504              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
000025CA  103C 000E               2505              MOVE.B      #14, D0             ; command for trap call to display message
000025CE  4E4F                    2506              TRAP        #15                 ; trap call
000025D0                          2507          
000025D0  43F9 00004288           2508              LEA         dispWord, A1        ; display word
000025D6  103C 000E               2509              MOVE.B      #14, D0             ; command for trap call to display message
000025DA  4E4F                    2510              TRAP        #15                 ; trap call
000025DC                          2511          
000025DC  43F9 000041EB           2512              LEA         space, A1           ; display space 
000025E2  103C 000E               2513              MOVE.B      #14, D0             ; command for trap call to display message
000025E6  4E4F                    2514              TRAP        #15                 ; trap call
000025E8                          2515          
000025E8  4242                    2516              CLR         D2                  ; clear D2
000025EA  4243                    2517              CLR         D3                  ; clear D3
000025EC  1401                    2518              MOVE.B      D1,D2               ; move byte from D1 to D2
000025EE  1601                    2519              MOVE.B      D1,D3               ; move byte from D1 to D3
000025F0                          2520          
000025F0  E602                    2521              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
000025F2  C47C 0007               2522              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
000025F6  C67C 0007               2523              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
000025FA                          2524          
000025FA  4EB9 00002F1E           2525              JSR         printEA             ; jump to printEA
00002600                          2526          
00002600  43F9 000041E7           2527              LEA         newLine, A1         ; Display newLine
00002606  103C 000E               2528              MOVE.B      #14, D0             ; command for trap call to display message
0000260A  4E4F                    2529              TRAP        #15                 ; trap call
0000260C                          2530          
0000260C  6000 EA38               2531              BRA         LOOP                ; branch back to LOOP
00002610                          2532  
00002610                          2533  opROL   
00002610  43F9 0000427A           2534              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002616  103C 000E               2535              MOVE.B      #14, D0             ; command for trap call to display message
0000261A  4E4F                    2536              TRAP        #15                 ; trap call
0000261C                          2537          
0000261C  43F9 00004288           2538              LEA         dispWord, A1        ; display word
00002622  103C 000E               2539              MOVE.B      #14, D0             ; command for trap call to display message
00002626  4E4F                    2540              TRAP        #15                 ; trap call
00002628                          2541          
00002628  43F9 000041EB           2542              LEA         space, A1           ; display space 
0000262E  103C 000E               2543              MOVE.B      #14, D0             ; command for trap call to display message
00002632  4E4F                    2544              TRAP        #15                 ; trap call
00002634                          2545          
00002634  4242                    2546              CLR         D2                  ; clear D2
00002636  4243                    2547              CLR         D3                  ; clear D3
00002638  1401                    2548              MOVE.B      D1,D2               ; move byte from D1 to D2
0000263A  1601                    2549              MOVE.B      D1,D3               ; move byte from D1 to D3
0000263C                          2550          
0000263C  E602                    2551              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
0000263E  C47C 0007               2552              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
00002642  C67C 0007               2553              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
00002646                          2554          
00002646  4EB9 00002F1E           2555              JSR         printEA             ; jump to printEA
0000264C                          2556          
0000264C  43F9 000041E7           2557              LEA         newLine, A1         ; Display newLine
00002652  103C 000E               2558              MOVE.B      #14, D0             ; command for trap call to display message
00002656  4E4F                    2559              TRAP        #15                 ; trap call
00002658                          2560          
00002658  6000 E9EC               2561              BRA         LOOP                ; branch back to LOOP
0000265C                          2562  
0000265C                          2563  opROR   
0000265C  43F9 00004276           2564              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002662  103C 000E               2565              MOVE.B      #14, D0             ; command for trap call to display message
00002666  4E4F                    2566              TRAP        #15                 ; trap call
00002668                          2567          
00002668  43F9 00004288           2568              LEA         dispWord, A1        ; display word
0000266E  103C 000E               2569              MOVE.B      #14, D0             ; command for trap call to display message
00002672  4E4F                    2570              TRAP        #15                 ; trap call
00002674                          2571          
00002674  43F9 000041EB           2572              LEA         space, A1           ; display space 
0000267A  103C 000E               2573              MOVE.B      #14, D0             ; command for trap call to display message
0000267E  4E4F                    2574              TRAP        #15                 ; trap call
00002680                          2575          
00002680  4242                    2576              CLR         D2                  ; clear D2
00002682  4243                    2577              CLR         D3                  ; clear D3
00002684  1401                    2578              MOVE.B      D1,D2               ; move byte from D1 to D2
00002686  1601                    2579              MOVE.B      D1,D3               ; move byte from D1 to D3
00002688                          2580          
00002688  E602                    2581              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
0000268A  C47C 0007               2582              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
0000268E  C67C 0007               2583              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
00002692                          2584          
00002692  4EB9 00002F1E           2585              JSR         printEA             ; jump to printEA
00002698                          2586          
00002698  43F9 000041E7           2587              LEA         newLine, A1         ; Display newLine
0000269E  103C 000E               2588              MOVE.B      #14, D0             ; command for trap call to display message
000026A2  4E4F                    2589              TRAP        #15                 ; trap call
000026A4                          2590          
000026A4  6000 E9A0               2591              BRA         LOOP                ; branch back to LOOP
000026A8                          2592          
000026A8                          2593  memSB       
000026A8  4242                    2594              CLR         D2                  ; clear D2
000026AA  1401                    2595              MOVE.B      D1,D2               ; move D1 to D2
000026AC  E642                    2596              ASR         #three, D2          ; shift D2 by 3 bits to get i/r
000026AE                          2597              
000026AE  C47C 0007               2598              AND         #$07, D2            ; and D2 by 3 bits 
000026B2                          2599          
000026B2  B43C 0000               2600              CMP.B       #zero, D2           ; compare 0 to D2
000026B6  6700 002E               2601              BEQ         opASBI              ; if true, branch to ASBI for immediate
000026BA  B43C 0004               2602              CMP.B       #four, D2           ; compare 4 to D2 
000026BE  6700 0088               2603              BEQ         opASBR              ; if true, branch to ASBR for register
000026C2  B43C 0001               2604              CMP.B       #one, D2            ; compare 1 to D2
000026C6  6700 00E2               2605              BEQ         opLSBI              ; if true, branch to LSBI for immediate
000026CA  B43C 0005               2606              CMP.B       #five, D2           ; compare 5 to D2
000026CE  6700 013C               2607              BEQ         opLSBR              ; if true, branch to LSBR for register
000026D2  B43C 0003               2608              CMP.B       #three, D2          ; compare 3 to D2
000026D6  6700 0196               2609              BEQ         opROBI              ; if true, branch to ROBI for immediate
000026DA  B43C 0007               2610              CMP.B       #seven, D2          ; compare 7 to D2
000026DE  6700 01F0               2611              BEQ         opROBR              ; if true, branch to ROBR for register
000026E2  6000 15A8               2612              BRA         printInvalid        ; otherwise invalid
000026E6                          2613          
000026E6                          2614  opASBI  
000026E6  4242                    2615              CLR         D2                  ; clear D2
000026E8  3401                    2616              MOVE.W      D1, D2              ; move word from D1 to D2
000026EA  E042                    2617              ASR         #eight, D2          ; shift D2 over by 8 bits 
000026EC  C47C 0001               2618              AND         #$01, D2            ; and D2 by 1 bit to get direction
000026F0                          2619      
000026F0  B43C 0000               2620              CMP.B       #zero, D2           ; compare 0 to D2
000026F4  6700 000E               2621              BEQ         opASRBI             ; if true, branch to ASRBI for right
000026F8  B43C 0001               2622              CMP.B       #one, D2            ; compare 1 to D2
000026FC  6700 0028               2623              BEQ         opASLBI             ; if true, branch to ASLBI for left
00002700  6000 158A               2624              BRA         printInvalid        ; otherwise invalid
00002704                          2625          
00002704                          2626  opASRBI 
00002704  43F9 0000426E           2627              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
0000270A  103C 000E               2628              MOVE.B      #14, D0             ; command for trap call to display message
0000270E  4E4F                    2629              TRAP        #15                 ; trap call
00002710                          2630  
00002710  43F9 00004285           2631              LEA         dispByte, A1        ; display byte
00002716  103C 000E               2632              MOVE.B      #14, D0             ; command for trap call to display message
0000271A  4E4F                    2633              TRAP        #15                 ; trap call
0000271C                          2634          
0000271C  4EB9 00002E46           2635              JSR         PrntImm             ; jump to PrntImm
00002722                          2636          
00002722  6000 E922               2637              BRA         LOOP                ; branch back to LOOP
00002726                          2638  
00002726                          2639  opASLBI 
00002726  43F9 00004272           2640              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
0000272C  103C 000E               2641              MOVE.B      #14, D0             ; command for trap call to display message
00002730  4E4F                    2642              TRAP        #15                 ; trap call
00002732                          2643  
00002732  43F9 00004285           2644              LEA         dispByte, A1        ; display byte
00002738  103C 000E               2645              MOVE.B      #14, D0             ; command for trap call to display message
0000273C  4E4F                    2646              TRAP        #15                 ; trap call
0000273E                          2647          
0000273E  4EB9 00002E46           2648              JSR         PrntImm             ; jump to PrntImm
00002744                          2649          
00002744  6000 E900               2650              BRA         LOOP                ; branch back to LOOP
00002748                          2651  
00002748                          2652  opASBR  
00002748  4242                    2653              CLR         D2                  ; clear D2
0000274A  3401                    2654              MOVE.W      D1, D2              ; move word from D1 to D2
0000274C  E042                    2655              ASR         #eight, D2          ; shift D2 over by 8 bits 
0000274E  C47C 0001               2656              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002752                          2657      
00002752  B43C 0000               2658              CMP.B       #zero, D2           ; compare 0 to D2 
00002756  6700 000E               2659              BEQ         opASRBR             ; if true, branch to ASRBR for right
0000275A  B43C 0001               2660              CMP.B       #one, D2            ; compare 1 to D2
0000275E  6700 0028               2661              BEQ         opASLBR             ; if true, branch to ASLBR for left
00002762  6000 1528               2662              BRA         printInvalid        ; otherwise invalid
00002766                          2663          
00002766                          2664  opASRBR 
00002766  43F9 0000426E           2665              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
0000276C  103C 000E               2666              MOVE.B      #14, D0             ; command for trap call to display message
00002770  4E4F                    2667              TRAP        #15                 ; trap call
00002772                          2668  
00002772  43F9 00004285           2669              LEA         dispByte, A1        ; display byte
00002778  103C 000E               2670              MOVE.B      #14, D0             ; command for trap call to display message
0000277C  4E4F                    2671              TRAP        #15                 ; trap call
0000277E                          2672          
0000277E  4EB9 00002EA2           2673              JSR         PrntReg             ; jump to PrntReg
00002784                          2674          
00002784  6000 E8C0               2675              BRA         LOOP                ; branch back to LOOP
00002788                          2676  
00002788                          2677  opASLBR 
00002788  43F9 00004272           2678              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
0000278E  103C 000E               2679              MOVE.B      #14, D0             ; command for trap call to display message
00002792  4E4F                    2680              TRAP        #15                 ; trap call
00002794                          2681  
00002794  43F9 00004285           2682              LEA         dispByte, A1        ; display byte
0000279A  103C 000E               2683              MOVE.B      #14, D0             ; command for trap call to display message
0000279E  4E4F                    2684              TRAP        #15                 ; trap call
000027A0                          2685          
000027A0  4EB9 00002EA2           2686              JSR         PrntReg             ; jump to PrntReg
000027A6                          2687          
000027A6  6000 E89E               2688              BRA         LOOP                ; branch back to LOOP
000027AA                          2689  
000027AA                          2690  opLSBI      
000027AA  4242                    2691              CLR         D2                  ; clear D2
000027AC  3401                    2692              MOVE.W      D1, D2              ; move word from D1 to D2
000027AE  E042                    2693              ASR         #eight, D2          ; shift D2 over by 8 bits 
000027B0  C47C 0001               2694              AND         #$01, D2            ; and D2 by 1 bit to get direction
000027B4                          2695      
000027B4  B43C 0000               2696              CMP.B       #zero, D2           ; compare 0 to D2 
000027B8  6700 000E               2697              BEQ         opLSRBI             ; if true, branch to LSRBI for right
000027BC  B43C 0001               2698              CMP.B       #one, D2            ; compare 1 to D2
000027C0  6700 0028               2699              BEQ         opLSLBI             ; if true, branch to LSLBI for left
000027C4  6000 14C6               2700              BRA         printInvalid        ; otherwise invalid
000027C8                          2701          
000027C8                          2702  opLSRBI 
000027C8  43F9 00004266           2703              LEA         LSRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000027CE  103C 000E               2704              MOVE.B      #14, D0             ; command for trap call to display message
000027D2  4E4F                    2705              TRAP        #15                 ; trap call
000027D4                          2706  
000027D4  43F9 00004285           2707              LEA         dispByte, A1        ; display byte
000027DA  103C 000E               2708              MOVE.B      #14, D0             ; command for trap call to display message
000027DE  4E4F                    2709              TRAP        #15                 ; trap call
000027E0                          2710          
000027E0  4EB9 00002E46           2711              JSR         PrntImm             ; jump to PrntImm
000027E6                          2712          
000027E6  6000 E85E               2713              BRA         LOOP                ; branch back to LOOP
000027EA                          2714              
000027EA                          2715  opLSLBI     
000027EA  43F9 0000426A           2716              LEA         LSLmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000027F0  103C 000E               2717              MOVE.B      #14, D0             ; command for trap call to display message
000027F4  4E4F                    2718              TRAP        #15                 ; trap call
000027F6                          2719  
000027F6  43F9 00004285           2720              LEA         dispByte, A1        ; display byte
000027FC  103C 000E               2721              MOVE.B      #14, D0             ; command for trap call to display message
00002800  4E4F                    2722              TRAP        #15                 ; trap call
00002802                          2723          
00002802  4EB9 00002E46           2724              JSR         PrntImm             ; jump to PrntImm
00002808                          2725          
00002808  6000 E83C               2726              BRA         LOOP                ; branch back to LOOP
0000280C                          2727  
0000280C                          2728  opLSBR  
0000280C  4242                    2729              CLR         D2                  ; clear D2
0000280E  3401                    2730              MOVE.W      D1, D2              ; move word from D1 to D2
00002810  E042                    2731              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002812  C47C 0001               2732              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002816                          2733      
00002816  B43C 0000               2734              CMP.B       #zero, D2           ; compare 0 to D2 
0000281A  6700 000E               2735              BEQ         opLSRBR             ; if true, branch to LSRBR for right
0000281E  B43C 0001               2736              CMP.B       #one, D2            ; compare 1 to D2
00002822  6700 0028               2737              BEQ         opLSLBR             ; if true, branch to LSLBR for left
00002826  6000 1464               2738              BRA         printInvalid        ; otherwise invalid
0000282A                          2739          
0000282A                          2740  opLSRBR 
0000282A  43F9 00004266           2741              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002830  103C 000E               2742              MOVE.B      #14, D0             ; command for trap call to display message
00002834  4E4F                    2743              TRAP        #15                 ; trap call
00002836                          2744  
00002836  43F9 00004285           2745              LEA         dispByte, A1        ; display byte
0000283C  103C 000E               2746              MOVE.B      #14, D0             ; command for trap call to display message
00002840  4E4F                    2747              TRAP        #15                 ; trap call
00002842                          2748          
00002842  4EB9 00002EA2           2749              JSR         PrntReg             ; jump to PrntReg
00002848                          2750          
00002848  6000 E7FC               2751              BRA         LOOP                ; branch back to LOOP
0000284C                          2752          
0000284C                          2753  opLSLBR     
0000284C  43F9 0000426A           2754              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002852  103C 000E               2755              MOVE.B      #14, D0             ; command for trap call to display message
00002856  4E4F                    2756              TRAP        #15                 ; trap call
00002858                          2757  
00002858  43F9 00004285           2758              LEA         dispByte, A1        ; display byte
0000285E  103C 000E               2759              MOVE.B      #14, D0             ; command for trap call to display message
00002862  4E4F                    2760              TRAP        #15                 ; trap call
00002864                          2761          
00002864  4EB9 00002EA2           2762              JSR         PrntReg             ; jump to PrntReg
0000286A                          2763          
0000286A  6000 E7DA               2764              BRA         LOOP                ; branch back to LOOP
0000286E                          2765              
0000286E                          2766  opROBI  
0000286E  4242                    2767              CLR         D2                  ; clear D2
00002870  3401                    2768              MOVE.W      D1, D2              ; move word from D1 to D2
00002872  E042                    2769              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002874  C47C 0001               2770              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002878                          2771      
00002878  B43C 0000               2772              CMP.B       #zero, D2           ; compare 0 to D2
0000287C  6700 000E               2773              BEQ         opRORBI             ; if true, branch to RORBI for right
00002880  B43C 0001               2774              CMP.B       #one, D2            ; compare 1 to D2
00002884  6700 0028               2775              BEQ         opROLBI             ; if true, branch to ROLBI for left
00002888  6000 1402               2776              BRA         printInvalid        ; otherwise invalid
0000288C                          2777          
0000288C                          2778  opRORBI 
0000288C  43F9 00004276           2779              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002892  103C 000E               2780              MOVE.B      #14, D0             ; command for trap call to display message
00002896  4E4F                    2781              TRAP        #15                 ; trap call
00002898                          2782  
00002898  43F9 00004285           2783              LEA         dispByte, A1        ; display byte
0000289E  103C 000E               2784              MOVE.B      #14, D0             ; command for trap call to display message
000028A2  4E4F                    2785              TRAP        #15                 ; trap call
000028A4                          2786          
000028A4  4EB9 00002E46           2787              JSR         PrntImm             ; jump to PrntImm
000028AA                          2788          
000028AA  6000 E79A               2789              BRA         LOOP                ; branch back to LOOP
000028AE                          2790  
000028AE                          2791  opROLBI 
000028AE  43F9 0000427A           2792              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
000028B4  103C 000E               2793              MOVE.B      #14, D0             ; command for trap call to display message
000028B8  4E4F                    2794              TRAP        #15                 ; trap call
000028BA                          2795  
000028BA  43F9 00004285           2796              LEA         dispByte, A1        ; display byte
000028C0  103C 000E               2797              MOVE.B      #14, D0             ; command for trap call to display message
000028C4  4E4F                    2798              TRAP        #15                 ; trap call
000028C6                          2799          
000028C6  4EB9 00002E46           2800              JSR         PrntImm             ; jump to PrntImm
000028CC                          2801          
000028CC  6000 E778               2802              BRA         LOOP                ; branch back to LOOP
000028D0                          2803  
000028D0                          2804  opROBR  
000028D0  4242                    2805              CLR         D2                  ; clear D2
000028D2  3401                    2806              MOVE.W      D1, D2              ; move word from D1 to D2
000028D4  E042                    2807              ASR         #eight, D2          ; shift D2 over by 8 bits 
000028D6  C47C 0001               2808              AND         #$01, D2            ; and D2 by 1 bit to get direction
000028DA                          2809      
000028DA  B43C 0000               2810              CMP.B       #zero, D2           ; compare 0 to D2 
000028DE  6700 000E               2811              BEQ         opRORBR             ; if true, branch to RORBR for right
000028E2  B43C 0001               2812              CMP.B       #one, D2            ; compare 1 to D2
000028E6  6700 0028               2813              BEQ         opROLBR             ; if true, branch to ROLBR for left
000028EA  6000 13A0               2814              BRA         printInvalid        ; otherwise invalid    
000028EE                          2815          
000028EE                          2816  opRORBR 
000028EE  43F9 00004276           2817              LEA         RORmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000028F4  103C 000E               2818              MOVE.B      #14, D0             ; command for trap call to display message
000028F8  4E4F                    2819              TRAP        #15                 ; trap call
000028FA                          2820  
000028FA  43F9 00004285           2821              LEA         dispByte, A1        ; display byte
00002900  103C 000E               2822              MOVE.B      #14, D0             ; command for trap call to display message
00002904  4E4F                    2823              TRAP        #15                 ; trap call
00002906                          2824          
00002906  4EB9 00002EA2           2825              JSR         PrntReg             ; jump to PrntReg
0000290C                          2826          
0000290C  6000 E738               2827              BRA         LOOP                ; branch back to LOOP
00002910                          2828  
00002910                          2829  opROLBR 
00002910  43F9 0000427A           2830              LEA         ROLmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002916  103C 000E               2831              MOVE.B      #14, D0             ; command for trap call to display message
0000291A  4E4F                    2832              TRAP        #15                 ; trap call
0000291C                          2833  
0000291C  43F9 00004285           2834              LEA         dispByte, A1        ; display byte
00002922  103C 000E               2835              MOVE.B      #14, D0             ; command for trap call to display message
00002926  4E4F                    2836              TRAP        #15                 ; trap call
00002928                          2837          
00002928  4EB9 00002EA2           2838              JSR         PrntReg             ; jump to PrntReg
0000292E                          2839          
0000292E  6000 E716               2840              BRA         LOOP                ; branch back to LOOP       
00002932                          2841  
00002932                          2842  memSW   
00002932  4242                    2843              CLR         D2                  ; clear D2
00002934  1401                    2844              MOVE.B      D1,D2               ; move D1 to D2
00002936  E642                    2845              ASR         #three, D2          ; shift D2 by 3 bits to get i/r
00002938                          2846              
00002938  C47C 0007               2847              AND         #$07, D2            ; and D2 by 3 bits 
0000293C                          2848          
0000293C  B43C 0000               2849              CMP.B       #zero, D2           ; compare 0 to D2
00002940  6700 002E               2850              BEQ         opASWI              ; if true, branch to ASWI for immediate
00002944  B43C 0004               2851              CMP.B       #four, D2           ; compare 4 to D2 
00002948  6700 0088               2852              BEQ         opASWR              ; if true, branch to ASWR for register
0000294C  B43C 0001               2853              CMP.B       #one, D2            ; compare 1 to D2
00002950  6700 00E2               2854              BEQ         opLSWI              ; if true, branch to LSWI for immediate
00002954  B43C 0005               2855              CMP.B       #five, D2           ; compare 5 to D2
00002958  6700 013C               2856              BEQ         opLSWR              ; if true, branch to LSWR for register
0000295C  B43C 0003               2857              CMP.B       #three, D2          ; compare 3 to D2
00002960  6700 0196               2858              BEQ         opROWI              ; if true, branch to ROWI for immediate
00002964  B43C 0007               2859              CMP.B       #seven, D2          ; compare 7 to D2
00002968  6700 01F0               2860              BEQ         opROWR              ; if true, branch to ROWR for register
0000296C  6000 131E               2861              BRA         printInvalid        ; otherwise invalid
00002970                          2862          
00002970                          2863  opASWI  
00002970  4242                    2864              CLR         D2                  ; clear D2
00002972  3401                    2865              MOVE.W      D1, D2              ; move word from D1 to D2
00002974  E042                    2866              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002976  C47C 0001               2867              AND         #$01, D2            ; and D2 by 1 bit to get direction
0000297A                          2868      
0000297A  B43C 0000               2869              CMP.B       #zero, D2           ; compare 0 to D2
0000297E  6700 000E               2870              BEQ         opASRWI             ; if true, branch to ASRWI for right
00002982  B43C 0001               2871              CMP.B       #one, D2            ; compare 1 to D2
00002986  6700 0028               2872              BEQ         opASLWI             ; if true, branch to ASLWI for left
0000298A  6000 1300               2873              BRA         printInvalid        ; otherwise invalid
0000298E                          2874          
0000298E                          2875  opASRWI 
0000298E  43F9 0000426E           2876              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002994  103C 000E               2877              MOVE.B      #14, D0             ; command for trap call to display message
00002998  4E4F                    2878              TRAP        #15                 ; trap call
0000299A                          2879  
0000299A  43F9 00004288           2880              LEA         dispWord, A1        ; display word
000029A0  103C 000E               2881              MOVE.B      #14, D0             ; command for trap call to display message
000029A4  4E4F                    2882              TRAP        #15                 ; trap call
000029A6                          2883          
000029A6  4EB9 00002E46           2884              JSR         PrntImm             ; jump to PrntImm
000029AC                          2885          
000029AC  6000 E698               2886              BRA         LOOP                ; branch back to LOOP
000029B0                          2887  
000029B0                          2888  opASLWI 
000029B0  43F9 00004272           2889              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
000029B6  103C 000E               2890              MOVE.B      #14, D0             ; command for trap call to display message
000029BA  4E4F                    2891              TRAP        #15                 ; trap call
000029BC                          2892  
000029BC  43F9 00004288           2893              LEA         dispWord, A1        ; display word
000029C2  103C 000E               2894              MOVE.B      #14, D0             ; command for trap call to display message
000029C6  4E4F                    2895              TRAP        #15                 ; trap call
000029C8                          2896          
000029C8  4EB9 00002E46           2897              JSR         PrntImm             ; jump to PrntImm
000029CE                          2898          
000029CE  6000 E676               2899              BRA         LOOP                ; branch back to LOOP
000029D2                          2900  
000029D2                          2901  opASWR  
000029D2  4242                    2902              CLR         D2                  ; clear D2
000029D4  3401                    2903              MOVE.W      D1, D2              ; move word from D1 to D2
000029D6  E042                    2904              ASR         #eight, D2          ; shift D2 over by 8 bits 
000029D8  C47C 0001               2905              AND         #$01, D2            ; and D2 by 1 bit to get direction
000029DC                          2906      
000029DC  B43C 0000               2907              CMP.B       #zero, D2           ; compare 0 to D2 
000029E0  6700 000E               2908              BEQ         opASRWR             ; if true, branch to ASRWR for right
000029E4  B43C 0001               2909              CMP.B       #one, D2            ; compare 1 to D2
000029E8  6700 0028               2910              BEQ         opASLWR             ; if true, branch to ASLWR for left
000029EC  6000 129E               2911              BRA         printInvalid        ; otherwise invalid
000029F0                          2912          
000029F0                          2913  opASRWR     
000029F0  43F9 0000426E           2914              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000029F6  103C 000E               2915              MOVE.B      #14, D0             ; command for trap call to display message
000029FA  4E4F                    2916              TRAP        #15                 ; trap call
000029FC                          2917  
000029FC  43F9 00004288           2918              LEA         dispWord, A1        ; display word
00002A02  103C 000E               2919              MOVE.B      #14, D0             ; command for trap call to display message
00002A06  4E4F                    2920              TRAP        #15                 ; trap call
00002A08                          2921          
00002A08  4EB9 00002EA2           2922              JSR         PrntReg             ; jump to PrntReg
00002A0E                          2923          
00002A0E  6000 E636               2924              BRA         LOOP                ; branch back to LOOP
00002A12                          2925  
00002A12                          2926  opASLWR     
00002A12  43F9 00004272           2927              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
00002A18  103C 000E               2928              MOVE.B      #14, D0             ; command for trap call to display message
00002A1C  4E4F                    2929              TRAP        #15                 ; trap call
00002A1E                          2930  
00002A1E  43F9 00004288           2931              LEA         dispWord, A1        ; display word
00002A24  103C 000E               2932              MOVE.B      #14, D0             ; command for trap call to display message
00002A28  4E4F                    2933              TRAP        #15                 ; trap call
00002A2A                          2934          
00002A2A  4EB9 00002EA2           2935              JSR         PrntReg             ; jump to PrntReg
00002A30                          2936          
00002A30  6000 E614               2937              BRA         LOOP                ; branch back to LOOP
00002A34                          2938  
00002A34                          2939  opLSWI      
00002A34  4242                    2940              CLR         D2                  ; clear D2
00002A36  3401                    2941              MOVE.W      D1, D2              ; move word from D1 to D2
00002A38  E042                    2942              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002A3A  C47C 0001               2943              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002A3E                          2944      
00002A3E  B43C 0000               2945              CMP.B       #zero, D2           ; compare 0 to D2 
00002A42  6700 000E               2946              BEQ         opLSRWI             ; if true, branch to LSRWI for right
00002A46  B43C 0001               2947              CMP.B       #one, D2            ; compare 1 to D2
00002A4A  6700 0028               2948              BEQ         opLSLWI             ; if true, branch to LSLWI for left
00002A4E  6000 123C               2949              BRA         printInvalid        ; otherwise invalid 
00002A52                          2950          
00002A52                          2951  opLSRWI 
00002A52  43F9 00004266           2952              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002A58  103C 000E               2953              MOVE.B      #14, D0             ; command for trap call to display message
00002A5C  4E4F                    2954              TRAP        #15                 ; trap call
00002A5E                          2955      
00002A5E  43F9 00004288           2956              LEA         dispWord, A1        ; display word
00002A64  103C 000E               2957              MOVE.B      #14, D0             ; command for trap call to display message
00002A68  4E4F                    2958              TRAP        #15                 ; trap call
00002A6A                          2959          
00002A6A  4EB9 00002E46           2960              JSR         PrntImm             ; jump to PrntImm
00002A70                          2961          
00002A70  6000 E5D4               2962              BRA         LOOP                ; branch back to LOOP
00002A74                          2963              
00002A74                          2964  opLSLWI 
00002A74  43F9 0000426A           2965              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002A7A  103C 000E               2966              MOVE.B      #14, D0             ; command for trap call to display message
00002A7E  4E4F                    2967              TRAP        #15                 ; trap call
00002A80                          2968  
00002A80  43F9 00004288           2969              LEA         dispWord, A1        ; display word
00002A86  103C 000E               2970              MOVE.B      #14, D0             ; command for trap call to display message
00002A8A  4E4F                    2971              TRAP        #15                 ; trap call
00002A8C                          2972          
00002A8C  4EB9 00002E46           2973              JSR         PrntImm             ; jump to PrntImm
00002A92                          2974          
00002A92  6000 E5B2               2975              BRA         LOOP                ; branch back to LOOP
00002A96                          2976              
00002A96                          2977  opLSWR  
00002A96  4242                    2978              CLR         D2                  ; clear D2
00002A98  3401                    2979              MOVE.W      D1, D2              ; move word from D1 to D2
00002A9A  E042                    2980              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002A9C  C47C 0001               2981              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002AA0                          2982      
00002AA0  B43C 0000               2983              CMP.B       #zero, D2           ; compare 0 to D2 
00002AA4  6700 000E               2984              BEQ         opLSRWR             ; if true, branch to LSRWR for right
00002AA8  B43C 0001               2985              CMP.B       #one, D2            ; compare 1 to D2
00002AAC  6700 0028               2986              BEQ         opLSLWR             ; if true, branch to LSLWR for left
00002AB0  6000 11DA               2987              BRA         printInvalid        ; otherwise invalid
00002AB4                          2988          
00002AB4                          2989  opLSRWR 
00002AB4  43F9 00004266           2990              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002ABA  103C 000E               2991              MOVE.B      #14, D0             ; command for trap call to display message
00002ABE  4E4F                    2992              TRAP        #15                 ; trap call
00002AC0                          2993  
00002AC0  43F9 00004288           2994              LEA         dispWord, A1        ; display word
00002AC6  103C 000E               2995              MOVE.B      #14, D0             ; command for trap call to display message
00002ACA  4E4F                    2996              TRAP        #15                 ; trap call
00002ACC                          2997          
00002ACC  4EB9 00002EA2           2998              JSR         PrntReg             ; jump to PrntReg
00002AD2                          2999          
00002AD2  6000 E572               3000              BRA         LOOP                ; branch back to LOOP
00002AD6                          3001          
00002AD6                          3002  opLSLWR 
00002AD6  43F9 0000426A           3003              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002ADC  103C 000E               3004              MOVE.B      #14, D0             ; command for trap call to display message
00002AE0  4E4F                    3005              TRAP        #15                 ; trap call
00002AE2                          3006  
00002AE2  43F9 00004288           3007              LEA         dispWord, A1        ; display word
00002AE8  103C 000E               3008              MOVE.B      #14, D0             ; command for trap call to display message
00002AEC  4E4F                    3009              TRAP        #15                 ; trap call
00002AEE                          3010          
00002AEE  4EB9 00002EA2           3011              JSR         PrntReg             ; jump to PrntReg
00002AF4                          3012          
00002AF4  6000 E550               3013              BRA         LOOP                ; branch back to LOOP
00002AF8                          3014  
00002AF8                          3015  opROWI  
00002AF8  4242                    3016              CLR         D2                  ; clear D2
00002AFA  3401                    3017              MOVE.W      D1, D2              ; move word from D1 to D2
00002AFC  E042                    3018              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002AFE  C47C 0001               3019              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002B02                          3020      
00002B02  B43C 0000               3021              CMP.B       #zero, D2           ; compare 0 to D2
00002B06  6700 000E               3022              BEQ         opRORWI             ; if true, branch to RORWI for right
00002B0A  B43C 0001               3023              CMP.B       #one, D2            ; compare 1 to D2
00002B0E  6700 0028               3024              BEQ         opROLWI             ; if true, branch to ROLWI for left
00002B12  6000 1178               3025              BRA         printInvalid        ; otherwise invalid
00002B16                          3026          
00002B16                          3027  opRORWI 
00002B16  43F9 00004276           3028              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002B1C  103C 000E               3029              MOVE.B      #14, D0             ; command for trap call to display message
00002B20  4E4F                    3030              TRAP        #15                 ; trap call
00002B22                          3031  
00002B22  43F9 00004288           3032              LEA         dispWord, A1        ; display word
00002B28  103C 000E               3033              MOVE.B      #14, D0             ; command for trap call to display message
00002B2C  4E4F                    3034              TRAP        #15                 ; trap call
00002B2E                          3035          
00002B2E  4EB9 00002E46           3036              JSR         PrntImm             ; jump to PrntImm
00002B34                          3037          
00002B34  6000 E510               3038              BRA         LOOP                ; branch back to LOOP
00002B38                          3039  
00002B38                          3040  opROLWI     
00002B38  43F9 0000427A           3041              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002B3E                          3042          
00002B3E  103C 000E               3043              MOVE.B      #14, D0             ; command for trap call to display message
00002B42  4E4F                    3044              TRAP        #15                 ; trap call
00002B44                          3045  
00002B44  43F9 00004288           3046              LEA         dispWord, A1        ; display word
00002B4A  103C 000E               3047              MOVE.B      #14, D0             ; command for trap call to display message
00002B4E  4E4F                    3048              TRAP        #15                 ; trap call
00002B50                          3049          
00002B50  4EB9 00002E46           3050              JSR         PrntImm             ; jump to PrntImm
00002B56                          3051          
00002B56  6000 E4EE               3052              BRA         LOOP                ; branch back to LOOP
00002B5A                          3053  
00002B5A                          3054  opROWR      
00002B5A  4242                    3055              CLR         D2                  ; clear D2
00002B5C  3401                    3056              MOVE.W      D1, D2              ; move word from D1 to D2
00002B5E  E042                    3057              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002B60  C47C 0001               3058              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002B64                          3059      
00002B64  B43C 0000               3060              CMP.B       #zero, D2           ; compare 0 to D2 
00002B68  6700 000E               3061              BEQ         opRORWR             ; if true, branch to RORWR for right
00002B6C  B43C 0001               3062              CMP.B       #one, D2            ; compare 1 to D2
00002B70  6700 0028               3063              BEQ         opROLWR             ; if true, branch to ROLWR for left
00002B74  6000 1116               3064              BRA         printInvalid        ; otherwise invalid     
00002B78                          3065          
00002B78                          3066  opRORWR 
00002B78  43F9 00004276           3067              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002B7E  103C 000E               3068              MOVE.B      #14, D0             ; command for trap call to display message
00002B82  4E4F                    3069              TRAP        #15                 ; trap call
00002B84                          3070      
00002B84  43F9 00004288           3071              LEA         dispWord, A1        ; display word
00002B8A  103C 000E               3072              MOVE.B      #14, D0             ; command for trap call to display message
00002B8E  4E4F                    3073              TRAP        #15                 ; trap call
00002B90                          3074          
00002B90  4EB9 00002EA2           3075              JSR         PrntReg             ; jump to PrntReg
00002B96                          3076          
00002B96  6000 E4AE               3077              BRA         LOOP                ; branch back to LOOP
00002B9A                          3078  
00002B9A                          3079  opROLWR 
00002B9A  43F9 0000427A           3080              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002BA0  103C 000E               3081              MOVE.B      #14, D0             ; command for trap call to display message
00002BA4  4E4F                    3082              TRAP        #15                 ; trap call
00002BA6                          3083  
00002BA6  43F9 00004288           3084              LEA         dispWord, A1        ; display word
00002BAC  103C 000E               3085              MOVE.B      #14, D0             ; command for trap call to display message
00002BB0  4E4F                    3086              TRAP        #15                 ; trap call
00002BB2                          3087          
00002BB2  4EB9 00002EA2           3088              JSR         PrntReg             ; jump to PrntReg
00002BB8                          3089          
00002BB8  6000 E48C               3090              BRA         LOOP                ; branch back to LOOP
00002BBC                          3091  
00002BBC                          3092  memSL   
00002BBC  4242                    3093              CLR         D2                  ; clear D2
00002BBE  1401                    3094              MOVE.B      D1,D2               ; move D1 to D2
00002BC0  E642                    3095              ASR         #three, D2          ; shift D2 by 3 bits to get i/r
00002BC2                          3096              
00002BC2  C47C 0007               3097              AND         #$07, D2            ; and D2 by 3 bits 
00002BC6                          3098          
00002BC6  B43C 0000               3099              CMP.B       #zero, D2           ; compare 0 to D2
00002BCA  6700 002E               3100              BEQ         opASLI              ; if true, branch to ASLI for immediate
00002BCE  B43C 0004               3101              CMP.B       #four, D2           ; compare 4 to D2 
00002BD2  6700 0088               3102              BEQ         opASLR              ; if true, branch to ASLR for register
00002BD6  B43C 0001               3103              CMP.B       #one, D2            ; compare 1 to D2
00002BDA  6700 00E2               3104              BEQ         opLSLI              ; if true, branch to LSLI for immediate
00002BDE  B43C 0005               3105              CMP.B       #five, D2           ; compare 5 to D2
00002BE2  6700 013C               3106              BEQ         opLSLR              ; if true, branch to LSLR for register
00002BE6  B43C 0003               3107              CMP.B       #three, D2          ; compare 3 to D2
00002BEA  6700 0196               3108              BEQ         opROLI              ; if true, branch to ROLI for immediate
00002BEE  B43C 0007               3109              CMP.B       #seven, D2          ; compare 7 to D2
00002BF2  6700 01F0               3110              BEQ         opROLR              ; if true, branch to ROLR for register
00002BF6  6000 1094               3111              BRA         printInvalid        ; otherwise invalid
00002BFA                          3112          
00002BFA                          3113  opASLI  
00002BFA  4242                    3114              CLR         D2                  ; clear D2
00002BFC  3401                    3115              MOVE.W      D1, D2              ; move word from D1 to D2
00002BFE  E042                    3116              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002C00  C47C 0001               3117              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002C04                          3118      
00002C04  B43C 0000               3119              CMP.B       #zero, D2           ; compare 0 to D2
00002C08  6700 000E               3120              BEQ         opASRLI             ; if true, branch to ASRLI for right
00002C0C  B43C 0001               3121              CMP.B       #one, D2            ; compare 1 to D2
00002C10  6700 0028               3122              BEQ         opASLLI             ; if true, branch to ASLLI for left
00002C14  6000 1076               3123              BRA         printInvalid        ; otherwise invalid
00002C18                          3124          
00002C18                          3125  opASRLI 
00002C18  43F9 0000426E           3126              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002C1E  103C 000E               3127              MOVE.B      #14, D0             ; command for trap call to display message
00002C22  4E4F                    3128              TRAP        #15                 ; trap call
00002C24                          3129  
00002C24  43F9 0000428B           3130              LEA         dispLong, A1        ; display long
00002C2A  103C 000E               3131              MOVE.B      #14, D0             ; command for trap call to display message
00002C2E  4E4F                    3132              TRAP        #15                 ; trap call
00002C30                          3133          
00002C30  4EB9 00002E46           3134              JSR         PrntImm             ; jump to PrntImm
00002C36                          3135          
00002C36  6000 E40E               3136              BRA         LOOP                ; branch back to LOOP
00002C3A                          3137  
00002C3A                          3138  opASLLI 
00002C3A  43F9 00004272           3139              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
00002C40  103C 000E               3140              MOVE.B      #14, D0             ; command for trap call to display message
00002C44  4E4F                    3141              TRAP        #15                 ; trap call
00002C46                          3142  
00002C46  43F9 0000428B           3143              LEA         dispLong, A1        ; display long
00002C4C  103C 000E               3144              MOVE.B      #14, D0             ; command for trap call to display message
00002C50  4E4F                    3145              TRAP        #15                 ; trap call
00002C52                          3146          
00002C52  4EB9 00002E46           3147              JSR         PrntImm             ; jump to PrntImm
00002C58                          3148          
00002C58  6000 E3EC               3149              BRA         LOOP                ; branch back to LOOP
00002C5C                          3150  
00002C5C                          3151  opASLR  
00002C5C  4242                    3152              CLR         D2                  ; clear D2
00002C5E  3401                    3153              MOVE.W      D1, D2              ; move word from D1 to D2
00002C60  E042                    3154              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002C62  C47C 0001               3155              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002C66                          3156      
00002C66  B43C 0000               3157              CMP.B       #zero, D2           ; compare 0 to D2 
00002C6A  6700 000E               3158              BEQ         opASRLR             ; if true, branch to ASRLR for right
00002C6E  B43C 0001               3159              CMP.B       #one, D2            ; compare 1 to D2
00002C72  6700 0028               3160              BEQ         opASLLR             ; if true, branch to ASLLR for left
00002C76  6000 1014               3161              BRA         printInvalid        ; otherwise invalid 
00002C7A                          3162          
00002C7A                          3163  opASRLR 
00002C7A  43F9 0000426E           3164              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002C80  103C 000E               3165              MOVE.B      #14, D0             ; command for trap call to display message
00002C84  4E4F                    3166              TRAP        #15                 ; trap call
00002C86                          3167  
00002C86  43F9 0000428B           3168              LEA         dispLong, A1        ; display long
00002C8C  103C 000E               3169              MOVE.B      #14, D0             ; command for trap call to display message
00002C90  4E4F                    3170              TRAP        #15                 ; trap call
00002C92                          3171          
00002C92  4EB9 00002EA2           3172              JSR         PrntReg             ; jump to PrntReg
00002C98                          3173          
00002C98  6000 E3AC               3174              BRA         LOOP                ; branch back to LOOP
00002C9C                          3175  
00002C9C                          3176  opASLLR 
00002C9C  43F9 00004272           3177              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
00002CA2  103C 000E               3178              MOVE.B      #14, D0             ; command for trap call to display message
00002CA6  4E4F                    3179              TRAP        #15                 ; trap call
00002CA8                          3180  
00002CA8  43F9 0000428B           3181              LEA         dispLong, A1        ; display long
00002CAE  103C 000E               3182              MOVE.B      #14, D0             ; command for trap call to display message
00002CB2  4E4F                    3183              TRAP        #15                 ; trap call
00002CB4                          3184          
00002CB4  4EB9 00002EA2           3185              JSR         PrntReg             ; jump to PrntReg
00002CBA                          3186          
00002CBA  6000 E38A               3187              BRA         LOOP                ; branch back to LOOP
00002CBE                          3188  
00002CBE                          3189  opLSLI  
00002CBE  4242                    3190              CLR         D2                  ; clear D2
00002CC0  3401                    3191              MOVE.W      D1, D2              ; move word from D1 to D2
00002CC2  E042                    3192              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002CC4  C47C 0001               3193              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002CC8                          3194      
00002CC8  B43C 0000               3195              CMP.B       #zero, D2           ; compare 0 to D2 
00002CCC  6700 000E               3196              BEQ         opLSRLI             ; if true, branch to LSRLI for right
00002CD0  B43C 0001               3197              CMP.B       #one, D2            ; compare 1 to D2
00002CD4  6700 0028               3198              BEQ         opLSLLI             ; if true, branch to LSLLI for left
00002CD8  6000 0FB2               3199              BRA         printInvalid        ; otherwise invalid  
00002CDC                          3200          
00002CDC                          3201  opLSRLI 
00002CDC  43F9 00004266           3202              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002CE2  103C 000E               3203              MOVE.B      #14, D0             ; command for trap call to display message
00002CE6  4E4F                    3204              TRAP        #15                 ; trap call
00002CE8                          3205  
00002CE8  43F9 0000428B           3206              LEA         dispLong, A1        ; display long
00002CEE  103C 000E               3207              MOVE.B      #14, D0             ; command for trap call to display message
00002CF2  4E4F                    3208              TRAP        #15                 ; trap call
00002CF4                          3209          
00002CF4  4EB9 00002E46           3210              JSR         PrntImm             ; jump to PrntImm
00002CFA                          3211          
00002CFA  6000 E34A               3212              BRA         LOOP                ; branch back to LOOP
00002CFE                          3213  
00002CFE                          3214  
00002CFE                          3215  opLSLLI 
00002CFE  43F9 0000426A           3216              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002D04  103C 000E               3217              MOVE.B      #14, D0             ; command for trap call to display message
00002D08  4E4F                    3218              TRAP        #15                 ; trap call
00002D0A                          3219  
00002D0A  43F9 0000428B           3220              LEA         dispLong, A1        ; display long
00002D10  103C 000E               3221              MOVE.B      #14, D0             ; command for trap call to display message
00002D14  4E4F                    3222              TRAP        #15                 ; trap call
00002D16                          3223          
00002D16  4EB9 00002E46           3224              JSR         PrntImm             ; jump to PrntImm
00002D1C                          3225          
00002D1C  6000 E328               3226              BRA         LOOP                ; branch back to LOOP
00002D20                          3227  
00002D20                          3228  opLSLR  
00002D20  4242                    3229              CLR         D2                  ; clear D2
00002D22  3401                    3230              MOVE.W      D1, D2              ; move word from D1 to D2
00002D24  E042                    3231              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002D26  C47C 0001               3232              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002D2A                          3233      
00002D2A  B43C 0000               3234              CMP.B       #zero, D2           ; compare 0 to D2 
00002D2E  6700 000E               3235              BEQ         opLSRLR             ; if true, branch to LSRLR for right
00002D32  B43C 0001               3236              CMP.B       #one, D2            ; compare 1 to D2
00002D36  6700 0028               3237              BEQ         opLSLLR             ; if true, branch to LSLLR for left
00002D3A  6000 0F50               3238              BRA         printInvalid        ; otherwise invalid
00002D3E                          3239          
00002D3E                          3240  opLSRLR 
00002D3E  43F9 00004266           3241              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002D44  103C 000E               3242              MOVE.B      #14, D0             ; command for trap call to display message
00002D48  4E4F                    3243              TRAP        #15                 ; trap call
00002D4A                          3244  
00002D4A  43F9 0000428B           3245              LEA         dispLong, A1        ; display long
00002D50  103C 000E               3246              MOVE.B      #14, D0             ; command for trap call to display message
00002D54  4E4F                    3247              TRAP        #15                 ; trap call
00002D56                          3248          
00002D56  4EB9 00002EA2           3249              JSR         PrntReg             ; jump to PrntReg
00002D5C                          3250          
00002D5C  6000 E2E8               3251              BRA         LOOP                ; branch back to LOOP
00002D60                          3252          
00002D60                          3253  opLSLLR 
00002D60  43F9 0000426A           3254              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002D66  103C 000E               3255              MOVE.B      #14, D0             ; command for trap call to display message
00002D6A  4E4F                    3256              TRAP        #15                 ; trap call
00002D6C                          3257  
00002D6C  43F9 0000428B           3258              LEA         dispLong, A1        ; display long
00002D72  103C 000E               3259              MOVE.B      #14, D0             ; command for trap call to display message
00002D76  4E4F                    3260              TRAP        #15                 ; trap call
00002D78                          3261          
00002D78  4EB9 00002EA2           3262              JSR         PrntReg             ; jump to PrntReg
00002D7E                          3263          
00002D7E  6000 E2C6               3264              BRA         LOOP                ; branch back to LOOP
00002D82                          3265              
00002D82                          3266  opROLI  
00002D82  4242                    3267              CLR         D2                  ; clear D2
00002D84  3401                    3268              MOVE.W      D1, D2              ; move word from D1 to D2
00002D86  E042                    3269              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002D88  C47C 0001               3270              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002D8C                          3271      
00002D8C  B43C 0000               3272              CMP.B       #zero, D2           ; compare 0 to D2
00002D90  6700 000E               3273              BEQ         opRORLI             ; if true, branch to RORLI for right
00002D94  B43C 0001               3274              CMP.B       #one, D2            ; compare 1 to D2
00002D98  6700 0028               3275              BEQ         opROLLI             ; if true, branch to ROLLI for left
00002D9C  6000 0EEE               3276              BRA         printInvalid        ; otherwise invalid
00002DA0                          3277          
00002DA0                          3278  opRORLI 
00002DA0  43F9 00004276           3279              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002DA6  103C 000E               3280              MOVE.B      #14, D0             ; command for trap call to display message
00002DAA  4E4F                    3281              TRAP        #15                 ; trap call
00002DAC                          3282  
00002DAC  43F9 0000428B           3283              LEA         dispLong, A1        ; display long
00002DB2  103C 000E               3284              MOVE.B      #14, D0             ; command for trap call to display message
00002DB6  4E4F                    3285              TRAP        #15                 ; trap call
00002DB8                          3286          
00002DB8  4EB9 00002E46           3287              JSR         PrntImm             ; jump to PrntImm
00002DBE                          3288          
00002DBE  6000 E286               3289              BRA         LOOP                ; branch back to LOOP
00002DC2                          3290  
00002DC2                          3291  opROLLI 
00002DC2  43F9 0000427A           3292              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002DC8  103C 000E               3293              MOVE.B      #14, D0             ; command for trap call to display message
00002DCC  4E4F                    3294              TRAP        #15                 ; trap call
00002DCE                          3295  
00002DCE  43F9 0000428B           3296              LEA         dispLong, A1        ; display long
00002DD4  103C 000E               3297              MOVE.B      #14, D0             ; command for trap call to display message
00002DD8  4E4F                    3298              TRAP        #15                 ; trap call
00002DDA                          3299          
00002DDA  4EB9 00002E46           3300              JSR         PrntImm             ; jump to PrntImm
00002DE0                          3301          
00002DE0  6000 E264               3302              BRA         LOOP                ; branch back to LOOP
00002DE4                          3303  
00002DE4                          3304  opROLR  
00002DE4  4242                    3305              CLR         D2                  ; clear D2
00002DE6  3401                    3306              MOVE.W      D1, D2              ; move word from D1 to D2
00002DE8  E042                    3307              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002DEA  C47C 0001               3308              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002DEE                          3309      
00002DEE  B43C 0000               3310              CMP.B       #zero, D2           ; compare 0 to D2 
00002DF2  6700 000E               3311              BEQ         opRORLR             ; if true, branch to RORLR for right
00002DF6  B43C 0001               3312              CMP.B       #one, D2            ; compare 1 to D2
00002DFA  6700 0028               3313              BEQ         opROLLR             ; if true, branch to ROLLR for left
00002DFE  6000 0E8C               3314              BRA         printInvalid        ; otherwise invalid     
00002E02                          3315          
00002E02                          3316  opRORLR 
00002E02  43F9 00004276           3317              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002E08  103C 000E               3318              MOVE.B      #14, D0             ; command for trap call to display message
00002E0C  4E4F                    3319              TRAP        #15                 ; trap call
00002E0E                          3320  
00002E0E  43F9 0000428B           3321              LEA         dispLong, A1        ; display long
00002E14  103C 000E               3322              MOVE.B      #14, D0             ; command for trap call to display message
00002E18  4E4F                    3323              TRAP        #15                 ; trap call
00002E1A                          3324          
00002E1A  4EB9 00002EA2           3325              JSR         PrntReg             ; jump to PrntReg
00002E20                          3326          
00002E20  6000 E224               3327              BRA         LOOP                ; branch back to LOOP
00002E24                          3328  
00002E24                          3329  opROLLR     
00002E24  43F9 0000427A           3330              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002E2A  103C 000E               3331              MOVE.B      #14, D0             ; command for trap call to display message
00002E2E  4E4F                    3332              TRAP        #15                 ; trap call
00002E30                          3333      
00002E30  43F9 0000428B           3334              LEA         dispLong, A1        ; display long
00002E36  103C 000E               3335              MOVE.B      #14, D0             ; command for trap call to display message
00002E3A  4E4F                    3336              TRAP        #15                 ; trap call
00002E3C                          3337          
00002E3C  4EB9 00002EA2           3338              JSR         PrntReg             ; jump to PrntReg
00002E42                          3339          
00002E42  6000 E202               3340              BRA         LOOP                ; branch back to LOOP
00002E46                          3341          
00002E46                          3342  ***********************************************************************************************************
00002E46                          3343  *                       Immediate Data Subroutine Part 1
00002E46                          3344  *
00002E46                          3345  * The following subroutine displays the immediate number to shift and the data register that is being shifted. 
00002E46                          3346  * This subroutine calls two printing immediate subroutine first, the the ea print subroutine.        
00002E46                          3347  *
00002E46                          3348  ***********************************************************************************************************
00002E46                          3349  
00002E46                          3350  PrntImm 
00002E46  48E7 FF7E               3351              MOVEM.L     D0-D7/A1-A6, -(SP)  ; callee saved registers
00002E4A                          3352              
00002E4A  43F9 000041EB           3353              LEA         space, A1           ; display space
00002E50  103C 000E               3354              MOVE.B      #14, D0             ; command for trap call to display message
00002E54  4E4F                    3355              TRAP        #15                 ; trap call
00002E56                          3356              
00002E56  43F9 000041EE           3357              LEA         hashTag, A1         ; display #
00002E5C  103C 000E               3358              MOVE.B      #14, D0             ; command for trap call to display message
00002E60  4E4F                    3359              TRAP        #15                 ; trap call
00002E62                          3360              
00002E62  4242                    3361              CLR         D2                  ; clear D2
00002E64  3401                    3362              MOVE.W      D1, D2              ; move word from D1 to D2
00002E66  E042                    3363              ASR         #eight, D2          ; shift D2 by 8 bits
00002E68  E242                    3364              ASR         #one, D2            ; shift D2 by one bit
00002E6A  C47C 0007               3365              AND         #$07, D2            ; and D2 to get just first 3 bits
00002E6E                          3366          
00002E6E  4EB9 00002EF4           3367              JSR         MemShiftImm         ; jump to MemShiftImm
00002E74                          3368          
00002E74  43F9 000041F2           3369              LEA         comma, A1           ; display comma
00002E7A  103C 000E               3370              MOVE.B      #14, D0             ; command for trap call to display message
00002E7E  4E4F                    3371              TRAP        #15                 ; trap call
00002E80                          3372          
00002E80  4242                    3373              CLR         D2                  ; clear D2 since destination mode must be data register
00002E82  4243                    3374              CLR         D3                  ; clear D3 to get register
00002E84  1601                    3375              MOVE.B      D1,D3               ; move byte from D1 to D3
00002E86  C67C 0007               3376              AND         #$07, D3            ; and D3 to get first 3 bits only
00002E8A                          3377          
00002E8A  4EB9 00002F1E           3378              JSR         printEA             ; jump to printEA
00002E90                          3379          
00002E90  43F9 000041E7           3380              LEA         newLine, A1         ; create new line
00002E96  103C 000E               3381              MOVE.B      #14, D0             ; command for trap call to display message
00002E9A  4E4F                    3382              TRAP        #15                 ; trap call
00002E9C                          3383          
00002E9C  4CDF 7EFF               3384              MOVEM.L     (SP)+, D0-D7/A1-A6  ; pop saved registers from stack
00002EA0  4E75                    3385              RTS                             ; return
00002EA2                          3386              
00002EA2                          3387  ***********************************************************************************************************
00002EA2                          3388  *
00002EA2                          3389  *                       Shifting Helping Function
00002EA2                          3390  *
00002EA2                          3391  * The following subroutine determines the correct data register to display, and sets the values of D2 and 
00002EA2                          3392  *       D3 accordingly to display the data register.
00002EA2                          3393  * after setting the values, it calls another subroutine to actually display the data register.        
00002EA2                          3394  *
00002EA2                          3395  ***********************************************************************************************************
00002EA2                          3396  
00002EA2                          3397  PrntReg     
00002EA2  48E7 FF7E               3398              MOVEM.L     D0-D7/A1-A6, -(SP)  ; callee saved
00002EA6                          3399          
00002EA6  43F9 000041EB           3400              LEA         space, A1           ; display space
00002EAC  103C 000E               3401              MOVE.B      #14, D0             ; command for trap call to display message
00002EB0  4E4F                    3402              TRAP        #15                 ; trap call
00002EB2                          3403          
00002EB2  4242                    3404              CLR         D2                  ; clear D2
00002EB4  4243                    3405              CLR         D3                  ; clear D3
00002EB6  3601                    3406              MOVE.W      D1, D3              ; move word from D1 to D3
00002EB8  E043                    3407              ASR         #eight, D3          ; shift D3 by 8 bits
00002EBA  E243                    3408              ASR         #one, D3            ; shift D3 by 1 bit
00002EBC  C67C 0007               3409              AND         #$07, D3            ; and D3 to get first 3 bits only
00002EC0                          3410          
00002EC0  4EB9 00002F1E           3411              JSR         printEA
00002EC6                          3412          
00002EC6  43F9 000041F2           3413              LEA         comma, A1           ; display comma
00002ECC  103C 000E               3414              MOVE.B      #14, D0             ; command for trap call to display message
00002ED0  4E4F                    3415              TRAP        #15                 ; trap call
00002ED2                          3416          
00002ED2  4242                    3417              CLR         D2                  ; clear D2
00002ED4  4243                    3418              CLR         D3                  ; clear D3
00002ED6  1601                    3419              MOVE.B      D1,D3               ; move byte from D1 to D3
00002ED8  C67C 0007               3420              AND         #$07, D3            ; and D3 to get first 3 bits only
00002EDC                          3421          
00002EDC  4EB9 00002F1E           3422              JSR         printEA             ; jump to printEA
00002EE2                          3423          
00002EE2  43F9 000041E7           3424              LEA         newLine, A1         ; newline
00002EE8  103C 000E               3425              MOVE.B      #14, D0             ; command for trap call to display message
00002EEC  4E4F                    3426              TRAP        #15                 ; trap call
00002EEE                          3427          
00002EEE  4CDF 7EFF               3428              MOVEM.L     (SP)+, D0-D7/A1-A6  ; pop saved registers from stack
00002EF2  4E75                    3429              RTS                             ; return
00002EF4                          3430  
00002EF4                          3431  ***********************************************************************************************************
00002EF4                          3432  *
00002EF4                          3433  *                       Immediate Data Subroutine Part 2
00002EF4                          3434  *
00002EF4                          3435  * The following subroutine is used to display the number between 1-8 for the bit vount for the shift/rotate opcode
00002EF4                          3436  * It displays it by storing the appropriate number in D1 and running trap task 3.
00002EF4                          3437  *
00002EF4                          3438  ***********************************************************************************************************
00002EF4                          3439  
00002EF4                          3440  MemShiftImm     
00002EF4  48E7 FF7E               3441              MOVEM.L     D0-D7/A1-A6, -(SP)  ; caller saved data
00002EF8  4241                    3442              CLR         D1                  ; clear D1
00002EFA                          3443                 
00002EFA  1202                    3444              MOVE.B      D2, D1              ; move byte from D2 to D1
00002EFC  B23C 0000               3445              CMP.B       #zero, D1           ; compare 0 to D1
00002F00  6700 000C               3446              BEQ         displayEight        ; if true, branch to displayEight
00002F04                          3447                  
00002F04  103C 0003               3448              MOVE.B      #3, D0              ; trap task command to display decimal
00002F08  4E4F                    3449              TRAP        #15                 ; trap call
00002F0A  6000 000C               3450              BRA         endSubroutine       ; branch to endSubroutine
00002F0E                          3451                  
00002F0E                          3452  displayEight    
00002F0E  123C 0008               3453              MOVE.B      #$08, D1            ; move 8 to D1
00002F12  103C 0003               3454              MOVE.B      #3, D0              ; trap task command to display decimal
00002F16  4E4F                    3455              TRAP        #15                 ; trap call
00002F18                          3456              
00002F18                          3457  endSubroutine
00002F18  4CDF 7EFF               3458              MOVEM.L     (SP)+, D0-D7/A1-A6  ; pop saved registers from stack
00002F1C  4E75                    3459              RTS                             ; return
00002F1E                          3460          
00002F1E                          3461  ***********************************************************************************************************
00002F1E                          3462  *
00002F1E                          3463  *                       EA Print Subroutine
00002F1E                          3464  *
00002F1E                          3465  ***********************************************************************************************************
00002F1E                          3466  
00002F1E                          3467  printEA     
00002F1E  48E7 FF7E               3468              MOVEM.L  D0-D7/A1-A6, -(SP)
00002F22                          3469  
00002F22  B43C 0000               3470              CMP.B       #zero, D2
00002F26  6700 002E               3471              BEQ         pDataReg
00002F2A  B43C 0001               3472              CMP.B       #one, D2
00002F2E  6700 00E6               3473              BEQ         pAddrReg
00002F32  B43C 0002               3474              CMP.B       #two, D2
00002F36  6700 019E               3475              BEQ         pAddrDir
00002F3A  B43C 0003               3476              CMP.B       #three, D2
00002F3E  6700 02C2               3477              BEQ         pAddrPost
00002F42  B43C 0004               3478              CMP.B       #four, D2
00002F46  6700 0446               3479              BEQ         pAddrDec
00002F4A  B43C 0007               3480              CMP.B       #seven, D2
00002F4E  6700 0576               3481              BEQ         pHex
00002F52  6000 0642               3482              BRA         invalid
00002F56                          3483  
00002F56                          3484  ***********************************************************************************************************
00002F56                          3485  * Data Register        
00002F56                          3486  pDataReg    
00002F56  B63C 0000               3487              CMP.B       #zero,D3
00002F5A  6700 003A               3488              BEQ         displayD0
00002F5E  B63C 0001               3489              CMP.B       #one,D3
00002F62  6700 0042               3490              BEQ         displayD1
00002F66  B63C 0002               3491              CMP.B       #two,D3
00002F6A  6700 004A               3492              BEQ         displayD2
00002F6E  B63C 0003               3493              CMP.B       #three,D3
00002F72  6700 0052               3494              BEQ         displayD3
00002F76  B63C 0004               3495              CMP.B       #four,D3
00002F7A  6700 005A               3496              BEQ         displayD4
00002F7E  B63C 0005               3497              CMP.B       #five,D3
00002F82  6700 0062               3498              BEQ         displayD5
00002F86  B63C 0006               3499              CMP.B       #six,D3
00002F8A  6700 006A               3500              BEQ         displayD6
00002F8E  B63C 0007               3501              CMP.B       #seven,D3
00002F92  6700 0072               3502              BEQ         displayD7
00002F96                          3503              
00002F96  43F9 000042A8           3504  displayD0   LEA         dispD0, A1          ; Display space
00002F9C  103C 000E               3505              MOVE.B      #14, D0             ; command for trap call to display message
00002FA0  4E4F                    3506              TRAP        #15                 ; trap call
00002FA2  6000 05F6               3507              BRA         endSUB              ; go to the end of the subroutine
00002FA6                          3508              
00002FA6  43F9 000042AB           3509  displayD1   LEA         dispD1, A1          ; Display space
00002FAC  103C 000E               3510              MOVE.B      #14, D0             ; command for trap call to display message
00002FB0  4E4F                    3511              TRAP        #15                 ; trap call
00002FB2  6000 05E6               3512              BRA         endSUB              ; go to the end of the subroutine
00002FB6                          3513  
00002FB6  43F9 000042AE           3514  displayD2   LEA         dispD2, A1          ; Display space
00002FBC  103C 000E               3515              MOVE.B      #14, D0             ; command for trap call to display message
00002FC0  4E4F                    3516              TRAP        #15                 ; trap call
00002FC2  6000 05D6               3517              BRA         endSUB              ; go to the end of the subroutine
00002FC6                          3518  
00002FC6  43F9 000042B1           3519  displayD3   LEA         dispD3, A1          ; Display space
00002FCC  103C 000E               3520              MOVE.B      #14, D0             ; command for trap call to display message
00002FD0  4E4F                    3521              TRAP        #15                 ; trap call
00002FD2  6000 05C6               3522              BRA         endSUB              ; go to the end of the subroutine
00002FD6                          3523  
00002FD6  43F9 000042B4           3524  displayD4   LEA         dispD4, A1          ; Display space
00002FDC  103C 000E               3525              MOVE.B      #14, D0             ; command for trap call to display message
00002FE0  4E4F                    3526              TRAP        #15                 ; trap call
00002FE2  6000 05B6               3527              BRA         endSUB              ; go to the end of the subroutine
00002FE6                          3528  
00002FE6  43F9 000042B7           3529  displayD5   LEA         dispD5, A1          ; Display space
00002FEC  103C 000E               3530              MOVE.B      #14, D0             ; command for trap call to display message
00002FF0  4E4F                    3531              TRAP        #15                 ; trap call
00002FF2  6000 05A6               3532              BRA         endSUB              ; go to the end of the subroutine
00002FF6                          3533  
00002FF6  43F9 000042BA           3534  displayD6   LEA         dispD6, A1          ; Display space
00002FFC  103C 000E               3535              MOVE.B      #14, D0             ; command for trap call to display message
00003000  4E4F                    3536              TRAP        #15                 ; trap call
00003002  6000 0596               3537              BRA         endSUB              ; go to the end of the subroutine
00003006                          3538  
00003006  43F9 000042BD           3539  displayD7   LEA         dispD7, A1          ; Display space
0000300C  103C 000E               3540              MOVE.B      #14, D0             ; command for trap call to display message
00003010  4E4F                    3541              TRAP        #15                 ; trap call
00003012  6000 0586               3542              BRA         endSUB              ; go to the end of the subroutine
00003016                          3543              
00003016                          3544  ***********************************************************************************************************
00003016                          3545  * Address Register
00003016                          3546  
00003016  B63C 0000               3547  pAddrReg    CMP.B       #zero,D3
0000301A  6700 003A               3548              BEQ         displayA0
0000301E  B63C 0001               3549              CMP.B       #one,D3
00003022  6700 0042               3550              BEQ         displayA1
00003026  B63C 0002               3551              CMP.B       #two,D3
0000302A  6700 004A               3552              BEQ         displayA2
0000302E  B63C 0003               3553              CMP.B       #three,D3
00003032  6700 0052               3554              BEQ         displayA3
00003036  B63C 0004               3555              CMP.B       #four,D3
0000303A  6700 005A               3556              BEQ         displayA4
0000303E  B63C 0005               3557              CMP.B       #five,D3
00003042  6700 0062               3558              BEQ         displayA5
00003046  B63C 0006               3559              CMP.B       #six,D3
0000304A  6700 006A               3560              BEQ         displayA6
0000304E  B63C 0007               3561              CMP.B       #seven,D3
00003052  6700 0072               3562              BEQ         displayA7
00003056                          3563              
00003056  43F9 0000428E           3564  displayA0   LEA         dispA0, A1          ; Display space
0000305C  103C 000E               3565              MOVE.B      #14, D0             ; command for trap call to display message
00003060  4E4F                    3566              TRAP        #15                 ; trap call
00003062  6000 0536               3567              BRA         endSUB              ; go to the end of the subroutine
00003066                          3568              
00003066  43F9 00004291           3569  displayA1   LEA         dispA1, A1          ; Display space
0000306C  103C 000E               3570              MOVE.B      #14, D0             ; command for trap call to display message
00003070  4E4F                    3571              TRAP        #15                 ; trap call
00003072  6000 0526               3572              BRA         endSUB              ; go to the end of the subroutine
00003076                          3573  
00003076  43F9 00004294           3574  displayA2   LEA         dispA2, A1          ; Display space
0000307C  103C 000E               3575              MOVE.B      #14, D0             ; command for trap call to display message
00003080  4E4F                    3576              TRAP        #15                 ; trap call
00003082  6000 0516               3577              BRA         endSUB              ; go to the end of the subroutine
00003086                          3578  
00003086  43F9 00004297           3579  displayA3   LEA         dispA3, A1          ; Display space
0000308C  103C 000E               3580              MOVE.B      #14, D0             ; command for trap call to display message
00003090  4E4F                    3581              TRAP        #15                 ; trap call
00003092  6000 0506               3582              BRA         endSUB              ; go to the end of the subroutine
00003096                          3583  
00003096  43F9 0000429A           3584  displayA4   LEA         dispA4, A1          ; Display space
0000309C  103C 000E               3585              MOVE.B      #14, D0             ; command for trap call to display message
000030A0  4E4F                    3586              TRAP        #15                 ; trap call
000030A2  6000 04F6               3587              BRA         endSUB              ; go to the end of the subroutine
000030A6                          3588  
000030A6  43F9 0000429D           3589  displayA5   LEA         dispA5, A1          ; Display space
000030AC  103C 000E               3590              MOVE.B      #14, D0             ; command for trap call to display message
000030B0  4E4F                    3591              TRAP        #15                 ; trap call
000030B2  6000 04E6               3592              BRA         endSUB              ; go to the end of the subroutine
000030B6                          3593  
000030B6  43F9 000042A0           3594  displayA6   LEA         dispA6, A1          ; Display space
000030BC  103C 000E               3595              MOVE.B      #14, D0             ; command for trap call to display message
000030C0  4E4F                    3596              TRAP        #15                 ; trap call
000030C2  6000 04D6               3597              BRA         endSUB              ; go to the end of the subroutine
000030C6                          3598  
000030C6  43F9 000042A3           3599  displayA7   LEA         dispA7, A1          ; Display space
000030CC  103C 000E               3600              MOVE.B      #14, D0             ; command for trap call to display message
000030D0  4E4F                    3601              TRAP        #15                 ; trap call
000030D2  6000 04C6               3602              BRA         endSUB              ; go to the end of the subroutine
000030D6                          3603  
000030D6                          3604  ***********************************************************************************************************
000030D6                          3605  * Address Register Direct
000030D6                          3606  
000030D6  43F9 000041F4           3607  pAddrDir    LEA         opPer, A1           ; Display space
000030DC  103C 000E               3608              MOVE.B      #14, D0             ; command for trap call to display message
000030E0  4E4F                    3609              TRAP        #15                 ; trap call
000030E2                          3610              
000030E2  B63C 0000               3611              CMP.B       #zero,D3
000030E6  6700 003A               3612              BEQ         displayA0A
000030EA  B63C 0001               3613              CMP.B       #one,D3
000030EE  6700 004E               3614              BEQ         displayA1A
000030F2  B63C 0002               3615              CMP.B       #two,D3
000030F6  6700 0062               3616              BEQ         displayA2A
000030FA  B63C 0003               3617              CMP.B       #three,D3
000030FE  6700 0076               3618              BEQ         displayA3A
00003102  B63C 0004               3619              CMP.B       #four,D3
00003106  6700 008A               3620              BEQ         displayA4A
0000310A  B63C 0005               3621              CMP.B       #five,D3
0000310E  6700 009E               3622              BEQ         displayA5A
00003112  B63C 0006               3623              CMP.B       #six,D3
00003116  6700 00B2               3624              BEQ         displayA6A
0000311A  B63C 0007               3625              CMP.B       #seven,D3
0000311E  6700 00C6               3626              BEQ         displayA7A
00003122                          3627              
00003122  43F9 0000428E           3628  displayA0A  LEA         dispA0, A1          ; Display space
00003128  103C 000E               3629              MOVE.B      #14, D0             ; command for trap call to display message
0000312C  4E4F                    3630              TRAP        #15                 ; trap call
0000312E  43F9 000041F6           3631              LEA         clPer, A1           ; Display space
00003134  103C 000E               3632              MOVE.B      #14, D0             ; command for trap call to display message
00003138  4E4F                    3633              TRAP        #15                 ; trap call
0000313A  6000 045E               3634              BRA         endSUB              ; go to the end of the subroutine
0000313E                          3635              
0000313E  43F9 00004291           3636  displayA1A  LEA         dispA1, A1          ; Display space
00003144  103C 000E               3637              MOVE.B      #14, D0             ; command for trap call to display message
00003148  4E4F                    3638              TRAP        #15                 ; trap call
0000314A  43F9 000041F6           3639              LEA         clPer, A1           ; Display space
00003150  103C 000E               3640              MOVE.B      #14, D0             ; command for trap call to display message
00003154  4E4F                    3641              TRAP        #15                 ; trap call
00003156  6000 0442               3642              BRA         endSUB              ; go to the end of the subroutine
0000315A                          3643  
0000315A  43F9 00004294           3644  displayA2A  LEA         dispA2, A1          ; Display space
00003160  103C 000E               3645              MOVE.B      #14, D0             ; command for trap call to display message
00003164  4E4F                    3646              TRAP        #15                 ; trap call
00003166  43F9 000041F6           3647              LEA         clPer, A1           ; Display space
0000316C  103C 000E               3648              MOVE.B      #14, D0             ; command for trap call to display message
00003170  4E4F                    3649              TRAP        #15                 ; trap call
00003172  6000 0426               3650              BRA         endSUB              ; go to the end of the subroutine
00003176                          3651  
00003176  43F9 00004297           3652  displayA3A  LEA         dispA3, A1          ; Display space
0000317C  103C 000E               3653              MOVE.B      #14, D0             ; command for trap call to display message
00003180  4E4F                    3654              TRAP        #15                 ; trap call
00003182  43F9 000041F6           3655              LEA         clPer, A1           ; Display space
00003188  103C 000E               3656              MOVE.B      #14, D0             ; command for trap call to display message
0000318C  4E4F                    3657              TRAP        #15                 ; trap call
0000318E  6000 040A               3658              BRA         endSUB              ; go to the end of the subroutine
00003192                          3659  
00003192  43F9 0000429A           3660  displayA4A  LEA         dispA4, A1          ; Display space
00003198  103C 000E               3661              MOVE.B      #14, D0             ; command for trap call to display message
0000319C  4E4F                    3662              TRAP        #15                 ; trap call
0000319E  43F9 000041F6           3663              LEA         clPer, A1           ; Display space
000031A4  103C 000E               3664              MOVE.B      #14, D0             ; command for trap call to display message
000031A8  4E4F                    3665              TRAP        #15                 ; trap call
000031AA  6000 03EE               3666              BRA         endSUB              ; go to the end of the subroutine
000031AE                          3667  
000031AE  43F9 0000429D           3668  displayA5A  LEA         dispA5, A1          ; Display space
000031B4  103C 000E               3669              MOVE.B      #14, D0             ; command for trap call to display message
000031B8  4E4F                    3670              TRAP        #15                 ; trap call
000031BA  43F9 000041F6           3671              LEA         clPer, A1           ; Display space
000031C0  103C 000E               3672              MOVE.B      #14, D0             ; command for trap call to display message
000031C4  4E4F                    3673              TRAP        #15                 ; trap call
000031C6  6000 03D2               3674              BRA         endSUB              ; go to the end of the subroutine
000031CA                          3675  
000031CA  43F9 000042A0           3676  displayA6A  LEA         dispA6, A1          ; Display space
000031D0  103C 000E               3677              MOVE.B      #14, D0             ; command for trap call to display message
000031D4  4E4F                    3678              TRAP        #15                 ; trap call
000031D6  43F9 000041F6           3679              LEA         clPer, A1           ; Display space
000031DC  103C 000E               3680              MOVE.B      #14, D0             ; command for trap call to display message
000031E0  4E4F                    3681              TRAP        #15                 ; trap call
000031E2  6000 03B6               3682              BRA         endSUB              ; go to the end of the subroutine
000031E6                          3683  
000031E6  43F9 000042A3           3684  displayA7A  LEA         dispA7, A1          ; Display space
000031EC  103C 000E               3685              MOVE.B      #14, D0             ; command for trap call to display message
000031F0  4E4F                    3686              TRAP        #15                 ; trap call
000031F2  43F9 000041F6           3687              LEA         clPer, A1           ; Display space
000031F8  103C 000E               3688              MOVE.B      #14, D0             ; command for trap call to display message
000031FC  4E4F                    3689              TRAP        #15                 ; trap call
000031FE  6000 039A               3690              BRA         endSUB              ; go to the end of the subroutine
00003202                          3691              
00003202                          3692  ***********************************************************************************************************
00003202                          3693  * Addr Postincrement
00003202                          3694              
00003202  43F9 000041F4           3695  pAddrPost   LEA         opPer, A1           ; Display space
00003208  103C 000E               3696              MOVE.B      #14, D0             ; command for trap call to display message
0000320C  4E4F                    3697              TRAP        #15                 ; trap call
0000320E                          3698              
0000320E  B63C 0000               3699              CMP.B       #zero,D3
00003212  6700 003A               3700              BEQ         displayA0P
00003216  B63C 0001               3701              CMP.B       #one,D3
0000321A  6700 005A               3702              BEQ         displayA1P
0000321E  B63C 0002               3703              CMP.B       #two,D3
00003222  6700 007A               3704              BEQ         displayA2P
00003226  B63C 0003               3705              CMP.B       #three,D3
0000322A  6700 009A               3706              BEQ         displayA3P
0000322E  B63C 0004               3707              CMP.B       #four,D3
00003232  6700 00BA               3708              BEQ         displayA4P
00003236  B63C 0005               3709              CMP.B       #five,D3
0000323A  6700 00DA               3710              BEQ         displayA5P
0000323E  B63C 0006               3711              CMP.B       #six,D3
00003242  6700 00FA               3712              BEQ         displayA6P
00003246  B63C 0007               3713              CMP.B       #seven,D3
0000324A  6700 011A               3714              BEQ         displayA7P
0000324E                          3715              
0000324E  43F9 0000428E           3716  displayA0P  LEA         dispA0, A1          ; Display space
00003254  103C 000E               3717              MOVE.B      #14, D0             ; command for trap call to display message
00003258  4E4F                    3718              TRAP        #15                 ; trap call
0000325A  43F9 000041F6           3719              LEA         clPer, A1           ; Display space
00003260  103C 000E               3720              MOVE.B      #14, D0             ; command for trap call to display message
00003264  4E4F                    3721              TRAP        #15                 ; trap call
00003266  43F9 000041FA           3722              LEA         inc, A1             ; Display space
0000326C  103C 000E               3723              MOVE.B      #14, D0             ; command for trap call to display message
00003270  4E4F                    3724              TRAP        #15                 ; trap call
00003272  6000 0326               3725              BRA         endSUB              ; go to the end of the subroutine
00003276                          3726              
00003276  43F9 00004291           3727  displayA1P  LEA         dispA1, A1          ; Display space
0000327C  103C 000E               3728              MOVE.B      #14, D0             ; command for trap call to display message
00003280  4E4F                    3729              TRAP        #15                 ; trap call
00003282  43F9 000041F6           3730              LEA         clPer, A1           ; Display space
00003288  103C 000E               3731              MOVE.B      #14, D0             ; command for trap call to display message
0000328C  4E4F                    3732              TRAP        #15                 ; trap call
0000328E  43F9 000041FA           3733              LEA         inc, A1             ; Display space
00003294  103C 000E               3734              MOVE.B      #14, D0             ; command for trap call to display message
00003298  4E4F                    3735              TRAP        #15                 ; trap call
0000329A  6000 02FE               3736              BRA         endSUB              ; go to the end of the subroutine
0000329E                          3737  
0000329E  43F9 00004294           3738  displayA2P  LEA         dispA2, A1          ; Display space
000032A4  103C 000E               3739              MOVE.B      #14, D0             ; command for trap call to display message
000032A8  4E4F                    3740              TRAP        #15                 ; trap call
000032AA  43F9 000041F6           3741              LEA         clPer, A1           ; Display space
000032B0  103C 000E               3742              MOVE.B      #14, D0             ; command for trap call to display message
000032B4  4E4F                    3743              TRAP        #15                 ; trap call
000032B6  43F9 000041FA           3744              LEA         inc, A1             ; Display space
000032BC  103C 000E               3745              MOVE.B      #14, D0             ; command for trap call to display message
000032C0  4E4F                    3746              TRAP        #15                 ; trap call
000032C2  6000 02D6               3747              BRA         endSUB              ; go to the end of the subroutine
000032C6                          3748  
000032C6  43F9 00004297           3749  displayA3P  LEA         dispA3, A1          ; Display space
000032CC  103C 000E               3750              MOVE.B      #14, D0             ; command for trap call to display message
000032D0  4E4F                    3751              TRAP        #15                 ; trap call
000032D2  43F9 000041F6           3752              LEA         clPer, A1           ; Display space
000032D8  103C 000E               3753              MOVE.B      #14, D0             ; command for trap call to display message
000032DC  4E4F                    3754              TRAP        #15                 ; trap call
000032DE  43F9 000041FA           3755              LEA         inc, A1             ; Display space
000032E4  103C 000E               3756              MOVE.B      #14, D0             ; command for trap call to display message
000032E8  4E4F                    3757              TRAP        #15                 ; trap call
000032EA  6000 02AE               3758              BRA         endSUB              ; go to the end of the subroutine
000032EE                          3759  
000032EE  43F9 0000429A           3760  displayA4P  LEA         dispA4, A1          ; Display space
000032F4  103C 000E               3761              MOVE.B      #14, D0             ; command for trap call to display message
000032F8  4E4F                    3762              TRAP        #15                 ; trap call
000032FA  43F9 000041F6           3763              LEA         clPer, A1           ; Display space
00003300  103C 000E               3764              MOVE.B      #14, D0             ; command for trap call to display message
00003304  4E4F                    3765              TRAP        #15                 ; trap call
00003306  43F9 000041FA           3766              LEA         inc, A1             ; Display space
0000330C  103C 000E               3767              MOVE.B      #14, D0             ; command for trap call to display message
00003310  4E4F                    3768              TRAP        #15                 ; trap call
00003312  6000 0286               3769              BRA         endSUB              ; go to the end of the subroutine
00003316                          3770  
00003316  43F9 0000429D           3771  displayA5P  LEA         dispA5, A1          ; Display space
0000331C  103C 000E               3772              MOVE.B      #14, D0             ; command for trap call to display message
00003320  4E4F                    3773              TRAP        #15                 ; trap call
00003322  43F9 000041F6           3774              LEA         clPer, A1           ; Display space
00003328  103C 000E               3775              MOVE.B      #14, D0             ; command for trap call to display message
0000332C  4E4F                    3776              TRAP        #15                 ; trap call
0000332E  43F9 000041FA           3777              LEA         inc, A1             ; Display space
00003334  103C 000E               3778              MOVE.B      #14, D0             ; command for trap call to display message
00003338  4E4F                    3779              TRAP        #15                 ; trap call
0000333A  6000 025E               3780              BRA         endSUB              ; go to the end of the subroutine
0000333E                          3781  
0000333E  43F9 000042A0           3782  displayA6P  LEA         dispA6, A1          ; Display space
00003344  103C 000E               3783              MOVE.B      #14, D0             ; command for trap call to display message
00003348  4E4F                    3784              TRAP        #15                 ; trap call
0000334A  43F9 000041F6           3785              LEA         clPer, A1           ; Display space
00003350  103C 000E               3786              MOVE.B      #14, D0             ; command for trap call to display message
00003354  4E4F                    3787              TRAP        #15                 ; trap call
00003356  43F9 000041FA           3788              LEA         inc, A1             ; Display space
0000335C  103C 000E               3789              MOVE.B      #14, D0             ; command for trap call to display message
00003360  4E4F                    3790              TRAP        #15                 ; trap call
00003362  6000 0236               3791              BRA         endSUB              ; go to the end of the subroutine
00003366                          3792  
00003366  43F9 000042A3           3793  displayA7P  LEA         dispA7, A1          ; Display space
0000336C  103C 000E               3794              MOVE.B      #14, D0             ; command for trap call to display message
00003370  4E4F                    3795              TRAP        #15                 ; trap call
00003372  43F9 000041F6           3796              LEA         clPer, A1           ; Display space
00003378  103C 000E               3797              MOVE.B      #14, D0             ; command for trap call to display message
0000337C  4E4F                    3798              TRAP        #15                 ; trap call
0000337E  43F9 000041FA           3799              LEA         inc, A1             ; Display space
00003384  103C 000E               3800              MOVE.B      #14, D0             ; command for trap call to display message
00003388  4E4F                    3801              TRAP        #15                 ; trap call
0000338A  6000 020E               3802              BRA         endSUB              ; go to the end of the subroutine
0000338E                          3803  
0000338E                          3804  ***********************************************************************************************************
0000338E                          3805  * Addr Postdecrement
0000338E                          3806  
0000338E                          3807  pAddrDec    
0000338E  43F9 000041F8           3808              LEA         dec, A1             ; Display space
00003394  103C 000E               3809              MOVE.B      #14, D0             ; command for trap call to display message
00003398  4E4F                    3810              TRAP        #15                 ; trap call
0000339A                          3811              
0000339A  43F9 000041F4           3812              LEA         opPer, A1           ; Display space
000033A0  103C 000E               3813              MOVE.B      #14, D0             ; command for trap call to display message
000033A4  4E4F                    3814              TRAP        #15                 ; trap call
000033A6                          3815              
000033A6  B63C 0000               3816              CMP.B       #zero,D3
000033AA  6700 003A               3817              BEQ         displayA0D
000033AE  B63C 0001               3818              CMP.B       #one,D3
000033B2  6700 004E               3819              BEQ         displayA1D
000033B6  B63C 0002               3820              CMP.B       #two,D3
000033BA  6700 0062               3821              BEQ         displayA2D
000033BE  B63C 0003               3822              CMP.B       #three,D3
000033C2  6700 0076               3823              BEQ         displayA3D
000033C6  B63C 0004               3824              CMP.B       #four,D3
000033CA  6700 008A               3825              BEQ         displayA4D
000033CE  B63C 0005               3826              CMP.B       #five,D3
000033D2  6700 009E               3827              BEQ         displayA5D
000033D6  B63C 0006               3828              CMP.B       #six,D3
000033DA  6700 00B2               3829              BEQ         displayA6D
000033DE  B63C 0007               3830              CMP.B       #seven,D3
000033E2  6700 00C6               3831              BEQ         displayA7D
000033E6                          3832              
000033E6                          3833  displayA0D  
000033E6  43F9 0000428E           3834              LEA         dispA0, A1          ; Display space
000033EC  103C 000E               3835              MOVE.B      #14, D0             ; command for trap call to display message
000033F0  4E4F                    3836              TRAP        #15                 ; trap call
000033F2  43F9 000041F6           3837              LEA         clPer, A1           ; Display space
000033F8  103C 000E               3838              MOVE.B      #14, D0             ; command for trap call to display message
000033FC  4E4F                    3839              TRAP        #15                 ; trap call
000033FE  6000 019A               3840              BRA         endSUB              ; go to the end of the subroutine
00003402                          3841              
00003402                          3842  displayA1D  
00003402  43F9 00004291           3843              LEA         dispA1, A1          ; Display space
00003408  103C 000E               3844              MOVE.B      #14, D0             ; command for trap call to display message
0000340C  4E4F                    3845              TRAP        #15                 ; trap call
0000340E  43F9 000041F6           3846              LEA         clPer, A1           ; Display space
00003414  103C 000E               3847              MOVE.B      #14, D0             ; command for trap call to display message
00003418  4E4F                    3848              TRAP        #15                 ; trap call
0000341A  6000 017E               3849              BRA         endSUB              ; go to the end of the subroutine
0000341E                          3850  
0000341E                          3851  displayA2D  
0000341E  43F9 00004294           3852              LEA         dispA2, A1          ; Display space
00003424  103C 000E               3853              MOVE.B      #14, D0             ; command for trap call to display message
00003428  4E4F                    3854              TRAP        #15                 ; trap call
0000342A  43F9 000041F6           3855              LEA         clPer, A1           ; Display space
00003430  103C 000E               3856              MOVE.B      #14, D0             ; command for trap call to display message
00003434  4E4F                    3857              TRAP        #15                 ; trap call
00003436  6000 0162               3858              BRA         endSUB              ; go to the end of the subroutine
0000343A                          3859  
0000343A                          3860  displayA3D  
0000343A  43F9 00004297           3861              LEA         dispA3, A1          ; Display space
00003440  103C 000E               3862              MOVE.B      #14, D0             ; command for trap call to display message
00003444  4E4F                    3863              TRAP        #15                 ; trap call
00003446  43F9 000041F6           3864              LEA         clPer, A1           ; Display space
0000344C  103C 000E               3865              MOVE.B      #14, D0             ; command for trap call to display message
00003450  4E4F                    3866              TRAP        #15                 ; trap call
00003452  6000 0146               3867              BRA         endSUB              ; go to the end of the subroutine
00003456                          3868  
00003456                          3869  displayA4D  
00003456  43F9 0000429A           3870              LEA         dispA4, A1          ; Display space
0000345C  103C 000E               3871              MOVE.B      #14, D0             ; command for trap call to display message
00003460  4E4F                    3872              TRAP        #15                 ; trap call
00003462  43F9 000041F6           3873              LEA         clPer, A1           ; Display space
00003468  103C 000E               3874              MOVE.B      #14, D0             ; command for trap call to display message
0000346C  4E4F                    3875              TRAP        #15                 ; trap call
0000346E  6000 012A               3876              BRA         endSUB              ; go to the end of the subroutine
00003472                          3877  
00003472                          3878  displayA5D  
00003472  43F9 0000429D           3879              LEA         dispA5, A1          ; Display space
00003478  103C 000E               3880              MOVE.B      #14, D0             ; command for trap call to display message
0000347C  4E4F                    3881              TRAP        #15                 ; trap call
0000347E  43F9 000041F6           3882              LEA         clPer, A1           ; Display space
00003484  103C 000E               3883              MOVE.B      #14, D0             ; command for trap call to display message
00003488  4E4F                    3884              TRAP        #15                 ; trap call
0000348A  6000 010E               3885              BRA         endSUB              ; go to the end of the subroutine
0000348E                          3886  
0000348E                          3887  displayA6D  
0000348E  43F9 000042A0           3888              LEA         dispA6, A1          ; Display space
00003494  103C 000E               3889              MOVE.B      #14, D0             ; command for trap call to display message
00003498  4E4F                    3890              TRAP        #15                 ; trap call
0000349A  43F9 000041F6           3891              LEA         clPer, A1           ; Display space
000034A0  103C 000E               3892              MOVE.B      #14, D0             ; command for trap call to display message
000034A4  4E4F                    3893              TRAP        #15                 ; trap call
000034A6  6000 00F2               3894              BRA         endSUB              ; go to the end of the subroutine
000034AA                          3895  
000034AA                          3896  displayA7D  
000034AA  43F9 000042A3           3897              LEA         dispA7, A1          ; Display space
000034B0  103C 000E               3898              MOVE.B      #14, D0             ; command for trap call to display message
000034B4  4E4F                    3899              TRAP        #15                 ; trap call
000034B6  43F9 000041F6           3900              LEA         clPer, A1           ; Display space
000034BC  103C 000E               3901              MOVE.B      #14, D0             ; command for trap call to display message
000034C0  4E4F                    3902              TRAP        #15                 ; trap call
000034C2  6000 00D6               3903              BRA         endSUB              ; go to the end of the subroutine
000034C6                          3904  
000034C6                          3905  ***********************************************************************************************************
000034C6                          3906  * Display Hex
000034C6                          3907  
000034C6                          3908  pHex        
000034C6  B63C 0000               3909              CMP.B       #zero, D3
000034CA  6700 0012               3910              BEQ         AbsShort
000034CE  B63C 0001               3911              CMP.B       #one, D3
000034D2  6700 0042               3912              BEQ         AbsLong
000034D6  B63C 0004               3913              CMP.B       #four, D3
000034DA  6700 0072               3914              BEQ         DispImm
000034DE                          3915              
000034DE                          3916  AbsShort    
000034DE  43F9 000041F4           3917              LEA         opPer, A1           ; Display space
000034E4  103C 000E               3918              MOVE.B      #14, D0             ; command for trap call to display message
000034E8  4E4F                    3919              TRAP        #15                 ; trap call
000034EA                          3920              
000034EA  43F9 000041F0           3921              LEA         dispHex, A1         ; Display space
000034F0  103C 000E               3922              MOVE.B      #14, D0             ; command for trap call to display message
000034F4  4E4F                    3923              TRAP        #15                 ; trap call
000034F6                          3924              
000034F6  4241                    3925              CLR         D1
000034F8  3218                    3926              MOVE.W      (A0)+, D1
000034FA  4240                    3927              CLR         D0
000034FC  103C 0004               3928              MOVE.B      #4, D0
00003500                          3929              
00003500  4EB9 00003AC2           3930              JSR         outHex
00003506                          3931              
00003506  43F9 000041F6           3932              LEA         clPer, A1           ; Display space
0000350C  103C 000E               3933              MOVE.B      #14, D0             ; command for trap call to display message
00003510  4E4F                    3934              TRAP        #15                 ; trap call
00003512                          3935              
00003512  6000 0086               3936              BRA         endSub
00003516                          3937              
00003516                          3938  AbsLong     
00003516  43F9 000041F4           3939              LEA         opPer, A1           ; Display space
0000351C  103C 000E               3940              MOVE.B      #14, D0             ; command for trap call to display message
00003520  4E4F                    3941              TRAP        #15                 ; trap call
00003522                          3942              
00003522  43F9 000041F0           3943              LEA         dispHex, A1         ; Display space
00003528  103C 000E               3944              MOVE.B      #14, D0             ; command for trap call to display message
0000352C  4E4F                    3945              TRAP        #15                 ; trap call
0000352E                          3946              
0000352E  4241                    3947              CLR         D1
00003530  2218                    3948              MOVE.L      (A0)+, D1
00003532  4240                    3949              CLR         D0
00003534  103C 0008               3950              MOVE.B      #8, D0
00003538                          3951              
00003538  4EB9 00003AC2           3952              JSR         outHex
0000353E                          3953              
0000353E  43F9 000041F6           3954              LEA         clPer, A1           ; Display space
00003544  103C 000E               3955              MOVE.B      #14, D0             ; command for trap call to display message
00003548  4E4F                    3956              TRAP        #15                 ; trap call
0000354A                          3957              
0000354A  6000 004E               3958              BRA         endSub
0000354E                          3959  
0000354E                          3960  DispImm     
0000354E  43F9 000041EE           3961              LEA         hashTag, A1         ; Display space
00003554  103C 000E               3962              MOVE.B      #14, D0             ; command for trap call to display message
00003558  4E4F                    3963              TRAP        #15                 ; trap call
0000355A                          3964  
0000355A  43F9 000041F0           3965              LEA         dispHex, A1         ; Display space
00003560  103C 000E               3966              MOVE.B      #14, D0             ; command for trap call to display message
00003564  4E4F                    3967              TRAP        #15                 ; trap call
00003566                          3968              
00003566  BC3C 0001               3969              CMP.B       #1,D6
0000356A  6700 0016               3970              BEQ         ImmLong
0000356E                          3971              
0000356E  4241                    3972              CLR         D1
00003570  3218                    3973              MOVE.W      (A0)+, D1
00003572  4240                    3974              CLR         D0
00003574  103C 0004               3975              MOVE.B      #4, D0
00003578  4EB9 00003AC2           3976              JSR         outHex
0000357E  6000 0012               3977              BRA         LongSkip
00003582                          3978              
00003582                          3979  ImmLong     
00003582  4241                    3980              CLR         D1
00003584  2218                    3981              MOVE.L      (A0)+, D1
00003586  4240                    3982              CLR         D0
00003588  103C 0008               3983              MOVE.B      #8, D0
0000358C  4EB9 00003AC2           3984              JSR         outHex             
00003592                          3985  
00003592                          3986  LongSkip
00003592  6000 0006               3987              BRA         endSub
00003596                          3988  
00003596                          3989  invalid
00003596  6000 06F4               3990              BRA         printInvalid
0000359A                          3991  
0000359A                          3992  endSUB        
0000359A  4CDF 7EFF               3993              MOVEM.L     (SP)+, D0-D7/A1-A6
0000359E  4E75                    3994              RTS
000035A0                          3995  
000035A0                          3996  ***********************************************************************************************************
000035A0                          3997  *
000035A0                          3998  *                       MOVEM Helper Function
000035A0                          3999  *       This function is dedicated to printing out the address and data register for MOVEM. The 
000035A0                          4000  *       function starts by identifying the size and then identifying the dr field. If the dr field
000035A0                          4001  *       is 1, then the program goes to print before print out the address and data register for MOVEM. If dr
000035A0                          4002  *       field is zero, program goes to print out the address and data register before printing out the
000035A0                          4003  *       post increment or immediate data.
000035A0                          4004  *
000035A0                          4005  ***********************************************************************************************************
000035A0                          4006  
000035A0                          4007  MOVEMBRA    
000035A0  48E7 FF7E               4008              MOVEM.L     D0-D7/A1-A6, -(SP)  ; Branches off depending on size bit
000035A4  BA7C 0000               4009              CMP         #zero,D5            ; Checks the size to see if it word
000035A8  6700 000E               4010              BEQ         MOVEMW              ; Branches if it is equal to word
000035AC  BA7C 0001               4011              CMP         #one, D5            ; Compares bits to long.
000035B0  6700 0022               4012              BEQ         MOVEML              ; Branches if it is equal to long size.
000035B4  6000 06D6               4013              BRA         printInvalid        ; Is invalid if it is not equal to either
000035B8                          4014              
000035B8                          4015  MOVEMW     
000035B8  43F9 00004288           4016              LEA         dispWord, A1        ; Prints a W to symbolize word
000035BE  103C 000E               4017              MOVE.B      #14, D0             ; command for trap call to display message
000035C2  4E4F                    4018              TRAP        #15                 ; trap call
000035C4                          4019  
000035C4  43F9 000041EB           4020              LEA         space, A1           ; Print a space
000035CA  103C 000E               4021              MOVE.B      #14, D0             ; command for trap call to display message
000035CE  4E4F                    4022              TRAP        #15                 ; trap call
000035D0                          4023              
000035D0  6000 001E               4024              BRA         CheckDR
000035D4                          4025  
000035D4                          4026  MOVEML   
000035D4  43F9 0000428B           4027              LEA         dispLong, A1        ; we know that the opcode will be MOVEML, so load A1 to print message
000035DA  103C 000E               4028              MOVE.B      #14, D0             ; command for trap call to display message
000035DE  4E4F                    4029              TRAP        #15                 ; trap call
000035E0                          4030  
000035E0  43F9 000041EB           4031              LEA         space, A1           ; Print a space
000035E6  103C 000E               4032              MOVE.B      #14, D0             ; command for trap call to display message
000035EA  4E4F                    4033              TRAP        #15                 ; trap call
000035EC                          4034           
000035EC                          4035  
000035EC  6000 0002               4036              BRA         CheckDR             ; Branch to CheckDR
000035F0                          4037  
000035F0                          4038  CheckDR     
000035F0  3218                    4039              MOVE.W      (A0)+, D1           ; Taking in next word
000035F2  BC7C 0000               4040              CMP         #zero,D6            ; Check if dr is 0, then print out data/address first
000035F6  6700 0020               4041              BEQ         printRegMem         ; branch to printRegMem
000035FA  BC7C 0001               4042              CMP         #one,D6             ; dr field is one, must print stack pointer first
000035FE  6700 0004               4043              BEQ         printStack          ; Go to print stack pointer
00003602  6092                    4044              BRA         invalid             ; Go to invalid if equal to neither
00003604                          4045              
00003604                          4046  printStack 
00003604  4EB8 2F1E               4047              JSR         printEA             ; Prints out the stack pointer
00003608                          4048              
00003608  43F9 000041F2           4049              LEA         comma,A1            ; Prints out comma
0000360E  103C 000E               4050              MOVE.B      #14, D0             ; command for trap call to display message
00003612  4E4F                    4051              TRAP        #15                 ; trap call
00003614                          4052              
00003614                          4053              
00003614  6000 0002               4054              BRA         printRegMem
00003618                          4055             
00003618                          4056  printRegMem 
00003618  4244                    4057              CLR         D4                  ; Using D4 to store predecrement mode addresses
0000361A  1801                    4058              MOVE.B      D1,D4               ; Stores bits for D0-D7
0000361C                          4059              
0000361C  4245                    4060              CLR         D5                  ; Clear data register
0000361E  1A01                    4061              MOVE.B      D1,D5               ; Move bits containing information on filled data to D5
00003620  CA7C 0001               4062              AND         #mask1,D5           ; Use a bit mask to mask every bit except for the first bit
00003624  BA7C 0001               4063              CMP         #mask1,D5           ; Check if certain bit is 1 or 0
00003628  6700 0076               4064              BEQ         DataReg0            ; If comparison matches, then data register that is being put on stack starts her
0000362C                          4065              
0000362C  4245                    4066              CLR         D5                  ; Clear data register
0000362E  1A01                    4067              MOVE.B      D1,D5               ; Move bits containing information on filled data to D5
00003630  CA7C 0002               4068              AND         #mask2,D5           ; Use a bit mask to mask every bit except for the second bit
00003634  BA7C 0002               4069              CMP         #mask2,D5           ; Check if certain bit is 1 or 0
00003638  6700 0096               4070              BEQ         DataReg1            ; If comparison matches, then data register that is being put on stack starts here
0000363C                          4071  
0000363C  4245                    4072              CLR         D5                  ; Clear data register
0000363E  1A01                    4073              MOVE.B      D1,D5               ; Move bits containing information on filled data to D5
00003640  CA7C 0004               4074              AND         #mask3,D5           ; Use a bit mask to mask every bit except for the third bit
00003644  BA7C 0004               4075              CMP         #mask3,D5           ; Check if certain bit is 1 or 0
00003648  6700 00C6               4076              BEQ         DataReg2            ; If comparison matches, then data register that is being put on stack starts her
0000364C                          4077              
0000364C  4245                    4078              CLR         D5                  ; Clear data register
0000364E  1A01                    4079              MOVE.B      D1,D5               ; Move bits containing information on filled data to D5
00003650  CA7C 0008               4080              AND         #mask4,D5           ; Use a bit mask to mask every bit except for the fourth
00003654  BA7C 0008               4081              CMP         #mask4,D5           ; Check if certain bit is 1 or 0
00003658  6700 00F6               4082              BEQ         DataReg3            ; If comparison matches, then data register that is being put on stack starts her
0000365C                          4083              
0000365C  4245                    4084              CLR         D5                  ; Clear data register
0000365E  1A01                    4085              MOVE.B      D1,D5               ; Move bits containing information on filled address/data to D5
00003660  CA7C 0010               4086              AND         #mask5,D5           ; Use a bit mask to mask every bit except for the fifth bit
00003664  BA7C 0010               4087              CMP         #mask5,D5           ; Check if certain bit is 1 or 0
00003668  6700 0126               4088              BEQ         DataReg4            ; If comparison matches, then data register that is being put on stack starts her
0000366C                          4089  
0000366C  4245                    4090              CLR         D5                  ; Clear data register
0000366E  1A01                    4091              MOVE.B      D1,D5               ; Move bits containing information on filled address/data to D5
00003670  CA7C 0020               4092              AND         #mask6,D5           ; Use a bit mask to mask every bit except for the sixth bit
00003674  BA7C 0020               4093              CMP         #mask6,D5           ; Check if certain bit is 1 or 0
00003678  6700 0156               4094              BEQ         DataReg5            ; If comparison matches, then data register that is being put on stack starts her
0000367C                          4095  
0000367C  4245                    4096              CLR         D5                  ; Clear data register
0000367E  1A01                    4097              MOVE.B      D1,D5               ; Move bits containing information on filled address/data to D5
00003680  CA7C 0040               4098              AND         #mask7,D5           ; Use a bit mask to mask every bit except for the seventh
00003684  BA7C 0040               4099              CMP         #mask7,D5           ; Check if certain bit is 1 or 0
00003688  6700 0186               4100              BEQ         DataReg6            ; If comparison matches, then data register that is being put on stack starts her
0000368C                          4101  
0000368C  4245                    4102              CLR         D5                  ; Clear data register
0000368E  1A01                    4103              MOVE.B      D1,D5               ; Move bits containing information on filled address/data to D5
00003690  CA7C 0080               4104              AND         #mask8,D5           ; Use a bit mask to mask every bit except for the seventh
00003694  BA7C 0080               4105              CMP         #mask8,D5           ; Check if certain bit is 1 or 0
00003698  6700 01B6               4106              BEQ         DataReg7            ; If comparison matches, then only D7 is being used
0000369C                          4107              
0000369C  6000 FEF8               4108              BRA         invalid             ; If comaparisons fail then this is not MOVEM. Branch out.
000036A0                          4109              
000036A0                          4110  DataReg0
000036A0  43F9 000042A8           4111              LEA         dispD0, A1          ; Output string D0
000036A6  103C 000E               4112              MOVE.B      #14, D0             ; command for trap call to display message
000036AA  4E4F                    4113              TRAP        #15                 ; trap call
000036AC                          4114              
000036AC  4245                    4115              CLR         D5                  ; Clear data register
000036AE  1A01                    4116              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000036B0  CA7C 0002               4117              AND         #mask2,D5           ; Uses mask to check for valid after current bit
000036B4  BA7C 0002               4118              CMP         #mask2,D5           ; Check if there are anymore data registers used
000036B8  6700 0006               4119              BEQ         Reg0Cont            ; Continues to check for last register used if so
000036BC  6000 01A2               4120              BRA         printMem            ; Else it will continue on to print the address/memory
000036C0                          4121              
000036C0                          4122  Reg0Cont        
000036C0  43F9 000041F8           4123              LEA         dec, A1             ; Output -
000036C6  103C 000E               4124              MOVE.B      #14, D0             ; command for trap call to display message
000036CA  4E4F                    4125              TRAP        #15                 ; trap call        
000036CC  6000 0002               4126              BRA         DataReg1            ; Found starting register move on to find ending register
000036D0                          4127  
000036D0                          4128  DataReg1
000036D0  4245                    4129              CLR         D5                  ; Clear data register
000036D2  1A01                    4130              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000036D4  CA7C 0005               4131              AND         #maskA,D5           ; Uses mask to check for valid bits before and after current bit
000036D8  BA7C 0005               4132              CMP         #maskA,D5           ; Check if there are bits before and after current masked bit
000036DC  6700 0032               4133              BEQ         DataReg2            ; Branch to skip printing until the end register is found
000036E0                          4134              
000036E0  43F9 000042AB           4135              LEA         dispD1, A1          ; Output string D0
000036E6  103C 000E               4136              MOVE.B      #14, D0             ; command for trap call to display message
000036EA  4E4F                    4137              TRAP        #15                 ; trap call
000036EC                          4138              
000036EC  4245                    4139              CLR         D5                  ; Clear data register
000036EE  1A01                    4140              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000036F0  CA7C 0004               4141              AND         #mask3,D5           ; Bitmasking to check if next bit is used or not
000036F4  BA7C 0004               4142              CMP         #mask3,D5           ; Checking if next bit is use
000036F8  6700 0006               4143              BEQ         Reg1Cont            ; Continues to check for last register used if so
000036FC  6000 0162               4144              BRA         printMem            ; Else it will continue on to print the address/memory
00003700                          4145              
00003700                          4146  Reg1Cont        
00003700  43F9 000041F8           4147              LEA         dec, A1             ; Output -
00003706  103C 000E               4148              MOVE.B      #14, D0             ; command for trap call to display message
0000370A  4E4F                    4149              TRAP        #15                 ; trap call        
0000370C  6000 0002               4150              BRA         DataReg2            ; Found starting register move on to find ending registe
00003710                          4151  
00003710                          4152  DataReg2
00003710  4245                    4153              CLR         D5                  ; Clear data register
00003712  1A01                    4154              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003714  CA7C 000A               4155              AND         #maskB,D5           ; Uses mask to check for valid bits before and after current bit
00003718  BA7C 000A               4156              CMP         #maskB,D5           ; Check if there are bits before and after current masked bit
0000371C  6700 0032               4157              BEQ         DataReg3            ; If there are bits before and after, skip to next register to find ending
00003720                          4158              
00003720                          4159              
00003720  43F9 000042AE           4160              LEA         dispD2, A1          ; Output D2
00003726  103C 000E               4161              MOVE.B      #14, D0             ; command for trap call to display message
0000372A  4E4F                    4162              TRAP        #15                 ; trap call
0000372C                          4163              
0000372C  4245                    4164              CLR         D5                  ; Clear data register
0000372E  1A01                    4165              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003730  CA7C 0008               4166              AND         #mask4,D5           ; Bitmasking to check if next bit is used or not
00003734  BA7C 0008               4167              CMP         #mask4,D5           ; Checking if next bit is used
00003738  6700 0006               4168              BEQ         Reg2Cont            ; Continues to check for last register used if so
0000373C  6000 0122               4169              BRA         printMem            ; Else it will continue on to print the address/memory
00003740                          4170              
00003740                          4171  Reg2Cont        
00003740  43F9 000041F8           4172              LEA         dec, A1             ; Output -
00003746  103C 000E               4173              MOVE.B      #14, D0             ; command for trap call to display message
0000374A  4E4F                    4174              TRAP        #15                 ; trap call        
0000374C  6000 0002               4175              BRA         DataReg3            ; Found starting register move on to find ending registe
00003750                          4176  
00003750                          4177  DataReg3
00003750  4245                    4178              CLR         D5                  ; Clear data register
00003752  1A01                    4179              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003754  CA7C 0014               4180              AND         #maskC,D5           ; Uses mask to check for valid bits before and after current bit
00003758  BA7C 0014               4181              CMP         #maskC,D5           ; Check if there are bits before and after current masked bit
0000375C  6700 0032               4182              BEQ         DataReg4            ; If there are bits before and after, skip to next register to find ending
00003760                          4183      
00003760                          4184              
00003760  43F9 000042B1           4185              LEA         dispD3, A1          ; Output string D0
00003766  103C 000E               4186              MOVE.B      #14, D0             ; command for trap call to display message
0000376A  4E4F                    4187              TRAP        #15                 ; trap call
0000376C                          4188              
0000376C  4245                    4189              CLR         D5                  ; Clear data register
0000376E  1A01                    4190              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003770  CA7C 0010               4191              AND         #mask5,D5           ; Bitmasking to check if next bit is used or not
00003774  BA7C 0010               4192              CMP         #mask5,D5
00003778  6700 0006               4193              BEQ         Reg3Cont            ; Continues to check for last register used if so
0000377C  6000 00E2               4194              BRA         printMem            ; Else it will continue on to print the address/memory
00003780                          4195              
00003780                          4196  Reg3Cont        
00003780  43F9 000041F8           4197              LEA         dec, A1             ; Output -
00003786  103C 000E               4198              MOVE.B      #14, D0             ; command for trap call to display message
0000378A  4E4F                    4199              TRAP        #15                 ; trap call        
0000378C  6000 0002               4200              BRA         DataReg4            ; Found starting register move on to find ending registe
00003790                          4201  
00003790                          4202  DataReg4
00003790  4245                    4203              CLR         D5                  ; Clear data register
00003792  1A01                    4204              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003794  CA7C 0028               4205              AND         #maskD,D5           ; Uses mask to check for valid bits before and after current bit
00003798  BA7C 0028               4206              CMP         #maskD,D5           ; Check if there are bits before and after current masked bit
0000379C  6700 0032               4207              BEQ         DataReg5            ; If there are bits before and after, skip to next register to find ending
000037A0                          4208              
000037A0  43F9 000042B4           4209              LEA         dispD4, A1          ; Output string D0
000037A6  103C 000E               4210              MOVE.B      #14, D0             ; command for trap call to display message
000037AA  4E4F                    4211              TRAP        #15                 ; trap call
000037AC                          4212              
000037AC  4245                    4213              CLR         D5                  ; Clear data register
000037AE  1A01                    4214              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000037B0  CA7C 0020               4215              AND         #mask6,D5           ; Bitmasking to check if next bit is used or not
000037B4  BA7C 0020               4216              CMP         #mask6,D5           ; Checking if next bit is use
000037B8  6700 0006               4217              BEQ         Reg4Cont            ; Continues to check for last register used if so
000037BC  6000 00A2               4218              BRA         printMem            ; Else it will continue on to print the address/memory
000037C0                          4219              
000037C0                          4220  Reg4Cont        
000037C0  43F9 000041F8           4221              LEA         dec, A1             ; Output -
000037C6  103C 000E               4222              MOVE.B      #14, D0             ; command for trap call to display message
000037CA  4E4F                    4223              TRAP        #15                 ; trap call        
000037CC  6000 0002               4224              BRA         DataReg5            ; Found starting register move on to find ending registe
000037D0                          4225  
000037D0                          4226  DataReg5
000037D0  4245                    4227              CLR         D5                  ; Clear data register
000037D2  1A01                    4228              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000037D4  CA7C 0050               4229              AND         #maskE,D5           ; Uses mask to check for valid bits before and after current bit
000037D8  BA7C 0050               4230              CMP         #maskE,D5           ; Check if there are bits before and after current masked bit
000037DC  6700 0032               4231              BEQ         DataReg6            ; If there are bits before and after, skip to next register to find ending
000037E0                          4232              
000037E0  43F9 000042B7           4233              LEA         dispD5, A1          ; Output string D0
000037E6  103C 000E               4234              MOVE.B      #14, D0             ; command for trap call to display message
000037EA  4E4F                    4235              TRAP        #15                 ; trap call
000037EC                          4236              
000037EC  4245                    4237              CLR         D5                  ; Clear data register
000037EE  1A01                    4238              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000037F0  CA7C 0040               4239              AND         #mask7,D5           ; Bitmasking to check if next bit is used or not
000037F4  BA7C 0040               4240              CMP         #mask7,D5           ; Checking if next bit is use
000037F8  6700 0006               4241              BEQ         Reg5Cont            ; Continues to check for last register used if so
000037FC  6000 0062               4242              BRA         printMem            ; Else it will continue on to print the address/memory
00003800                          4243              
00003800                          4244  Reg5Cont        
00003800  43F9 000041F8           4245              LEA         dec, A1             ; Output -
00003806  103C 000E               4246              MOVE.B      #14, D0             ; command for trap call to display message
0000380A  4E4F                    4247              TRAP        #15                 ; trap call        
0000380C  6000 0042               4248              BRA         DataReg7            ; Found starting register move on to find ending registe
00003810                          4249  
00003810                          4250  DataReg6
00003810  4245                    4251              CLR         D5                  ; Clear data register
00003812  1A01                    4252              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003814  CA7C 00A0               4253              AND         #maskF,D5           ; Uses mask to check for valid bits before and after current bit
00003818  BA7C 00A0               4254              CMP         #maskF,D5           ; Check if there are bits before and after current masked bit
0000381C  6700 0032               4255              BEQ         DataReg7            ; If there are bits before and after, skip to next register to find ending
00003820                          4256  
00003820  43F9 000042BA           4257              LEA         dispD6, A1          ; Output string D0
00003826  103C 000E               4258              MOVE.B      #14, D0             ; command for trap call to display message
0000382A  4E4F                    4259              TRAP        #15                 ; trap call
0000382C                          4260              
0000382C  4245                    4261              CLR         D5                  ; Clear data register
0000382E  1A01                    4262              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003830  CA7C 0080               4263              AND         #mask8,D5           ; Bitmasking to check if next bit is used or not
00003834  BA7C 0080               4264              CMP         #mask8,D5           ; Checking if next bit is use
00003838  6700 0006               4265              BEQ         Reg6Cont            ; Continues to check for last register used if so
0000383C  6000 0022               4266              BRA         printMem            ; Else it will continue on to print the address/memory
00003840                          4267              
00003840                          4268  Reg6Cont        
00003840  43F9 000041F8           4269              LEA         dec, A1             ; Output -
00003846  103C 000E               4270              MOVE.B      #14, D0             ; command for trap call to display message
0000384A  4E4F                    4271              TRAP        #15                 ; trap call        
0000384C  6000 0002               4272              BRA         DataReg7            ; Found starting register move on to find ending registe
00003850                          4273  
00003850                          4274  DataReg7    
00003850  43F9 000042BD           4275              LEA         dispD7, A1          ; Output -
00003856  103C 000E               4276              MOVE.B      #14, D0             ; command for trap call to display message
0000385A  4E4F                    4277              TRAP        #15                 ; trap call        
0000385C  6000 0002               4278              BRA         printMem            ; Last check, branch to print out the address register     
00003860                          4279              
00003860                          4280  printMem                                    ; Made this function in order to reuse if DR is 1
00003860  6000 0002               4281              BRA         printMemNow         ; Branch out to printMemNow
00003864                          4282              
00003864                          4283  printMemNow                           
00003864  43F9 0000427E           4284              LEA         slash, A1           ; Display slash
0000386A  103C 000E               4285              MOVE.B      #14, D0             ; command for trap call to display message
0000386E  4E4F                    4286              TRAP        #15                 ; trap call
00003870                          4287           
00003870  4244                    4288              CLR         D4                  ; Using D4 to store predecrement mode addresses
00003872  3801                    4289              MOVE.W      D1,D4               ; Stores bits for D0-D7
00003874  E044                    4290              ASR         #eight,D4           ; Rotate to the right, to create space for next byte
00003876                          4291              
00003876  4245                    4292              CLR         D5                  ; Clear space
00003878  1A04                    4293              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
0000387A  CA7C 0001               4294              AND         #mask1,D5           ; Use a bit mask to mask every bit except for the first bit
0000387E  BA7C 0001               4295              CMP         #mask1,D5           ; Check if certain bit is 1 or 0
00003882  6700 0072               4296              BEQ         AddrReg0            ; If comparison matches, then address register that is being put on stack starts here
00003886                          4297              
00003886  4245                    4298              CLR         D5                  ; Clear data register 
00003888  1A04                    4299              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
0000388A  CA7C 0002               4300              AND         #mask2,D5           ; Use a bit mask to mask every bit except for the second bit
0000388E  BA7C 0002               4301              CMP         #mask2,D5           ; Check if certain bit is 1 or 0
00003892  6700 0092               4302              BEQ         AddrReg1            ; If comparison matches, then address register that is being put on stack starts here
00003896                          4303  
00003896  4245                    4304              CLR         D5                  ; Clear data register
00003898  1A04                    4305              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
0000389A  CA7C 0004               4306              AND         #mask3,D5           ; Use a bit mask to mask every bit except for the third
0000389E  BA7C 0004               4307              CMP         #mask3,D5           ; Check if certain bit is 1 or 0
000038A2  6700 00C2               4308              BEQ         AddrReg2            ; If comparison matches, then address register that is being put on stack starts here         
000038A6                          4309              
000038A6  4245                    4310              CLR         D5                  ; Clear data register
000038A8  1A04                    4311              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
000038AA  CA7C 0008               4312              AND         #mask4,D5           ; Use a bit mask to mask every bit except for the fourth bit
000038AE  BA7C 0008               4313              CMP         #mask4,D5           ; Check if certain bit is 1 or 0
000038B2  6700 00F2               4314              BEQ         AddrReg3            ; If comparison matches, then address register that is being put on stack starts here     
000038B6                          4315                  
000038B6  4245                    4316              CLR         D5                  ; Clear data register
000038B8  1A04                    4317              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
000038BA  CA7C 0010               4318              AND         #mask5,D5           ; Use a bit mask to mask every bit except for the fifth bit
000038BE  BA7C 0010               4319              CMP         #mask5,D5           ; Check if certain bit is 1 or 0
000038C2  6700 0122               4320              BEQ         AddrReg4            ; If comparison matches, then address register that is being put on stack starts here
000038C6                          4321  
000038C6  4245                    4322              CLR         D5                  ; Clear data register
000038C8  1A04                    4323              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
000038CA  CA7C 0020               4324              AND         #mask6,D5           ; Use a bit mask to mask every bit except for the sixth bit
000038CE  BA7C 0020               4325              CMP         #mask6,D5           ; Check if certain bit is 1 or 0
000038D2  6700 0152               4326              BEQ         AddrReg5            ; If comparison matches, then address register that is being put on stack starts here
000038D6                          4327  
000038D6  4245                    4328              CLR         D5                  ; Clear data register
000038D8  1A04                    4329              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
000038DA  CA7C 0040               4330              AND         #mask7,D5           ; Use a bit mask to mask every bit except for the seventh bit
000038DE  BA7C 0040               4331              CMP         #mask7,D5           ; Check if certain bit is 1 or 0
000038E2  6700 0182               4332              BEQ         AddrReg6            ; If comparison matches, then address register that is being put on stack starts here
000038E6                          4333  
000038E6  4245                    4334              CLR         D5                  ; Clear data register
000038E8  1A04                    4335              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
000038EA  CA7C 0080               4336              AND         #mask8,D5           ; Use a bit mask to mask every bit except for the last bit
000038EE  BA7C 0080               4337              CMP         #mask8,D5           ; Check if certain bit is 1 or 0
000038F2  6700 01B2               4338              BEQ         AddrReg7            ; If comparison matches, then address register that is being put on stack starts here
000038F6                          4339              
000038F6                          4340  AddrReg0
000038F6                          4341  
000038F6  43F9 0000428E           4342              LEA         dispA0, A1          ; Output string D0
000038FC  103C 000E               4343              MOVE.B      #14, D0             ; command for trap call to display message
00003900  4E4F                    4344              TRAP        #15                 ; trap call
00003902                          4345              
00003902  4245                    4346              CLR         D5                  ; Clear data register
00003904  1A01                    4347              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003906  CA7C 0002               4348              AND         #mask2,D5           ; Bitmasking to check if next bit is used or not
0000390A  BA7C 0002               4349              CMP         #mask2,D5           ; Checking if next bit is use
0000390E  6700 0006               4350              BEQ         Addr0Cont           ; Continues to check for last register used if so
00003912  6000 01A2               4351              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
00003916                          4352              
00003916                          4353  Addr0Cont        
00003916  43F9 000041F8           4354              LEA         dec, A1             ; Output -
0000391C  103C 000E               4355              MOVE.B      #14, D0             ; command for trap call to display message
00003920  4E4F                    4356              TRAP        #15                 ; trap call        
00003922  6000 0002               4357              BRA         AddrReg1            ; Branch to second address
00003926                          4358  
00003926                          4359  AddrReg1
00003926  4245                    4360              CLR         D5                  ; Clear data register
00003928  1A04                    4361              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
0000392A  CA7C 0005               4362              AND         #maskA,D5           ; Uses mask to check for valid bits before and after current bit
0000392E  BA7C 0005               4363              CMP         #maskA,D5           ; Check if there are bits before and after current masked bit
00003932  6700 0032               4364              BEQ         AddrReg2            ; Skip print and move to next address to check if it the last address used
00003936                          4365              
00003936  43F9 00004291           4366              LEA         dispA1, A1          ; Output string D0
0000393C  103C 000E               4367              MOVE.B      #14, D0             ; command for trap call to display message
00003940  4E4F                    4368              TRAP        #15                 ; trap call
00003942                          4369              
00003942  4245                    4370              CLR         D5                  ; Clear data register
00003944  1A04                    4371              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003946  CA7C 0004               4372              AND         #mask3,D5           ; Bitmasking to check if next bit is used or not
0000394A  BA7C 0004               4373              CMP         #mask3,D5           ; Checking if next bit is use
0000394E  6700 0006               4374              BEQ         Addr1Cont           ; Continues to check for last register used if so
00003952  6000 0162               4375              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
00003956                          4376              
00003956                          4377  Addr1Cont        
00003956  43F9 000041F8           4378              LEA         dec, A1             ; Output -
0000395C  103C 000E               4379              MOVE.B      #14, D0             ; command for trap call to display message
00003960  4E4F                    4380              TRAP        #15                 ; trap call        
00003962  6000 0002               4381              BRA         AddrReg2            ; Skip print and move to next address to check if it the last address used    
00003966                          4382  
00003966                          4383  AddrReg2
00003966  4245                    4384              CLR         D5                  ; Clear data register
00003968  1A04                    4385              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
0000396A  CA7C 000A               4386              AND         #maskB,D5           ; Uses mask to check for valid bits before and after current bit
0000396E  BA7C 000A               4387              CMP         #maskB,D5           ; Check if there are bits before and after current masked bit
00003972  6700 0032               4388              BEQ         AddrReg3            ; If there are bits before and after, skip to next register to find ending
00003976                          4389  
00003976                          4390              
00003976  43F9 00004294           4391              LEA         dispA2, A1          ; Output string D0
0000397C  103C 000E               4392              MOVE.B      #14, D0             ; command for trap call to display message
00003980  4E4F                    4393              TRAP        #15                 ; trap call
00003982                          4394              
00003982  4245                    4395              CLR         D5                  ; Clear data register
00003984  1A04                    4396              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003986  CA7C 0008               4397              AND         #mask4,D5           ; Bitmasking to check if next bit is used or not
0000398A  BA7C 0008               4398              CMP         #mask4,D5           ; Checking if next bit is use
0000398E  6700 0006               4399              BEQ         Addr2Cont           ; Continues to check for last register used if so
00003992  6000 0122               4400              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
00003996                          4401              
00003996                          4402  Addr2Cont        
00003996  43F9 000041F8           4403              LEA         dec, A1             ; Output -
0000399C  103C 000E               4404              MOVE.B      #14, D0             ; command for trap call to display message
000039A0  4E4F                    4405              TRAP        #15                 ; trap call        
000039A2  6000 0002               4406              BRA         AddrReg3            ; Skip print and move to next address to check if it the last address used
000039A6                          4407  
000039A6                          4408  AddrReg3
000039A6  4245                    4409              CLR         D5                  ; Clear data register
000039A8  1A04                    4410              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
000039AA  CA7C 0014               4411              AND         #maskC,D5           ; Uses mask to check for valid bits before and after current bit
000039AE  BA7C 0014               4412              CMP         #maskC,D5           ; Check if there are bits before and after current masked bit
000039B2  6700 0032               4413              BEQ         AddrReg4            ; If there are bits before and after, skip to next register to find ending
000039B6                          4414              
000039B6  43F9 00004297           4415              LEA         dispA3, A1          ; Output string D0
000039BC  103C 000E               4416              MOVE.B      #14, D0             ; command for trap call to display message
000039C0  4E4F                    4417              TRAP        #15                 ; trap call
000039C2                          4418              
000039C2  4245                    4419              CLR         D5                  ; Clear data register
000039C4  1A04                    4420              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
000039C6  CA7C 0010               4421              AND         #mask5,D5           ; Bitmasking to check if next bit is used or not  
000039CA  BA7C 0010               4422              CMP         #mask5,D5           ; Checking if next bit is use
000039CE  6700 0006               4423              BEQ         Addr3Cont           ; Continues to check for last register used if so
000039D2  6000 00E2               4424              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
000039D6                          4425              
000039D6                          4426  Addr3Cont        
000039D6  43F9 000041F8           4427              LEA         dec, A1             ; Output -
000039DC  103C 000E               4428              MOVE.B      #14, D0             ; command for trap call to display message
000039E0  4E4F                    4429              TRAP        #15                 ; trap call        
000039E2  6000 0002               4430              BRA         AddrReg4
000039E6                          4431  
000039E6                          4432  AddrReg4
000039E6  4245                    4433              CLR         D5                  ; Clear data register
000039E8  1A04                    4434              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
000039EA  CA7C 0028               4435              AND         #maskD,D5           ; Uses mask to check for valid bits before and after current bit
000039EE  BA7C 0028               4436              CMP         #maskD,D5           ; Check if there are bits before and after current masked bit
000039F2  6700 0032               4437              BEQ         AddrReg5            ; If there are bits before and after, skip to next register to find ending
000039F6                          4438              
000039F6  43F9 0000429A           4439              LEA         dispA4, A1          ; Output string D0
000039FC  103C 000E               4440              MOVE.B      #14, D0             ; command for trap call to display message
00003A00  4E4F                    4441              TRAP        #15                 ; trap call
00003A02                          4442              
00003A02  4245                    4443              CLR         D5                  ; Clear data register
00003A04  1A04                    4444              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003A06  CA7C 0020               4445              AND         #mask6,D5           ; Bitmasking to check if next bit is used or not 
00003A0A  BA7C 0020               4446              CMP         #mask6,D5           ; Checking if next bit is use
00003A0E  6700 0006               4447              BEQ         Addr4Cont           ; Continues to check for last register used if so
00003A12  6000 00A2               4448              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
00003A16                          4449              
00003A16                          4450  Addr4Cont        
00003A16  43F9 000041F8           4451              LEA         dec, A1             ; Output -
00003A1C  103C 000E               4452              MOVE.B      #14, D0             ; command for trap call to display message
00003A20  4E4F                    4453              TRAP        #15                 ; trap call        
00003A22  6000 0002               4454              BRA         AddrReg5
00003A26                          4455  AddrReg5
00003A26  4245                    4456              CLR         D5                  ; Clear data register
00003A28  1A04                    4457              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003A2A  CA7C 0050               4458              AND         #maskE,D5           ; Uses mask to check for valid bits before and after current bit
00003A2E  BA7C 0050               4459              CMP         #maskE,D5           ; Check if there are bits before and after current masked bit
00003A32  6700 0032               4460              BEQ         AddrReg6            ; If there are bits before and after, skip to next register to find ending
00003A36                          4461              
00003A36  43F9 0000429D           4462              LEA         dispA5, A1          ; Output string D0
00003A3C  103C 000E               4463              MOVE.B      #14, D0             ; command for trap call to display message
00003A40  4E4F                    4464              TRAP        #15                 ; trap call
00003A42                          4465              
00003A42  4245                    4466              CLR         D5                  ; Clear data register
00003A44  1A04                    4467              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003A46  CA7C 0040               4468              AND         #mask7,D5           ; Bitmasking to check if next bit is used or not
00003A4A  BA7C 0040               4469              CMP         #mask7,D5           ; Checking if next bit is use
00003A4E  6700 0006               4470              BEQ         Addr5Cont           ; Continues to check for last register used if so
00003A52  6000 0062               4471              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
00003A56                          4472              
00003A56                          4473  Addr5Cont        
00003A56  43F9 000041F8           4474              LEA         dec, A1             ; Output -
00003A5C  103C 000E               4475              MOVE.B      #14, D0             ; command for trap call to display message
00003A60  4E4F                    4476              TRAP        #15                 ; trap call        
00003A62  6000 0042               4477              BRA         AddrReg7
00003A66                          4478  
00003A66                          4479  AddrReg6
00003A66  4245                    4480              CLR         D5                  ; Clear data register
00003A68  1A04                    4481              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003A6A  CA7C 00A0               4482              AND         #maskF,D5           ; Uses mask to check for valid bits before and after current bit
00003A6E  BA7C 00A0               4483              CMP         #maskF,D5           ; Check if there are bits before and after current masked bit
00003A72  6700 0032               4484              BEQ         AddrReg7            ; If there are bits before and after, skip to next register to find ending
00003A76                          4485  
00003A76  43F9 000042A0           4486              LEA         dispA6, A1          ; Output string D0
00003A7C  103C 000E               4487              MOVE.B      #14, D0             ; command for trap call to display message
00003A80  4E4F                    4488              TRAP        #15                 ; trap call
00003A82                          4489              
00003A82  4245                    4490              CLR         D5                  ; Clear data register
00003A84  1A04                    4491              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003A86  CA7C 0080               4492              AND         #mask8,D5           ; Bitmasking to check if next bit is used or not
00003A8A  BA7C 0080               4493              CMP         #mask8,D5           ; Checking if next bit is use
00003A8E  6700 0006               4494              BEQ         Addr6Cont           ; Continues to check for last register used if so
00003A92  6000 0022               4495              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
00003A96                          4496              
00003A96                          4497  Addr6Cont        
00003A96  43F9 000041F8           4498              LEA         dec, A1             ; Output -
00003A9C  103C 000E               4499              MOVE.B      #14, D0             ; command for trap call to display message
00003AA0  4E4F                    4500              TRAP        #15                 ; trap call        
00003AA2  6000 0002               4501              BRA         AddrReg7            ; Skip print and move to next address to check if it the last address used
00003AA6                          4502  
00003AA6                          4503  AddrReg7    
00003AA6  43F9 000042A3           4504              LEA         dispA7, A1          ; Output -
00003AAC  103C 000E               4505              MOVE.B      #14, D0             ; command for trap call to display message
00003AB0  4E4F                    4506              TRAP        #15                 ; trap call        
00003AB2  6000 0002               4507              BRA         endMOVE             ; Skip print and move to next address to check if it the last address used
00003AB6                          4508          
00003AB6                          4509  endMOVE
00003AB6  4CDF 7EFF               4510              MOVEM.L  (SP)+, D0-D7/A1-A6     ; Pops all data and address register off the stack
00003ABA  4E75                    4511              RTS
00003ABC                          4512  endMove1                                    ; Used if MOVEM has DR is 1
00003ABC  4CDF 7EFF               4513              MOVEM.L  (SP)+, D0-D7/A1-A6
00003AC0  4E75                    4514              RTS
00003AC2                          4515  ***********************************************************************************************************
00003AC2                          4516  *
00003AC2                          4517  *                       Hex Decode
00003AC2                          4518  *
00003AC2                          4519  *this subroutine displays hex code stored in D1. It displays based on the number of 
00003AC2                          4520  *It displays based on the number of hex to display which is stored in D0. If it is a
00003AC2                          4521  *long or word to display, it will figure out the ascii character and add $37 if it
00003AC2                          4522  *is a letter, and $30 if its a number. It will then load the character into D1 and 
00003AC2                          4523  *display it via trap task 6 and loop however many times is needed, 4 or 8. If a word
00003AC2                          4524  *needs to be displayed, it will roll the bits over so that, the hex are shifted by a word.
00003AC2                          4525  *
00003AC2                          4526  ***********************************************************************************************************
00003AC2                          4527  
00003AC2                          4528  outHex      
00003AC2  48E7 FF7E               4529              MOVEM.L     D0-D7/A1-A6, -(SP)
00003AC6  4243                    4530              CLR         D3
00003AC8  4244                    4531              CLR         D4
00003ACA  1800                    4532              MOVE.B      D0, D4
00003ACC  2601                    4533              MOVE.L      D1, D3
00003ACE  B03C 0004               4534              CMP.B       #4, D0
00003AD2  6700 0006               4535              BEQ         moveOver
00003AD6  6000 0006               4536              BRA         dispLOOP
00003ADA                          4537              
00003ADA                          4538  moveOver    
00003ADA  E19B                    4539              ROL.L       #8,D3
00003ADC  E19B                    4540              ROL.L       #8,D3
00003ADE                          4541              
00003ADE                          4542  dispLOOP    
00003ADE  B83C 0000               4543              CMP.B       #0, D4
00003AE2  6700 0042               4544              BEQ         endDispSub
00003AE6  E99B                    4545              ROL.L       #4, D3
00003AE8  4245                    4546              CLR         D5
00003AEA  1A03                    4547              MOVE.B      D3, D5 
00003AEC  CABC 0000000F           4548              AND.L       #$0F, D5
00003AF2  BA3C 000A               4549              CMP.B       #10, D5
00003AF6  6D00 0006               4550              BLT         DLnine
00003AFA  6000 0016               4551              BRA         DLetters
00003AFE                          4552              
00003AFE                          4553  DLnine      
00003AFE  0645 0030               4554              ADD         #$30, D5
00003B02  4241                    4555              CLR         D1
00003B04  1205                    4556              MOVE.B      D5, D1
00003B06  4240                    4557              CLR         D0
00003B08  103C 0006               4558              MOVE.B      #6, D0
00003B0C  4E4F                    4559              TRAP        #15
00003B0E  5344                    4560              SUB         #1, D4
00003B10  60CC                    4561              BRA         dispLOOP  
00003B12                          4562   
00003B12                          4563  DLetters    
00003B12  0645 0037               4564              ADD         #$37, D5
00003B16  4241                    4565              CLR         D1
00003B18  1205                    4566              MOVE.B      D5, D1
00003B1A  4240                    4567              CLR         D0
00003B1C  103C 0006               4568              MOVE.B      #6, D0
00003B20  4E4F                    4569              TRAP        #15
00003B22  5344                    4570              SUB         #1, D4
00003B24  60B8                    4571              BRA         dispLOOP        
00003B26                          4572  
00003B26                          4573  endDispSub  
00003B26  4CDF 7EFF               4574              MOVEM.L     (SP)+, D0-D7/A1-A6
00003B2A  4E75                    4575              RTS
00003B2C                          4576  
00003B2C                          4577              
00003B2C                          4578  ***********************************************************************************************************
00003B2C                          4579  *
00003B2C                          4580  *                       IO Subroutine
00003B2C                          4581  *
00003B2C                          4582  *
00003B2C                          4583  *   the following subroutine gets the string address from the user
00003B2C                          4584  *   and converts it to Hex for a starting/ending address. it is done 
00003B2C                          4585  *   by checking each byte at address A1, and converting it from ascii to 
00003B2C                          4586  *   hex number. If the user enters an invalid character string, the
00003B2C                          4587  *   program will have a simhalt.
00003B2C                          4588  *
00003B2C                          4589  ***********************************************************************************************************
00003B2C                          4590  
00003B2C                          4591  
00003B2C                          4592  Address                                     
00003B2C  48E7 1F3E               4593              MOVEM.L     D3-D7/A2-A6, -(SP)
00003B30                          4594  
00003B30                          4595  Retry       
00003B30  4242                    4596              CLR         D2
00003B32  4243                    4597              CLR         D3
00003B34  B23C 0004               4598              CMP.B       #4, D1
00003B38  6700 000E               4599              BEQ         subLOOP
00003B3C  B23C 0008               4600              CMP.B       #8, D1
00003B40  6700 0006               4601              BEQ         subLOOP
00003B44  6000 012A               4602              BRA         ADDinvalid        
00003B48                          4603          
00003B48                          4604  subLOOP     
00003B48  E85C                    4605              ROR         #4, D4
00003B4A  1404                    4606              MOVE.B      D4, D2
00003B4C  4244                    4607              CLR         D4
00003B4E  4245                    4608              CLR         D5
00003B50  B601                    4609              CMP.B       D1, D3
00003B52  6700 0132               4610              BEQ         endLOOP
00003B56  5443                    4611              ADD.W       #2, D3
00003B58  E19A                    4612              ROL.L       #8, D2
00003B5A                          4613          
00003B5A                          4614  bytLOOP     
00003B5A  E95C                    4615              ROL         #4, D4
00003B5C                          4616          
00003B5C  0C11 0030               4617              CMP.B       #$30, (A1)
00003B60  6700 007E               4618              BEQ         hZero 
00003B64  0C11 0031               4619              CMP.B       #$31, (A1)
00003B68  6700 007E               4620              BEQ         hOne
00003B6C  0C11 0032               4621              CMP.B       #$32, (A1)
00003B70  6700 007E               4622              BEQ         hTwo
00003B74  0C11 0033               4623              CMP.B       #$33, (A1)
00003B78  6700 007E               4624              BEQ         hThree
00003B7C  0C11 0034               4625              CMP.B       #$34, (A1)
00003B80  6700 007E               4626              BEQ         hFour
00003B84  0C11 0035               4627              CMP.B       #$35, (A1)
00003B88  6700 007E               4628              BEQ         hFive
00003B8C  0C11 0036               4629              CMP.B       #$36, (A1)
00003B90  6700 007E               4630              BEQ         hSix
00003B94  0C11 0037               4631              CMP.B       #$37, (A1)
00003B98  6700 007E               4632              BEQ         hSeven
00003B9C  0C11 0038               4633              CMP.B       #$38, (A1)
00003BA0  6700 007E               4634              BEQ         hEight
00003BA4  0C11 0039               4635              CMP.B       #$39, (A1)
00003BA8  6700 007E               4636              BEQ         hNine
00003BAC  0C11 0041               4637              CMP.B       #$41, (A1)
00003BB0  6700 007E               4638              BEQ         hA
00003BB4  0C11 0042               4639              CMP.B       #$42, (A1)
00003BB8  6700 007E               4640              BEQ         hB
00003BBC  0C11 0043               4641              CMP.B       #$43, (A1)
00003BC0  6700 007E               4642              BEQ         hC
00003BC4  0C11 0044               4643              CMP.B       #$44, (A1)
00003BC8  6700 007E               4644              BEQ         hD
00003BCC  0C11 0045               4645              CMP.B       #$45, (A1)
00003BD0  6700 007E               4646              BEQ         hE
00003BD4  0C11 0046               4647              CMP.B       #$46, (A1)
00003BD8  6700 007E               4648              BEQ         hF 
00003BDC                          4649              
00003BDC  6000 F9B8               4650              BRA         invalid 
00003BE0                          4651              
00003BE0                          4652  hZero       
00003BE0  183C 0000               4653              MOVE.B      #$00, D4
00003BE4  6000 007A               4654              BRA         nextH
00003BE8                          4655              
00003BE8                          4656  hOne        
00003BE8  183C 0010               4657              MOVE.B      #$10, D4
00003BEC  6000 0072               4658              BRA         nextH
00003BF0                          4659  hTwo        
00003BF0  183C 0020               4660              MOVE.B      #$20, D4
00003BF4  6000 006A               4661              BRA         nextH
00003BF8                          4662              
00003BF8                          4663  hThree      
00003BF8  183C 0030               4664              MOVE.B      #$30, D4
00003BFC  6000 0062               4665              BRA         nextH
00003C00                          4666              
00003C00  183C 0040               4667  hFour       MOVE.B      #$40, D4
00003C04  6000 005A               4668              BRA         nextH
00003C08                          4669              
00003C08                          4670  hFive       
00003C08  183C 0050               4671              MOVE.B      #$50, D4
00003C0C  6000 0052               4672              BRA         nextH
00003C10                          4673              
00003C10                          4674  hSix        
00003C10  183C 0060               4675              MOVE.B      #$60, D4
00003C14  6000 004A               4676              BRA         nextH
00003C18                          4677              
00003C18                          4678  hSeven      
00003C18  183C 0070               4679              MOVE.B      #$70, D4
00003C1C  6000 0042               4680              BRA         nextH
00003C20                          4681              
00003C20                          4682  hEight      
00003C20  183C 0080               4683              MOVE.B      #$80, D4
00003C24  6000 003A               4684              BRA         nextH
00003C28                          4685              
00003C28                          4686  hNine       
00003C28  183C 0090               4687              MOVE.B      #$90, D4
00003C2C  6000 0032               4688              BRA         nextH
00003C30                          4689          
00003C30                          4690  hA          
00003C30  183C 00A0               4691              MOVE.B      #$A0, D4
00003C34  6000 002A               4692              BRA         nextH
00003C38                          4693              
00003C38                          4694  hB          
00003C38  183C 00B0               4695              MOVE.B      #$B0, D4
00003C3C  6000 0022               4696              BRA         nextH
00003C40                          4697              
00003C40                          4698  hC          
00003C40  183C 00C0               4699              MOVE.B      #$C0, D4
00003C44  6000 001A               4700              BRA         nextH
00003C48                          4701              
00003C48                          4702  hD          
00003C48  183C 00D0               4703              MOVE.B      #$D0, D4
00003C4C  6000 0012               4704              BRA         nextH
00003C50                          4705              
00003C50                          4706  hE          
00003C50  183C 00E0               4707              MOVE.B      #$E0, D4
00003C54  6000 000A               4708              BRA         nextH
00003C58                          4709              
00003C58                          4710  hF          
00003C58  183C 00F0               4711              MOVE.B      #$F0, D4
00003C5C  6000 0002               4712              BRA         nextH
00003C60                          4713  
00003C60                          4714  nextH       
00003C60  1019                    4715              MOVE.B      (A1)+, D0
00003C62  5245                    4716              ADD         #1, D5
00003C64  BA3C 0002               4717              CMP.B       #2, D5
00003C68  6700 FEDE               4718              BEQ         subLOOP
00003C6C  6000 FEEC               4719              BRA         bytLOOP
00003C70                          4720          
00003C70                          4721  ADDinvalid  
00003C70  43F9 000041C8           4722              LEA         errorMessage, A1
00003C76  103C 000E               4723              MOVE.B      #14, D0
00003C7A  4E4F                    4724              TRAP        #15    
00003C7C                          4725      
00003C7C  103C 0002               4726              MOVE.B      #2, D0
00003C80  4E4F                    4727              TRAP        #15
00003C82                          4728  
00003C82  6000 FEAC               4729              BRA         Retry
00003C86                          4730     
00003C86                          4731  endLOOP     
00003C86  4CDF 7CF8               4732              MOVEM.L     (SP)+, D3-D7/A2-A6
00003C8A  4E75                    4733              RTS
00003C8C                          4734  
00003C8C                          4735  printInvalid
00003C8C  1218                    4736              MOVE.B      (A0)+,D1
00003C8E  6000 D3B6               4737              BRA         LOOP
00003C92                          4738  
00003C92                          4739  endPROG    
00003C92                          4740  
00003C92  FFFF FFFF               4741      SIMHALT                             ; halt simulator
00003C96                          4742  
00003C96                          4743  ***********************************************************************************************************
00003C96                          4744  *
00003C96                          4745  *                       Start Menu
00003C96                          4746  *           
00003C96                          4747  *       This section prints out in the beginning of the program.
00003C96                          4748  *
00003C96                          4749  ***********************************************************************************************************
00003C96                          4750  displayStart
00003C96  48E7 FFFF               4751              MOVEM.L     D0-D7/A0-A7, -(SP)
00003C9A                          4752              
00003C9A  43F9 00003CAC           4753              LEA         Title,A1
00003CA0  103C 000E               4754              MOVE.B      #14,D0
00003CA4  4E4F                    4755              TRAP        #15
00003CA6                          4756              
00003CA6  4CDF FFFF               4757              MOVEM.L     (SP)+, D0-D7/A0-A7
00003CAA  4E75                    4758              RTS
00003CAC                          4759              
00003CAC                          4760  Title       
00003CAC= 2A 2A 2A 2A 20 20 ...   4761              DC.B       '****       ****  *******     ****    ***      ***',CR,LF
00003CDF= 2A 2A 2A 2A 20 20 ...   4762              DC.B       '****       **** *******    ********  ***     ***',CR,LF
00003D11= 2A 2A 2A 2A 2A 20 ...   4763              DC.B       '*****     ***** ***       ***    *** ***    ***',CR,LF
00003D42= 2A 2A 2A 2A 2A 2A ...   4764              DC.B       '******   ****** ***       ***    *** ***   ***',CR,LF
00003D72= 2A 2A 2A 2A 2A 2A ...   4765              DC.B       '******* ******* ***        ********  ***  ***',CR,LF
00003DA1= 2A 2A 2A 2A 2A 2A ...   4766              DC.B       '*************** *******     ******   ********',CR,LF
00003DD0= 2A 2A 2A 2A 20 20 ...   4767              DC.B       '****  ***  **** ********   ********  ***  ***',CR,LF
00003DFF= 2A 2A 2A 2A 20 20 ...   4768              DC.B       '****   *   **** ***   *** ***    *** ***   ***',CR,LF 
00003E2F= 2A 2A 2A 2A 20 20 ...   4769              DC.B       '****       **** ***   *** ***    *** ***    ***',CR,LF
00003E60= 2A 2A 2A 2A 20 20 ...   4770              DC.B       '****       **** ***   ***  ********  ***     ***',CR,LF
00003E92= 2A 2A 2A 2A 20 20 ...   4771              DC.B       '****       ****  *******     ****    ***      ***',CR,LF
00003EC5                          4772      
00003EC5= 20 20 20 20 2A 2A ...   4773              DC.B                '    *********          ********** ****       ****',CR,LF
00003EF8= 20 20 20 20 2A 2A ...   4774              DC.B                '    ***********      *********    ****       ****',CR,LF
00003F2B= 20 20 20 20 2A 2A ...   4775              DC.B                '    ***    *****   *********      *****     *****',CR,LF
00003F5E= 20 20 20 20 2A 2A ...   4776              DC.B                '    ***      **** ********        ******   ******',CR,LF
00003F91= 20 20 20 20 2A 2A ...   4777              DC.B                '    ***       *** ************    ******* *******',CR,LF
00003FC4= 20 20 20 20 2A 2A ...   4778              DC.B                '    ***       *** *************** ***************',CR,LF
00003FF7= 20 20 20 20 2A 2A ...   4779              DC.B                '    ***       ***    ************ ****  ***  ****',CR,LF
0000402A= 20 20 20 20 2A 2A ...   4780              DC.B                '    ***      ***         ******** ****   *   ****',CR,LF
0000405D= 20 20 20 20 2A 2A ...   4781              DC.B                '    ***    *****       ********   ****       ****',CR,LF
00004090= 20 20 20 20 2A 2A ...   4782              DC.B                '    ***********      *********    ****       ****',CR,LF
000040C3= 20 20 20 20 2A 2A ...   4783              DC.B                '    *********     **********      ****       ****',CR,LF,LF
000040F7= 44 69 73 73 65 6D ...   4784              DC.B        'Dissembler will only take addresses 4000 or higher',CR,LF
0000412B= 2D 2D 2D 2D 2D 2D ...   4785              DC.B        '-----------------------------------------------------------------------------------------',CR,LF  
00004186                          4786  ***********************************************************************************************************
00004186                          4787  *
00004186                          4788  *                       IO Strings
00004186                          4789  *           
00004186                          4790  *       This section holds all of the various strings to output to the console.
00004186                          4791  *
00004186                          4792  ***********************************************************************************************************  
00004186                          4793  
00004186= 45 6E 74 65 72 20 ...   4794  startingMessage DC.B    'Enter Starting Address (in hex): ', 0
000041A8= 45 6E 74 65 72 20 ...   4795  endingMessage   DC.B    'Enter Ending Address (in hex): ', 0
000041C8= 49 6E 63 6F 72 72 ...   4796  errorMessage    DC.B    'Incorrect Address, try again: ', 0
000041E7                          4797  
000041E7= 20 0D 0A 00             4798  newLine         DC.B    ' ', CR, LF, 0
000041EB= 20 20 00                4799  space           DC.B    '  ', 0
000041EE                          4800  
000041EE= 23 00                   4801  hashTag         DC.B    '#', 0
000041F0= 24 00                   4802  dispHex         DC.B    '$', 0
000041F2= 2C 00                   4803  comma           DC.B    ',', 0
000041F4                          4804  
000041F4= 28 00                   4805  opPer           DC.B    '(', 0
000041F6= 29 00                   4806  clPer           DC.B    ')', 0
000041F8= 2D 00                   4807  dec             DC.B    '-', 0
000041FA= 2B 00                   4808  inc             DC.B    '+', 0
000041FC                          4809  
000041FC= 4F 52 49 00             4810  ORImatch        DC.B    'ORI', 0
00004200= 43 4D 50 49 00          4811  CMPImatch       DC.B    'CMPI', 0
00004205= 42 43 4C 52 00          4812  BCLRmatch       DC.B    'BCLR', 0
0000420A= 4D 4F 56 45 00          4813  MOVEmatch       DC.B    'MOVE', 0
0000420F= 4D 4F 56 45 41 00       4814  MOVEAmatch      DC.B    'MOVEA', 0
00004215= 4E 45 47 00             4815  NEGmatch        DC.B    'NEG', 0
00004219= 52 54 53 00             4816  RTSmatch        DC.B    'RTS', 0
0000421D= 4A 53 52 00             4817  JSRmatch        DC.B    'JSR', 0
00004221= 4D 4F 56 45 4D 00       4818  MOVEMmatch      DC.B    'MOVEM', 0
00004227= 4C 45 41 00             4819  LEAmatch        DC.B    'LEA', 0
0000422B= 53 55 42 51 00          4820  SUBQmatch       DC.B    'SUBQ', 0
00004230= 42 52 41 00             4821  BRAmatch        DC.B    'BRA', 0
00004234= 42 43 53 00             4822  BCSmatch        DC.B    'BCS', 0
00004238= 42 56 43 00             4823  BVCmatch        DC.B    'BVC', 0
0000423C= 42 47 45 00             4824  BGEmatch        DC.B    'BGE', 0
00004240= 42 4C 54 00             4825  BLTmatch        DC.B    'BLT', 0
00004244= 44 49 56 53 00          4826  DIVSmatch       DC.B    'DIVS', 0
00004249= 4F 52 00                4827  ORmatch         DC.B    'OR', 0
0000424C= 53 55 42 00             4828  SUBmatch        DC.B    'SUB', 0
00004250= 45 4F 52 00             4829  EORmatch        DC.B    'EOR', 0
00004254= 43 4D 50 00             4830  CMPmatch        DC.B    'CMP', 0
00004258= 4D 55 4C 53 00          4831  MULSmatch       DC.B    'MULS', 0
0000425D= 41 44 44 00             4832  ADDmatch        DC.B    'ADD', 0
00004261= 41 44 44 41 00          4833  ADDAmatch       DC.B    'ADDA', 0
00004266= 4C 53 52 00             4834  LSRmatch        DC.B    'LSR', 0
0000426A= 4C 53 4C 00             4835  LSLmatch        DC.B    'LSL', 0
0000426E= 41 53 52 00             4836  ASRmatch        DC.B    'ASR', 0
00004272= 41 53 4C 00             4837  ASLmatch        DC.B    'ASL', 0
00004276= 52 4F 52 00             4838  RORmatch        DC.B    'ROR', 0
0000427A= 52 4F 4C 00             4839  ROLmatch        DC.B    'ROL', 0
0000427E                          4840  
0000427E= 2F 00                   4841  slash           DC.B    '/', 0
00004280= 28 53 50 29 00          4842  stack           DC.B    '(SP)', 0
00004285                          4843   
00004285= 2E 42 00                4844  dispByte        DC.B    '.B', 0
00004288= 2E 57 00                4845  dispWord        DC.B    '.W', 0
0000428B= 2E 4C 00                4846  dispLong        DC.B    '.L', 0
0000428E                          4847  
0000428E= 41 30 00                4848  dispA0          DC.B    'A0', 0
00004291= 41 31 00                4849  dispA1          DC.B    'A1', 0
00004294= 41 32 00                4850  dispA2          DC.B    'A2', 0
00004297= 41 33 00                4851  dispA3          DC.B    'A3', 0
0000429A= 41 34 00                4852  dispA4          DC.B    'A4', 0
0000429D= 41 35 00                4853  dispA5          DC.B    'A5', 0
000042A0= 41 36 00                4854  dispA6          DC.B    'A6', 0
000042A3= 41 37 00                4855  dispA7          DC.B    'A7', 0
000042A6                          4856  
000042A6= 44 00                   4857  dispD           DC.B    'D',0
000042A8= 44 30 00                4858  dispD0          DC.B    'D0', 0
000042AB= 44 31 00                4859  dispD1          DC.B    'D1', 0
000042AE= 44 32 00                4860  dispD2          DC.B    'D2', 0
000042B1= 44 33 00                4861  dispD3          DC.B    'D3', 0
000042B4= 44 34 00                4862  dispD4          DC.B    'D4', 0
000042B7= 44 35 00                4863  dispD5          DC.B    'D5', 0
000042BA= 44 36 00                4864  dispD6          DC.B    'D6', 0
000042BD= 44 37 00                4865  dispD7          DC.B    'D7', 0 
000042C0                          4866   
000042C0                          4867             END    START                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             3516
ABSSHORT            34DE
ADDAMATCH           4261
ADDINVALID          3C70
ADDMATCH            425D
ADDR0CONT           3916
ADDR1CONT           3956
ADDR2CONT           3996
ADDR3CONT           39D6
ADDR4CONT           3A16
ADDR5CONT           3A56
ADDR6CONT           3A96
ADDRESS             3B2C
ADDRREG0            38F6
ADDRREG1            3926
ADDRREG2            3966
ADDRREG3            39A6
ADDRREG4            39E6
ADDRREG5            3A26
ADDRREG6            3A66
ADDRREG7            3AA6
ASLMATCH            4272
ASRMATCH            426E
BCLRMATCH           4205
BCSMATCH            4234
BGEMATCH            423C
BLTMATCH            4240
BRAEIGHT            1152
BRAELEVEN           1170
BRAFIVE             111A
BRAFOUR             10FE
BRAFOURTEEN         11E0
BRAMATCH            4230
BRANINE             116C
BRAONE              10F2
BRASIX              111E
BRATHIRTEEN         118E
BRATHREE            10FA
BRATWELVE           118A
BRATWO              10F6
BRAZERO             10C2
BVCMATCH            4238
BYTLOOP             3B5A
CHECKDR             35F0
CLPER               41F6
CMPIMATCH           4200
CMPMATCH            4254
COMMA               41F2
CR                  D
DATAREG0            36A0
DATAREG1            36D0
DATAREG2            3710
DATAREG3            3750
DATAREG4            3790
DATAREG5            37D0
DATAREG6            3810
DATAREG7            3850
DEC                 41F8
DISPA0              428E
DISPA1              4291
DISPA2              4294
DISPA3              4297
DISPA4              429A
DISPA5              429D
DISPA6              42A0
DISPA7              42A3
DISPBYTE            4285
DISPD               42A6
DISPD0              42A8
DISPD1              42AB
DISPD2              42AE
DISPD3              42B1
DISPD4              42B4
DISPD5              42B7
DISPD6              42BA
DISPD7              42BD
DISPHEX             41F0
DISPIMM             354E
DISPLAYA0           3056
DISPLAYA0A          3122
DISPLAYA0D          33E6
DISPLAYA0P          324E
DISPLAYA1           3066
DISPLAYA1A          313E
DISPLAYA1D          3402
DISPLAYA1P          3276
DISPLAYA2           3076
DISPLAYA2A          315A
DISPLAYA2D          341E
DISPLAYA2P          329E
DISPLAYA3           3086
DISPLAYA3A          3176
DISPLAYA3D          343A
DISPLAYA3P          32C6
DISPLAYA4           3096
DISPLAYA4A          3192
DISPLAYA4D          3456
DISPLAYA4P          32EE
DISPLAYA5           30A6
DISPLAYA5A          31AE
DISPLAYA5D          3472
DISPLAYA5P          3316
DISPLAYA6           30B6
DISPLAYA6A          31CA
DISPLAYA6D          348E
DISPLAYA6P          333E
DISPLAYA7           30C6
DISPLAYA7A          31E6
DISPLAYA7D          34AA
DISPLAYA7P          3366
DISPLAYD0           2F96
DISPLAYD1           2FA6
DISPLAYD2           2FB6
DISPLAYD3           2FC6
DISPLAYD4           2FD6
DISPLAYD5           2FE6
DISPLAYD6           2FF6
DISPLAYD7           3006
DISPLAYEIGHT        2F0E
DISPLAYSTART        3C96
DISPLONG            428B
DISPLOOP            3ADE
DISPWORD            4288
DIVSMATCH           4244
DLETTERS            3B12
DLNINE              3AFE
EIGHT               8
ELEVEN              B
ENDDISPSUB          3B26
ENDINGMESSAGE       41A8
ENDLOOP             3C86
ENDMOVE             3AB6
ENDMOVE1            3ABC
ENDPROG             3C92
ENDSUB              359A
ENDSUBROUTINE       2F18
EORMATCH            4250
ERRORMESSAGE        41C8
FIRSTNIB            F0
FIVE                5
FOUR                4
FOURTEEN            E
HA                  3C30
HASHTAG             41EE
HB                  3C38
HC                  3C40
HD                  3C48
HE                  3C50
HEIGHT              3C20
HF                  3C58
HFIVE               3C08
HFOUR               3C00
HNINE               3C28
HONE                3BE8
HSEVEN              3C18
HSIX                3C10
HTHREE              3BF8
HTWO                3BF0
HZERO               3BE0
IMMLONG             3582
INC                 41FA
INVALID             3596
JSRMATCH            421D
LEAMATCH            4227
LF                  A
LONGSKIP            3592
LOOP                1046
LSLMATCH            426A
LSRMATCH            4266
MASK0               0
MASK1               1
MASK2               2
MASK3               4
MASK4               8
MASK5               10
MASK6               20
MASK7               40
MASK8               80
MASKA               5
MASKB               A
MASKC               14
MASKD               28
MASKE               50
MASKF               A0
MEMSB               26A8
MEMSHIFTIMM         2EF4
MEMSHIFTS           11FA
MEMSL               2BBC
MEMSW               2932
MOVEAMATCH          420F
MOVEMATCH           420A
MOVEMBRA            35A0
MOVEML              35D4
MOVEMMATCH          4221
MOVEMW              35B8
MOVEOVER            3ADA
MULSMATCH           4258
NEGMATCH            4215
NEWLINE             41E7
NEXTH               3C60
NINE                9
ONE                 1
OPADDAL             2470
OPADDAW             2400
OPADDB              22B4
OPADDL              238C
OPADDW              2320
OPASBI              26E6
OPASBR              2748
OPASL               24E0
OPASLBI             2726
OPASLBR             2788
OPASLI              2BFA
OPASLLI             2C3A
OPASLLR             2C9C
OPASLR              2C5C
OPASLWI             29B0
OPASLWR             2A12
OPASR               252C
OPASRBI             2704
OPASRBR             2766
OPASRLI             2C18
OPASRLR             2C7A
OPASRWI             298E
OPASRWR             29F0
OPASWI              2970
OPASWR              29D2
OPBCLR              155E
OPBCS               20F8
OPBGE               2168
OPBLT               21A0
OPBRA               20C0
OPBVC               2130
OPCMP               1E28
OPCMPB              1E5A
OPCMPI              13D4
OPCMPIB             13F6
OPCMPIL             14EC
OPCMPIW             1468
OPCMPL              1F0E
OPCMPW              1EB4
OPDIVS              1C80
OPDYNBCLR           15C2
OPEOR               1CDA
OPEORB              1D08
OPEORL              1DC8
OPEORW              1D68
OPJSR               19AE
OPLEA               1AB2
OPLSBI              27AA
OPLSBR              280C
OPLSL               2578
OPLSLBI             27EA
OPLSLBR             284C
OPLSLI              2CBE
OPLSLLI             2CFE
OPLSLLR             2D60
OPLSLR              2D20
OPLSLWI             2A74
OPLSLWR             2AD6
OPLSR               25C4
OPLSRBI             27C8
OPLSRBR             282A
OPLSRLI             2CDC
OPLSRLR             2D3E
OPLSRWI             2A52
OPLSRWR             2AB4
OPLSWI              2A34
OPLSWR              2A96
OPMOVEAL            1748
OPMOVEAW            183E
OPMOVEB             1630
OPMOVEL             16B4
OPMOVEM             1A28
OPMOVEMLEA          1A0C
OPMOVEW             17B0
OPMULS              2250
OPNEG               18A6
OPNEGB              18D4
OPNEGL              1914
OPNEGW              1954
OPOR                1B32
OPORB               1B72
OPORI               1254
OPORIB              1276
OPORIL              1362
OPORIW              12E8
OPORL               1C26
OPORW               1BCC
OPPER               41F4
OPROBI              286E
OPROBR              28D0
OPROL               2610
OPROLBI             28AE
OPROLBR             2910
OPROLI              2D82
OPROLLI             2DC2
OPROLLR             2E24
OPROLR              2DE4
OPROLWI             2B38
OPROLWR             2B9A
OPROR               265C
OPRORBI             288C
OPRORBR             28EE
OPRORLI             2DA0
OPRORLR             2E02
OPRORWI             2B16
OPRORWR             2B78
OPROWI              2AF8
OPROWR              2B5A
OPRTS               19F0
OPRTSJSR            1994
OPSUB               1F68
OPSUBB              1FB2
OPSUBL              2066
OPSUBQ              21D8
OPSUBQB             2208
OPSUBQL             2234
OPSUBQW             221E
OPSUBW              200C
ORIMATCH            41FC
ORMATCH             4249
OUTHEX              3AC2
PADDRDEC            338E
PADDRDIR            30D6
PADDRPOST           3202
PADDRREG            3016
PDATAREG            2F56
PHEX                34C6
PRINTEA             2F1E
PRINTINVALID        3C8C
PRINTMEM            3860
PRINTMEMNOW         3864
PRINTREGMEM         3618
PRINTSTACK          3604
PRNTIMM             2E46
PRNTREG             2EA2
REG0CONT            36C0
REG1CONT            3700
REG2CONT            3740
REG3CONT            3780
REG4CONT            37C0
REG5CONT            3800
REG6CONT            3840
REGSHIFTS           1238
RETRY               3B30
ROLMATCH            427A
RORMATCH            4276
RTSMATCH            4219
SECNIB              F
SEVEN               7
SIX                 6
SKIPPRINTEA         1AA2
SLASH               427E
SPACE               41EB
STACK               4280
START               1000
STARTINGMESSAGE     4186
SUBLOOP             3B48
SUBMATCH            424C
SUBQMATCH           422B
THIRTEEN            D
THREE               3
TITLE               3CAC
TWELVE              C
TWO                 2
ZERO                0
