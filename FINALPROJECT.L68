00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 11/24/2014 12:19:10 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :
00000000                             3  * Written by :  Abdul Hakim, David Trinh, Alexander Auxier
00000000                             4  * Date       :
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00000000  =0000000D                  7  CR          EQU     $0D     
00000000  =0000000A                  8  LF          EQU     $0A
00000000                             9    
00000000  =00002000                 10  test_start  EQU     $00002000   ; defined starting address
00000000  =00002005                 11  test_end    EQU     $00002005   ; defined ending address
00000000                            12       
00000000  =00000000                 13  zero        EQU     $00         ; defined hex value 0
00000000  =00000001                 14  one         EQU     $01         ; defined hex value 1 
00000000  =00000002                 15  two         EQU     $02         ; defined hex value 2
00000000  =00000003                 16  three       EQU     $03         ; defined hex value 3
00000000  =00000004                 17  four        EQU     $04         ; defined hex value 4
00000000  =00000005                 18  five        EQU     $05         ; defined hex value 5
00000000  =00000006                 19  six         EQU     $06         ; defined hex value 6
00000000  =00000008                 20  eight       EQU     $08         ; defined hex value 8
00000000  =00000009                 21  nine        EQU     $09         ; defined hex value 9
00000000  =0000000B                 22  eleven      EQU     $0B         ; defined hex value 11
00000000  =0000000C                 23  twelve      EQU     $0C         ; defined hex value 12
00000000  =0000000D                 24  thirteen    EQU     $0D         ; defined hex value 13
00000000  =0000000E                 25  fourteen    EQU     $0E         ; defined hex value 14
00000000                            26  
00000000  =00000000                 27  s1B         EQU     %0000       ; byte size 1 
00000000  =00000001                 28  s1W         EQU     %0001       ; word size 1
00000000  =00000002                 29  s1L         EQU     %0010       ; long size 1
00000000                            30  
00000000  =00000000                 31  s2W         EQU     %0000       ; word size 2
00000000  =00000001                 32  s2L         EQU     %0001       ; long size 2
00000000                            33  
00000000  =00000001                 34  s3B         EQU     %0001       ; byte size 3
00000000  =00000003                 35  s3W         EQU     %0011       ; word size 3
00000000  =00000002                 36  s3L         EQU     %0010       ; long size 3
00000000                            37  
00000000  =00000000                 38  addMatchDn  EQU     %0000       ; Address Mode Data Register
00000000  =00000001                 39  addMatchAn  EQU     %0001       ; Address Mode Address Register
00000000  =00000002                 40  addMatchAd  EQU     %0010       ; Address Mode Address
00000000  =00000003                 41  addMatchPi  EQU     %0011       ; Address Mode with PostIncrement
00000000  =00000004                 42  addMatchPd  EQU     %0100       ; Address Mode with PreDecrement
00000000  =00000007                 43  addMatchDi  EQU     %0111       ; Address Mode for Word, Long, or Immediate 
00000000                            44  
00000000  =00000000                 45  reg0        EQU     %0000       ; register 0
00000000  =00000001                 46  reg1        EQU     %0001       ; register 1
00000000  =00000002                 47  reg2        EQU     %0010       ; register 2
00000000  =00000003                 48  reg3        EQU     %0011       ; register 3
00000000  =00000004                 49  reg4        EQU     %0100       ; register 4
00000000  =00000005                 50  reg5        EQU     %0101       ; register 5
00000000  =00000006                 51  reg6        EQU     %0110       ; register 6
00000000  =00000007                 52  reg7        EQU     %0111       ; register 7
00000000                            53               
00001000                            54              ORG    $1000
00001000                            55  START:                                  ; first instruction of program
00001000                            56        
00001000  207C 00002000             57          MOVEA.L     #test_start, A0     ; load starting address
00001006  247C 00002005             58          MOVEA.L     #test_end, A2       ; load ending address
0000100C                            59            
0000100C  4241                      60  LOOP    CLR         D1                  ; clear out D1
0000100E  4242                      61          CLR         D2                  ; clear out D2
00001010  B1CA                      62          CMPA.L      A2, A0              ; compare starting and ending addresses
00001012  6E00 00DA                 63          BGT         endProg             ; if A0 > A1, we've finished, end program
00001016  1218                      64          MOVE.B      (A0)+, D1           ; load byte to D1 and increment A0 to next byte
00001018  1401                      65          MOVE.B      D1, D2              ; copy byte to D2 for manipulation
0000101A  E882                      66          ASR.L       #four, D2           ; get first nibble in D2
0000101C                            67          
0000101C  B43C 0000                 68          CMP.B       #zero, D2           ; compare with 0
00001020  6700 0064                 69          BEQ         braZero             ; branch out to zero method
00001024  B43C 0001                 70          CMP.B       #one, D2            ; compare with 1
00001028  6700 0078                 71          BEQ         braOne              ; branch out to one method
0000102C  B43C 0002                 72          CMP.B       #two, D2            ; compare with 2    
00001030  6700 0070                 73          BEQ         braTwo              ; branch out to two method
00001034  B43C 0003                 74          CMP.B       #three, D2          ; compare with 3
00001038  6700 0068                 75          BEQ         braThree            ; branch out to three method
0000103C  B43C 0004                 76          CMP.B       #four, D2           ; compare with 4
00001040  6700 0060                 77          BEQ         braFour             ; branch out to four method
00001044  B43C 0005                 78          CMP.B       #five, D2           ; compare with 5
00001048  6700 0058                 79          BEQ         braFive             ; branch out to five method
0000104C  B43C 0006                 80          CMP.B       #six, D2            ; compare with 6
00001050  6700 0050                 81          BEQ         braSix              ; branch out to six method
00001054  B43C 0008                 82          CMP.B       #eight, D2          ; compare with 8
00001058  6700 0048                 83          BEQ         braEight            ; branch out to eight method
0000105C  B43C 0009                 84          CMP.B       #nine, D2           ; compare with 9
00001060  6700 0040                 85          BEQ         braNine             ; branch out to nine method
00001064  B43C 000B                 86          CMP.B       #eleven, D2         ; compare with 11
00001068  6700 0038                 87          BEQ         braEleven           ; branch out to eleven method
0000106C  B43C 000C                 88          CMP.B       #twelve, D2         ; compare with 12
00001070  6700 0030                 89          BEQ         braTwelve           ; branch out to twelve method
00001074  B43C 000D                 90          CMP.B       #thirteen, D2       ; compare with 13
00001078  6700 0028                 91          BEQ         braThirteen         ; branch out to thirteen method
0000107C  B43C 000E                 92          CMP.B       #fourteen, D2       ; compare with 14
00001080  6700 0020                 93          BEQ         braFourteen         ; branch out to fourteen method
00001084  6086                      94          BRA         loop
00001086                            95  
00001086  4242                      96  braZero CLR         D2                  ; first nibble is 0, 3 opcodes are possible 
00001088  1401                      97          MOVE.B      D1, D2              ; clear out D2 and copy D1 back in
0000108A  C438 000F                 98          AND.B       $0F, D2             ; set first nibble to 0
0000108E                            99   
0000108E  B43C 0000                100          CMP.B       #zero, D2           ; compare second nibble to 0
00001092  6700 000E                101          BEQ         opORI               ; branch to ORI method
00001096  B43C 000C                102          CMP.B       #twelve, D2         ; compare second nibble to 12
0000109A  6700 0032                103          BEQ         opCMPI              ; branch to CMPI method
0000109E  6000 003E                104          BRA         opBCLR              ; otherwise, branch to BCLR method; I think we should fix this, there are other posibilities
000010A2                           105          
000010A2                           106  braOne
000010A2                           107  braTwo
000010A2                           108  braThree
000010A2                           109  braFour
000010A2                           110  braFive
000010A2                           111  braSix
000010A2                           112  braEight
000010A2                           113  braNine
000010A2                           114  braEleven
000010A2                           115  braTwelve
000010A2                           116  braThirteen
000010A2                           117  braFourteen
000010A2                           118  
000010A2  43F9 000010F6            119  opORI   LEA         ORImatch, A1        ; we know that the opcode will be ORI, so load A1 to print message
000010A8  103C 000E                120          MOVE.B      #14, D0             ; command for trap call to display message
000010AC  4E4F                     121          TRAP        #15                 ; trap call
000010AE                           122        
000010AE  1218                     123          MOVE.B      (A0)+, D1
000010B0  1401                     124          MOVE.B      D1,D2               ; copy data over
000010B2  EC42                     125          ASR         #6,D2               ; shifts 6 bits over to read just the size
000010B4  B478 0000                126          CMP         zero,D2             ; size is zero
000010B8  6700 0014                127          BEQ         opORI0              ; branch??
000010BC                           128          
000010BC  3602                     129          MOVE        D2,D3
000010BE  4242                     130          CLR         D2
000010C0  1401                     131          MOVE.B      D1,D2
000010C2  E442                     132          ASR         #2,D2               ;Moving two bits over to isolate the size
000010C4  0242 0000                133          ANDI       #0,D2              ; Trying to clear the first nibble, doesn't work though
000010C8  E242                     134          ASR         #1,D2               ; shift to the right in order to get just the mode
000010CA                           135          
000010CA                           136          
000010CA  6000 FF40                137          BRA         LOOP                ; go back to the loop
000010CE                           138  
000010CE                           139  opORI0
000010CE                           140  
000010CE                           141           
000010CE  43F9 000010FA            142  opCMPI  LEA         CMPImatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
000010D4  103C 000E                143          MOVE.B      #14, D0             ; command for trap call to display message
000010D8  4E4F                     144          TRAP        #15                 ; trap call
000010DA                           145                  
000010DA  6000 FF30                146          BRA         LOOP                ; go back to the loop
000010DE                           147  
000010DE                           148  
000010DE                           149  
000010DE  43F9 000010FF            150  opBCLR  LEA         BCLRmatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
000010E4  103C 000E                151          MOVE.B      #14, D0             ; command for trap call to display message
000010E8  4E4F                     152          TRAP        #15                 ; trap call
000010EA                           153          
000010EA  6000 FF20                154          BRA         LOOP                ; go back to the loop
000010EE                           155   
000010EE                           156  endPROG    
000010EE                           157  
000010EE  FFFF FFFF                158      SIMHALT                             ; halt simulator
000010F2                           159  
000010F2= 20 0D 0A 00              160  newLine     DC.B    ' ', CR, LF, 0
000010F6                           161  
000010F6= 4F 52 49 00              162  ORImatch    DC.B    'ORI', 0
000010FA= 43 4D 50 49 00           163  CMPImatch   DC.B    'CMPI', 0
000010FF= 42 43 4C 52 00           164  BCLRmatch   DC.B    'BCLR', 0
00001104                           165   
00001104= 2E 42 20 20 00           166  dispByte    DC.B    '.B  ', 0
00001109= 2E 57 20 20 00           167  dispWord    DC.B    '.W  ', 0
0000110E= 2E 4C 20 20 00           168  dispLong    DC.B    '.L  ', 0
00001113                           169  
00001113= 41 30 00                 170  dispA0      DC.B    'A0', 0
00001116= 41 31 00                 171  dispA1      DC.B    'A1', 0
00001119= 41 32 00                 172  dispA2      DC.B    'A2', 0
0000111C= 41 33 00                 173  dispA3      DC.B    'A3', 0
0000111F= 41 34 00                 174  dispA4      DC.B    'A4', 0
00001122= 41 35 00                 175  dispA5      DC.B    'A5', 0
00001125= 41 36 00                 176  dispA6      DC.B    'A6', 0
00001128= 41 37 00                 177  dispA7      DC.B    'A7', 0
0000112B                           178  
0000112B                           179  
0000112B                           180             END    START                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDMATCHAD          2
ADDMATCHAN          1
ADDMATCHDI          7
ADDMATCHDN          0
ADDMATCHPD          4
ADDMATCHPI          3
BCLRMATCH           10FF
BRAEIGHT            10A2
BRAELEVEN           10A2
BRAFIVE             10A2
BRAFOUR             10A2
BRAFOURTEEN         10A2
BRANINE             10A2
BRAONE              10A2
BRASIX              10A2
BRATHIRTEEN         10A2
BRATHREE            10A2
BRATWELVE           10A2
BRATWO              10A2
BRAZERO             1086
CMPIMATCH           10FA
CR                  D
DISPA0              1113
DISPA1              1116
DISPA2              1119
DISPA3              111C
DISPA4              111F
DISPA5              1122
DISPA6              1125
DISPA7              1128
DISPBYTE            1104
DISPLONG            110E
DISPWORD            1109
EIGHT               8
ELEVEN              B
ENDPROG             10EE
FIVE                5
FOUR                4
FOURTEEN            E
LF                  A
LOOP                100C
NEWLINE             10F2
NINE                9
ONE                 1
OPBCLR              10DE
OPCMPI              10CE
OPORI               10A2
OPORI0              10CE
ORIMATCH            10F6
REG0                0
REG1                1
REG2                2
REG3                3
REG4                4
REG5                5
REG6                6
REG7                7
S1B                 0
S1L                 2
S1W                 1
S2L                 1
S2W                 0
S3B                 1
S3L                 2
S3W                 3
SIX                 6
START               1000
TEST_END            2005
TEST_START          2000
THIRTEEN            D
THREE               3
TWELVE              C
TWO                 2
ZERO                0
