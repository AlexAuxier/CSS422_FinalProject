00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/12/2014 3:25:44 PM

00000000                             1                                     
00000000                             2      ****       ****  *******     ****    ***      ***
00000000                             3      ****       **** *******    ********  ***     ***
00000000                             4      *****     ***** ***       ***    *** ***    ***
00000000                             5      ******   ****** ***       ***    *** ***   ***
00000000                             6      ******* ******* ***        ********  ***  ***
00000000                             7      *************** *******     ******   ********
00000000                             8      ****  ***  **** ********   ********  ***  ***
00000000                             9      ****   *   **** ***   *** ***    *** ***   ***
00000000                            10      ****       **** ***   *** ***    *** ***    ***
00000000                            11      ****       **** ***   ***  ********  ***     ***
00000000                            12      ****       ****  *******     ****    ***      ***
00000000                            13      
00000000                            14              *********          ********** ****       ****
00000000                            15              ***********      *********    ****       ****
00000000                            16              ***    *****   *********      *****     *****
00000000                            17              ***      **** ********        ******   ******
00000000                            18              ***       *** ************    ******* *******
00000000                            19              ***       *** *************** ***************
00000000                            20              ***       ***    ************ ****  ***  ****
00000000                            21              ***      ***         ******** ****   *   ****
00000000                            22              ***    *****       ********   ****       ****
00000000                            23              ***********      *********    ****       ****
00000000                            24              *********     **********      ****       ****
00000000                            25          
00000000                            26  *----------------------------------------------------------------------
00000000                            27  * Title      :  Motorola 68k Instruction Disassembler (DSM)
00000000                            28  * Written by :  Abdul Hakim, David Trinh, Alexander Auxier
00000000                            29  * Date       :  2014-12-11
00000000                            30  * Description:  The following code is for a partial M68k instruction
00000000                            31  *               disassembler. The opcodes that are supported are part
00000000                            32  *               of the base M68k processor.
00000000                            33  *               
00000000                            34  *               List of Supported Opcodes:
00000000                            35  *               * MOVE, MOVEA, MOVEM
00000000                            36  *               * ADD, ADDA
00000000                            37  *               * MULS, DIVS
00000000                            38  *               * LEA
00000000                            39  *               * OR, ORI, EOR
00000000                            40  *               * NEG
00000000                            41  *               * LSL, LSR
00000000                            42  *               * ASL, ASR
00000000                            43  *               * ROL, ROR
00000000                            44  *               * BCLR
00000000                            45  *               * BRA, JSR, RTS
00000000                            46  *               * Bcc with the following condition codes (cc)
00000000                            47  *                   * CS, VS, GE, LT
00000000                            48  *
00000000                            49  *               Supported Effective Addressing Modes:
00000000                            50  *               * Data Register Direct: Dn
00000000                            51  *               * Address Register Direct: An
00000000                            52  *               * Address Register Indirect: (An)
00000000                            53  *               * Address Register Indirect w/ Post Increment: (A0)+
00000000                            54  *               * Address Register Indirect w/ Pre Decrement: -(SP)
00000000                            55  *               * Immediate Data: #
00000000                            56  *               * Absolute Long Address: (xxx).L
00000000                            57  *               * Absolute Word Address: (xxx).W
00000000                            58  *               
00000000                            59  *               Let it be known that our program makes assumptions in
00000000                            60  *               order to run. That being, our disassembler will not
00000000                            61  *               accept an of the unsupported opcodes/EA modes.
00000000                            62  *               We also assume that the user starts the disassembler
00000000                            63  *               at an address that is 4000 (in hex) or higher.
00000000                            64  *----------------------------------------------------------------------
00000000                            65  
00000000  =0000000D                 66  CR          EQU     $0D     
00000000  =0000000A                 67  LF          EQU     $0A
00000000                            68       
00000000  =00000000                 69  zero        EQU     $00                     ; defined hex value 0
00000000  =00000001                 70  one         EQU     $01                     ; defined hex value 1 
00000000  =00000002                 71  two         EQU     $02                     ; defined hex value 2
00000000  =00000003                 72  three       EQU     $03                     ; defined hex value 3
00000000  =00000004                 73  four        EQU     $04                     ; defined hex value 4
00000000  =00000005                 74  five        EQU     $05                     ; defined hex value 5
00000000  =00000006                 75  six         EQU     $06                     ; defined hex value 6
00000000  =00000007                 76  seven       EQU     $07                     ; defined hex value 7
00000000  =00000008                 77  eight       EQU     $08                     ; defined hex value 8
00000000  =00000009                 78  nine        EQU     $09                     ; defined hex value 9
00000000  =0000000B                 79  eleven      EQU     $0B                     ; defined hex value 11
00000000  =0000000C                 80  twelve      EQU     $0C                     ; defined hex value 12
00000000  =0000000D                 81  thirteen    EQU     $0D                     ; defined hex value 13
00000000  =0000000E                 82  fourteen    EQU     $0E                     ; defined hex value 14
00000000                            83  
00000000  =00000000                 84  mask0       EQU     %00000000
00000000  =00000001                 85  mask1       EQU     %00000001
00000000  =00000002                 86  mask2       EQU     %00000010
00000000  =00000004                 87  mask3       EQU     %00000100
00000000  =00000008                 88  mask4       EQU     %00001000
00000000  =00000010                 89  mask5       EQU     %00010000
00000000  =00000020                 90  mask6       EQU     %00100000
00000000  =00000040                 91  mask7       EQU     %01000000
00000000  =00000080                 92  mask8       EQU     %10000000
00000000                            93  
00000000  =00000005                 94  maskA       EQU     %00000101
00000000  =0000000A                 95  maskB       EQU     %00001010
00000000  =00000014                 96  maskC       EQU     %00010100
00000000  =00000028                 97  maskD       EQU     %00101000
00000000  =00000050                 98  maskE       EQU     %01010000
00000000  =000000A0                 99  maskF       EQU     %10100000
00000000                           100  
00000000  =000000F0                101  firstNib    EQU     $F0
00000000  =0000000F                102  secNib      EQU     $0F
00000000                           103               
00001000                           104              ORG     $1000
00001000                           105  START: 
00001000                           106  ***********************************************************************************************************
00001000                           107  *
00001000                           108  *                   Dissassembler Start
00001000                           109  *
00001000                           110  ***********************************************************************************************************
00001000                           111              ; Dissassemble Start, obtain addr range
00001000                           112              
00001000  43F9 00003C84            113              LEA         Title, A1           ; load title message to A1
00001006  103C 000E                114              MOVE.B      #14, D0             ; trap task to display message
0000100A  4E4F                     115              TRAP        #15                 ; trap call
0000100C                           116              
0000100C                           117  RetrySAdd   
0000100C  43F9 00003E7A            118              LEA         startingMessage, A1 ; load starting message to A1
00001012  103C 000E                119              MOVE.B      #14, D0             ; trap task to display message
00001016  4E4F                     120              TRAP        #15                 ; trap call
00001018  103C 0002                121              MOVE.B      #2, D0              ; trap task to read input 
0000101C  4E4F                     122              TRAP        #15                 ; trap call
0000101E                           123      
0000101E  4EB9 00003B18            124              JSR         Address             ; jump to Address
00001024  B4BC 00004000            125              CMP.L       #$00004000, D2      ; compare minimum starting address to D2
0000102A  6DE0                     126              BLT         RetrySAdd           ; if less than, branch back up to starting address
0000102C  2042                     127              MOVEA.L     D2, A0              ; move starting address to A0
0000102E                           128          
0000102E                           129  RetryEAdd   
0000102E  43F9 00003E9C            130              LEA         endingMessage, A1   ; load ending address message to A1
00001034  103C 000E                131              MOVE.B      #14, D0             ; trap task to display message
00001038  4E4F                     132              TRAP        #15                 ; trap call
0000103A                           133          
0000103A  103C 0002                134              MOVE.B      #2, D0              ; trap task to read input 
0000103E  4E4F                     135              TRAP        #15                 ; trap call
00001040                           136      
00001040  4EB9 00003B18            137              JSR         Address             ; jump to Address
00001046  B488                     138              CMP.L       A0, D2              ; compare starting address to D2
00001048  6DE4                     139              BLT         RetryEAdd           ; if less than, branch back up to ending address
0000104A  2442                     140              MOVEA.L     D2, A2              ; move ending address to A2
0000104C                           141          
0000104C  43F9 00003EDB            142              LEA         newline, A1         ; display new line
00001052  103C 000E                143              MOVE.B      #14, D0             ; trap task to display message
00001056  4E4F                     144              TRAP        #15                 ; trap call
00001058                           145            
00001058                           146  ***********************************************************************************************************
00001058                           147  *
00001058                           148  *                   Control Loop
00001058                           149  *
00001058                           150  *       This loop cycles and branches our code by the first nibble of OPCODE binary
00001058                           151  *
00001058                           152  ***********************************************************************************************************
00001058                           153            
00001058  4241                     154  LOOP        CLR         D1                  ; clear out D1
0000105A  4242                     155              CLR         D2                  ; clear out D2
0000105C  B1CA                     156              CMPA.L      A2, A0              ; compare starting and ending addresses
0000105E  6E00 2C20                157              BGT         endProg             ; if A0 > A1, we've finished, end program
00001062  1218                     158              MOVE.B      (A0)+, D1           ; load byte to D1 and increment A0 to next byte
00001064  1401                     159              MOVE.B      D1, D2              ; copy byte to D2 for manipulation
00001066  E882                     160              ASR.L       #four, D2           ; get first nibble in D2
00001068                           161          
00001068  B43C 0000                162              CMP.B       #zero, D2           ; compare with 0
0000106C  6700 0064                163              BEQ         braZero             ; branch out to zero method
00001070  B43C 0001                164              CMP.B       #one, D2            ; compare with 1
00001074  6700 008C                165              BEQ         braOne              ; branch out to one method
00001078  B43C 0002                166              CMP.B       #two, D2            ; compare with 2    
0000107C  6700 0088                167              BEQ         braTwo              ; branch out to two method
00001080  B43C 0003                168              CMP.B       #three, D2          ; compare with 3
00001084  6700 0084                169              BEQ         braThree            ; branch out to three method
00001088  B43C 0004                170              CMP.B       #four, D2           ; compare with 4
0000108C  6700 0080                171              BEQ         braFour             ; branch out to four method
00001090  B43C 0005                172              CMP.B       #five, D2           ; compare with 5
00001094  6700 0094                173              BEQ         braFive             ; branch out to five method
00001098  B43C 0006                174              CMP.B       #six, D2            ; compare with 6
0000109C  6700 0090                175              BEQ         braSix              ; branch out to six method
000010A0  B43C 0008                176              CMP.B       #eight, D2          ; compare with 8
000010A4  6700 00BC                177              BEQ         braEight            ; branch out to eight method
000010A8  B43C 0009                178              CMP.B       #nine, D2           ; compare with 9
000010AC  6700 00CE                179              BEQ         braNine             ; branch out to nine method
000010B0  B43C 000B                180              CMP.B       #eleven, D2         ; compare with 11
000010B4  6700 00CA                181              BEQ         braEleven           ; branch out to eleven method
000010B8  B43C 000C                182              CMP.B       #twelve, D2         ; compare with 12
000010BC  6700 00DC                183              BEQ         braTwelve           ; branch out to twelve method
000010C0  B43C 000D                184              CMP.B       #thirteen, D2       ; compare with 13
000010C4  6700 00D8                185              BEQ         braThirteen         ; branch out to thirteen method
000010C8  B43C 000E                186              CMP.B       #fourteen, D2       ; compare with 14
000010CC  6700 0122                187              BEQ         braFourteen         ; branch out to fourteen method
000010D0  6086                     188              BRA         loop
000010D2                           189  
000010D2                           190  ***********************************************************************************************************
000010D2                           191  *
000010D2                           192  *                   Nibble Branch Section
000010D2                           193  *
000010D2                           194  *       This section decides which nibble goes to the corresponding opcode
000010D2                           195  *
000010D2                           196  *********************************************************************************************************** 
000010D2                           197          
000010D2                           198  braZero     
000010D2  4242                     199              CLR         D2                  ; first nibble is 0, 3 opcodes are possible 
000010D4  1401                     200              MOVE.B      D1, D2              ; clear out D2 and copy D1 back in
000010D6  C43C 000F                201              AND.B       #secNib, D2         ; set first nibble to 0
000010DA                           202  
000010DA  B43C 0000                203              CMP.B       #zero, D2           ; compare second nibble to 0
000010DE  6700 0184                204              BEQ         opORI               ; branch to ORI method
000010E2  B43C 000C                205              CMP.B       #twelve, D2         ; compare second nibble to 12
000010E6  6700 02DC                206              BEQ         opCMPI              ; branch to CMPI method
000010EA  B43C 0008                207              CMP.B       #eight,D2           ; Test for static BCLR
000010EE  6700 045E                208              BEQ         opBCLR
000010F2  C47C 0001                209              AND         #one,D2             ; Sets all bits to 0 except for first bit if it is 1
000010F6  B43C 0001                210              CMP.B       #one,D2             ; if it is one then there is a chance it is dynamic BCLR
000010FA  6700 04B6                211              BEQ         opDynBCLR
000010FE  6000 2B7A                212              BRA         printInvalid
00001102                           213          
00001102                           214  braOne      
00001102  6000 051C                215              BRA         opMOVEB             ; we know that there is only one opcode that is MOVE.B
00001106                           216  
00001106                           217  braTwo      
00001106  6000 059C                218              BRA         opMOVEL             ; there are two opCodes available, MOVE.L, or MOVEA.L
0000110A                           219  
0000110A                           220  braThree                                    ; there are two opCodes available, MOVE.W, or MOVEA.W
0000110A  6000 0694                221              BRA         opMOVEW
0000110E                           222  
0000110E  4242                     223  braFour     CLR         D2                  ; first nibble is 4, 5 opcodes are possible 
00001110  1401                     224              MOVE.B      D1, D2              ; clear out D2 and copy D1 back in
00001112  C43C 000F                225              AND.B       #secNib, D2         ; set first nibble to 0
00001116                           226   
00001116  B43C 0004                227              CMP.B       #four, D2           ; compare second nibble to 4
0000111A  6700 077A                228              BEQ         opNEG               ; branch to NEG method
0000111E  B43C 000E                229              CMP.B       #fourteen, D2       ; compare second nibble to E
00001122  6700 0860                230              BEQ         opRTSJSR            ; branch to JSR or RTS method
00001126  6000 08D4                231              BRA         opMOVEMLEA          ; otherwise, branch to MOVEM or LEA method
0000112A                           232  
0000112A                           233  braFive     
0000112A  6000 109C                234              BRA         opSUBQ              ; we know that there is only one opcode that is SUBQ
0000112E                           235  
0000112E                           236  braSix      
0000112E  4242                     237              CLR         D2                  ; first nibble is 6, 5 opcodes are possible 
00001130  1401                     238              MOVE.B      D1, D2              ; clear out D2 and copy D1 back in
00001132  C43C 000F                239              AND.B       #$0F, D2             ; set first nibble to 0
00001136                           240   
00001136  B43C 0000                241              CMP.B       #zero, D2           ; compare second nibble to 0
0000113A  6700 0F74                242              BEQ         opBRA               ; branch to BRA method
0000113E  B43C 0005                243              CMP.B       #five, D2           ; compare second nibble to 5
00001142  6700 0FA4                244              BEQ         opBCS               ; branch to BCS method
00001146  B43C 0008                245              CMP.B       #eight, D2          ; compare second nibble to 8
0000114A  6700 0FD4                246              BEQ         opBVC               ; branch to BCS method
0000114E  B43C 000C                247              CMP.B       #twelve, D2         ; compare second nibble to 12
00001152  6700 1004                248              BEQ         opBGE               ; branch to BGE method
00001156  B43C 000D                249              CMP.B       #thirteen,D2        ; compare second nibble to 13
0000115A  6700 1034                250              BEQ         opBLT               ; branch to BLT method
0000115E  6000 2B1A                251              BRA         printInvalid        ; found an un-supported opcode
00001162                           252  
00001162                           253  braEight                                    ; there are two opCodes available DIVS, or OR
00001162  4242                     254              CLR         D2                  ; clear D2 for use
00001164  E141                     255              ASL         #8,D1               ; Shift by eight 
00001166  1218                     256              MOVE.B      (A0)+,D1            ; Move the instruction byte into D1
00001168  3401                     257              MOVE.W      D1,D2               ; Load D2 with the word from D1
0000116A  EC42                     258              ASR         #six,D2             ; Shift by 6 to find second nibble
0000116C  C47C 0007                259              AND         #$07,D2             ; AND by 7 to remove unwanted bits
00001170  B43C 0007                260              CMP.B       #seven,D2           ; Compare second nibble to 7
00001174  6700 0AFA                261              BEQ         opDIVS              ; If bits 8 - 6 are equal to 7, we have DIVS
00001178  6000 09A8                262              BRA         opOR                ; else opcode is OR
0000117C                           263  
0000117C                           264  braNine     
0000117C  6000 0DDA                265              BRA         opSUB               ; we know that there is only one opcode that is SUB
00001180                           266  
00001180                           267  braEleven                                   ; there are two opCodes available EOR, or CMP
00001180  4242                     268              CLR         D2                  ; clear D2 for use
00001182  E141                     269              ASL         #8,D1               ; Shift by eight for
00001184  1218                     270              MOVE.B      (A0)+,D1            ; Re-load the instruction byte into D1
00001186  3401                     271              MOVE.W      D1,D2               ; Move the word into D2 for the comparison
00001188  EC42                     272              ASR         #six,D2             ; Shift by 6 to find second nibble
0000118A  C47C 0007                273              AND         #$07,D2             ; AND by 7 to remove unwanted bits
0000118E  B43C 0003                274              CMP.B       #three,D2           ; Compare second nibble to 3
00001192  6D00 0C84                275              BLT         opCMP               ; If opmode bits are less than 3, we have CMP
00001196  6E00 0B32                276              BGT         opEOR               ; Else its EOR
0000119A                           277  
0000119A                           278  braTwelve   
0000119A  6000 10A4                279              BRA         opMULS              ; we know that there is only one opcode that is MULS    
0000119E                           280    
0000119E                           281  braThirteen 
0000119E  E141                     282              ASL         #eight, D1          ; we need the whole word to compare between add and adda, so move over the current byte 
000011A0  1218                     283              MOVE.B      (A0)+, D1           ; load the remaining byte to D1
000011A2                           284              
000011A2  4242                     285              CLR         D2                  ; clear D2
000011A4  3401                     286              MOVE.W      D1, D2              ; copy opcode to D2
000011A6  EC42                     287              ASR         #six, D2            ; shift the bits right to get size and type
000011A8  C47C 0007                288              AND         #seven,D2           ; clear out all but first 3 bits
000011AC                           289              
000011AC  B43C 0000                290              CMP.B       #zero,D2            ; compare 0 to D2
000011B0  6700 10F2                291              BEQ         opADDB              ; we know its ADDB
000011B4  B43C 0001                292              CMP.B       #one, D2            ; compare 1 to D2
000011B8  6700 1156                293              BEQ         opADDW              ; we know its ADDW
000011BC  B43C 0002                294              CMP.B       #two, D2            ; compare 2 to D2
000011C0  6700 11BA                295              BEQ         opADDL              ; we know its ADDL
000011C4  B43C 0003                296              CMP.B       #three, D2          ; compare 3 to D2
000011C8  6700 1226                297              BEQ         opADDAW             ; we know its ADDAW
000011CC  B43C 0004                298              CMP.B       #four, D2           ; compare 4 to D2
000011D0  6700 10D2                299              BEQ         opADDB              ; we know its ADDB
000011D4  B43C 0005                300              CMP.B       #five, D2           ; compare 5 to D2
000011D8  6700 1136                301              BEQ         opADDW              ; we know its ADDW
000011DC  B43C 0006                302              CMP.B       #six, D2            ; compare 6 to D2
000011E0  6700 119A                303              BEQ         opADDL              ; we know its ADDL
000011E4  B43C 0007                304              CMP.B       #seven, D2          ; compare 7 to D2
000011E8  6700 1276                305              BEQ         opADDAL             ; we know its ADDAL
000011EC  6000 2A8C                306              BRA         printInvalid        ; invalid opcode
000011F0                           307               
000011F0                           308  braFourteen 
000011F0  E141                     309              ASL.W       #eight,D1           ; we need the whole word to compare between add and adda, so move over the current byte
000011F2  1218                     310              MOVE.B      (A0)+, D1           ; load the remaining byte to D1
000011F4                           311              
000011F4  4242                     312              CLR         D2                  ; clear D2
000011F6  3401                     313              MOVE.W      D1, D2              ; copy opcode to D2
000011F8  EC42                     314              ASR         #six, D2            ; shift the bits right to get size
000011FA  C47C 0003                315              AND         #03,D2
000011FE                           316          
000011FE  B43C 0003                317              CMP.B       #three, D2          ; if the size is three, we are shifting memory
00001202  6700 0006                318              BEQ         memShifts           ; go to memory shift
00001206  6000 0040                319              BRA         regShifts           ; else go to register shift
0000120A                           320  
0000120A                           321  memShifts   
0000120A  4242                     322              CLR         D2             
0000120C  3401                     323              MOVE.W      D1, D2              ; clear out D2 and copy D1 back in
0000120E  E082                     324              ASR.L       #eight,D2           ; move to get first byte back
00001210  C47C 000F                325              AND         #secNib, D2         ; set first nibble to 0
00001214                           326   
00001214  B43C 0000                327              CMP.B       #zero, D2           ; compare second nibble to 0
00001218  6700 1302                328              BEQ         opASR               ; branch to ASR method
0000121C  B43C 0001                329              CMP.B       #one, D2            ; compare second nibble to 1
00001220  6700 12AE                330              BEQ         opASL               ; branch to ASL method
00001224  B43C 0002                331              CMP.B       #two, D2            ; compare second nibble to 2
00001228  6700 138A                332              BEQ         opLSR               ; branch to LSR method
0000122C  B43C 0003                333              CMP.B       #three, D2          ; compare second nibble to 3
00001230  6700 1336                334              BEQ         opLSL               ; branch to LSL method
00001234  B43C 0006                335              CMP.B       #six, D2            ; compare second nibble to 6
00001238  6700 1412                336              BEQ         opROR               ; branch to ROR method
0000123C  B43C 0007                337              CMP.B       #seven, D2          ; compare second nibble to 7
00001240  6700 13BE                338              BEQ         opROL               ; branch to ROL method
00001244  6000 2A34                339              BRA         printInvalid        ; otherwise, invalid
00001248                           340              
00001248                           341  regShifts   
00001248  B43C 0000                342              CMP.B       #zero, D2           ; if size is 0, we are shifting a byte
0000124C  6700 144A                343              BEQ         memSB               ; branch to register shift byte
00001250  B43C 0001                344              CMP.B       #one, D2            ; if size is 1, we are shifting a word
00001254  6700 16CC                345              BEQ         memSW               ; branch to register shift word
00001258  B43C 0002                346              CMP.B       #two, D2            ; if size is 1, we are shifting a long
0000125C  6700 194E                347              BEQ         memSL               ; branch to register shift long
00001260  6000 2A18                348              BRA         printInvalid        ; otherwise, invalid
00001264                           349              
00001264                           350  ***********************************************************************************************************
00001264                           351  *
00001264                           352  *                   ORI OPCODE
00001264                           353  *       ORI starts out with size branching. Will compare sizes and branch to appropriate size.
00001264                           354  *       Once size is found, code will print out ORI and continue to find mode and register and print it out
00001264                           355  *
00001264                           356  ***********************************************************************************************************
00001264                           357  
00001264                           358  opORI       
00001264  43F9 00003EF0            359              LEA         ORImatch, A1        ; we know that the opcode will be ORI, so load A1 to print message
0000126A  103C 000E                360              MOVE.B      #14, D0             ; command for trap call to display message
0000126E  4E4F                     361              TRAP        #15                 ; trap call
00001270                           362          
00001270  1218                     363              MOVE.B      (A0)+, D1
00001272  1401                     364              MOVE.B      D1,D2               ; copy data over
00001274  EC42                     365              ASR         #6,D2               ; shifts 6 bits over to read just the size        
00001276  B43C 0000                366              CMP.B       #zero,D2            ; Size is 0, must be byte
0000127A  6700 0016                367              BEQ         opORIB              ; Branch to ORIB to print and deal with the byte
0000127E  B43C 0001                368              CMP.B       #one,D2             ; Compare size to one
00001282  6700 0074                369              BEQ         opORIW              ; If size is one, then ORI is dealing with a word.
00001286  B43C 0002                370              CMP.B       #two,D2             ; Compare size to two
0000128A  6700 00D2                371              BEQ         opORIL              ; If size is two then move onto deal with long in opORIL
0000128E                           372          
0000128E  6000 29EA                373              BRA         printInvalid        ; None matches, invalid code. Branch off.
00001292                           374          
00001292                           375  opORIB      
00001292  43F9 00003F79            376              LEA         dispByte, A1        ; Display byte
00001298  103C 000E                377              MOVE.B      #14, D0             ; command for trap call to display message
0000129C  4E4F                     378              TRAP        #15                 ; trap call
0000129E                           379          
0000129E  43F9 00003EDF            380              LEA         space, A1           ; Display space
000012A4  103C 000E                381              MOVE.B      #14, D0             ; command for trap call to display message
000012A8  4E4F                     382              TRAP        #15                 ; trap call
000012AA                           383          
000012AA  4244                     384              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
000012AC  1801                     385              MOVE.B      D1,D4               ; Move byte over to D4 to use
000012AE  E644                     386              ASR         #three,D4           ; Moves out insignifcant bits to find mode
000012B0  C87C 0007                387              AND         #seven,D4           ; Clear other bits besides mode
000012B4  4245                     388              CLR         D5                  ; Use D5 as temporary register for destination regsiter
000012B6  1A01                     389              MOVE.B      D1,D5               ; Move data over to isolate mode
000012B8  CA7C 0007                390              AND         #seven,D5           ; Isolate the mode
000012BC                           391          
000012BC  4243                     392              CLR         D3                  ; Clear D3 to move register into it
000012BE  4242                     393              CLR         D2                  ; Clear D2 to move mode into it
000012C0  163C 0004                394              MOVE.B      #four,D3            ; Set values to be used in printEA
000012C4  143C 0007                395              MOVE.B      #seven,D2           ; Set values to be used in printEA
000012C8                           396      
000012C8  4EB9 00002F0E            397              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000012CE                           398          
000012CE  43F9 00003EE6            399              LEA         comma, A1           ; Display space
000012D4  103C 000E                400              MOVE.B      #14, D0             ; command for trap call to display message
000012D8  4E4F                     401              TRAP        #15                 ; trap call
000012DA                           402          
000012DA  4242                     403              CLR         D2                  ; Clear out D2 to move destination mode in
000012DC  4243                     404              CLR         D3                  ; Clear out D3 to move destintion register in
000012DE  1404                     405              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
000012E0  1605                     406              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA
000012E2                           407          
000012E2  4EB9 00002F0E            408              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000012E8                           409          
000012E8  43F9 00003EDB            410              LEA         newLine, A1           ; Display space
000012EE  103C 000E                411              MOVE.B      #14, D0             ; command for trap call to display message
000012F2  4E4F                     412              TRAP        #15                 ; trap call
000012F4                           413          
000012F4  6000 FD62                414              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000012F8                           415          
000012F8                           416  opORIW      
000012F8  43F9 00003F7C            417              LEA         dispWord, A1        ; Display byte
000012FE  103C 000E                418              MOVE.B      #14, D0             ; command for trap call to display message
00001302  4E4F                     419              TRAP        #15                 ; trap call
00001304                           420          
00001304  43F9 00003EDF            421              LEA         space, A1           ; Display space
0000130A  103C 000E                422              MOVE.B      #14, D0             ; command for trap call to display message
0000130E  4E4F                     423              TRAP        #15                 ; trap call
00001310                           424          
00001310  4244                     425              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
00001312  1801                     426              MOVE.B      D1,D4               ; Move byte over to D4 to use
00001314  E644                     427              ASR         #three,D4           ; Moves out insignifcant bits to find mode
00001316  C87C 0007                428              AND         #seven,D4           ; Clear other bits besides mode
0000131A  4245                     429              CLR         D5                  ; Use D5 as temporary register for destination regsiter
0000131C  1A01                     430              MOVE.B      D1,D5               ; Move data over to isolate mode
0000131E  CA7C 0007                431              AND         #seven,D5           ; Isolate the mode
00001322                           432          
00001322  4243                     433              CLR         D3                  ; Clear D3 to move register into it
00001324  4242                     434              CLR         D2                  ; Clear D2 to move mode into it
00001326  163C 0004                435              MOVE.B      #four,D3            ; Set values to be used in printEA
0000132A  143C 0007                436              MOVE.B      #seven,D2           ; Set values to be used in printEA
0000132E                           437          
0000132E  4EB9 00002F0E            438              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001334                           439          
00001334  43F9 00003EE6            440              LEA         comma, A1           ; Display space
0000133A  103C 000E                441              MOVE.B      #14, D0             ; command for trap call to display message
0000133E  4E4F                     442              TRAP        #15                 ; trap call
00001340                           443          
00001340  4242                     444              CLR         D2                  ; Clear out D2 to move destination mode in
00001342  4243                     445              CLR         D3                  ; Clear out D3 to move destintion register in
00001344  1404                     446              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
00001346  1605                     447              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA
00001348                           448                  
00001348  4EB9 00002F0E            449              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000134E                           450          
0000134E  43F9 00003EDB            451              LEA         newLine, A1           ; Display space
00001354  103C 000E                452              MOVE.B      #14, D0             ; command for trap call to display message
00001358  4E4F                     453              TRAP        #15                 ; trap call
0000135A                           454          
0000135A  6000 FCFC                455              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
0000135E                           456       
0000135E                           457  opORIL      
0000135E  43F9 00003F7F            458              LEA         dispLong, A1        ; Display byte
00001364  103C 000E                459              MOVE.B      #14, D0             ; command for trap call to display message
00001368  4E4F                     460              TRAP        #15                 ; trap call
0000136A                           461          
0000136A  43F9 00003EDF            462              LEA         space, A1           ; Display space
00001370  103C 000E                463              MOVE.B      #14, D0             ; command for trap call to display message
00001374  4E4F                     464              TRAP        #15                 ; trap call
00001376                           465          
00001376  4244                     466              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
00001378  1801                     467              MOVE.B      D1,D4               ; Move byte over to D4 to use
0000137A  E644                     468              ASR         #three,D4           ; Moves out insignifcant bits to find mode
0000137C  C87C 0007                469              AND         #seven,D4           ; Clear other bits besides mode
00001380  4245                     470              CLR         D5                  ; Use D5 as temporary register for destination regsiter
00001382  1A01                     471              MOVE.B      D1,D5               ; Move data over to isolate mode
00001384  CA7C 0007                472              AND         #seven,D5           ; Isolate the mode
00001388                           473          
00001388  4243                     474              CLR         D3                  ; Clear D3 to move register into it
0000138A  4242                     475              CLR         D2                  ; Clear D2 to move mode into it
0000138C  163C 0004                476              MOVE.B      #four,D3            ; Set values to be used in printEA
00001390  143C 0007                477              MOVE.B      #seven,D2           ; Set values to be used in printEA
00001394                           478          
00001394  4EB9 00002F0E            479              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000139A                           480          
0000139A  4242                     481              CLR         D2                  ; Clear out D2 to move destination mode in
0000139C  4243                     482              CLR         D3                  ; Clear out D3 to move destintion register in
0000139E  1404                     483              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
000013A0  1605                     484              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA
000013A2                           485          
000013A2  43F9 00003EE6            486              LEA         comma, A1           ; Display space
000013A8  103C 000E                487              MOVE.B      #14, D0             ; command for trap call to display message
000013AC  4E4F                     488              TRAP        #15                 ; trap call
000013AE                           489          
000013AE  4EB9 00002F0E            490              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000013B4                           491          
000013B4  43F9 00003EDB            492              LEA         newLine, A1           ; Display space
000013BA  103C 000E                493              MOVE.B      #14, D0             ; command for trap call to display message
000013BE  4E4F                     494              TRAP        #15                 ; trap call
000013C0                           495          
000013C0  6000 FC96                496              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000013C4                           497          
000013C4                           498  ***********************************************************************************************************
000013C4                           499  *
000013C4                           500  *                   CMPI OPCODE
000013C4                           501  *       This section is dedicated to the compare (CMPI) instruction. Its determined in the control loop
000013C4                           502  *       that the first nibble is 0 for CMPI, and the second nibble is 12.
000013C4                           503  *       The type of CMPI, or the opmode, is used to determined what we output to our console next.
000013C4                           504  *       From that point, we load the correct size/opmode, and then route to the EA subroutine to output
000013C4                           505  *       EA related register information.
000013C4                           506  *       The process for finding the operand register info (EA info) is similar for all opmodes.
000013C4                           507  *
000013C4                           508  ***********************************************************************************************************
000013C4                           509          
000013C4                           510  opCMPI           
000013C4  1218                     511              MOVE.B      (A0)+, D1
000013C6  1401                     512              MOVE.B      D1,D2               ; copy data over
000013C8  EC42                     513              ASR         #6,D2               ; shifts 6 bits over to read just the size        
000013CA  B43C 0000                514              CMP.B       #zero,D2            ; Check if size is 0 which is byte
000013CE  6700 0016                515              BEQ         opCMPIB             ; Moves to CMPIB if it is 0
000013D2  B43C 0001                516              CMP.B       #one,D2             ; Check if size is 0 which is word
000013D6  6700 0080                517              BEQ         opCMPIW             ; Branch to CMPIW
000013DA  B43C 0002                518              CMP.B       #two,D2             ; Check if size is 2 which is long
000013DE  6700 00FC                519              BEQ         opCMPIL             ; Branch to CMPIL
000013E2  6000 21A2                520              BRA         invalid             ; Size is invalid, therefore code is invalid.
000013E6                           521  
000013E6                           522  opCMPIB 
000013E6  43F9 00003EF4            523              LEA         CMPImatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
000013EC  103C 000E                524              MOVE.B      #14, D0             ; command for trap call to display message
000013F0  4E4F                     525              TRAP        #15                 ; trap call
000013F2                           526          
000013F2  43F9 00003F79            527              LEA         dispByte, A1        ; Display byte
000013F8  103C 000E                528              MOVE.B      #14, D0             ; command for trap call to display message
000013FC  4E4F                     529              TRAP        #15                 ; trap call
000013FE                           530          
000013FE  43F9 00003EDF            531              LEA         space, A1           ; Display space
00001404  103C 000E                532              MOVE.B      #14, D0             ; command for trap call to display message
00001408  4E4F                     533              TRAP        #15                 ; trap call
0000140A                           534          
0000140A  4244                     535              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
0000140C  1801                     536              MOVE.B      D1,D4               ; Move byte over to D4 to use
0000140E  E644                     537              ASR         #three,D4           ; Moves out insignifcant bits to find mode
00001410  C87C 0007                538              AND         #seven,D4           ; Clear other bits besides mode
00001414  4245                     539              CLR         D5                  ; Use D5 as temporary register for destination regsiter
00001416  1A01                     540              MOVE.B      D1,D5               ; Move data over to isolate mode
00001418  CA7C 0007                541              AND         #seven,D5           ; Isolate the mode
0000141C                           542          
0000141C  4243                     543              CLR         D3                  ; Clear D3 to move register into it
0000141E  4242                     544              CLR         D2                  ; Clear D2 to move mode into it
00001420  163C 0004                545              MOVE.B      #four,D3            ; Set values to be used in printEA
00001424  143C 0007                546              MOVE.B      #seven,D2           ; Set values to be used in printEA  
00001428                           547          
00001428  4EB9 00002F0E            548              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000142E                           549              
0000142E  43F9 00003EE6            550              LEA         comma, A1           ; Display space
00001434  103C 000E                551              MOVE.B      #14, D0             ; command for trap call to display message
00001438  4E4F                     552              TRAP        #15                 ; trap call
0000143A                           553          
0000143A  4242                     554              CLR         D2                  ; Clear out D2 to move destination mode in
0000143C  4243                     555              CLR         D3                  ; Clear out D3 to move destintion register in
0000143E  1404                     556              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
00001440  1605                     557              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA    
00001442                           558          
00001442  4EB9 00002F0E            559              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001448                           560          
00001448  43F9 00003EDB            561              LEA         newLine, A1         ; Display space
0000144E  103C 000E                562              MOVE.B      #14, D0             ; command for trap call to display message
00001452  4E4F                     563              TRAP        #15                 ; trap call
00001454                           564  
00001454  6000 FC02                565              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001458                           566  
00001458                           567  opCMPIW 
00001458  43F9 00003EF4            568              LEA         CMPImatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
0000145E  103C 000E                569              MOVE.B      #14, D0             ; command for trap call to display message
00001462  4E4F                     570              TRAP        #15                 ; trap call
00001464                           571          
00001464  43F9 00003F7C            572              LEA         dispWord, A1        ; Display byte
0000146A  103C 000E                573              MOVE.B      #14, D0             ; command for trap call to display message
0000146E  4E4F                     574              TRAP        #15                 ; trap call
00001470                           575          
00001470  43F9 00003EDF            576              LEA         space, A1           ; Display space
00001476  103C 000E                577              MOVE.B      #14, D0             ; command for trap call to display message
0000147A  4E4F                     578              TRAP        #15                 ; trap call
0000147C                           579          
0000147C  4244                     580              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
0000147E  1801                     581              MOVE.B      D1,D4               ; Move byte over to D4 to use
00001480  E644                     582              ASR         #three,D4           ; Moves out insignifcant bits to find mode
00001482  C87C 0007                583              AND         #seven,D4           ; Clear other bits besides mode
00001486  4245                     584              CLR         D5                  ; Use D5 as temporary register for destination regsiter
00001488  1A01                     585              MOVE.B      D1,D5               ; Move data over to isolate mode
0000148A  CA7C 0007                586              AND         #seven,D5           ; Isolate the mode
0000148E                           587          
0000148E  4243                     588              CLR         D3                  ; Clear D3 to move register into it
00001490  4242                     589              CLR         D2                  ; Clear D2 to move mode into it
00001492  163C 0004                590              MOVE.B      #four,D3            ; Set values to be used in printEA
00001496  143C 0007                591              MOVE.B      #seven,D2           ; Set values to be used in printEA      
0000149A                           592          
0000149A  4EB9 00002F0E            593              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000014A0                           594          
000014A0  43F9 00003EE2            595              LEA         hashTag, A1         ; Display space
000014A6  103C 000E                596              MOVE.B      #14, D0             ; command for trap call to display message
000014AA  4E4F                     597              TRAP        #15                 ; trap call
000014AC                           598          
000014AC  103C 0003                599              MOVE.B      #3, D0              ; Move 3 into D0 to output
000014B0  4E4F                     600              TRAP        #15                 ; Use TRAP #15 to output the immediate data
000014B2                           601          
000014B2  43F9 00003EE6            602              LEA         comma, A1           ; Display space
000014B8  103C 000E                603              MOVE.B      #14, D0             ; command for trap call to display message
000014BC  4E4F                     604              TRAP        #15                 ; trap call
000014BE                           605  
000014BE  4242                     606              CLR         D2                  ; Clear out D2 to move destination mode in
000014C0  4243                     607              CLR         D3                  ; Clear out D3 to move destintion register in
000014C2  1404                     608              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
000014C4  1605                     609              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA    
000014C6                           610          
000014C6  4EB9 00002F0E            611              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000014CC                           612          
000014CC  43F9 00003EDB            613              LEA         newLine, A1           ; Display space
000014D2  103C 000E                614              MOVE.B      #14, D0             ; command for trap call to display message
000014D6  4E4F                     615              TRAP        #15                 ; trap call
000014D8  6000 FB7E                616              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000014DC                           617  
000014DC                           618  opCMPIL 
000014DC  43F9 00003EF4            619              LEA         CMPImatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
000014E2  103C 000E                620              MOVE.B      #14, D0             ; command for trap call to display message
000014E6  4E4F                     621              TRAP        #15                 ; trap call
000014E8                           622          
000014E8  43F9 00003F7F            623              LEA         dispLong, A1        ; Display byte
000014EE  103C 000E                624              MOVE.B      #14, D0             ; command for trap call to display message
000014F2  4E4F                     625              TRAP        #15                 ; trap call
000014F4                           626          
000014F4  43F9 00003EDF            627              LEA         space, A1           ; Display space
000014FA  103C 000E                628              MOVE.B      #14, D0             ; command for trap call to display message
000014FE  4E4F                     629              TRAP        #15                 ; trap call
00001500                           630              
00001500  4244                     631              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
00001502  1801                     632              MOVE.B      D1,D4               ; Move byte over to D4 to use
00001504  E644                     633              ASR         #three,D4           ; Moves out insignifcant bits to find mode
00001506  C87C 0007                634              AND         #seven,D4           ; Clear other bits besides mode
0000150A  4245                     635              CLR         D5                  ; Use D5 as temporary register for destination regsiter
0000150C  1A01                     636              MOVE.B      D1,D5               ; Move data over to isolate mode
0000150E  CA7C 0007                637              AND         #seven,D5           ; Isolate the mode
00001512                           638          
00001512  4243                     639              CLR         D3                  ; Clear D3 to move register into it
00001514  4242                     640              CLR         D2                  ; Clear D2 to move mode into it
00001516  163C 0004                641              MOVE.B      #four,D3            ; Set values to be used in printEA
0000151A  143C 0007                642              MOVE.B      #seven,D2           ; Set values to be used in printEA  
0000151E                           643          
0000151E  4EB9 00002F0E            644              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001524                           645          
00001524  43F9 00003EE6            646              LEA         comma, A1           ; Display space
0000152A  103C 000E                647              MOVE.B      #14, D0             ; command for trap call to display message
0000152E  4E4F                     648              TRAP        #15                 ; trap call
00001530                           649          
00001530  4242                     650              CLR         D2                  ; Clear out D2 to move destination mode in
00001532  4243                     651              CLR         D3                  ; Clear out D3 to move destintion register in
00001534  1404                     652              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
00001536  1605                     653              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA                
00001538                           654          
00001538  4EB9 00002F0E            655              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000153E                           656          
0000153E  43F9 00003EDB            657              LEA         newLine, A1         ; Display space
00001544  103C 000E                658              MOVE.B      #14, D0             ; command for trap call to display message
00001548  4E4F                     659              TRAP        #15                 ; trap call
0000154A                           660          
0000154A  6000 FB0C                661              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
0000154E                           662          
0000154E                           663  ***********************************************************************************************************
0000154E                           664  *
0000154E                           665  *                   BCLR OPCODE
0000154E                           666  *       This section is dedicated to the compare BCLR instruction. The first nibble is 0 and the second
0000154E                           667  *       nibble is 2. Once both checks are passed then code goes to print BCLR and its EA.
0000154E                           668  *       
0000154E                           669  ***********************************************************************************************************
0000154E                           670  
0000154E                           671  opBCLR      
0000154E  43F9 00003EF9            672              LEA         BCLRmatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
00001554  103C 000E                673              MOVE.B      #14, D0             ; command for trap call to display message
00001558  4E4F                     674              TRAP        #15                 ; trap call
0000155A                           675  
0000155A  43F9 00003EDF            676              LEA         space, A1           ; Display space
00001560  103C 000E                677              MOVE.B      #14, D0             ; command for trap call to display message
00001564  4E4F                     678              TRAP        #15                 ; trap call
00001566                           679                  
00001566  4242                     680              CLR         D2                  ; Clear data register
00001568  1218                     681              MOVE.B      (A0)+, D1           ; Move byte over to D1 to be used
0000156A  1401                     682              MOVE.B      D1,D2               ; copy data over
0000156C  E642                     683              ASR         #three,D2           ; Shift to the right to remove register
0000156E  C47C 0007                684              AND         #seven,D2           ; Sets other bits to 0 and leave Mode the same
00001572                           685                  
00001572  4243                     686              CLR         D3                  ; Clear D3 so we can move D1 in
00001574  1601                     687              MOVE.B      D1,D3               ; Move othr byte in
00001576  C67C 0007                688              AND         #seven,D3           ; Set everything besides register to 0
0000157A                           689                 
0000157A  4241                     690              CLR         D1                  ; Clear out data register
0000157C  3218                     691              MOVE.W      (A0)+, D1           ; Take in next nibble that contains data
0000157E                           692                 
0000157E                           693                  
0000157E  43F9 00003EE2            694              LEA         hashTag, A1         ; Display space
00001584  103C 000E                695              MOVE.B      #14, D0             ; command for trap call to display message
00001588  4E4F                     696              TRAP        #15                 ; trap call
0000158A                           697          
0000158A  103C 0003                698              MOVE.B      #3, D0
0000158E  4E4F                     699              TRAP        #15
00001590                           700          
00001590  43F9 00003EE6            701              LEA         comma, A1           ; Display space
00001596  103C 000E                702              MOVE.B      #14, D0             ; command for trap call to display message
0000159A  4E4F                     703              TRAP        #15                 ; trap call
0000159C                           704                  
0000159C  4EB9 00002F0E            705              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000015A2                           706          
000015A2  43F9 00003EDB            707              LEA         newLine, A1           ; Display space
000015A8  103C 000E                708              MOVE.B      #14, D0             ; command for trap call to display message
000015AC  4E4F                     709              TRAP        #15                 ; trap call
000015AE                           710                  
000015AE  6000 FAA8                711              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits   
000015B2                           712          
000015B2                           713  opDynBCLR       
000015B2  4241                     714              CLR         D1
000015B4  1218                     715              MOVE.B      (A0)+,D1            ; Copy second byte in
000015B6  1601                     716              MOVE.B      D1,D3               ; Will use D4 to store in the source register
000015B8  E243                     717              ASR         #one,D3             ; Shift register over to the end
000015BA  C67C 0007                718              AND         #seven,D3           ; Change all bits except for the register to 0. Source Register is now in D4
000015BE                           719                  
000015BE  1401                     720              MOVE.B      D1,D2
000015C0  EC42                     721              ASR         #six,D2             ; Removing mode and register to check BCLR bits
000015C2  B47C 0002                722              CMP         #two,D2             ; Checking the static bits to make sure it is BCLR
000015C6  6600 26B2                723              BNE         printInvalid        ; If not equal, than this is not BCLR or any other mode we're dealing with
000015CA                           724  
000015CA                           725                  
000015CA  43F9 00003EF9            726              LEA         BCLRmatch, A1       ; we now know that the opcode will be BCLR, so load A1 to print message
000015D0  103C 000E                727              MOVE.B      #14, D0             ; command for trap call to display message
000015D4  4E4F                     728              TRAP        #15                 ; trap call  
000015D6                           729                  
000015D6  43F9 00003EDF            730              LEA         space, A1           ; Display space
000015DC  103C 000E                731              MOVE.B      #14, D0             ; command for trap call to display message
000015E0  4E4F                     732              TRAP        #15                 ; trap call
000015E2                           733                  
000015E2  143C 0000                734              MOVE.B      #zero,D2            ; Move 0 into D2 to print out data register in printEA   
000015E6  4EB9 00002F0E            735              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000015EC                           736                  
000015EC  43F9 00003EE6            737              LEA         comma, A1           ; Display space
000015F2  103C 000E                738              MOVE.B      #14, D0             ; command for trap call to display message
000015F6  4E4F                     739              TRAP        #15                 ; trap call
000015F8                           740                
000015F8  4242                     741              CLR         D2
000015FA  1401                     742              MOVE.B      D1,D2               ; Using D2 to store EA mode
000015FC  E642                     743              ASR         #three,D2           ; Remove/shift the register out
000015FE  C47C 0007                744              AND         #seven,D2           ; Change all bits except for the mode bits to 0
00001602                           745                  
00001602  4243                     746              CLR         D3                  ; Clearing D3 to avoid mashing data
00001604  1601                     747              MOVE.B      D1,D3               ; Moving byte into D3. Using D3 to store EA register
00001606  C67C 0007                748              AND         #seven,D3           ; Change all bits except for register bits to 0
0000160A                           749              
0000160A  4EB9 00002F0E            750              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001610                           751          
00001610  43F9 00003EDB            752              LEA         newLine, A1         ; Display space
00001616  103C 000E                753              MOVE.B      #14, D0             ; command for trap call to display message
0000161A  4E4F                     754              TRAP        #15                 ; trap call            
0000161C                           755  
0000161C                           756  
0000161C  6000 FA3A                757              BRA         LOOP                ; go back to the loop   
00001620                           758                  
00001620                           759  ***********************************************************************************************************
00001620                           760  *
00001620                           761  *                   MOVE OPCODE
00001620                           762  *                   MOVEA OPCODE
00001620                           763  *       This section of code is dedication to MOVE and MOVEA opcode instructions. MOVEA is determined by
00001620                           764  *       its static bits at 8, 7, and 6. Once those static bits are confirmed, the code branches off to 
00001620                           765  *       MOVEA, else it continues into MOVE.
00001620                           766  *
00001620                           767  ***********************************************************************************************************
00001620                           768   
00001620                           769  opMOVEB 
00001620  43F9 00003EFE            770              LEA         MOVEmatch, A1       ; we know that the opcode will be MOVE.B, so load A1 to print message
00001626  103C 000E                771              MOVE.B      #14, D0             ; command for trap call to display message
0000162A  4E4F                     772              TRAP        #15                 ; trap call
0000162C  43F9 00003F79            773              LEA         dispByte, A1        ; display byte
00001632  103C 000E                774              MOVE.B      #14, D0             ; command for trap call to display message
00001636  4E4F                     775              TRAP        #15                 ; trap call
00001638  43F9 00003EDF            776              LEA         space, A1           ; create spaces
0000163E  103C 000E                777              MOVE.B      #14, D0             ; command for trap call to display message
00001642  4E4F                     778              TRAP        #15                 ; trap call
00001644                           779          
00001644                           780          
00001644  4245                     781              CLR         D5                  ; Clear D5
00001646  1A01                     782              MOVE.B      D1,D5               ; Copying byte over to D5. Will use D5 to store destination Register
00001648  E245                     783              ASR         #one,D5             ; shifted mode out. Register is now stored into D5
0000164A  CA7C 0007                784              AND         #seven,D5
0000164E                           785          
0000164E  4244                     786              CLR         D4                  ; Clear out D4
00001650  1801                     787              MOVE.B      D1,D4               ; Copy byte over to store destination mode
00001652  C87C 0001                788              AND         #one,D4             ; Set all the other bits to 0, leave the bit for the destination mode alone.
00001656                           789          
00001656  4241                     790              CLR          D1                 ; Clear data register
00001658  4242                     791              CLR          D2                 ; Clear data register
0000165A  1218                     792              MOVE.B      (A0)+,D1            ; Copy byte into D1
0000165C  1401                     793              MOVE.B      D1,D2
0000165E  EC42                     794              ASR         #6,D2               ; Shifts source mode and register out to get destination mode
00001660  D842                     795              ADD         D2,D4               ; Adds the remaining bits to D4
00001662                           796          
00001662  4242                     797              CLR         D2                  ; Clear data register
00001664  1401                     798              MOVE.B      D1,D2               ; Copy new byte over to D2
00001666  E642                     799              ASR         #three,D2           ; Shift source register out
00001668  C47C 0007                800              AND         #seven,D2           ; Set everything to 0 except for the mode
0000166C                           801          
0000166C  4243                     802              CLR         D3                  ; Clear Data register 3
0000166E  1601                     803              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
00001670  C67C 0007                804              AND         #seven,D3           ; Sets up everything to 0 except for the register bits
00001674                           805          
00001674  4EB9 00002F0E            806              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000167A                           807          
0000167A  43F9 00003EE6            808              LEA         comma, A1           ; Display space
00001680  103C 000E                809              MOVE.B      #14, D0             ; command for trap call to display message
00001684  4E4F                     810              TRAP        #15                 ; trap call
00001686                           811          
00001686  4242                     812              CLR         D2                  ; Clear data register
00001688  4243                     813              CLR         D3                  ; Clear data register
0000168A  1404                     814              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
0000168C  1605                     815              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
0000168E                           816          
0000168E  4EB9 00002F0E            817              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001694                           818          
00001694  43F9 00003EDB            819              LEA         newLine, A1         ; Display space
0000169A  103C 000E                820              MOVE.B      #14, D0             ; command for trap call to display message
0000169E  4E4F                     821              TRAP        #15                 ; trap call            
000016A0                           822  
000016A0  6000 F9B6                823              BRA         LOOP                ; go back to the loop
000016A4                           824          
000016A4                           825  opMOVEL     
000016A4  4245                     826              CLR         D5                  ; Clear D5
000016A6  1A01                     827              MOVE.B      D1,D5               ; Copying byte over to D5. Will use D5 to store destination Register
000016A8  E245                     828              ASR         #one,D5             ; shifted mode out. Register is now stored into D5
000016AA  CA7C 0007                829              AND         #seven,D5
000016AE                           830          
000016AE  4244                     831              CLR         D4                  ; Clear out D4
000016B0  1801                     832              MOVE.B      D1,D4               ; Copy byte over to store destination mode
000016B2  C87C 0001                833              AND         #one,D4             ; Set all the other bits to 0, leave the bit for the destination mode alone.
000016B6                           834          
000016B6  4241                     835              CLR          D1                 ; Clear data register
000016B8  4242                     836              CLR          D2                 ; Clear data register
000016BA  1218                     837              MOVE.B      (A0)+,D1            ; Copy byte into D1
000016BC  1401                     838              MOVE.B      D1,D2
000016BE  EC42                     839              ASR         #6,D2               ; Shifts source mode and register out to get destination mode
000016C0  D842                     840              ADD         D2,D4               ; Adds the remaining bits to D4
000016C2                           841          
000016C2  B87C 0001                842              CMP         #one,D4             ; Check if it is MOVEA
000016C6  6700 0070                843              BEQ         opMOVEAL            ; If it is, branch off
000016CA                           844              
000016CA  43F9 00003EFE            845              LEA         MOVEmatch, A1       ; we know that the opcode will be MOVE.L OR MOVEA.L, so load A1 to print message
000016D0  103C 000E                846              MOVE.B      #14, D0             ; command for trap call to display message
000016D4  4E4F                     847              TRAP        #15                 ; trap call  
000016D6                           848              
000016D6  43F9 00003F7F            849              LEA         dispLong,A1         ; Prints out L to display a long
000016DC  103C 000E                850              MOVE.B      #14, D0             ; command for trap call to display message
000016E0  4E4F                     851              TRAP        #15                 ; trap call
000016E2                           852              
000016E2  43F9 00003EDF            853              LEA         space, A1           ; create spaces
000016E8  103C 000E                854              MOVE.B      #14, D0             ; command for trap call to display message
000016EC  4E4F                     855              TRAP        #15                 ; trap call
000016EE                           856          
000016EE  4242                     857              CLR         D2                  ; Clear data register
000016F0  1401                     858              MOVE.B      D1,D2               ; Copy new byte over to D2
000016F2  E642                     859              ASR         #three,D2           ; Shift source register out
000016F4  C47C 0007                860              AND         #seven,D2           ; Set everything to 0 except for the mode
000016F8                           861          
000016F8  4243                     862              CLR         D3                  ; Clear Data register 3
000016FA  1601                     863              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
000016FC  C67C 0007                864              AND         #seven,D3           ; Sets up everything to 0 except for the register bits      
00001700                           865              
00001700  4246                     866              CLR         D6                  ; Clear data register
00001702  1C3C 0001                867              MOVE.B      #1,D6               ; Moves 1 into D6 to be used in printEA to display long
00001706  4EB9 00002F0E            868              JSR         printEA             ; Prints out EA
0000170C  4246                     869              CLR         D6
0000170E                           870              
0000170E  43F9 00003EE6            871              LEA         comma, A1           ; Display comma
00001714  103C 000E                872              MOVE.B      #14, D0             ; command for trap call to display message
00001718  4E4F                     873              TRAP        #15                 ; trap call
0000171A                           874          
0000171A  4242                     875              CLR         D2                  ; Clear data register            
0000171C  4243                     876              CLR         D3                  ; Clear data register
0000171E  1404                     877              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
00001720  1605                     878              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
00001722                           879          
00001722  4EB9 00002F0E            880              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001728                           881  
00001728  43F9 00003EDB            882              LEA         newLine, A1         ; Display space
0000172E  103C 000E                883              MOVE.B      #14, D0             ; command for trap call to display message
00001732  4E4F                     884              TRAP        #15                 ; trap call            
00001734                           885  
00001734  6000 F922                886              BRA         LOOP                ; go back to the loop
00001738                           887              
00001738                           888  opMOVEAL
00001738  43F9 00003F03            889              LEA         MOVEAmatch,A1       ; MOVEA has been determined. Print out MOVEA
0000173E  103C 000E                890              MOVE.B      #14, D0             ; command for trap call to display message
00001742  4E4F                     891              TRAP        #15                 ; trap call
00001744                           892              
00001744  43F9 00003F7F            893              LEA         dispLong,A1         ; Prints out L
0000174A  103C 000E                894              MOVE.B      #14, D0             ; command for trap call to display message
0000174E  4E4F                     895              TRAP        #15                 ; trap call
00001750                           896              
00001750                           897  
00001750  43F9 00003EDF            898              LEA         space, A1           ; create spaces
00001756  103C 000E                899              MOVE.B      #14, D0             ; command for trap call to display message
0000175A  4E4F                     900              TRAP        #15                 ; trap call
0000175C                           901              
0000175C  4242                     902              CLR         D2                  ; Clear data register
0000175E  1401                     903              MOVE.B      D1,D2               ; Copy new byte over to D2
00001760  E642                     904              ASR         #three,D2           ; Shift source register out
00001762  C47C 0007                905              AND         #seven,D2           ; Set everything to 0 except for the mode
00001766                           906          
00001766  4243                     907              CLR         D3                  ; Clear Data register 3
00001768  1601                     908              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
0000176A  C67C 0007                909              AND         #seven,D3           ; Sets up everything to 0 except for the register bits    
0000176E                           910              
0000176E  4241                     911              CLR         D1                  ; Clear D1
00001770                           912              
00001770  4EB9 00002F0E            913              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001776                           914              
00001776  43F9 00003EE6            915              LEA         comma, A1           ; Display comma
0000177C  103C 000E                916              MOVE.B      #14, D0             ; command for trap call to display message
00001780  4E4F                     917              TRAP        #15                 ; trap call
00001782                           918  
00001782  4242                     919              CLR         D2                  ; Clear data register
00001784  4243                     920              CLR         D3                  ; Clear data register
00001786  1404                     921              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
00001788  1605                     922              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
0000178A                           923          
0000178A  4EB9 00002F0E            924              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001790                           925          
00001790  43F9 00003EDB            926              LEA         newLine, A1         ; Display space
00001796  103C 000E                927              MOVE.B      #14, D0             ; command for trap call to display message
0000179A  4E4F                     928              TRAP        #15                 ; trap call            
0000179C                           929  
0000179C  6000 F8BA                930              BRA         LOOP                ; go back to the loop
000017A0                           931  
000017A0                           932  opMOVEW
000017A0  4245                     933              CLR         D5                  ; Clear D5
000017A2  1A01                     934              MOVE.B      D1,D5               ; Copying byte over to D5. Will use D5 to store destination Register
000017A4  E245                     935              ASR         #one,D5             ; shifted mode out. Register is now stored into D5
000017A6  CA7C 0007                936              AND         #seven,D5
000017AA                           937          
000017AA  4244                     938              CLR         D4                  ; Clear out D4
000017AC  1801                     939              MOVE.B      D1,D4               ; Copy byte over to store destination mode
000017AE  C87C 0001                940              AND         #one,D4             ; Set all the other bits to 0, leave the bit for the destination mode alone.
000017B2                           941          
000017B2  4241                     942              CLR          D1                 ; Clear data register
000017B4  4242                     943              CLR          D2                 ; Clear data register
000017B6  1218                     944              MOVE.B      (A0)+,D1            ; Copy byte into D1
000017B8  1401                     945              MOVE.B      D1,D2
000017BA  EC42                     946              ASR         #6,D2               ; Shifts source mode and register out to get destination mode
000017BC  D842                     947              ADD         D2,D4               ; Adds the remaining bits to D4
000017BE                           948          
000017BE  B87C 0001                949              CMP         #one,D4             ; Check if it is MOVEA
000017C2  6700 006A                950              BEQ         opMOVEAW            ; If it is, branch off
000017C6                           951              
000017C6  43F9 00003EFE            952              LEA         MOVEmatch, A1       ; we know that the opcode will be MOVE.L OR MOVEA.L, so load A1 to print message
000017CC  103C 000E                953              MOVE.B      #14, D0             ; command for trap call to display message
000017D0  4E4F                     954              TRAP        #15                 ; trap call  
000017D2                           955              
000017D2  43F9 00003F7C            956              LEA         dispWord,A1         ; Prints out a W after the opcode
000017D8  103C 000E                957              MOVE.B      #14, D0             ; command for trap call to display message
000017DC  4E4F                     958              TRAP        #15                 ; trap call
000017DE                           959              
000017DE  43F9 00003EDF            960              LEA         space, A1           ; create spaces
000017E4  103C 000E                961              MOVE.B      #14, D0             ; command for trap call to display message
000017E8  4E4F                     962              TRAP        #15                 ; trap call
000017EA                           963          
000017EA  4242                     964              CLR         D2
000017EC  1401                     965              MOVE.B      D1,D2               ; Copy new byte over to D2
000017EE  E642                     966              ASR         #three,D2           ; Shift source register out
000017F0  C47C 0007                967              AND         #seven,D2           ; Set everything to 0 except for the mode
000017F4                           968          
000017F4  4243                     969              CLR         D3                  ; Clear Data register 3
000017F6  1601                     970              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
000017F8  C67C 0007                971              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
000017FC                           972              
000017FC  4241                     973              CLR         D1                  ; Clear D1
000017FE                           974              
000017FE  4EB9 00002F0E            975              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001804                           976              
00001804  43F9 00003EE6            977              LEA         comma, A1           ; Display comma
0000180A  103C 000E                978              MOVE.B      #14, D0             ; command for trap call to display message
0000180E  4E4F                     979              TRAP        #15                 ; trap call
00001810                           980          
00001810  4242                     981              CLR         D2                  ; Clear data register 
00001812  4243                     982              CLR         D3                  ; Clear data register
00001814  1404                     983              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
00001816  1605                     984              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
00001818  4EB9 00002F0E            985              JSR         printEA
0000181E                           986          
0000181E  43F9 00003EDB            987              LEA         newLine, A1         ; Display space
00001824  103C 000E                988              MOVE.B      #14, D0             ; command for trap call to display message
00001828  4E4F                     989              TRAP        #15                 ; trap call            
0000182A                           990  
0000182A  6000 F82C                991              BRA         LOOP                ; go back to the loop
0000182E                           992              
0000182E                           993  opMOVEAW  
0000182E  43F9 00003F03            994              LEA         MOVEAmatch,A1       ; Prints out MOVEA
00001834  103C 000E                995              MOVE.B      #14, D0             ; command for trap call to display message
00001838  4E4F                     996              TRAP        #15                 ; trap call
0000183A                           997                  
0000183A  43F9 00003F7C            998              LEA         dispWord,A1         ; Prints out W
00001840  103C 000E                999              MOVE.B      #14, D0             ; command for trap call to display message
00001844  4E4F                    1000              TRAP        #15                 ; trap call
00001846                          1001              
00001846  43F9 00003EDF           1002              LEA         space, A1           ; create spaces
0000184C  103C 000E               1003              MOVE.B      #14, D0             ; command for trap call to display message
00001850  4E4F                    1004              TRAP        #15                 ; trap call
00001852                          1005              
00001852  4242                    1006              CLR         D2                  ; Clear data register
00001854  1401                    1007              MOVE.B      D1,D2               ; Copy new byte over to D2
00001856  E642                    1008              ASR         #three,D2           ; Shift source register out
00001858  C47C 0007               1009              AND         #seven,D2           ; Set everything to 0 except for the mode
0000185C                          1010          
0000185C  4243                    1011              CLR         D3                  ; Clear Data register 3
0000185E  1601                    1012              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
00001860  C67C 0007               1013              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
00001864                          1014              
00001864  4241                    1015              CLR         D1                  ; Clear D1      
00001866                          1016              
00001866  4EB9 00002F0E           1017              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000186C                          1018              
0000186C  43F9 00003EE6           1019              LEA         comma, A1           ; Display comma
00001872  103C 000E               1020              MOVE.B      #14, D0             ; command for trap call to display message
00001876  4E4F                    1021              TRAP        #15                 ; trap call
00001878                          1022  
00001878  4242                    1023              CLR         D2                  ; Clear data register
0000187A  4243                    1024              CLR         D3                  ; Clear data register
0000187C  1404                    1025              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
0000187E  1605                    1026              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
00001880                          1027          
00001880  4EB9 00002F0E           1028              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001886                          1029          
00001886  43F9 00003EDB           1030              LEA         newLine, A1         ; Display space
0000188C  103C 000E               1031              MOVE.B      #14, D0             ; command for trap call to display message
00001890  4E4F                    1032              TRAP        #15                 ; trap call            
00001892                          1033  
00001892  6000 F7C4               1034              BRA         LOOP                ; go back to the loop
00001896                          1035  
00001896                          1036  ***********************************************************************************************************
00001896                          1037  *
00001896                          1038  *                   NEG OPCODE
00001896                          1039  *       This section is dedicated to the NEG opmode instruction. NEG is determined by the first and
00001896                          1040  *       the second nibble. The first nibble is 4 and the second nibble is equal to 0. Once that has been
00001896                          1041  *       determined. NEG is printed out.
00001896                          1042  ***********************************************************************************************************
00001896                          1043  
00001896                          1044  opNEG   
00001896  43F9 00003F09           1045              LEA         NEGmatch, A1        ; we know that the opcode will be NEG, so load A1 to print message
0000189C  103C 000E               1046              MOVE.B      #14, D0             ; command for trap call to display message
000018A0  4E4F                    1047              TRAP        #15                 ; trap call
000018A2                          1048          
000018A2                          1049          
000018A2  1218                    1050              MOVE.B      (A0)+, D1           ; Move data into D1 for use 
000018A4  1401                    1051              MOVE.B      D1,D2               ; copy data over
000018A6  EC42                    1052              ASR         #six,D2             ; Moves six bits over to read the size
000018A8                          1053              
000018A8  B47C 0000               1054              CMP         #zero,D2            ; Compare size
000018AC  6700 0016               1055              BEQ         opNEGB              ; Branch to NEG if size is byte
000018B0  B47C 0001               1056              CMP         #one,D2             ; Compare size with one, 
000018B4  6700 008E               1057              BEQ         opNEGW              ; If equal, size is a word. Branch to NEGW
000018B8  B47C 0002               1058              CMP         #two,D2             ; Compare size with two
000018BC  6700 0046               1059              BEQ         opNEGL              ; If size is two, NEG size is long. Branch to NEGL
000018C0  6000 1CC4               1060              BRA         invalid             ; If size is neither, code is invalid. Branch to deal with invalid code.
000018C4                          1061              
000018C4                          1062  opNEGB
000018C4  43F9 00003F79           1063              LEA         dispByte, A1        ; we know that the opcode will be NEG, so load A1 to print message
000018CA  103C 000E               1064              MOVE.B      #14, D0             ; command for trap call to display message
000018CE  4E4F                    1065              TRAP        #15                 ; trap call
000018D0                          1066          
000018D0  43F9 00003EDF           1067              LEA         space, A1           ; we know that the opcode will be NEG, so load A1 to print message
000018D6  103C 000E               1068              MOVE.B      #14, D0             ; command for trap call to display message
000018DA  4E4F                    1069              TRAP        #15                 ; trap call
000018DC                          1070          
000018DC  4242                    1071              CLR         D2                  ; Clear Data register 2
000018DE  3401                    1072              MOVE        D1,D2               ; Move byte into D2
000018E0  E642                    1073              ASR         #three,D2           ; Shift mode into place and moves mode into place
000018E2  C47C 0007               1074              AND         #seven,D2           ; Stores mode
000018E6                          1075              
000018E6  4243                    1076              CLR         D3                  ; Clear Data register 3
000018E8  1601                    1077              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
000018EA  C67C 0007               1078              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
000018EE                          1079              
000018EE  4EB9 00002F0E           1080              JSR         printEA
000018F4                          1081                  
000018F4  43F9 00003EDB           1082              LEA         newLine, A1         ; Display space
000018FA  103C 000E               1083              MOVE.B      #14, D0             ; command for trap call to display message
000018FE  4E4F                    1084              TRAP        #15                 ; trap call  
00001900                          1085          
00001900  6000 F756               1086              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001904                          1087  
00001904                          1088  opNEGL
00001904  43F9 00003F7F           1089              LEA         dispLong, A1        ; we know that the opcode will be NEG, so load A1 to print message
0000190A  103C 000E               1090              MOVE.B      #14, D0             ; command for trap call to display message
0000190E  4E4F                    1091              TRAP        #15                 ; trap call
00001910                          1092  
00001910  43F9 00003EDF           1093              LEA         space, A1           ; we know that the opcode will be NEG, so load A1 to print message
00001916  103C 000E               1094              MOVE.B      #14, D0             ; command for trap call to display message
0000191A  4E4F                    1095              TRAP        #15                 ; trap call
0000191C                          1096                  
0000191C  4242                    1097              CLR         D2                  ; Clear Data register 2
0000191E  3401                    1098              MOVE        D1,D2               ; Move byte into D2
00001920  E642                    1099              ASR         #three,D2           ; Shift mode into place and moves mode into place
00001922  C47C 0007               1100              AND         #seven,D2           ; Stores mode
00001926                          1101          
00001926  4243                    1102              CLR         D3                  ; Clear Data register 3
00001928  1601                    1103              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
0000192A  C67C 0007               1104              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
0000192E                          1105          
0000192E  4EB9 00002F0E           1106              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001934                          1107                      
00001934  43F9 00003EDB           1108              LEA         newLine, A1         ; Display space
0000193A  103C 000E               1109              MOVE.B      #14, D0             ; command for trap call to display message
0000193E  4E4F                    1110              TRAP        #15                 ; trap call  
00001940                          1111          
00001940  6000 F716               1112              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001944                          1113  
00001944                          1114  opNEGW
00001944  43F9 00003F7C           1115              LEA         dispWord, A1        ; we know that the opcode will be NEG, so load A1 to print message
0000194A  103C 000E               1116              MOVE.B      #14, D0             ; command for trap call to display message
0000194E  4E4F                    1117              TRAP        #15                 ; trap call
00001950                          1118          
00001950  43F9 00003EDF           1119              LEA         space, A1           ; we know that the opcode will be NEG, so load A1 to print message
00001956  103C 000E               1120              MOVE.B      #14, D0             ; command for trap call to display message
0000195A  4E4F                    1121              TRAP        #15                 ; trap call        
0000195C                          1122                  
0000195C  4242                    1123              CLR         D2                  ; Clear Data register 2
0000195E  3401                    1124              MOVE        D1,D2               ; Move byte into D2
00001960  E642                    1125              ASR         #three,D2           ; Shift mode into place and moves mode into place
00001962  C47C 0007               1126              AND         #seven,D2           ; Stores mode
00001966                          1127          
00001966  4243                    1128              CLR         D3                  ; Clear Data register 3
00001968  1601                    1129              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
0000196A  C67C 0007               1130              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
0000196E                          1131          
0000196E  4EB9 00002F0E           1132              JSR         printEA
00001974                          1133              
00001974  43F9 00003EDB           1134              LEA         newLine, A1         ; Display space
0000197A  103C 000E               1135              MOVE.B      #14, D0             ; command for trap call to display message
0000197E  4E4F                    1136              TRAP        #15                 ; trap call  
00001980                          1137          
00001980  6000 F6D6               1138              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001984                          1139              
00001984                          1140  ***********************************************************************************************************
00001984                          1141  *
00001984                          1142  *                   RTS_JSR Helper Function
00001984                          1143  *       Compare byte with static bits from JSR and RTS. If data is not equal to either, then data is
00001984                          1144  *       considered an invalid opcode and branches off to invalid.
00001984                          1145  *
00001984                          1146  ***********************************************************************************************************
00001984                          1147  
00001984                          1148  opRTSJSR
00001984  1218                    1149              MOVE.B      (A0)+, D1           ; Move byte into D1 and increment.
00001986                          1150              
00001986  1401                    1151              MOVE.B      D1,D2               ; copy data over
00001988  B47C 0075               1152              CMP         #117,D2             ; 117 is the decimal value of RTS.
0000198C  6700 0052               1153              BEQ         opRTS               ; If equal, branch to RTS to print out.
00001990                          1154              
00001990  EC42                    1155              ASR         #six,D2             ; Moving bits over to check if it matches the two static bits in JSR
00001992  B47C 0002               1156              CMP         #two,D2             ; Checking if it is JSR
00001996  6700 0006               1157              BEQ         opJSR               ; It is equal, so branch off to opJSR
0000199A                          1158  
0000199A  6000 1BEA               1159              BRA         invalid             ; Branch to invalid to deal with invalid data.
0000199E                          1160              
0000199E                          1161  ***********************************************************************************************************
0000199E                          1162  *
0000199E                          1163  *                   JSR OPCODE
0000199E                          1164  *       This section is dedicated to the JSR opmode instruction. JSR is determined by the 9 static bits.
0000199E                          1165  *       Once the bits have matched the disassembled code, the code passes through and prints out JSR along
0000199E                          1166  *       with its EA.               
0000199E                          1167  *
0000199E                          1168  ***********************************************************************************************************
0000199E                          1169  
0000199E                          1170  opJSR
0000199E  43F9 00003F11           1171              LEA         JSRMatch, A1        ; we know that the opcode will be JSR, so load A1 to print message
000019A4  103C 000E               1172              MOVE.B      #14, D0             ; command for trap call to display message
000019A8  4E4F                    1173              TRAP        #15                 ; trap call
000019AA                          1174              
000019AA  43F9 00003EDF           1175              LEA         space, A1           ; we know that the opcode will be NEG, so load A1 to print message
000019B0  103C 000E               1176              MOVE.B      #14, D0             ; command for trap call to display message
000019B4  4E4F                    1177              TRAP        #15                 ; trap call
000019B6                          1178              
000019B6  4242                    1179              CLR         D2                  ; Clearing data register 
000019B8  4243                    1180              CLR         D3                  ; Clearing data register 
000019BA                          1181              
000019BA  1401                    1182              MOVE.B      D1,D2               ; Move D1 data to D2 to find the EA mode
000019BC  E642                    1183              ASR         #three,D2           ; Move mode over to the end in order to read
000019BE  C47C 0007               1184              AND         #seven,D2           ; Set every bit to 0 except for mode bits
000019C2                          1185              
000019C2  4243                    1186              CLR         D3
000019C4  1601                    1187              MOVE.B      D1,D3               ; Move bits over to D3 to find register
000019C6  C67C 0007               1188              AND         #seven,D3           ; Sets every bit to 0 except for register bits
000019CA                          1189              
000019CA  4EB9 00002F0E           1190              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000019D0                          1191              
000019D0  43F9 00003EDB           1192              LEA         newLine, A1         ; Display space
000019D6  103C 000E               1193              MOVE.B      #14, D0             ; command for trap call to display message
000019DA  4E4F                    1194              TRAP        #15                 ; trap call  
000019DC                          1195              
000019DC  6000 F67A               1196              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000019E0                          1197  
000019E0                          1198  ***********************************************************************************************************
000019E0                          1199  *
000019E0                          1200  *                   RTS OPCODE
000019E0                          1201  *       Function prints out RTS. Does not need to check in here as it is done beforehand. Branches back
000019E0                          1202  *       into loop afterwards.
000019E0                          1203  *
000019E0                          1204  ***********************************************************************************************************
000019E0                          1205  
000019E0                          1206  opRTS
000019E0  43F9 00003F0D           1207              LEA         RTSMatch, A1        ; we know that the opcode will be RTS, so load A1 to print message
000019E6  103C 000E               1208              MOVE.B      #14, D0             ; command for trap call to display message
000019EA  4E4F                    1209              TRAP        #15                 ; trap call
000019EC                          1210              
000019EC  43F9 00003EDB           1211              LEA         newLine, A1         ; Display space
000019F2  103C 000E               1212              MOVE.B      #14, D0             ; command for trap call to display message
000019F6  4E4F                    1213              TRAP        #15                 ; trap call 
000019F8                          1214              
000019F8  6000 F65E               1215              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000019FC                          1216              
000019FC                          1217  ***********************************************************************************************************
000019FC                          1218  *
000019FC                          1219  *                   MOVEM_LEA OPCODE
000019FC                          1220  *       This part of the code is used to branch to either MOVEM or LEA depending on the second nibble.
000019FC                          1221  *
000019FC                          1222  ***********************************************************************************************************
000019FC                          1223  
000019FC                          1224  opMOVEMLEA
000019FC  4242                    1225              CLR         D2                  ; Clear D2
000019FE  1401                    1226              MOVE.B      D1,D2               ; Copy byte over
00001A00  C47C 000F               1227              AND         #secNib,D2          ; Check only the second nibble
00001A04  B47C 000C               1228              CMP         #twelve,D2          ; Compare the second nibble to twelve
00001A08  6700 000E               1229              BEQ         opMOVEM             ; If it is twelve, then it is MOVEM
00001A0C  B47C 0008               1230              CMP         #eight,D2           ; Compare the second nibble to eight
00001A10  6700 0006               1231              BEQ         opMOVEM             ; If it is eight, then it is also MOVEM
00001A14  6000 008C               1232              BRA         opLEA               ; Otherwise branch to OPLEA and check for invalid in there
00001A18                          1233              
00001A18                          1234  ***********************************************************************************************************
00001A18                          1235  *
00001A18                          1236  *                   MOVEM OPCODE
00001A18                          1237  *       MOVEM has 7 static bits. Before anything is done, static bits are checked and the dr field is stored
00001A18                          1238  *       into D6 to be used later on for specific branching. After the static bits have confirmed this is
00001A18                          1239  *       indeed MOVEM that is being disassembled, the code will print out MOVEM and goes into the subroutine
00001A18                          1240  *       to print out the data and address registers.
00001A18                          1241  *
00001A18                          1242  ***********************************************************************************************************
00001A18                          1243  
00001A18                          1244  opMOVEM            
00001A18  4246                    1245              CLR         D6                  ; Clearing D4 to store dr field
00001A1A  1C01                    1246              MOVE.B      D1,D6               ; Moving byte to find dr field
00001A1C  E446                    1247              ASR         #two,D6             ; Moving dr field to readable spot
00001A1E  CC7C 0001               1248              AND         #one,D6             ; seting everything except dr to 0
00001A22                          1249  
00001A22  4241                    1250              CLR         D1  
00001A24  1218                    1251              MOVE.B      (A0)+, D1           ; Taking in next byte
00001A26                          1252              
00001A26  4245                    1253              CLR         D5
00001A28  1A01                    1254              MOVE.B      D1,D5               ; Using D6 to check if this is indeed MOVEM
00001A2A  EE45                    1255              ASR         #seven,D5
00001A2C  CA7C 0001               1256              AND         #one,D5
00001A30  BA7C 0001               1257              CMP         #one,D5             ; This bit should be one if this is MOVEM
00001A34  6600 1B50               1258              BNE         invalid             ; If this is not 1 then this is not moveM
00001A38  4245                    1259              CLR         D5
00001A3A                          1260              
00001A3A  43F9 00003F15           1261              LEA         MOVEMMatch, A1       ; we know that the opcode will be MOVEM, so load A1 to print message
00001A40  103C 000E               1262              MOVE.B      #14, D0             ; command for trap call to display message
00001A44  4E4F                    1263              TRAP        #15                 ; trap call
00001A46                          1264              
00001A46  4245                    1265              CLR         D5                  ; Clearing D5 to store size
00001A48  1A01                    1266              MOVE.B      D1,D5               ; Moving byte that contains bit for size
00001A4A  EC45                    1267              ASR         #six,D5             ; Moving size bit to the very right to read
00001A4C  CA7C 0001               1268              AND         #one,D5             ; Isolating the one bit for size
00001A50                          1269              
00001A50  4242                    1270              CLR         D2                  ; Clear Data register 2
00001A52  3401                    1271              MOVE        D1,D2               ; Move byte into D2
00001A54  E642                    1272              ASR         #three,D2           ; Shift mode into place and moves mode into place
00001A56  C47C 0007               1273              AND         #seven,D2           ; Stores mode
00001A5A                          1274              
00001A5A  4243                    1275              CLR         D3                  ; Storing EA register into D3
00001A5C  1601                    1276              MOVE.B      D1,D3               ; Move bits over to D3 to find register
00001A5E  C67C 0007               1277              AND         #seven,D3           ; Sets every bit to 0 except for register bits
00001A62                          1278              
00001A62  4EB9 0000358C           1279              JSR         MOVEMBRA            ; Jumps to subroutine that prints out the data and address registers
00001A68                          1280              
00001A68  B47C 0003               1281              CMP         #three,D2           ; Checks if this is post increment
00001A6C  6700 0024               1282              BEQ         skipPrintEA         ; If it is, skipping printing EA again, because it is printed already in JSR
00001A70                          1283              
00001A70  43F9 00003EE6           1284              LEA         comma, A1           ; Display comma
00001A76  103C 000E               1285              MOVE.B      #14, D0             ; command for trap call to display message
00001A7A  4E4F                    1286              TRAP        #15                 ; trap call
00001A7C                          1287              
00001A7C  4EB9 00002F0E           1288              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001A82                          1289              
00001A82  43F9 00003EDB           1290              LEA         newline, A1         ; we know that the opcode will be MOVEM, so load A1 to print message
00001A88  103C 000E               1291              MOVE.B      #14, D0             ; command for trap call to display message
00001A8C  4E4F                    1292              TRAP        #15                 ; trap call            
00001A8E                          1293  
00001A8E  6000 F5C8               1294              BRA         loop                ; Branch back to outer most loop that finds the first four bits
00001A92                          1295  
00001A92                          1296  skipPrintEA 
00001A92  43F9 00003EDB           1297              LEA         newline, A1         ; Prints out new line or carraige return
00001A98  103C 000E               1298              MOVE.B      #14, D0             ; command for trap call to display message
00001A9C  4E4F                    1299              TRAP        #15                 ; trap call            
00001A9E                          1300  
00001A9E  6000 F5B8               1301              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001AA2                          1302              
00001AA2                          1303  ***********************************************************************************************************
00001AA2                          1304  *
00001AA2                          1305  *               LEA OPCODE
00001AA2                          1306  *
00001AA2                          1307  *       This section is dedicated to the LEA opcode. This is determined that the first nibble is 4 nibbles as
00001AA2                          1308  *       well as the three static nibbles on 8,7, and 6. Once both have been checked, the code prints out
00001AA2                          1309  *       LEA and goes on to print its effective address.
00001AA2                          1310  *
00001AA2                          1311  ***********************************************************************************************************
00001AA2                          1312  
00001AA2                          1313  opLEA
00001AA2  4244                    1314              CLR         D4                  ; Clearing space for source register
00001AA4  1801                    1315              MOVE.B      D1,D4               ; Moving byte to isolate register
00001AA6  E244                    1316              ASR         #one,D4
00001AA8  C87C 0007               1317              AND         #seven,D4           ; Isolated register
00001AAC                          1318  
00001AAC  4245                    1319              CLR         D5                  ; Clearing D5 to check if bits match LEA static bits
00001AAE  1A01                    1320              MOVE.B      D1,D5               ; Stores destination register in temporary data register for later use
00001AB0  CA7C 0001               1321              AND         #one,D5             ; Setting all other bits to one except for mode register
00001AB4  E545                    1322              ASL         #two,D5             ; Shifts the two register bits over to correct spot
00001AB6                          1323              
00001AB6  1218                    1324              MOVE.B      (A0)+, D1           ; Taking in next byte
00001AB8                          1325              
00001AB8  1C01                    1326              MOVE.B      D1,D6               
00001ABA  EC46                    1327              ASR         #six,D6             ; Shifts 6 bits over to move register
00001ABC  DA46                    1328              ADD         D6,D5               ; Add the remaining bits to the register
00001ABE  4246                    1329              CLR         D6                  ; Clear out the temporary register
00001AC0                          1330  
00001AC0  BA7C 0007               1331              CMP         #seven,D5           ; Checks the seven static bits to see if it is LEA
00001AC4  6600 1AC0               1332              BNE         invalid             ; If it is not equal then this is not LEA
00001AC8                          1333              
00001AC8  43F9 00003F1B           1334              LEA         LEAmatch, A1        ; we know that the opcode will be LEA, so load A1 to print message
00001ACE  103C 000E               1335              MOVE.B      #14, D0             ; command for trap call to display message
00001AD2  4E4F                    1336              TRAP        #15                 ; trap call            
00001AD4                          1337  
00001AD4  43F9 00003EDF           1338              LEA         space, A1           ; we know that the opcode will be MOVEM, so load A1 to print message
00001ADA  103C 000E               1339              MOVE.B      #14, D0             ; command for trap call to display message
00001ADE  4E4F                    1340              TRAP        #15                 ; trap call            
00001AE0                          1341              
00001AE0  4242                    1342              CLR         D2                  ; Clear Data register 2
00001AE2  3401                    1343              MOVE        D1,D2               ; Move byte into D2
00001AE4  E642                    1344              ASR         #three,D2           ; Shift mode into place and moves mode into place
00001AE6  C47C 0007               1345              AND         #seven,D2           ; Stores mode
00001AEA                          1346              
00001AEA  4243                    1347              CLR         D3
00001AEC  1601                    1348              MOVE.B      D1,D3               ; Move bits over to D3 to find register
00001AEE  C67C 0007               1349              AND         #seven,D3           ; Sets every bit to 0 except for register bits
00001AF2                          1350              
00001AF2  4EB9 00002F0E           1351              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001AF8                          1352              
00001AF8  43F9 00003EE6           1353              LEA         comma, A1           ; we know that the opcode will be MOVEM, so load A1 to print message
00001AFE  103C 000E               1354              MOVE.B      #14, D0             ; command for trap call to display message
00001B02  4E4F                    1355              TRAP        #15                 ; trap call            
00001B04                          1356              
00001B04                          1357              
00001B04  4243                    1358              CLR         D3                  ; Clears D3 to move effective address into it
00001B06  1604                    1359              MOVE.B      D4,D3               ; Moves data with EA register
00001B08  143C 0001               1360              MOVE.B      #one,D2             ; Puts 1 into D2 to print an An within printEA
00001B0C                          1361              
00001B0C  4EB9 00002F0E           1362              JSR         printEA             ; Prints out source address
00001B12                          1363              
00001B12  43F9 00003EDB           1364              LEA         newline, A1         ; Prints new line
00001B18  103C 000E               1365              MOVE.B      #14, D0             ; command for trap call to display message
00001B1C  4E4F                    1366              TRAP        #15                 ; trap call
00001B1E                          1367  
00001B1E  6000 F538               1368              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits                 
00001B22                          1369  
00001B22                          1370  ***********************************************************************************************************
00001B22                          1371  *
00001B22                          1372  *                   OR OPCODE
00001B22                          1373  *
00001B22                          1374  *       This section is dedicated to the OR opcode. This is determined that the first nibble is 8, and the
00001B22                          1375  *       second nibble is not 7 (or we would have DIVS), we must have OR.
00001B22                          1376  *       OR is varied by the operand direction. We have and EA to Dn, and DN to EA operation.
00001B22                          1377  *       These operand directions determine our opmode, which we use to disassemble.
00001B22                          1378  *
00001B22                          1379  ***********************************************************************************************************
00001B22                          1380              
00001B22                          1381  opOR                                        ; Assumed we found OR, begin disassemble
00001B22  43F9 00003F3D           1382              LEA         ORmatch,A1          ; Output OR to the IO console
00001B28  103C 000E               1383              MOVE.B      #14,D0              ; Use trap 14
00001B2C  4E4F                    1384              TRAP        #15                 ; Halt for IO
00001B2E                          1385              
00001B2E  E141                    1386              ASL         #eight,D1           ; Shift D1 by eight to find opmode
00001B30  1401                    1387              MOVE.B      D1,D2               ; Load D2 with the resulting byte
00001B32                          1388              
00001B32                          1389              ; These are for EA to Dn direction
00001B32  B43C 0000               1390              CMP.B       #zero,D2            ; Check for a byte
00001B36  6700 002A               1391              BEQ         opORB               ; Byte in opmode
00001B3A  B43C 0001               1392              CMP.B       #one,D2             ; Check for a word
00001B3E  6700 007C               1393              BEQ         opORW               ; Word in opmode
00001B42  B43C 0002               1394              CMP.B       #two,D2             ; Check for a long
00001B46  6700 00CE               1395              BEQ         opORL               ; Long in opmode
00001B4A                          1396              
00001B4A                          1397              ; These are for Dn to EA direction
00001B4A  B43C 0004               1398              CMP.B       #four,D2            ; Check for a byte
00001B4E  6700 0012               1399              BEQ         opORB               ; Byte in opmode
00001B52  B43C 0005               1400              CMP.B       #five,D2            ; Check for a word
00001B56  6700 0064               1401              BEQ         opORW               ; Word in opmode
00001B5A  B43C 0006               1402              CMP.B       #six,D2             ; Check for a long
00001B5E  6700 00B6               1403              BEQ         opORL               ; Long in opmode
00001B62                          1404              
00001B62                          1405  opORB                                       ; Byte determined, find operands from here
00001B62  43F9 00003F79           1406              LEA         dispByte,A1         ; Display our byte info
00001B68  103C 000E               1407              MOVE.B      #14,D0              ; Trap #14 for our IO
00001B6C  4E4F                    1408              TRAP        #15                 ; Halt for IO
00001B6E                          1409              
00001B6E  43F9 00003EDF           1410              LEA         space, A1           ; Display space
00001B74  103C 000E               1411              MOVE.B      #14, D0             ; command for trap call to display message
00001B78  4E4F                    1412              TRAP        #15                 ; trap call
00001B7A                          1413              
00001B7A                          1414  
00001B7A  1401                    1415              MOVE.B      D1,D2               ; Load D2 again with the byte in D1
00001B7C  E642                    1416              ASR         #3,D2               ; Shift by 3 for finding 1 operand
00001B7E  C47C 0007               1417              AND         #$07,D2             ; AND by 7 to remove extras
00001B82  1601                    1418              MOVE.B      D1,D3               ; Load D3 with more necessary EA info
00001B84  C67C 0007               1419              AND         #$07,D3             ; AND by 7 to remove extra bits
00001B88  4EB9 00002F0E           1420              JSR         printEA             ; Determines the "left" operand register
00001B8E                          1421              
00001B8E  43F9 00003EE6           1422              LEA         comma, A1           ; Display space
00001B94  103C 000E               1423              MOVE.B      #14, D0             ; command for trap call to display message
00001B98  4E4F                    1424              TRAP        #15                 ; trap call
00001B9A                          1425              
00001B9A  4242                    1426              CLR         D2                  ; Clear D2 for use
00001B9C  3601                    1427              MOVE.W      D1,D3               ; Move our word into D3 for EA use
00001B9E  E043                    1428              ASR         #eight,D3           ; Shift by 8 to isolate EA info
00001BA0  E243                    1429              ASR         #one,D3             ; We need additional shift, so total shifts is by 9
00001BA2  C67C 0007               1430              AND         #$07,D3             ; AND to remove extra data
00001BA6  4EB9 00002F0E           1431              JSR         printEA             ; Redirect to EA subroutine to find EA operand info
00001BAC                          1432              
00001BAC  43F9 00003EDB           1433              LEA         newLine,A1          ; Prime a new line for the next instruction
00001BB2  103C 000E               1434              MOVE.B      #14,D0              ; Send it to the console
00001BB6  4E4F                    1435              TRAP        #15                 ; IO halt here
00001BB8                          1436              
00001BB8  6000 F49E               1437              BRA         LOOP                ; Return to control loop to find additional instructions
00001BBC                          1438              
00001BBC                          1439              
00001BBC                          1440  opORW                                       ; Word opmode has been found
00001BBC  43F9 00003F7C           1441              LEA         dispWord,A1         ; Display our word info
00001BC2  103C 000E               1442              MOVE.B      #14,D0              ; Trap #14 for our IO
00001BC6  4E4F                    1443              TRAP        #15                 ; Halt for IO
00001BC8                          1444              
00001BC8  43F9 00003EDF           1445              LEA         space, A1           ; Display space
00001BCE  103C 000E               1446              MOVE.B      #14, D0             ; command for trap call to display message
00001BD2  4E4F                    1447              TRAP        #15                 ; trap call
00001BD4                          1448              
00001BD4                          1449  
00001BD4  1401                    1450              MOVE.B      D1,D2               ; Load D2 again with the byte in D1
00001BD6  E642                    1451              ASR         #3,D2               ; Shift by 3 for finding 1 operand
00001BD8  C47C 0007               1452              AND         #$07,D2             ; AND by 7 to remove extras
00001BDC  1601                    1453              MOVE.B      D1,D3               ; Load D3 with more necessary EA info
00001BDE  C67C 0007               1454              AND         #$07,D3             ; AND by 7 to remove extra bits
00001BE2  4EB9 00002F0E           1455              JSR         printEA             ; Determines the "left" operand register
00001BE8                          1456              
00001BE8  43F9 00003EE6           1457              LEA         comma, A1           ; Display space
00001BEE  103C 000E               1458              MOVE.B      #14, D0             ; command for trap call to display message
00001BF2  4E4F                    1459              TRAP        #15                 ; trap call
00001BF4                          1460              
00001BF4  4242                    1461              CLR         D2                  ; Clear D2 for use
00001BF6  3601                    1462              MOVE.W      D1,D3               ; Move our word into D3 for EA use
00001BF8  E043                    1463              ASR         #eight,D3           ; Shift by 8 to isolate EA info
00001BFA  E243                    1464              ASR         #one,D3             ; We need additional shift, so total shifts is by 9
00001BFC  C67C 0007               1465              AND         #$07,D3             ; AND to remove extra data
00001C00  4EB9 00002F0E           1466              JSR         printEA             ; Redirect to EA subroutine to find EA operand info
00001C06                          1467              
00001C06  43F9 00003EDB           1468              LEA         newLine,A1          ; Prime a new line for the next instruction
00001C0C  103C 000E               1469              MOVE.B      #14,D0              ; Send it to the console
00001C10  4E4F                    1470              TRAP        #15                 ; IO halt here
00001C12                          1471              
00001C12  6000 F444               1472              BRA         LOOP                ; Return to control loop to find additional instructions
00001C16                          1473              
00001C16                          1474  opORL                                       ; Long value has been found for OR
00001C16  43F9 00003F7F           1475              LEA         dispLong,A1         ; Display our long info
00001C1C  103C 000E               1476              MOVE.B      #14,D0              ; Trap #14 for our IO
00001C20  4E4F                    1477              TRAP        #15                 ; Halt for IO
00001C22                          1478              
00001C22  43F9 00003EDF           1479              LEA         space, A1           ; Display space
00001C28  103C 000E               1480              MOVE.B      #14, D0             ; command for trap call to display message
00001C2C  4E4F                    1481              TRAP        #15                 ; trap call
00001C2E                          1482              
00001C2E                          1483  
00001C2E  1401                    1484              MOVE.B      D1,D2               ; Load D2 again with the byte in D1
00001C30  E642                    1485              ASR         #3,D2               ; Shift by 3 for finding 1 operand
00001C32  C47C 0007               1486              AND         #$07,D2             ; AND by 7 to remove extras
00001C36  1601                    1487              MOVE.B      D1,D3               ; Load D3 with more necessary EA info
00001C38  C67C 0007               1488              AND         #$07,D3             ; AND by 7 to remove extra bits
00001C3C  4EB9 00002F0E           1489              JSR         printEA             ; Determines the "left" operand register
00001C42                          1490              
00001C42  43F9 00003EE6           1491              LEA         comma, A1           ; Display space
00001C48  103C 000E               1492              MOVE.B      #14, D0             ; command for trap call to display message
00001C4C  4E4F                    1493              TRAP        #15                 ; trap call
00001C4E                          1494              
00001C4E  4242                    1495              CLR         D2                  ; Clear D2 for use
00001C50  3601                    1496              MOVE.W      D1,D3               ; Move our word into D3 for EA use
00001C52  E043                    1497              ASR         #eight,D3           ; Shift by 8 to isolate EA info
00001C54  E243                    1498              ASR         #one,D3             ; We need additional shift, so total shifts is by 9
00001C56  C67C 0007               1499              AND         #$07,D3             ; AND to remove extra data
00001C5A  4EB9 00002F0E           1500              JSR         printEA             ; Redirect to EA subroutine to find EA operand info
00001C60                          1501              
00001C60  43F9 00003EDB           1502              LEA         newLine,A1          ; Prime a new line for the next instruction
00001C66  103C 000E               1503              MOVE.B      #14,D0              ; Send it to the console
00001C6A  4E4F                    1504              TRAP        #15                 ; IO halt here
00001C6C                          1505              
00001C6C  6000 F3EA               1506              BRA         LOOP                ; Return to control loop to find additional instructions
00001C70                          1507              
00001C70                          1508  ***********************************************************************************************************
00001C70                          1509  *
00001C70                          1510  *                   DIVS OPCODE
00001C70                          1511  *
00001C70                          1512  *       This section is dedicate to the DIVS instruction, which is determined by a 8 in the first nibble
00001C70                          1513  *       and a 7 in the second nibble of the instruction.
00001C70                          1514  *       DIVSL is not supported, so the following code only accounts for the case of DIVS, which is short
00001C70                          1515  *       instead of a long
00001C70                          1516  *
00001C70                          1517  ***********************************************************************************************************
00001C70                          1518  
00001C70                          1519  opDIVS                                      ; Second nibble determined that the instruction was DIVS
00001C70  43F9 00003F38           1520              LEA         DIVSmatch,A1        ; Load DIVS into A1 for output console
00001C76  103C 000E               1521              MOVE.B      #14,D0              ; Get trap task #14 for IO
00001C7A  4E4F                    1522              TRAP        #15                 ; Trap call to halt
00001C7C                          1523              
00001C7C  43F9 00003EDF           1524              LEA         space, A1           ; Display space
00001C82  103C 000E               1525              MOVE.B      #14, D0             ; command for trap call to display message
00001C86  4E4F                    1526              TRAP        #15                 ; trap to halt
00001C88                          1527              
00001C88  1401                    1528              MOVE.B      D1,D2               ; Move our byte from D1 to D2 to manipulate
00001C8A  E642                    1529              ASR         #3,D2               ; Shift by 3 to find register
00001C8C  C47C 0007               1530              AND         #$07,D2             ; AND by 7 to clear unnecessary bits
00001C90  1601                    1531              MOVE.B      D1,D3               ; Load the byte into D3 for EA comparison
00001C92  C67C 0007               1532              AND         #$07,D3             ; AND by 7 to clear unnecessary bits
00001C96  4EB9 00002F0E           1533              JSR         printEA             ; Call our EA subroutine to obtain EA bits from instruction
00001C9C                          1534              
00001C9C  43F9 00003EE6           1535              LEA         comma, A1           ; Display space
00001CA2  103C 000E               1536              MOVE.B      #14, D0             ; command for trap call to display message
00001CA6  4E4F                    1537              TRAP        #15                 ; trap to halt call
00001CA8                          1538              
00001CA8  4242                    1539              CLR         D2                  ; Clear old data from D2 to avoid errors
00001CAA  3601                    1540              MOVE.W      D1,D3               ; Move word into D3 for EA subroutine
00001CAC  E043                    1541              ASR         #eight,D3           ; Shift by 8 to find to find the remaining EA components
00001CAE  E243                    1542              ASR         #one,D3             ; Additional shift by 1 to get proper bits
00001CB0  C67C 0007               1543              AND         #$07,D3             ; AND to clear unwanted bits
00001CB4  4EB9 00002F0E           1544              JSR         printEA             ; Obtain other operand info
00001CBA                          1545              
00001CBA  43F9 00003EDB           1546              LEA         newLine,A1          ; Prepare new line for next instruction
00001CC0  103C 000E               1547              MOVE.B      #14,D0              ; Utilize trap task 14
00001CC4  4E4F                    1548              TRAP        #15                 ; Halt for IO
00001CC6                          1549              
00001CC6  6000 F390               1550              BRA         LOOP                ; Return to control loop
00001CCA                          1551              
00001CCA                          1552  **********************************************************************************************************
00001CCA                          1553  *
00001CCA                          1554  *                   EOR OPCODE
00001CCA                          1555  *
00001CCA                          1556  *       This sectioon is dedicated to the EOR opcode. We determine this with an 11 in the first nibble, and
00001CCA                          1557  *       a value higher than 3 in the second nibble.
00001CCA                          1558  *       The opmode fields is used to differ this instruction from CMP.
00001CCA                          1559  *       Dissassembly acquires opmode field info, which is similar to size, and to different EA related
00001CCA                          1560  *       operands.
00001CCA                          1561  *
00001CCA                          1562  ***********************************************************************************************************
00001CCA                          1563  
00001CCA                          1564  opEOR                                       ; We found EOR, begin disassembly
00001CCA  43F9 00003F44           1565              LEA         EORmatch,A1         ; Load A1 with our EOR output
00001CD0  103C 000E               1566              MOVE.B      #14,D0              ; Prime trap task #14
00001CD4  4E4F                    1567              TRAP        #15                 ; Halt for IO
00001CD6                          1568              
00001CD6  4242                    1569              CLR         D2                  ; Clear D2 for use again
00001CD8                          1570              
00001CD8  1401                    1571              MOVE.B      D1,D2               ; Move byte used in D1 to D2 for opmode check
00001CDA  EE42                    1572              ASR         #seven,D2           ; Move bits 7 places over to find opmode
00001CDC  C47C 0007               1573              AND         #$07,D2             ; AND by 7 to clear extra bits
00001CE0  B43C 0005               1574              CMP.B       #five,D2            ; Check for a byte in opmode
00001CE4  6D00 0012               1575              BLT         opEORB              ; Byte in opmode
00001CE8  B43C 0005               1576              CMP.B       #five,D2            ; Check for a word in opmode
00001CEC  6700 006A               1577              BEQ         opEORW              ; Word in opmode
00001CF0  B43C 0005               1578              CMP.B       #five,D2            ; Check for a long in opmode
00001CF4  6E00 00C2               1579              BGT         opEORL              ; Long in opmode
00001CF8                          1580              
00001CF8                          1581  opEORB                                      ; Determine instruction is a byte operation
00001CF8  43F9 00003F79           1582              LEA         dispByte,A1         ; Send out the byte info for the instruction
00001CFE  103C 000E               1583              MOVE.B      #14,D0              ; Utilize trap task 14
00001D02  4E4F                    1584              TRAP        #15                 ; Halt for IO
00001D04                          1585              
00001D04  43F9 00003EDF           1586              LEA         space, A1           ; Display space
00001D0A  103C 000E               1587              MOVE.B      #14, D0             ; command for trap call to display message
00001D0E  4E4F                    1588              TRAP        #15                 ; trap call to halt
00001D10                          1589              
00001D10  4242                    1590              CLR         D2                  ; Clear D2 again for use
00001D12  4243                    1591              CLR         D3                  ; Remove anything from D3
00001D14  3601                    1592              MOVE.W      D1,D3               ; Move word to D3 to find an operand
00001D16  E043                    1593              ASR         #eight,D3           ; Shift by eight to ensure correct portion of instruction
00001D18  E243                    1594              ASR         #one,D3             ; Needs to be shifted by an additional 1
00001D1A  C67C 0007               1595              AND         #$07,D3             ; Clear extra bits 
00001D1E  4EB9 00002F0E           1596              JSR         printEA             ; Use EA subroutine to print operand
00001D24                          1597              
00001D24  43F9 00003EE6           1598              LEA         comma, A1           ; Display space
00001D2A  103C 000E               1599              MOVE.B      #14, D0             ; command for trap call to display message
00001D2E  4E4F                    1600              TRAP        #15                 ; trap call
00001D30                          1601              
00001D30  4242                    1602              CLR         D2                  ; Clear D2 again
00001D32  4243                    1603              CLR         D3                  ; Clear D3 again
00001D34  1401                    1604              MOVE.B      D1,D2               ; Move the byte value in D1 to D2 for EA use
00001D36  E642                    1605              ASR         #three,D2           ; Shift by 3 to find EA info
00001D38  C47C 0007               1606              AND         #seven,D2           ; AND by 7 to remove extra bits
00001D3C  1601                    1607              MOVE.B      D1,D3               ; Move byte value from D1 into D3
00001D3E  C67C 0007               1608              AND         #$07,D3             ; AND by 7 for EA subroutine
00001D42  4EB9 00002F0E           1609              JSR         printEA             ; Determines remained operand EA info to print
00001D48                          1610              
00001D48  43F9 00003EDB           1611              LEA         newLine,A1          ; Print new line for next instruction
00001D4E  103C 000E               1612              MOVE.B      #14,D0              ; Use trap 14 to output to console
00001D52  4E4F                    1613              TRAP        #15                 ; Halt for IO
00001D54                          1614              
00001D54  6000 F302               1615              BRA         LOOP                ; Return to control loop
00001D58                          1616               
00001D58                          1617  opEORW                                      ; Word opmode has been determined
00001D58  43F9 00003F7C           1618              LEA         dispWord,A1         ; Send out the word info for the instruction
00001D5E  103C 000E               1619              MOVE.B      #14,D0              ; Utilize trap task 14
00001D62  4E4F                    1620              TRAP        #15                 ; Halt for IO
00001D64                          1621              
00001D64  43F9 00003EDF           1622              LEA         space, A1           ; Display space
00001D6A  103C 000E               1623              MOVE.B      #14, D0             ; command for trap call to display message
00001D6E  4E4F                    1624              TRAP        #15                 ; trap call to halt
00001D70                          1625              
00001D70  4242                    1626              CLR         D2                  ; Clear D2 again for use
00001D72  4243                    1627              CLR         D3                  ; Remove anything from D3
00001D74  3601                    1628              MOVE.W      D1,D3               ; Move word to D3 to find an operand
00001D76  E043                    1629              ASR         #eight,D3           ; Shift by eight to ensure correct portion of instruction
00001D78  E243                    1630              ASR         #one,D3             ; Needs to be shifted by an additional 1
00001D7A  C67C 0007               1631              AND         #$07,D3             ; Clear extra bits 
00001D7E  4EB9 00002F0E           1632              JSR         printEA             ; Use EA subroutine to print operand
00001D84                          1633              
00001D84  43F9 00003EE6           1634              LEA         comma, A1           ; Display space
00001D8A  103C 000E               1635              MOVE.B      #14, D0             ; command for trap call to display message
00001D8E  4E4F                    1636              TRAP        #15                 ; trap call
00001D90                          1637              
00001D90  4242                    1638              CLR         D2                  ; Clear D2 again
00001D92  4243                    1639              CLR         D3                  ; Clear D3 again
00001D94  1401                    1640              MOVE.B      D1,D2               ; Move the byte value in D1 to D2 for EA use
00001D96  E642                    1641              ASR         #three,D2           ; Shift by 3 to find EA info
00001D98  C47C 0007               1642              AND         #seven,D2           ; AND by 7 to remove extra bits
00001D9C  1601                    1643              MOVE.B      D1,D3               ; Move byte value from D1 into D3
00001D9E  C67C 0007               1644              AND         #$07,D3             ; AND by 7 for EA subroutine
00001DA2  4EB9 00002F0E           1645              JSR         printEA             ; Determines remained operand EA info to print
00001DA8                          1646              
00001DA8  43F9 00003EDB           1647              LEA         newLine,A1          ; Print new line for next instruction
00001DAE  103C 000E               1648              MOVE.B      #14,D0              ; Use trap 14 to output to console
00001DB2  4E4F                    1649              TRAP        #15                 ; Halt for IO
00001DB4                          1650              
00001DB4  6000 F2A2               1651              BRA         LOOP                ; Return to control loop
00001DB8                          1652              
00001DB8                          1653  opEORL                                      ; Long has been determined
00001DB8  43F9 00003F7F           1654              LEA         dispLong,A1         ; Send out the long word info for the instruction
00001DBE  103C 000E               1655              MOVE.B      #14,D0              ; Utilize trap task 14
00001DC2  4E4F                    1656              TRAP        #15                 ; Halt for IO
00001DC4                          1657              
00001DC4  43F9 00003EDF           1658              LEA         space, A1           ; Display space
00001DCA  103C 000E               1659              MOVE.B      #14, D0             ; command for trap call to display message
00001DCE  4E4F                    1660              TRAP        #15                 ; trap call to halt
00001DD0                          1661              
00001DD0  4242                    1662              CLR         D2                  ; Clear D2 again for use
00001DD2  4243                    1663              CLR         D3                  ; Remove anything from D3
00001DD4  3601                    1664              MOVE.W      D1,D3               ; Move word to D3 to find an operand
00001DD6  E043                    1665              ASR         #eight,D3           ; Shift by eight to ensure correct portion of instruction
00001DD8  E243                    1666              ASR         #one,D3             ; Needs to be shifted by an additional 1
00001DDA  C67C 0007               1667              AND         #$07,D3             ; Clear extra bits 
00001DDE  4EB9 00002F0E           1668              JSR         printEA             ; Use EA subroutine to print operand
00001DE4                          1669              
00001DE4  43F9 00003EE6           1670              LEA         comma, A1           ; Display space
00001DEA  103C 000E               1671              MOVE.B      #14, D0             ; command for trap call to display message
00001DEE  4E4F                    1672              TRAP        #15                 ; trap call
00001DF0                          1673              
00001DF0  4242                    1674              CLR         D2                  ; Clear D2 again
00001DF2  4243                    1675              CLR         D3                  ; Clear D3 again
00001DF4  1401                    1676              MOVE.B      D1,D2               ; Move the byte value in D1 to D2 for EA use
00001DF6  E642                    1677              ASR         #three,D2           ; Shift by 3 to find EA info
00001DF8  C47C 0007               1678              AND         #seven,D2           ; AND by 7 to remove extra bits
00001DFC  1601                    1679              MOVE.B      D1,D3               ; Move byte value from D1 into D3
00001DFE  C67C 0007               1680              AND         #$07,D3             ; AND by 7 for EA subroutine
00001E02  4EB9 00002F0E           1681              JSR         printEA             ; Determines remained operand EA info to print
00001E08                          1682              
00001E08  43F9 00003EDB           1683              LEA         newLine,A1          ; Print new line for next instruction
00001E0E  103C 000E               1684              MOVE.B      #14,D0              ; Use trap 14 to output to console
00001E12  4E4F                    1685              TRAP        #15                 ; Halt for IO
00001E14                          1686              
00001E14  6000 F242               1687              BRA         LOOP                ; Return to the control loop
00001E18                          1688  
00001E18                          1689  ***********************************************************************************************************
00001E18                          1690  *
00001E18                          1691  *                   CMP OPCODE
00001E18                          1692  *
00001E18                          1693  *       This section is dedicated to the compare (CMP) instruction. Its determined in the control loop
00001E18                          1694  *       that the first nibble is 11 for CMP, and the second nibble is 3.
00001E18                          1695  *       The type of CMP, or the opmode, is used to determined what we output to our console next.
00001E18                          1696  *       From that point, we load the correct size/opmode, and then route to the EA subroutine to output
00001E18                          1697  *       EA related register information.
00001E18                          1698  *       The process for finding the operand register info (EA info) is similar for all opmodes.
00001E18                          1699  *
00001E18                          1700  ***********************************************************************************************************
00001E18                          1701  
00001E18                          1702  opCMP       
00001E18  43F9 00003F48           1703              LEA         CMPmatch,A1         ; We determined that the opcode is CMP, output to console
00001E1E  103C 000E               1704              MOVE.B      #14,D0              ; Getting trap task #14 ready
00001E22  4E4F                    1705              TRAP        #15                 ; Trap 15 call for IO
00001E24                          1706              
00001E24  4242                    1707              CLR         D2                  ; D2 should be cleared for use later
00001E26                          1708              
00001E26  1401                    1709              MOVE.B      D1,D2               ; Get the next byte to manipulate
00001E28  EC42                    1710              ASR         #six,D2             ; Move bits 7 places over to find opmode
00001E2A  C47C 0007               1711              AND         #$07,D2             ; AND by 7 allows us to compare properly on which opmode we need
00001E2E  B43C 0000               1712              CMP.B       #zero,D2            ; Compare to zero to see if we have a byte
00001E32  6700 0016               1713              BEQ         opCMPB              ; Byte in opmode
00001E36  B43C 0001               1714              CMP.B       #one,D2             ; Compare to one to see if we have a word
00001E3A  6700 0068               1715              BEQ         opCMPW              ; Word in opmode
00001E3E  B43C 0002               1716              CMP.B       #two,D2             ; Compare to two to see if we have a long
00001E42  6700 00BA               1717              BEQ         opCMPL              ; Long in opmode
00001E46                          1718              
00001E46  6000 1E32               1719              BRA         printInvalid        ; Incorrect input
00001E4A                          1720  
00001E4A                          1721  opCMPB                                      ; Known we have CMP.B, find and output operands
00001E4A  43F9 00003F79           1722              LEA         dispByte,A1         ; Output the byte component of the instruction
00001E50  103C 000E               1723              MOVE.B      #14,D0              ; Trap task #14 for console out
00001E54  4E4F                    1724              TRAP        #15                 ; Halt for console out
00001E56                          1725              
00001E56  43F9 00003EDF           1726              LEA         space, A1           ; Display space for operands
00001E5C  103C 000E               1727              MOVE.B      #14, D0             ; command for trap call to display message
00001E60  4E4F                    1728              TRAP        #15                 ; Console out/halt
00001E62                          1729              
00001E62  1401                    1730              MOVE.B      D1,D2               ; Move the byte for manipulation to D2
00001E64  E642                    1731              ASR         #3,D2               ; Shift right by 3 to find left operand register
00001E66  C47C 0007               1732              AND         #$07,D2             ; AND for comparison later
00001E6A  1601                    1733              MOVE.B      D1,D3               ; Move the byte to D3 for use in our EA subroutine
00001E6C  C67C 0007               1734              AND         #$07,D3             ; AND for comparison in subroutine
00001E70  4EB9 00002F0E           1735              JSR         printEA             ; Use our EA subroutine to determine the left operand register
00001E76                          1736              
00001E76  43F9 00003EE6           1737              LEA         comma, A1           ; Display space
00001E7C  103C 000E               1738              MOVE.B      #14, D0             ; command for trap call to display message
00001E80  4E4F                    1739              TRAP        #15                 ; trap call
00001E82                          1740              
00001E82  4242                    1741              CLR         D2                  ; D2 needs to be cleared for use later
00001E84  3601                    1742              MOVE.W      D1,D3               ; Move the entire word in D3 for shifting
00001E86  E043                    1743              ASR         #eight,D3           ; Shift right by 8 to get EA bits from instruction
00001E88  E243                    1744              ASR         #one,D3             ; Shift right once more to move the bits all the way
00001E8A  C67C 0007               1745              AND         #$07,D3             ; AND by 7 to clear unnecessary bits
00001E8E  4EB9 00002F0E           1746              JSR         printEA             ; EA subroutine call to get remaining operand sent to the console
00001E94                          1747              
00001E94  43F9 00003EDB           1748              LEA         newLine,A1          ; Prime A1 with our new line to output
00001E9A  103C 000E               1749              MOVE.B      #14,D0              ; Prime new line for next instruction
00001E9E  4E4F                    1750              TRAP        #15                 ; Halt for IO
00001EA0                          1751              
00001EA0  6000 F1B6               1752              BRA         LOOP                ; Return to control loop for next disassembly
00001EA4                          1753              
00001EA4                          1754  opCMPW                                      ; Known we have CMP.W, find and output operands
00001EA4  43F9 00003F7C           1755              LEA         dispWord,A1         ; Output the byte component of the instruction
00001EAA  103C 000E               1756              MOVE.B      #14,D0              ; Trap task #14 for console out
00001EAE  4E4F                    1757              TRAP        #15                 ; Halt for console out
00001EB0                          1758              
00001EB0  43F9 00003EDF           1759              LEA         space, A1           ; Display space for operands
00001EB6  103C 000E               1760              MOVE.B      #14, D0             ; command for trap call to display message
00001EBA  4E4F                    1761              TRAP        #15                 ; Console out/halt
00001EBC                          1762              
00001EBC  1401                    1763              MOVE.B      D1,D2               ; Move the byte for manipulation to D2
00001EBE  E642                    1764              ASR         #3,D2               ; Shift right by 3 to find left operand register
00001EC0  C47C 0007               1765              AND         #$07,D2             ; AND for comparison later
00001EC4  1601                    1766              MOVE.B      D1,D3               ; Move the byte to D3 for use in our EA subroutine
00001EC6  C67C 0007               1767              AND         #$07,D3             ; AND for comparison in subroutine
00001ECA  4EB9 00002F0E           1768              JSR         printEA             ; Use our EA subroutine to determine the left operand register
00001ED0                          1769              
00001ED0  43F9 00003EE6           1770              LEA         comma, A1           ; Display space
00001ED6  103C 000E               1771              MOVE.B      #14, D0             ; command for trap call to display message
00001EDA  4E4F                    1772              TRAP        #15                 ; trap call
00001EDC                          1773              
00001EDC  4242                    1774              CLR         D2                  ; D2 needs to be cleared for use later
00001EDE  3601                    1775              MOVE.W      D1,D3               ; Move the entire word in D3 for shifting
00001EE0  E043                    1776              ASR         #eight,D3           ; Shift right by 8 to get EA bits from instruction
00001EE2  E243                    1777              ASR         #one,D3             ; Shift right once more to move the bits all the way
00001EE4  C67C 0007               1778              AND         #$07,D3             ; AND by 7 to clear unnecessary bits
00001EE8  4EB9 00002F0E           1779              JSR         printEA             ; EA subroutine call to get remaining operand sent to the console
00001EEE                          1780              
00001EEE  43F9 00003EDB           1781              LEA         newLine,A1          ; Prime A1 with our new line to output
00001EF4  103C 000E               1782              MOVE.B      #14,D0              ; Prime new line for next instruction
00001EF8  4E4F                    1783              TRAP        #15                 ; Halt for IO
00001EFA                          1784              
00001EFA  6000 F15C               1785              BRA         LOOP                ; Return to control loop for next disassembly
00001EFE                          1786  
00001EFE                          1787  opCMPL                                      ; Known we have CMP.L, find and output operands
00001EFE  43F9 00003F7F           1788              LEA         dispLong,A1         ; Output the byte component of the instruction
00001F04  103C 000E               1789              MOVE.B      #14,D0              ; Trap task #14 for console out
00001F08  4E4F                    1790              TRAP        #15                 ; Halt for console out
00001F0A                          1791              
00001F0A  43F9 00003EDF           1792              LEA         space, A1           ; Display space for operands
00001F10  103C 000E               1793              MOVE.B      #14, D0             ; command for trap call to display message
00001F14  4E4F                    1794              TRAP        #15                 ; Console out/halt
00001F16                          1795              
00001F16  1401                    1796              MOVE.B      D1,D2               ; Move the byte for manipulation to D2
00001F18  E642                    1797              ASR         #3,D2               ; Shift right by 3 to find left operand register
00001F1A  C47C 0007               1798              AND         #$07,D2             ; AND for comparison later
00001F1E  1601                    1799              MOVE.B      D1,D3               ; Move the byte to D3 for use in our EA subroutine
00001F20  C67C 0007               1800              AND         #$07,D3             ; AND for comparison in subroutine
00001F24  4EB9 00002F0E           1801              JSR         printEA             ; Use our EA subroutine to determine the left operand register
00001F2A                          1802              
00001F2A  43F9 00003EE6           1803              LEA         comma, A1           ; Display space
00001F30  103C 000E               1804              MOVE.B      #14, D0             ; command for trap call to display message
00001F34  4E4F                    1805              TRAP        #15                 ; trap call
00001F36                          1806              
00001F36  4242                    1807              CLR         D2                  ; D2 needs to be cleared for use later
00001F38  3601                    1808              MOVE.W      D1,D3               ; Move the entire word in D3 for shifting
00001F3A  E043                    1809              ASR         #eight,D3           ; Shift right by 8 to get EA bits from instruction
00001F3C  E243                    1810              ASR         #one,D3             ; Shift right once more to move the bits all the way
00001F3E  C67C 0007               1811              AND         #$07,D3             ; AND by 7 to clear unnecessary bits
00001F42  4EB9 00002F0E           1812              JSR         printEA             ; EA subroutine call to get remaining operand sent to the console
00001F48                          1813              
00001F48  43F9 00003EDB           1814              LEA         newLine,A1          ; Prime A1 with our new line to output
00001F4E  103C 000E               1815              MOVE.B      #14,D0              ; Prime new line for next instruction
00001F52  4E4F                    1816              TRAP        #15                 ; Halt for IO
00001F54                          1817              
00001F54  6000 F102               1818              BRA         LOOP                ; Return to control loop for next disassembly
00001F58                          1819  
00001F58                          1820  ***********************************************************************************************************
00001F58                          1821  *
00001F58                          1822  *                   SUB OPCODE
00001F58                          1823  *
00001F58                          1824  *       This section is dedicated to disassembling the SUB opcode. We assume that the first nibble being 9
00001F58                          1825  *       leads us to the SUB opcode.
00001F58                          1826  *       SUB is differed by a operand direction, that being Dn - EA or EA - Dn.
00001F58                          1827  *       These directions are deteremined as an opmode, and doubles up for each byte, long, and word mode.
00001F58                          1828  *
00001F58                          1829  ***********************************************************************************************************
00001F58                          1830  
00001F58                          1831  opSUB                                       ; We assume we found SUB, begin SUB disassemble
00001F58  43F9 00003F40           1832              LEA         SUBmatch, A1        ; Load A1 to print SUB found message
00001F5E  103C 000E               1833              MOVE.B      #14, D0             ; command for trap call to display message
00001F62  4E4F                    1834              TRAP        #15                 ; trap call to halt
00001F64                          1835          
00001F64                          1836          
00001F64  E141                    1837              ASL         #eight,D1           ; Shift D1 to by 8 to find opmode
00001F66  1218                    1838              MOVE.B      (A0)+,D1            ; Reload instruction
00001F68  4242                    1839              CLR         D2                  ; Ensure D2 is clear
00001F6A                          1840              
00001F6A  3401                    1841              MOVE.W      D1,D2               ; Load our word into D2 to manipulate
00001F6C  EC42                    1842              ASR         #six,D2             ; Move bits 7 places over to find opmode
00001F6E  C47C 0007               1843              AND         #seven,D2           ; AND by 7 to remove extra bits
00001F72                          1844              
00001F72                          1845              ; These are for Dn - EA
00001F72  B43C 0000               1846              CMP.B       #zero,D2            ; Check for byte
00001F76  6700 002A               1847              BEQ         opSUBB              ; Byte in opmode
00001F7A  B43C 0001               1848              CMP.B       #one,D2             ; Check for word
00001F7E  6700 007C               1849              BEQ         opSUBW              ; Word in opmode
00001F82  B43C 0002               1850              CMP.B       #two,D2             ; Check for long
00001F86  6700 00CE               1851              BEQ         opSUBL              ; Long in opmode
00001F8A                          1852              
00001F8A                          1853              ; These are for EA - Dn
00001F8A  B43C 0004               1854              CMP.B       #four,D2            ; Check for byte
00001F8E  6700 0012               1855              BEQ         opSUBB              ; Byte in opmode
00001F92  B43C 0005               1856              CMP.B       #five,D2            ; Check for word
00001F96  6700 0064               1857              BEQ         opSUBW              ; Word in opmode
00001F9A  B43C 0006               1858              CMP.B       #six,D2             ; Check for long
00001F9E  6700 00B6               1859              BEQ         opSUBL              ; Long in opmode
00001FA2                          1860              
00001FA2                          1861  opSUBB                                      ; Byte has been found, find operands
00001FA2  43F9 00003F79           1862              LEA         dispByte,A1         ; Output the byte info to the console
00001FA8  103C 000E               1863              MOVE.B      #14,D0              ; Use trap task 14 for IO
00001FAC  4E4F                    1864              TRAP        #15                 ; Halt for IO
00001FAE                          1865              
00001FAE  43F9 00003EDF           1866              LEA         space, A1           ; Display space
00001FB4  103C 000E               1867              MOVE.B      #14, D0             ; command for trap call to display message
00001FB8  4E4F                    1868              TRAP        #15                 ; trap call         
00001FBA                          1869              
00001FBA  1401                    1870              MOVE.B      D1,D2               ; Load D2 with our D1 byte
00001FBC  E642                    1871              ASR         #3,D2               ; Shift by 3 to find an operand
00001FBE  C47C 0007               1872              AND         #$07,D2             ; AND by 7 to remove extra bits
00001FC2  3601                    1873              MOVE.W      D1,D3               ; Load D3 with our word in D1
00001FC4  C67C 0007               1874              AND         #$07,D3             ; AND by 7 to remove extra bits
00001FC8  4EB9 00002F0E           1875              JSR         printEA             ; Use EA subroutine to find an operand
00001FCE                          1876              
00001FCE  43F9 00003EE6           1877              LEA         comma, A1           ; Display space
00001FD4  103C 000E               1878              MOVE.B      #14, D0             ; command for trap call to display message
00001FD8  4E4F                    1879              TRAP        #15                 ; trap call
00001FDA                          1880              
00001FDA  4242                    1881              CLR         D2                  ; Empty D2 for use again
00001FDC  3601                    1882              MOVE.W      D1,D3               ; Load the word again into D3
00001FDE  E043                    1883              ASR         #eight,D3           ; Shift by 8 to find other operand
00001FE0  E243                    1884              ASR         #one,D3             ; Requires an additional shift
00001FE2  C67C 0007               1885              AND         #$07,D3             ; AND by 7 to remove extra bits
00001FE6  4EB9 00002F0E           1886              JSR         printEA             ; EA subroutine finds our remaining operand
00001FEC                          1887              
00001FEC  43F9 00003EDB           1888              LEA         newLine,A1          ; Ready console with newline
00001FF2  103C 000E               1889              MOVE.B      #14,D0              ; Trap 14 for output
00001FF6  4E4F                    1890              TRAP        #15                 ; Halt for IO
00001FF8                          1891              
00001FF8  6000 F05E               1892              BRA         LOOP                ; Return to control loop
00001FFC                          1893              
00001FFC                          1894  opSUBW                                      ; Word has been found, find operands
00001FFC  43F9 00003F7C           1895              LEA         dispWord,A1         ; Output the word info to the console
00002002  103C 000E               1896              MOVE.B      #14,D0              ; Use trap task 14 for IO
00002006  4E4F                    1897              TRAP        #15                 ; Halt for IO
00002008                          1898              
00002008  43F9 00003EDF           1899              LEA         space, A1           ; Display space
0000200E  103C 000E               1900              MOVE.B      #14, D0             ; command for trap call to display message
00002012  4E4F                    1901              TRAP        #15                 ; trap call         
00002014                          1902              
00002014  1401                    1903              MOVE.B      D1,D2               ; Load D2 with our D1 byte
00002016  E642                    1904              ASR         #3,D2               ; Shift by 3 to find an operand
00002018  C47C 0007               1905              AND         #$07,D2             ; AND by 7 to remove extra bits
0000201C  3601                    1906              MOVE.W      D1,D3               ; Load D3 with our word in D1
0000201E  C67C 0007               1907              AND         #$07,D3             ; AND by 7 to remove extra bits
00002022  4EB9 00002F0E           1908              JSR         printEA             ; Use EA subroutine to find an operand
00002028                          1909              
00002028  43F9 00003EE6           1910              LEA         comma, A1           ; Display space
0000202E  103C 000E               1911              MOVE.B      #14, D0             ; command for trap call to display message
00002032  4E4F                    1912              TRAP        #15                 ; trap call
00002034                          1913              
00002034  4242                    1914              CLR         D2                  ; Empty D2 for use again
00002036  3601                    1915              MOVE.W      D1,D3               ; Load the word again into D3
00002038  E043                    1916              ASR         #eight,D3           ; Shift by 8 to find other operand
0000203A  E243                    1917              ASR         #one,D3             ; Requires an additional shift
0000203C  C67C 0007               1918              AND         #$07,D3             ; AND by 7 to remove extra bits
00002040  4EB9 00002F0E           1919              JSR         printEA             ; EA subroutine finds our remaining operand
00002046                          1920              
00002046  43F9 00003EDB           1921              LEA         newLine,A1          ; Ready console with newline
0000204C  103C 000E               1922              MOVE.B      #14,D0              ; Trap 14 for output
00002050  4E4F                    1923              TRAP        #15                 ; Halt for IO
00002052                          1924              
00002052  6000 F004               1925              BRA         LOOP                ; Return to control loop
00002056                          1926              
00002056                          1927  opSUBL                                      ; Long has been found, find operands
00002056  43F9 00003F7F           1928              LEA         dispLong,A1         ; Output the long info to the console
0000205C  103C 000E               1929              MOVE.B      #14,D0              ; Use trap task 14 for IO
00002060  4E4F                    1930              TRAP        #15                 ; Halt for IO
00002062                          1931              
00002062  43F9 00003EDF           1932              LEA         space, A1           ; Display space
00002068  103C 000E               1933              MOVE.B      #14, D0             ; command for trap call to display message
0000206C  4E4F                    1934              TRAP        #15                 ; trap call         
0000206E                          1935              
0000206E  1401                    1936              MOVE.B      D1,D2               ; Load D2 with our D1 byte
00002070  E642                    1937              ASR         #3,D2               ; Shift by 3 to find an operand
00002072  C47C 0007               1938              AND         #$07,D2             ; AND by 7 to remove extra bits
00002076  3601                    1939              MOVE.W      D1,D3               ; Load D3 with our word in D1
00002078  C67C 0007               1940              AND         #$07,D3             ; AND by 7 to remove extra bits
0000207C  4EB9 00002F0E           1941              JSR         printEA             ; Use EA subroutine to find an operand
00002082                          1942              
00002082  43F9 00003EE6           1943              LEA         comma, A1           ; Display space
00002088  103C 000E               1944              MOVE.B      #14, D0             ; command for trap call to display message
0000208C  4E4F                    1945              TRAP        #15                 ; trap call
0000208E                          1946              
0000208E  4242                    1947              CLR         D2                  ; Empty D2 for use again
00002090  3601                    1948              MOVE.W      D1,D3               ; Load the word again into D3
00002092  E043                    1949              ASR         #eight,D3           ; Shift by 8 to find other operand
00002094  E243                    1950              ASR         #one,D3             ; Requires an additional shift
00002096  C67C 0007               1951              AND         #$07,D3             ; AND by 7 to remove extra bits
0000209A  4EB9 00002F0E           1952              JSR         printEA             ; EA subroutine finds our remaining operand
000020A0                          1953              
000020A0  43F9 00003EDB           1954              LEA         newLine,A1          ; Ready console with newline
000020A6  103C 000E               1955              MOVE.B      #14,D0              ; Trap 14 for output
000020AA  4E4F                    1956              TRAP        #15                 ; Halt for IO
000020AC                          1957              
000020AC  6000 EFAA               1958              BRA         LOOP                ; Return to control loop
000020B0                          1959              
000020B0                          1960  ***********************************************************************************************************
000020B0                          1961  *
000020B0                          1962  *                   BRA OPCODE
000020B0                          1963  *       
000020B0                          1964  *       This section is dedicated to the BRA opcode, which is determined by having six in the first
000020B0                          1965  *       nibble of the instruction, and zero in the second nibble.
000020B0                          1966  *
000020B0                          1967  ***********************************************************************************************************
000020B0                          1968              
000020B0                          1969  opBRA       
000020B0  43F9 00003F24           1970              LEA         BRAmatch, A1        ; we know that the opcode will be BRA, so load A1 to print message
000020B6  103C 000E               1971              MOVE.B      #14, D0             ; Prime trap task #14 for output
000020BA  4E4F                    1972              TRAP        #15                 ; trap call to output BRA
000020BC                          1973          
000020BC  4242                    1974              CLR         D2                  ; Data register to needs to be cleared for use again
000020BE  4243                    1975              CLR         D3                  ; Data register to needs to be cleared for use again
000020C0                          1976  
000020C0  43F9 00003EDF           1977              LEA         space,A1            ; output a space for the IO console
000020C6  103C 000E               1978              MOVE.B      #14,D0              ; Prime trap task #14 for the output
000020CA  4E4F                    1979              TRAP        #15                 ; Call trap #15 with number 14 for our IO
000020CC                          1980          
000020CC  143C 0007               1981              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
000020D0  1218                    1982              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
000020D2  4EB9 00002F0E           1983              JSR         printEA             ; this method handles the displacement hex values
000020D8                          1984          
000020D8  43F9 00003EDB           1985              LEA         newLine, A1         ; create new line for the IO console
000020DE  103C 000E               1986              MOVE.B      #14, D0             ; command for trap call to display message
000020E2  4E4F                    1987              TRAP        #15                 ; trap call ready console for next instruction
000020E4                          1988  
000020E4  6000 EF72               1989              BRA         LOOP                ; return back to our control loop to find next instruction
000020E8                          1990          
000020E8                          1991  ***********************************************************************************************************
000020E8                          1992  *
000020E8                          1993  *                   Bcc OPCODES
000020E8                          1994  *
000020E8                          1995  *       This section is dedicated to the conditional branching opcode. There are varying second nibble
000020E8                          1996  *       values, documented below, with the correspond cc code.
000020E8                          1997  *       BCC is similar to BRA, so we handle it in the same manner.
000020E8                          1998  *
000020E8                          1999  *       Supported cc condition codes:
000020E8                          2000  *           >Carry Clear        = CS        second nibble == 5
000020E8                          2001  *           >Overflow Set       = VC        second nibble == 8
000020E8                          2002  *           >Greater or EqualGE = GE        second nibble == 12
000020E8                          2003  *           >Less Than          = LT        second nibble == 13
000020E8                          2004  *
000020E8                          2005  ***********************************************************************************************************
000020E8                          2006  * CS Conition Code
000020E8                          2007  
000020E8                          2008  opBCS       
000020E8  43F9 00003F28           2009              LEA         BCSmatch, A1        ; we know that the opcode will be BCS, so load A1 to print message
000020EE  103C 000E               2010              MOVE.B      #14, D0             ; command for trap call to display message
000020F2  4E4F                    2011              TRAP        #15                 ; trap call
000020F4                          2012          
000020F4  4242                    2013              CLR         D2                  ; Data register to needs to be cleared for use again
000020F6  4243                    2014              CLR         D3                  ; Data register to needs to be cleared for use again
000020F8                          2015  
000020F8  43F9 00003EDF           2016              LEA         space,A1            ; output a space for the IO console
000020FE  103C 000E               2017              MOVE.B      #14,D0              ; Prime trap task #14 for the output
00002102  4E4F                    2018              TRAP        #15                 ; Call trap #15 with number 14 for our IO
00002104                          2019          
00002104  143C 0007               2020              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
00002108  1218                    2021              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
0000210A  4EB9 00002F0E           2022              JSR         printEA             ; this method handles the displacement hex values
00002110                          2023          
00002110  43F9 00003EDB           2024              LEA         newLine, A1         ; create new line for the IO console
00002116  103C 000E               2025              MOVE.B      #14, D0             ; command for trap call to display message
0000211A  4E4F                    2026              TRAP        #15                 ; trap call ready console for next instruction
0000211C                          2027              
0000211C  6000 EF3A               2028              BRA         LOOP                ; return to the control loop for next instruction
00002120                          2029  
00002120                          2030  ***********************************************************************************************************
00002120                          2031  * VC Condition Code
00002120                          2032  
00002120                          2033  opBVC       
00002120  43F9 00003F2C           2034              LEA         BVCmatch, A1        ; we know that the opcode will be BVC, so load A1 to print message
00002126  103C 000E               2035              MOVE.B      #14, D0             ; command for trap call to display message
0000212A  4E4F                    2036              TRAP        #15                 ; trap call
0000212C                          2037          
0000212C  4242                    2038              CLR         D2                  ; Data register to needs to be cleared for use again
0000212E  4243                    2039              CLR         D3                  ; Data register to needs to be cleared for use again
00002130                          2040  
00002130  43F9 00003EDF           2041              LEA         space,A1            ; output a space for the IO console
00002136  103C 000E               2042              MOVE.B      #14,D0              ; Prime trap task #14 for the output
0000213A  4E4F                    2043              TRAP        #15                 ; Call trap #15 with number 14 for our IO
0000213C                          2044          
0000213C  143C 0007               2045              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
00002140  1218                    2046              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
00002142  4EB9 00002F0E           2047              JSR         printEA             ; this method handles the displacement hex values
00002148                          2048          
00002148  43F9 00003EDB           2049              LEA         newLine, A1         ; create new line for the IO console
0000214E  103C 000E               2050              MOVE.B      #14, D0             ; command for trap call to display message
00002152  4E4F                    2051              TRAP        #15                 ; trap call ready console for next instruction
00002154                          2052              
00002154  6000 EF02               2053              BRA         LOOP                ; return to the control loop for next instruction
00002158                          2054  
00002158                          2055  ***********************************************************************************************************
00002158                          2056  * GE Conidtion Code     
00002158                          2057          
00002158                          2058  opBGE       
00002158  43F9 00003F30           2059              LEA         BGEmatch, A1        ; we know that the opcode will be BGE, so load A1 to print message
0000215E  103C 000E               2060              MOVE.B      #14, D0             ; command for trap call to display message
00002162  4E4F                    2061              TRAP        #15                 ; trap call
00002164                          2062          
00002164  4242                    2063              CLR         D2                  ; Data register to needs to be cleared for use again
00002166  4243                    2064              CLR         D3                  ; Data register to needs to be cleared for use again
00002168                          2065  
00002168  43F9 00003EDF           2066              LEA         space,A1            ; output a space for the IO console
0000216E  103C 000E               2067              MOVE.B      #14,D0              ; Prime trap task #14 for the output
00002172  4E4F                    2068              TRAP        #15                 ; Call trap #15 with number 14 for our IO
00002174                          2069          
00002174  143C 0007               2070              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
00002178  1218                    2071              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
0000217A  4EB9 00002F0E           2072              JSR         printEA             ; this method handles the displacement hex values
00002180                          2073          
00002180  43F9 00003EDB           2074              LEA         newLine, A1         ; create new line for the IO console
00002186  103C 000E               2075              MOVE.B      #14, D0             ; command for trap call to display message
0000218A  4E4F                    2076              TRAP        #15                 ; trap call ready console for next instruction
0000218C                          2077              
0000218C  6000 EECA               2078              BRA         LOOP                ; return to the control loop for next instruction
00002190                          2079  
00002190                          2080  ***********************************************************************************************************
00002190                          2081  * LT Conditions Code        
00002190                          2082          
00002190                          2083  opBLT   
00002190  43F9 00003F34           2084              LEA         BLTmatch, A1        ; we know that the opcode will be BLT, so load A1 to print message
00002196  103C 000E               2085              MOVE.B      #14, D0             ; command for trap call to display message
0000219A  4E4F                    2086              TRAP        #15                 ; trap call
0000219C                          2087          
0000219C  4242                    2088              CLR         D2                  ; Data register to needs to be cleared for use again
0000219E  4243                    2089              CLR         D3                  ; Data register to needs to be cleared for use again
000021A0                          2090  
000021A0  43F9 00003EDF           2091              LEA         space,A1            ; output a space for the IO console
000021A6  103C 000E               2092              MOVE.B      #14,D0              ; Prime trap task #14 for the output
000021AA  4E4F                    2093              TRAP        #15                 ; Call trap #15 with number 14 for our IO
000021AC                          2094          
000021AC  143C 0007               2095              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
000021B0  1218                    2096              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
000021B2  4EB9 00002F0E           2097              JSR         printEA             ; this method handles the displacement hex values
000021B8                          2098          
000021B8  43F9 00003EDB           2099              LEA         newLine, A1         ; create new line for the IO console
000021BE  103C 000E               2100              MOVE.B      #14, D0             ; command for trap call to display message
000021C2  4E4F                    2101              TRAP        #15                 ; trap call ready console for next instruction
000021C4                          2102              
000021C4  6000 EE92               2103              BRA         LOOP                ; return to the control loop for next instruction
000021C8                          2104          
000021C8                          2105  ***********************************************************************************************************
000021C8                          2106  *
000021C8                          2107  *               SUBQ OPCODE
000021C8                          2108  *
000021C8                          2109  *       This section is for disassembling the SUBQ instruction, which is determined by a 5 in the first
000021C8                          2110  *       nibble.
000021C8                          2111  *       We assume there is only 1 opcode with 5 in the first nibble.
000021C8                          2112  *       SUBQ utilizes immediate data, so we use an alternate subroutine for operand output.
000021C8                          2113  *       The size field is used to branch to the subvariants of SUBQ, which we determine before hitting the
000021C8                          2114  *       final subroutines.
000021C8                          2115  *
000021C8                          2116  ***********************************************************************************************************
000021C8                          2117  
000021C8                          2118  opSUBQ                                      ; Assumed that we found SUBQ, begin disassemble
000021C8  43F9 00003F1F           2119              LEA         SUBQmatch, A1       ; Send out SUBQ message
000021CE  103C 000E               2120              MOVE.B      #14, D0             ; command for trap call to display message
000021D2  4E4F                    2121              TRAP        #15                 ; trap call to halt
000021D4                          2122              
000021D4  E141                    2123              ASL         #eight,D1           ; Shift by 8 to find size bits
000021D6  1218                    2124              MOVE.B      (A0)+,D1            ; Reload D1
000021D8  1401                    2125              MOVE.B      D1,D2               ; Move data in D2 to alter later
000021DA  EE42                    2126              ASR         #seven,D2           ; Move bits 7 places over to find size
000021DC  C47C 0007               2127              AND         #$07,D2             ; AND by 7 to remove uneeded bits
000021E0                          2128              
000021E0                          2129              ; Find size bits
000021E0  B43C 0000               2130              CMP.B       #zero,D2            ; Check for a byte
000021E4  6700 0012               2131              BEQ         opSUBQB             ; Byte in size
000021E8  B43C 0001               2132              CMP.B       #one,D2             ; Check for a word
000021EC  6700 0020               2133              BEQ         opSUBQW             ; Word in size
000021F0  B43C 0002               2134              CMP.B       #two,D2             ; Check for a long
000021F4  6700 002E               2135              BEQ         opSUBQL             ; Long in size
000021F8                          2136              
000021F8                          2137  opSUBQB                                     ; Found a byte in size, prepare for JSR
000021F8  43F9 00003F79           2138              LEA         dispByte,A1         ; Display the byte in the console
000021FE  103C 000E               2139              MOVE.B      #14,D0              ; Trap task 14 for IO
00002202  4E4F                    2140              TRAP        #15                 ; Halt for IO
00002204                          2141            
00002204  4EB9 00002E36           2142              JSR         PrntImm             ; Call immediate data subroutine to handle SUBQ operands
0000220A                          2143              
0000220A  6000 EE4C               2144              BRA         LOOP                ; Return to control loop
0000220E                          2145              
0000220E                          2146  opSUBQW                                     ; Found a word in size, prepare for JSR
0000220E  43F9 00003F7C           2147              LEA         dispWord,A1         ; Display the word in the console
00002214  103C 000E               2148              MOVE.B      #14,D0              ; Trap task 14 for IO
00002218  4E4F                    2149              TRAP        #15                 ; Halt for IO
0000221A                          2150            
0000221A  4EB9 00002E36           2151              JSR         PrntImm             ; Call immediate data subroutine to handle SUBQ operands
00002220                          2152              
00002220  6000 EE36               2153              BRA         LOOP                ; Return to control loop
00002224                          2154              
00002224                          2155  opSUBQL                                     ; Found a long in size, prepare for JSR
00002224  43F9 00003F7F           2156              LEA         dispLong,A1         ; Display the long in the console
0000222A  103C 000E               2157              MOVE.B      #14,D0              ; Trap task 14 for IO
0000222E  4E4F                    2158              TRAP        #15                 ; Halt for IO
00002230                          2159            
00002230  4246                    2160              CLR         D6                  ; In the long size case, we need to ensure D6 is clear for the JSR call
00002232  1C3C 0001               2161              MOVE.B      #1,D6               ; Needed to ensure proper immediate data is output to the console
00002236                          2162            
00002236  4EB9 00002E36           2163              JSR         PrntImm             ; Call immediate data subroutine to handle SUBQ operands
0000223C                          2164              
0000223C  6000 EE1A               2165              BRA         LOOP                ; Return to control loop
00002240                          2166          
00002240                          2167  ***********************************************************************************************************
00002240                          2168  *
00002240                          2169  *                   MULS OPCODE
00002240                          2170  *
00002240                          2171  ***********************************************************************************************************
00002240                          2172  
00002240                          2173  opMULS  
00002240  43F9 00003F4C           2174              LEA         MULSmatch, A1       ; we know that the opcode will be MULS, so load A1 to print message
00002246  103C 000E               2175              MOVE.B      #14, D0             ; command for trap call to display message
0000224A  4E4F                    2176              TRAP        #15                 ; trap call
0000224C  43F9 00003EDF           2177              LEA         space, A1           ; create spaces
00002252  103C 000E               2178              MOVE.B      #14, D0             ; command for trap call to display message
00002256  4E4F                    2179              TRAP        #15                 ; trap call
00002258                          2180          
00002258  E141                    2181              ASL         #eight, D1          ; move D1 over by a byte
0000225A  1218                    2182              MOVE.B      (A0)+, D1           ; copy the next byte into D1
0000225C                          2183          
0000225C  4242                    2184              CLR         D2                  ; clear D2
0000225E  4243                    2185              CLR         D3                  ; clear D3
00002260  1401                    2186              MOVE.B      D1, D2              ; copy the byte from D1 to D2
00002262  E642                    2187              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
00002264  C47C 0007               2188              AND         #seven, D2          ; and D2 to get only first 3 bits
00002268  1601                    2189              MOVE.B      D1, D3              ; copy D1 byte to D3
0000226A  C67C 0007               2190              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
0000226E                          2191          
0000226E  4EB9 00002F0E           2192              JSR         printEA             ; jump to printEA
00002274                          2193          
00002274  43F9 00003EE6           2194              LEA         comma, A1           ; create comma
0000227A  103C 000E               2195              MOVE.B      #14, D0             ; command for trap call to display message
0000227E  4E4F                    2196              TRAP        #15                 ; trap call
00002280                          2197  
00002280  4242                    2198              CLR         D2                  ; clear D2 since we know mode should be data register
00002282  4243                    2199              CLR         D3                  ; clear D3
00002284  3601                    2200              MOVE.W      D1, D3              ; Move D1 word to D3
00002286  E043                    2201              ASR         #eight, D3          ; shift D3 by 8 bits
00002288  E243                    2202              ASR         #one, D3            ; shift D3 by 1 bit
0000228A  C67C 0007               2203              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
0000228E                          2204  
0000228E  4EB9 00002F0E           2205              JSR         printEA             ; jump to printEA
00002294                          2206          
00002294  43F9 00003EDB           2207              LEA         newLine, A1         ; create new line
0000229A  103C 000E               2208              MOVE.B      #14, D0             ; command for trap call to display message
0000229E  4E4F                    2209              TRAP        #15                 ; trap call
000022A0                          2210          
000022A0  6000 EDB6               2211              BRA         LOOP                ; branch back to LOOP
000022A4                          2212  
000022A4                          2213  ***********************************************************************************************************
000022A4                          2214  *
000022A4                          2215  *                   ADD OPCODE
000022A4                          2216  *
000022A4                          2217  ***********************************************************************************************************   
000022A4                          2218  
000022A4                          2219  opADDB  
000022A4  43F9 00003F51           2220              LEA         ADDmatch, A1        ; we know that the opcode will be ADD, so load A1 to print message
000022AA  103C 000E               2221              MOVE.B      #14, D0             ; command for trap call to display message
000022AE  4E4F                    2222              TRAP        #15                 ; trap call
000022B0                          2223          
000022B0  43F9 00003F79           2224              LEA         dispByte, A1        ; display byte
000022B6  103C 000E               2225              MOVE.B      #14, D0             ; command for trap call to display message
000022BA  4E4F                    2226              TRAP        #15                 ; trap call
000022BC  43F9 00003EDF           2227              LEA         space, A1           ; create spaces
000022C2  103C 000E               2228              MOVE.B      #14, D0             ; command for trap call to display message
000022C6  4E4F                    2229              TRAP        #15                 ; trap call
000022C8                          2230          
000022C8  4242                    2231              CLR         D2                  ; clear D2
000022CA  4243                    2232              CLR         D3                  ; clear D3
000022CC  1401                    2233              MOVE.B      D1, D2              ; copy the byte from D1 to D2
000022CE  E642                    2234              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
000022D0  C47C 0007               2235              AND         #seven, D2          ; and D2 to get only first 3 bits
000022D4  1601                    2236              MOVE.B      D1, D3              ; copy D1 byte to D3
000022D6  C67C 0007               2237              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
000022DA                          2238          
000022DA  4EB9 00002F0E           2239              JSR         printEA             ; jump to printEA
000022E0                          2240          
000022E0  43F9 00003EE6           2241              LEA         comma, A1           ; create comma
000022E6  103C 000E               2242              MOVE.B      #14, D0             ; command for trap call to display message
000022EA  4E4F                    2243              TRAP        #15                 ; trap call
000022EC                          2244  
000022EC  4242                    2245              CLR         D2                  ; clear D2 since we know mode should be data register
000022EE  4243                    2246              CLR         D3                  ; clear D3
000022F0  3601                    2247              MOVE.W      D1, D3              ; Move D1 word to D3
000022F2  E043                    2248              ASR         #eight, D3          ; shift D3 by 8 bits
000022F4  E243                    2249              ASR         #one, D3            ; shift D3 by 1 bit
000022F6  C67C 0007               2250              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
000022FA                          2251  
000022FA  4EB9 00002F0E           2252              JSR         printEA             ; jump to printEA
00002300                          2253          
00002300  43F9 00003EDB           2254              LEA         newLine, A1         ; create new line
00002306  103C 000E               2255              MOVE.B      #14, D0             ; command for trap call to display message
0000230A  4E4F                    2256              TRAP        #15                 ; trap call
0000230C                          2257          
0000230C  6000 ED4A               2258              BRA         LOOP                ; branch back to LOOP
00002310                          2259          
00002310                          2260  opADDW  
00002310  43F9 00003F51           2261              LEA         ADDmatch, A1        ; we know that the opcode will be ADD, so load A1 to print message
00002316  103C 000E               2262              MOVE.B      #14, D0             ; command for trap call to display message
0000231A  4E4F                    2263              TRAP        #15                 ; trap call
0000231C                          2264  
0000231C  43F9 00003F7C           2265              LEA         dispWord, A1        ; display word
00002322  103C 000E               2266              MOVE.B      #14, D0             ; command for trap call to display message
00002326  4E4F                    2267              TRAP        #15                 ; trap call
00002328  43F9 00003EDF           2268              LEA         space, A1           ; create spaces
0000232E  103C 000E               2269              MOVE.B      #14, D0             ; command for trap call to display message
00002332  4E4F                    2270              TRAP        #15                 ; trap call
00002334                          2271          
00002334  4242                    2272              CLR         D2                  ; clear D2
00002336  4243                    2273              CLR         D3                  ; clear D3
00002338  1401                    2274              MOVE.B      D1, D2              ; copy the byte from D1 to D2
0000233A  E642                    2275              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
0000233C  C47C 0007               2276              AND         #seven, D2          ; and D2 to get only first 3 bits
00002340  1601                    2277              MOVE.B      D1, D3              ; copy D1 byte to D3
00002342  C67C 0007               2278              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
00002346                          2279          
00002346  4EB9 00002F0E           2280              JSR         printEA             ; jump to printEA
0000234C                          2281          
0000234C  43F9 00003EE6           2282              LEA         comma, A1           ; create comma
00002352  103C 000E               2283              MOVE.B      #14, D0             ; command for trap call to display message
00002356  4E4F                    2284              TRAP        #15                 ; trap call
00002358                          2285  
00002358  4242                    2286              CLR         D2                  ; clear D2 since we know mode should be data register
0000235A  4243                    2287              CLR         D3                  ; clear D3
0000235C  3601                    2288              MOVE.W      D1, D3              ; Move D1 word to D3
0000235E  E043                    2289              ASR         #eight, D3          ; shift D3 by 8 bits
00002360  E243                    2290              ASR         #one, D3            ; shift D3 by 1 bit
00002362  C67C 0007               2291              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
00002366                          2292  
00002366  4EB9 00002F0E           2293              JSR         printEA             ; jump to printEA
0000236C                          2294          
0000236C  43F9 00003EDB           2295              LEA         newLine, A1         ; create new line
00002372  103C 000E               2296              MOVE.B      #14, D0             ; command for trap call to display message
00002376  4E4F                    2297              TRAP        #15                 ; trap call
00002378                          2298          
00002378  6000 ECDE               2299              BRA         LOOP                ; branch back to LOOP
0000237C                          2300          
0000237C                          2301  opADDL  
0000237C  43F9 00003F51           2302              LEA         ADDmatch, A1        ; we know that the opcode will be ADD, so load A1 to print message
00002382  103C 000E               2303              MOVE.B      #14, D0             ; command for trap call to display message
00002386  4E4F                    2304              TRAP        #15                 ; trap call
00002388                          2305          
00002388  43F9 00003F7F           2306              LEA         dispLong, A1        ; display long
0000238E  103C 000E               2307              MOVE.B      #14, D0             ; command for trap call to display message
00002392  4E4F                    2308              TRAP        #15                 ; trap call
00002394  43F9 00003EDF           2309              LEA         space, A1           ; create spaces
0000239A  103C 000E               2310              MOVE.B      #14, D0             ; command for trap call to display message
0000239E  4E4F                    2311              TRAP        #15                 ; trap call
000023A0                          2312          
000023A0  4242                    2313              CLR         D2                  ; clear D2
000023A2  4243                    2314              CLR         D3                  ; clear D3
000023A4  1401                    2315              MOVE.B      D1, D2              ; copy the byte from D1 to D2
000023A6  E642                    2316              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
000023A8  C47C 0007               2317              AND         #seven, D2          ; and D2 to get only first 3 bits
000023AC  1601                    2318              MOVE.B      D1, D3              ; copy D1 byte to D3
000023AE  C67C 0007               2319              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
000023B2                          2320          
000023B2  4246                    2321              CLR         D6                  ; Clear D6
000023B4  1C3C 0001               2322              MOVE.B      #1, D6              ; move 1 to D6 in case source is printing immediate
000023B8                          2323          
000023B8  4EB9 00002F0E           2324              JSR         printEA             ; jump to printEA
000023BE  4246                    2325              CLR         D6                  ; clear D6
000023C0                          2326          
000023C0  43F9 00003EE6           2327              LEA         comma, A1           ; create comma
000023C6  103C 000E               2328              MOVE.B      #14, D0             ; command for trap call to display message
000023CA  4E4F                    2329              TRAP        #15                 ; trap call
000023CC                          2330  
000023CC  4242                    2331              CLR         D2                  ; clear D2 since we know mode should be data register
000023CE  4243                    2332              CLR         D3                  ; clear D3
000023D0  3601                    2333              MOVE.W      D1, D3              ; Move D1 word to D3
000023D2  E043                    2334              ASR         #eight, D3          ; shift D3 by 8 bits
000023D4  E243                    2335              ASR         #one, D3            ; shift D3 by 1 bit
000023D6  C67C 0007               2336              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
000023DA                          2337  
000023DA  4EB9 00002F0E           2338              JSR         printEA             ; jump to printEA
000023E0                          2339          
000023E0  43F9 00003EDB           2340              LEA         newLine, A1         ; create new line
000023E6  103C 000E               2341              MOVE.B      #14, D0             ; command for trap call to display message
000023EA  4E4F                    2342              TRAP        #15                 ; trap call
000023EC                          2343          
000023EC  6000 EC6A               2344              BRA         LOOP                ; branch back to LOOP
000023F0                          2345  
000023F0                          2346  ***********************************************************************************************************
000023F0                          2347  *
000023F0                          2348  *                   ADDA OPCODE
000023F0                          2349  *
000023F0                          2350  *********************************************************************************************************** 
000023F0                          2351  
000023F0                          2352  opADDAW 
000023F0  43F9 00003F55           2353              LEA         ADDAmatch, A1       ; we know that the opcode will be ADDA, so load A1 to print message
000023F6  103C 000E               2354              MOVE.B      #14, D0             ; command for trap call to display message
000023FA  4E4F                    2355              TRAP        #15                 ; trap call
000023FC                          2356          
000023FC  43F9 00003F7C           2357              LEA         dispWord, A1        ; display word
00002402  103C 000E               2358              MOVE.B      #14, D0             ; command for trap call to display message
00002406  4E4F                    2359              TRAP        #15                 ; trap call
00002408  43F9 00003EDF           2360              LEA         space, A1           ; create spaces
0000240E  103C 000E               2361              MOVE.B      #14, D0             ; command for trap call to display message
00002412  4E4F                    2362              TRAP        #15                 ; trap call
00002414                          2363          
00002414  4242                    2364              CLR         D2                  ; clear D2
00002416  4243                    2365              CLR         D3                  ; clear D3
00002418  1401                    2366              MOVE.B      D1, D2              ; copy the byte from D1 to D2
0000241A  E642                    2367              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
0000241C  C47C 0007               2368              AND         #seven, D2          ; and D2 to get only first 3 bits
00002420  1601                    2369              MOVE.B      D1, D3              ; copy D1 byte to D3
00002422  C67C 0007               2370              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
00002426                          2371          
00002426  4EB9 00002F0E           2372              JSR         printEA             ; jump to printEA 
0000242C                          2373          
0000242C  43F9 00003EE6           2374              LEA         comma, A1           ; create comma
00002432  103C 000E               2375              MOVE.B      #14, D0             ; command for trap call to display message
00002436  4E4F                    2376              TRAP        #15                 ; trap call
00002438                          2377  
00002438  4242                    2378              CLR         D2                  ; clear D2 since we know mode should be data register
0000243A  4243                    2379              CLR         D3                  ; clear D3
0000243C  143C 0001               2380              MOVE.B      #one, D2            ; move 1 to D2 since mode should be address
00002440  3601                    2381              MOVE.W      D1, D3              ; Move D1 word to D3
00002442  E043                    2382              ASR         #eight, D3          ; shift D3 by 8 bits
00002444  E243                    2383              ASR         #one, D3            ; shift D3 by 1 bit
00002446  C67C 0007               2384              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
0000244A                          2385  
0000244A  4EB9 00002F0E           2386              JSR         printEA             ; jump to printEA
00002450                          2387          
00002450  43F9 00003EDB           2388              LEA         newLine, A1         ; create new line
00002456  103C 000E               2389              MOVE.B      #14, D0             ; command for trap call to display message
0000245A  4E4F                    2390              TRAP        #15                 ; trap call
0000245C                          2391          
0000245C  6000 EBFA               2392              BRA         LOOP                ; branch back to LOOP
00002460                          2393  
00002460                          2394  opADDAL 
00002460  43F9 00003F55           2395              LEA         ADDAmatch, A1       ; we know that the opcode will be ADDA, so load A1 to print message
00002466  103C 000E               2396              MOVE.B      #14, D0             ; command for trap call to display message
0000246A  4E4F                    2397              TRAP        #15                 ; trap call
0000246C                          2398  
0000246C  43F9 00003F7F           2399              LEA         dispLong, A1        ; display long
00002472  103C 000E               2400              MOVE.B      #14, D0             ; command for trap call to display message
00002476  4E4F                    2401              TRAP        #15                 ; trap call
00002478  43F9 00003EDF           2402              LEA         space, A1           ; create spaces
0000247E  103C 000E               2403              MOVE.B      #14, D0             ; command for trap call to display message
00002482  4E4F                    2404              TRAP        #15                 ; trap call
00002484                          2405          
00002484  4242                    2406              CLR         D2                  ; clear D2
00002486  4243                    2407              CLR         D3                  ; clear D3
00002488  1401                    2408              MOVE.B      D1, D2              ; copy the byte from D1 to D2
0000248A  E642                    2409              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
0000248C  C47C 0007               2410              AND         #seven, D2          ; and D2 to get only first 3 bits
00002490  1601                    2411              MOVE.B      D1, D3              ; copy D1 byte to D3
00002492  C67C 0007               2412              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
00002496                          2413          
00002496  4EB9 00002F0E           2414              JSR         printEA             ; jump to printEA 
0000249C                          2415          
0000249C  43F9 00003EE6           2416              LEA         comma, A1           ; create comma
000024A2  103C 000E               2417              MOVE.B      #14, D0             ; command for trap call to display message
000024A6  4E4F                    2418              TRAP        #15                 ; trap call
000024A8                          2419  
000024A8  4242                    2420              CLR         D2                  ; clear D2 since we know mode should be data register
000024AA  4243                    2421              CLR         D3                  ; clear D3
000024AC  143C 0001               2422              MOVE.B      #one, D2            ; move 1 to D2 since mode should be address
000024B0  3601                    2423              MOVE.W      D1, D3              ; Move D1 word to D3
000024B2  E043                    2424              ASR         #eight, D3          ; shift D3 by 8 bits
000024B4  E243                    2425              ASR         #one, D3            ; shift D3 by 1 bit
000024B6  C67C 0007               2426              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
000024BA                          2427  
000024BA  4EB9 00002F0E           2428              JSR         printEA             ; jump to printEA
000024C0                          2429          
000024C0  43F9 00003EDB           2430              LEA         newLine, A1         ; create new line
000024C6  103C 000E               2431              MOVE.B      #14, D0             ; command for trap call to display message
000024CA  4E4F                    2432              TRAP        #15                 ; trap call
000024CC                          2433          
000024CC  6000 EB8A               2434              BRA         LOOP                ; branch back to LOOP
000024D0                          2435          
000024D0                          2436  ***********************************************************************************************************
000024D0                          2437  *
000024D0                          2438  *                       Shifting OPCODES
000024D0                          2439  *
000024D0                          2440  ***********************************************************************************************************
000024D0                          2441  
000024D0                          2442  opASL       
000024D0  43F9 00003F66           2443              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
000024D6  103C 000E               2444              MOVE.B      #14, D0             ; command for trap call to display message
000024DA  4E4F                    2445              TRAP        #15                 ; trap call
000024DC                          2446          
000024DC  43F9 00003F7C           2447              LEA         dispWord, A1        ; display word
000024E2  103C 000E               2448              MOVE.B      #14, D0             ; command for trap call to display message
000024E6  4E4F                    2449              TRAP        #15                 ; trap call
000024E8                          2450          
000024E8  43F9 00003EDF           2451              LEA         space, A1           ; display space 
000024EE  103C 000E               2452              MOVE.B      #14, D0             ; command for trap call to display message
000024F2  4E4F                    2453              TRAP        #15                 ; trap call
000024F4                          2454          
000024F4  4242                    2455              CLR         D2                  ; clear D2
000024F6  4243                    2456              CLR         D3                  ; clear D3
000024F8  1401                    2457              MOVE.B      D1,D2               ; move byte from D1 to D2
000024FA  1601                    2458              MOVE.B      D1,D3               ; move byte from D1 to D3
000024FC                          2459          
000024FC  E602                    2460              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
000024FE  C47C 0007               2461              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
00002502  C67C 0007               2462              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
00002506                          2463          
00002506  4EB9 00002F0E           2464              JSR         printEA             ; jump to printEA
0000250C                          2465          
0000250C  43F9 00003EDB           2466              LEA         newLine, A1         ; Display newLine
00002512  103C 000E               2467              MOVE.B      #14, D0             ; command for trap call to display message
00002516  4E4F                    2468              TRAP        #15                 ; trap call
00002518                          2469          
00002518  6000 EB3E               2470              BRA         LOOP                ; branch back to LOOP
0000251C                          2471  
0000251C                          2472  opASR   
0000251C  43F9 00003F62           2473              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002522  103C 000E               2474              MOVE.B      #14, D0             ; command for trap call to display message
00002526  4E4F                    2475              TRAP        #15                 ; trap call
00002528                          2476          
00002528  43F9 00003F7C           2477              LEA         dispWord, A1        ; display word
0000252E  103C 000E               2478              MOVE.B      #14, D0             ; command for trap call to display message
00002532  4E4F                    2479              TRAP        #15                 ; trap call
00002534                          2480          
00002534  43F9 00003EDF           2481              LEA         space, A1           ; display space 
0000253A  103C 000E               2482              MOVE.B      #14, D0             ; command for trap call to display message
0000253E  4E4F                    2483              TRAP        #15                 ; trap call
00002540                          2484          
00002540  4242                    2485              CLR         D2                  ; clear D2
00002542  4243                    2486              CLR         D3                  ; clear D3
00002544  1401                    2487              MOVE.B      D1,D2               ; move byte from D1 to D2
00002546  1601                    2488              MOVE.B      D1,D3               ; move byte from D1 to D3
00002548                          2489          
00002548  E602                    2490              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
0000254A  C47C 0007               2491              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
0000254E  C67C 0007               2492              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
00002552                          2493          
00002552  4EB9 00002F0E           2494              JSR         printEA             ; jump to printEA
00002558                          2495          
00002558  43F9 00003EDB           2496              LEA         newLine, A1         ; Display newLine
0000255E  103C 000E               2497              MOVE.B      #14, D0             ; command for trap call to display message
00002562  4E4F                    2498              TRAP        #15                 ; trap call
00002564                          2499          
00002564  6000 EAF2               2500              BRA         LOOP                ; branch back to LOOP
00002568                          2501  
00002568                          2502  opLSL       
00002568  43F9 00003F5E           2503              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
0000256E  103C 000E               2504              MOVE.B      #14, D0             ; command for trap call to display message
00002572  4E4F                    2505              TRAP        #15                 ; trap call
00002574                          2506              
00002574  43F9 00003F7C           2507              LEA         dispWord, A1        ; display word
0000257A  103C 000E               2508              MOVE.B      #14, D0             ; command for trap call to display message
0000257E  4E4F                    2509              TRAP        #15                 ; trap call
00002580                          2510          
00002580  43F9 00003EDF           2511              LEA         space, A1           ; display space 
00002586  103C 000E               2512              MOVE.B      #14, D0             ; command for trap call to display message
0000258A  4E4F                    2513              TRAP        #15                 ; trap call
0000258C                          2514          
0000258C  4242                    2515              CLR         D2                  ; clear D2
0000258E  4243                    2516              CLR         D3                  ; clear D3
00002590  1401                    2517              MOVE.B      D1,D2               ; move byte from D1 to D2
00002592  1601                    2518              MOVE.B      D1,D3               ; move byte from D1 to D3
00002594                          2519          
00002594  E602                    2520              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
00002596  C47C 0007               2521              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
0000259A  C67C 0007               2522              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
0000259E                          2523          
0000259E  4EB9 00002F0E           2524              JSR         printEA             ; jump to printEA
000025A4                          2525          
000025A4  43F9 00003EDB           2526              LEA         newLine, A1         ; Display newLine
000025AA  103C 000E               2527              MOVE.B      #14, D0             ; command for trap call to display message
000025AE  4E4F                    2528              TRAP        #15                 ; trap call
000025B0                          2529          
000025B0  6000 EAA6               2530              BRA         LOOP                ; branch back to LOOP
000025B4                          2531  
000025B4                          2532  opLSR   
000025B4  43F9 00003F5A           2533              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
000025BA  103C 000E               2534              MOVE.B      #14, D0             ; command for trap call to display message
000025BE  4E4F                    2535              TRAP        #15                 ; trap call
000025C0                          2536          
000025C0  43F9 00003F7C           2537              LEA         dispWord, A1        ; display word
000025C6  103C 000E               2538              MOVE.B      #14, D0             ; command for trap call to display message
000025CA  4E4F                    2539              TRAP        #15                 ; trap call
000025CC                          2540          
000025CC  43F9 00003EDF           2541              LEA         space, A1           ; display space 
000025D2  103C 000E               2542              MOVE.B      #14, D0             ; command for trap call to display message
000025D6  4E4F                    2543              TRAP        #15                 ; trap call
000025D8                          2544          
000025D8  4242                    2545              CLR         D2                  ; clear D2
000025DA  4243                    2546              CLR         D3                  ; clear D3
000025DC  1401                    2547              MOVE.B      D1,D2               ; move byte from D1 to D2
000025DE  1601                    2548              MOVE.B      D1,D3               ; move byte from D1 to D3
000025E0                          2549          
000025E0  E602                    2550              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
000025E2  C47C 0007               2551              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
000025E6  C67C 0007               2552              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
000025EA                          2553          
000025EA  4EB9 00002F0E           2554              JSR         printEA             ; jump to printEA
000025F0                          2555          
000025F0  43F9 00003EDB           2556              LEA         newLine, A1         ; Display newLine
000025F6  103C 000E               2557              MOVE.B      #14, D0             ; command for trap call to display message
000025FA  4E4F                    2558              TRAP        #15                 ; trap call
000025FC                          2559          
000025FC  6000 EA5A               2560              BRA         LOOP                ; branch back to LOOP
00002600                          2561  
00002600                          2562  opROL   
00002600  43F9 00003F6E           2563              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002606  103C 000E               2564              MOVE.B      #14, D0             ; command for trap call to display message
0000260A  4E4F                    2565              TRAP        #15                 ; trap call
0000260C                          2566          
0000260C  43F9 00003F7C           2567              LEA         dispWord, A1        ; display word
00002612  103C 000E               2568              MOVE.B      #14, D0             ; command for trap call to display message
00002616  4E4F                    2569              TRAP        #15                 ; trap call
00002618                          2570          
00002618  43F9 00003EDF           2571              LEA         space, A1           ; display space 
0000261E  103C 000E               2572              MOVE.B      #14, D0             ; command for trap call to display message
00002622  4E4F                    2573              TRAP        #15                 ; trap call
00002624                          2574          
00002624  4242                    2575              CLR         D2                  ; clear D2
00002626  4243                    2576              CLR         D3                  ; clear D3
00002628  1401                    2577              MOVE.B      D1,D2               ; move byte from D1 to D2
0000262A  1601                    2578              MOVE.B      D1,D3               ; move byte from D1 to D3
0000262C                          2579          
0000262C  E602                    2580              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
0000262E  C47C 0007               2581              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
00002632  C67C 0007               2582              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
00002636                          2583          
00002636  4EB9 00002F0E           2584              JSR         printEA             ; jump to printEA
0000263C                          2585          
0000263C  43F9 00003EDB           2586              LEA         newLine, A1         ; Display newLine
00002642  103C 000E               2587              MOVE.B      #14, D0             ; command for trap call to display message
00002646  4E4F                    2588              TRAP        #15                 ; trap call
00002648                          2589          
00002648  6000 EA0E               2590              BRA         LOOP                ; branch back to LOOP
0000264C                          2591  
0000264C                          2592  opROR   
0000264C  43F9 00003F6A           2593              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002652  103C 000E               2594              MOVE.B      #14, D0             ; command for trap call to display message
00002656  4E4F                    2595              TRAP        #15                 ; trap call
00002658                          2596          
00002658  43F9 00003F7C           2597              LEA         dispWord, A1        ; display word
0000265E  103C 000E               2598              MOVE.B      #14, D0             ; command for trap call to display message
00002662  4E4F                    2599              TRAP        #15                 ; trap call
00002664                          2600          
00002664  43F9 00003EDF           2601              LEA         space, A1           ; display space 
0000266A  103C 000E               2602              MOVE.B      #14, D0             ; command for trap call to display message
0000266E  4E4F                    2603              TRAP        #15                 ; trap call
00002670                          2604          
00002670  4242                    2605              CLR         D2                  ; clear D2
00002672  4243                    2606              CLR         D3                  ; clear D3
00002674  1401                    2607              MOVE.B      D1,D2               ; move byte from D1 to D2
00002676  1601                    2608              MOVE.B      D1,D3               ; move byte from D1 to D3
00002678                          2609          
00002678  E602                    2610              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
0000267A  C47C 0007               2611              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
0000267E  C67C 0007               2612              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
00002682                          2613          
00002682  4EB9 00002F0E           2614              JSR         printEA             ; jump to printEA
00002688                          2615          
00002688  43F9 00003EDB           2616              LEA         newLine, A1         ; Display newLine
0000268E  103C 000E               2617              MOVE.B      #14, D0             ; command for trap call to display message
00002692  4E4F                    2618              TRAP        #15                 ; trap call
00002694                          2619          
00002694  6000 E9C2               2620              BRA         LOOP                ; branch back to LOOP
00002698                          2621          
00002698                          2622  memSB       
00002698  4242                    2623              CLR         D2                  ; clear D2
0000269A  1401                    2624              MOVE.B      D1,D2               ; move D1 to D2
0000269C  E642                    2625              ASR         #three, D2          ; shift D2 by 3 bits to get i/r
0000269E                          2626              
0000269E  C47C 0007               2627              AND         #$07, D2            ; and D2 by 3 bits 
000026A2                          2628          
000026A2  B43C 0000               2629              CMP.B       #zero, D2           ; compare 0 to D2
000026A6  6700 002E               2630              BEQ         opASBI              ; if true, branch to ASBI for immediate
000026AA  B43C 0004               2631              CMP.B       #four, D2           ; compare 4 to D2 
000026AE  6700 0088               2632              BEQ         opASBR              ; if true, branch to ASBR for register
000026B2  B43C 0001               2633              CMP.B       #one, D2            ; compare 1 to D2
000026B6  6700 00E2               2634              BEQ         opLSBI              ; if true, branch to LSBI for immediate
000026BA  B43C 0005               2635              CMP.B       #five, D2           ; compare 5 to D2
000026BE  6700 013C               2636              BEQ         opLSBR              ; if true, branch to LSBR for register
000026C2  B43C 0003               2637              CMP.B       #three, D2          ; compare 3 to D2
000026C6  6700 0196               2638              BEQ         opROBI              ; if true, branch to ROBI for immediate
000026CA  B43C 0007               2639              CMP.B       #seven, D2          ; compare 7 to D2
000026CE  6700 01F0               2640              BEQ         opROBR              ; if true, branch to ROBR for register
000026D2  6000 15A6               2641              BRA         printInvalid        ; otherwise invalid
000026D6                          2642          
000026D6                          2643  opASBI  
000026D6  4242                    2644              CLR         D2                  ; clear D2
000026D8  3401                    2645              MOVE.W      D1, D2              ; move word from D1 to D2
000026DA  E042                    2646              ASR         #eight, D2          ; shift D2 over by 8 bits 
000026DC  C47C 0001               2647              AND         #$01, D2            ; and D2 by 1 bit to get direction
000026E0                          2648      
000026E0  B43C 0000               2649              CMP.B       #zero, D2           ; compare 0 to D2
000026E4  6700 000E               2650              BEQ         opASRBI             ; if true, branch to ASRBI for right
000026E8  B43C 0001               2651              CMP.B       #one, D2            ; compare 1 to D2
000026EC  6700 0028               2652              BEQ         opASLBI             ; if true, branch to ASLBI for left
000026F0  6000 1588               2653              BRA         printInvalid        ; otherwise invalid
000026F4                          2654          
000026F4                          2655  opASRBI 
000026F4  43F9 00003F62           2656              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000026FA  103C 000E               2657              MOVE.B      #14, D0             ; command for trap call to display message
000026FE  4E4F                    2658              TRAP        #15                 ; trap call
00002700                          2659  
00002700  43F9 00003F79           2660              LEA         dispByte, A1        ; display byte
00002706  103C 000E               2661              MOVE.B      #14, D0             ; command for trap call to display message
0000270A  4E4F                    2662              TRAP        #15                 ; trap call
0000270C                          2663          
0000270C  4EB9 00002E36           2664              JSR         PrntImm             ; jump to PrntImm
00002712                          2665          
00002712  6000 E944               2666              BRA         LOOP                ; branch back to LOOP
00002716                          2667  
00002716                          2668  opASLBI 
00002716  43F9 00003F66           2669              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
0000271C  103C 000E               2670              MOVE.B      #14, D0             ; command for trap call to display message
00002720  4E4F                    2671              TRAP        #15                 ; trap call
00002722                          2672  
00002722  43F9 00003F79           2673              LEA         dispByte, A1        ; display byte
00002728  103C 000E               2674              MOVE.B      #14, D0             ; command for trap call to display message
0000272C  4E4F                    2675              TRAP        #15                 ; trap call
0000272E                          2676          
0000272E  4EB9 00002E36           2677              JSR         PrntImm             ; jump to PrntImm
00002734                          2678          
00002734  6000 E922               2679              BRA         LOOP                ; branch back to LOOP
00002738                          2680  
00002738                          2681  opASBR  
00002738  4242                    2682              CLR         D2                  ; clear D2
0000273A  3401                    2683              MOVE.W      D1, D2              ; move word from D1 to D2
0000273C  E042                    2684              ASR         #eight, D2          ; shift D2 over by 8 bits 
0000273E  C47C 0001               2685              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002742                          2686      
00002742  B43C 0000               2687              CMP.B       #zero, D2           ; compare 0 to D2 
00002746  6700 000E               2688              BEQ         opASRBR             ; if true, branch to ASRBR for right
0000274A  B43C 0001               2689              CMP.B       #one, D2            ; compare 1 to D2
0000274E  6700 0028               2690              BEQ         opASLBR             ; if true, branch to ASLBR for left
00002752  6000 1526               2691              BRA         printInvalid        ; otherwise invalid
00002756                          2692          
00002756                          2693  opASRBR 
00002756  43F9 00003F62           2694              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
0000275C  103C 000E               2695              MOVE.B      #14, D0             ; command for trap call to display message
00002760  4E4F                    2696              TRAP        #15                 ; trap call
00002762                          2697  
00002762  43F9 00003F79           2698              LEA         dispByte, A1        ; display byte
00002768  103C 000E               2699              MOVE.B      #14, D0             ; command for trap call to display message
0000276C  4E4F                    2700              TRAP        #15                 ; trap call
0000276E                          2701          
0000276E  4EB9 00002E92           2702              JSR         PrntReg             ; jump to PrntReg
00002774                          2703          
00002774  6000 E8E2               2704              BRA         LOOP                ; branch back to LOOP
00002778                          2705  
00002778                          2706  opASLBR 
00002778  43F9 00003F66           2707              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
0000277E  103C 000E               2708              MOVE.B      #14, D0             ; command for trap call to display message
00002782  4E4F                    2709              TRAP        #15                 ; trap call
00002784                          2710  
00002784  43F9 00003F79           2711              LEA         dispByte, A1        ; display byte
0000278A  103C 000E               2712              MOVE.B      #14, D0             ; command for trap call to display message
0000278E  4E4F                    2713              TRAP        #15                 ; trap call
00002790                          2714          
00002790  4EB9 00002E92           2715              JSR         PrntReg             ; jump to PrntReg
00002796                          2716          
00002796  6000 E8C0               2717              BRA         LOOP                ; branch back to LOOP
0000279A                          2718  
0000279A                          2719  opLSBI      
0000279A  4242                    2720              CLR         D2                  ; clear D2
0000279C  3401                    2721              MOVE.W      D1, D2              ; move word from D1 to D2
0000279E  E042                    2722              ASR         #eight, D2          ; shift D2 over by 8 bits 
000027A0  C47C 0001               2723              AND         #$01, D2            ; and D2 by 1 bit to get direction
000027A4                          2724      
000027A4  B43C 0000               2725              CMP.B       #zero, D2           ; compare 0 to D2 
000027A8  6700 000E               2726              BEQ         opLSRBI             ; if true, branch to LSRBI for right
000027AC  B43C 0001               2727              CMP.B       #one, D2            ; compare 1 to D2
000027B0  6700 0028               2728              BEQ         opLSLBI             ; if true, branch to LSLBI for left
000027B4  6000 14C4               2729              BRA         printInvalid        ; otherwise invalid
000027B8                          2730          
000027B8                          2731  opLSRBI 
000027B8  43F9 00003F5A           2732              LEA         LSRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000027BE  103C 000E               2733              MOVE.B      #14, D0             ; command for trap call to display message
000027C2  4E4F                    2734              TRAP        #15                 ; trap call
000027C4                          2735  
000027C4  43F9 00003F79           2736              LEA         dispByte, A1        ; display byte
000027CA  103C 000E               2737              MOVE.B      #14, D0             ; command for trap call to display message
000027CE  4E4F                    2738              TRAP        #15                 ; trap call
000027D0                          2739          
000027D0  4EB9 00002E36           2740              JSR         PrntImm             ; jump to PrntImm
000027D6                          2741          
000027D6  6000 E880               2742              BRA         LOOP                ; branch back to LOOP
000027DA                          2743              
000027DA                          2744  opLSLBI     
000027DA  43F9 00003F5E           2745              LEA         LSLmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000027E0  103C 000E               2746              MOVE.B      #14, D0             ; command for trap call to display message
000027E4  4E4F                    2747              TRAP        #15                 ; trap call
000027E6                          2748  
000027E6  43F9 00003F79           2749              LEA         dispByte, A1        ; display byte
000027EC  103C 000E               2750              MOVE.B      #14, D0             ; command for trap call to display message
000027F0  4E4F                    2751              TRAP        #15                 ; trap call
000027F2                          2752          
000027F2  4EB9 00002E36           2753              JSR         PrntImm             ; jump to PrntImm
000027F8                          2754          
000027F8  6000 E85E               2755              BRA         LOOP                ; branch back to LOOP
000027FC                          2756  
000027FC                          2757  opLSBR  
000027FC  4242                    2758              CLR         D2                  ; clear D2
000027FE  3401                    2759              MOVE.W      D1, D2              ; move word from D1 to D2
00002800  E042                    2760              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002802  C47C 0001               2761              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002806                          2762      
00002806  B43C 0000               2763              CMP.B       #zero, D2           ; compare 0 to D2 
0000280A  6700 000E               2764              BEQ         opLSRBR             ; if true, branch to LSRBR for right
0000280E  B43C 0001               2765              CMP.B       #one, D2            ; compare 1 to D2
00002812  6700 0028               2766              BEQ         opLSLBR             ; if true, branch to LSLBR for left
00002816  6000 1462               2767              BRA         printInvalid        ; otherwise invalid
0000281A                          2768          
0000281A                          2769  opLSRBR 
0000281A  43F9 00003F5A           2770              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002820  103C 000E               2771              MOVE.B      #14, D0             ; command for trap call to display message
00002824  4E4F                    2772              TRAP        #15                 ; trap call
00002826                          2773  
00002826  43F9 00003F79           2774              LEA         dispByte, A1        ; display byte
0000282C  103C 000E               2775              MOVE.B      #14, D0             ; command for trap call to display message
00002830  4E4F                    2776              TRAP        #15                 ; trap call
00002832                          2777          
00002832  4EB9 00002E92           2778              JSR         PrntReg             ; jump to PrntReg
00002838                          2779          
00002838  6000 E81E               2780              BRA         LOOP                ; branch back to LOOP
0000283C                          2781          
0000283C                          2782  opLSLBR     
0000283C  43F9 00003F5E           2783              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002842  103C 000E               2784              MOVE.B      #14, D0             ; command for trap call to display message
00002846  4E4F                    2785              TRAP        #15                 ; trap call
00002848                          2786  
00002848  43F9 00003F79           2787              LEA         dispByte, A1        ; display byte
0000284E  103C 000E               2788              MOVE.B      #14, D0             ; command for trap call to display message
00002852  4E4F                    2789              TRAP        #15                 ; trap call
00002854                          2790          
00002854  4EB9 00002E92           2791              JSR         PrntReg             ; jump to PrntReg
0000285A                          2792          
0000285A  6000 E7FC               2793              BRA         LOOP                ; branch back to LOOP
0000285E                          2794              
0000285E                          2795  opROBI  
0000285E  4242                    2796              CLR         D2                  ; clear D2
00002860  3401                    2797              MOVE.W      D1, D2              ; move word from D1 to D2
00002862  E042                    2798              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002864  C47C 0001               2799              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002868                          2800      
00002868  B43C 0000               2801              CMP.B       #zero, D2           ; compare 0 to D2
0000286C  6700 000E               2802              BEQ         opRORBI             ; if true, branch to RORBI for right
00002870  B43C 0001               2803              CMP.B       #one, D2            ; compare 1 to D2
00002874  6700 0028               2804              BEQ         opROLBI             ; if true, branch to ROLBI for left
00002878  6000 1400               2805              BRA         printInvalid        ; otherwise invalid
0000287C                          2806          
0000287C                          2807  opRORBI 
0000287C  43F9 00003F6A           2808              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002882  103C 000E               2809              MOVE.B      #14, D0             ; command for trap call to display message
00002886  4E4F                    2810              TRAP        #15                 ; trap call
00002888                          2811  
00002888  43F9 00003F79           2812              LEA         dispByte, A1        ; display byte
0000288E  103C 000E               2813              MOVE.B      #14, D0             ; command for trap call to display message
00002892  4E4F                    2814              TRAP        #15                 ; trap call
00002894                          2815          
00002894  4EB9 00002E36           2816              JSR         PrntImm             ; jump to PrntImm
0000289A                          2817          
0000289A  6000 E7BC               2818              BRA         LOOP                ; branch back to LOOP
0000289E                          2819  
0000289E                          2820  opROLBI 
0000289E  43F9 00003F6E           2821              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
000028A4  103C 000E               2822              MOVE.B      #14, D0             ; command for trap call to display message
000028A8  4E4F                    2823              TRAP        #15                 ; trap call
000028AA                          2824  
000028AA  43F9 00003F79           2825              LEA         dispByte, A1        ; display byte
000028B0  103C 000E               2826              MOVE.B      #14, D0             ; command for trap call to display message
000028B4  4E4F                    2827              TRAP        #15                 ; trap call
000028B6                          2828          
000028B6  4EB9 00002E36           2829              JSR         PrntImm             ; jump to PrntImm
000028BC                          2830          
000028BC  6000 E79A               2831              BRA         LOOP                ; branch back to LOOP
000028C0                          2832  
000028C0                          2833  opROBR  
000028C0  4242                    2834              CLR         D2                  ; clear D2
000028C2  3401                    2835              MOVE.W      D1, D2              ; move word from D1 to D2
000028C4  E042                    2836              ASR         #eight, D2          ; shift D2 over by 8 bits 
000028C6  C47C 0001               2837              AND         #$01, D2            ; and D2 by 1 bit to get direction
000028CA                          2838      
000028CA  B43C 0000               2839              CMP.B       #zero, D2           ; compare 0 to D2 
000028CE  6700 000E               2840              BEQ         opRORBR             ; if true, branch to RORBR for right
000028D2  B43C 0001               2841              CMP.B       #one, D2            ; compare 1 to D2
000028D6  6700 0028               2842              BEQ         opROLBR             ; if true, branch to ROLBR for left
000028DA  6000 139E               2843              BRA         printInvalid        ; otherwise invalid    
000028DE                          2844          
000028DE                          2845  opRORBR 
000028DE  43F9 00003F6A           2846              LEA         RORmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000028E4  103C 000E               2847              MOVE.B      #14, D0             ; command for trap call to display message
000028E8  4E4F                    2848              TRAP        #15                 ; trap call
000028EA                          2849  
000028EA  43F9 00003F79           2850              LEA         dispByte, A1        ; display byte
000028F0  103C 000E               2851              MOVE.B      #14, D0             ; command for trap call to display message
000028F4  4E4F                    2852              TRAP        #15                 ; trap call
000028F6                          2853          
000028F6  4EB9 00002E92           2854              JSR         PrntReg             ; jump to PrntReg
000028FC                          2855          
000028FC  6000 E75A               2856              BRA         LOOP                ; branch back to LOOP
00002900                          2857  
00002900                          2858  opROLBR 
00002900  43F9 00003F6E           2859              LEA         ROLmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002906  103C 000E               2860              MOVE.B      #14, D0             ; command for trap call to display message
0000290A  4E4F                    2861              TRAP        #15                 ; trap call
0000290C                          2862  
0000290C  43F9 00003F79           2863              LEA         dispByte, A1        ; display byte
00002912  103C 000E               2864              MOVE.B      #14, D0             ; command for trap call to display message
00002916  4E4F                    2865              TRAP        #15                 ; trap call
00002918                          2866          
00002918  4EB9 00002E92           2867              JSR         PrntReg             ; jump to PrntReg
0000291E                          2868          
0000291E  6000 E738               2869              BRA         LOOP                ; branch back to LOOP       
00002922                          2870  
00002922                          2871  memSW   
00002922  4242                    2872              CLR         D2                  ; clear D2
00002924  1401                    2873              MOVE.B      D1,D2               ; move D1 to D2
00002926  E642                    2874              ASR         #three, D2          ; shift D2 by 3 bits to get i/r
00002928                          2875              
00002928  C47C 0007               2876              AND         #$07, D2            ; and D2 by 3 bits 
0000292C                          2877          
0000292C  B43C 0000               2878              CMP.B       #zero, D2           ; compare 0 to D2
00002930  6700 002E               2879              BEQ         opASWI              ; if true, branch to ASWI for immediate
00002934  B43C 0004               2880              CMP.B       #four, D2           ; compare 4 to D2 
00002938  6700 0088               2881              BEQ         opASWR              ; if true, branch to ASWR for register
0000293C  B43C 0001               2882              CMP.B       #one, D2            ; compare 1 to D2
00002940  6700 00E2               2883              BEQ         opLSWI              ; if true, branch to LSWI for immediate
00002944  B43C 0005               2884              CMP.B       #five, D2           ; compare 5 to D2
00002948  6700 013C               2885              BEQ         opLSWR              ; if true, branch to LSWR for register
0000294C  B43C 0003               2886              CMP.B       #three, D2          ; compare 3 to D2
00002950  6700 0196               2887              BEQ         opROWI              ; if true, branch to ROWI for immediate
00002954  B43C 0007               2888              CMP.B       #seven, D2          ; compare 7 to D2
00002958  6700 01F0               2889              BEQ         opROWR              ; if true, branch to ROWR for register
0000295C  6000 131C               2890              BRA         printInvalid        ; otherwise invalid
00002960                          2891          
00002960                          2892  opASWI  
00002960  4242                    2893              CLR         D2                  ; clear D2
00002962  3401                    2894              MOVE.W      D1, D2              ; move word from D1 to D2
00002964  E042                    2895              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002966  C47C 0001               2896              AND         #$01, D2            ; and D2 by 1 bit to get direction
0000296A                          2897      
0000296A  B43C 0000               2898              CMP.B       #zero, D2           ; compare 0 to D2
0000296E  6700 000E               2899              BEQ         opASRWI             ; if true, branch to ASRWI for right
00002972  B43C 0001               2900              CMP.B       #one, D2            ; compare 1 to D2
00002976  6700 0028               2901              BEQ         opASLWI             ; if true, branch to ASLWI for left
0000297A  6000 12FE               2902              BRA         printInvalid        ; otherwise invalid
0000297E                          2903          
0000297E                          2904  opASRWI 
0000297E  43F9 00003F62           2905              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002984  103C 000E               2906              MOVE.B      #14, D0             ; command for trap call to display message
00002988  4E4F                    2907              TRAP        #15                 ; trap call
0000298A                          2908  
0000298A  43F9 00003F7C           2909              LEA         dispWord, A1        ; display word
00002990  103C 000E               2910              MOVE.B      #14, D0             ; command for trap call to display message
00002994  4E4F                    2911              TRAP        #15                 ; trap call
00002996                          2912          
00002996  4EB9 00002E36           2913              JSR         PrntImm             ; jump to PrntImm
0000299C                          2914          
0000299C  6000 E6BA               2915              BRA         LOOP                ; branch back to LOOP
000029A0                          2916  
000029A0                          2917  opASLWI 
000029A0  43F9 00003F66           2918              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
000029A6  103C 000E               2919              MOVE.B      #14, D0             ; command for trap call to display message
000029AA  4E4F                    2920              TRAP        #15                 ; trap call
000029AC                          2921  
000029AC  43F9 00003F7C           2922              LEA         dispWord, A1        ; display word
000029B2  103C 000E               2923              MOVE.B      #14, D0             ; command for trap call to display message
000029B6  4E4F                    2924              TRAP        #15                 ; trap call
000029B8                          2925          
000029B8  4EB9 00002E36           2926              JSR         PrntImm             ; jump to PrntImm
000029BE                          2927          
000029BE  6000 E698               2928              BRA         LOOP                ; branch back to LOOP
000029C2                          2929  
000029C2                          2930  opASWR  
000029C2  4242                    2931              CLR         D2                  ; clear D2
000029C4  3401                    2932              MOVE.W      D1, D2              ; move word from D1 to D2
000029C6  E042                    2933              ASR         #eight, D2          ; shift D2 over by 8 bits 
000029C8  C47C 0001               2934              AND         #$01, D2            ; and D2 by 1 bit to get direction
000029CC                          2935      
000029CC  B43C 0000               2936              CMP.B       #zero, D2           ; compare 0 to D2 
000029D0  6700 000E               2937              BEQ         opASRWR             ; if true, branch to ASRWR for right
000029D4  B43C 0001               2938              CMP.B       #one, D2            ; compare 1 to D2
000029D8  6700 0028               2939              BEQ         opASLWR             ; if true, branch to ASLWR for left
000029DC  6000 129C               2940              BRA         printInvalid        ; otherwise invalid
000029E0                          2941          
000029E0                          2942  opASRWR     
000029E0  43F9 00003F62           2943              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000029E6  103C 000E               2944              MOVE.B      #14, D0             ; command for trap call to display message
000029EA  4E4F                    2945              TRAP        #15                 ; trap call
000029EC                          2946  
000029EC  43F9 00003F7C           2947              LEA         dispWord, A1        ; display word
000029F2  103C 000E               2948              MOVE.B      #14, D0             ; command for trap call to display message
000029F6  4E4F                    2949              TRAP        #15                 ; trap call
000029F8                          2950          
000029F8  4EB9 00002E92           2951              JSR         PrntReg             ; jump to PrntReg
000029FE                          2952          
000029FE  6000 E658               2953              BRA         LOOP                ; branch back to LOOP
00002A02                          2954  
00002A02                          2955  opASLWR     
00002A02  43F9 00003F66           2956              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
00002A08  103C 000E               2957              MOVE.B      #14, D0             ; command for trap call to display message
00002A0C  4E4F                    2958              TRAP        #15                 ; trap call
00002A0E                          2959  
00002A0E  43F9 00003F7C           2960              LEA         dispWord, A1        ; display word
00002A14  103C 000E               2961              MOVE.B      #14, D0             ; command for trap call to display message
00002A18  4E4F                    2962              TRAP        #15                 ; trap call
00002A1A                          2963          
00002A1A  4EB9 00002E92           2964              JSR         PrntReg             ; jump to PrntReg
00002A20                          2965          
00002A20  6000 E636               2966              BRA         LOOP                ; branch back to LOOP
00002A24                          2967  
00002A24                          2968  opLSWI      
00002A24  4242                    2969              CLR         D2                  ; clear D2
00002A26  3401                    2970              MOVE.W      D1, D2              ; move word from D1 to D2
00002A28  E042                    2971              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002A2A  C47C 0001               2972              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002A2E                          2973      
00002A2E  B43C 0000               2974              CMP.B       #zero, D2           ; compare 0 to D2 
00002A32  6700 000E               2975              BEQ         opLSRWI             ; if true, branch to LSRWI for right
00002A36  B43C 0001               2976              CMP.B       #one, D2            ; compare 1 to D2
00002A3A  6700 0028               2977              BEQ         opLSLWI             ; if true, branch to LSLWI for left
00002A3E  6000 123A               2978              BRA         printInvalid        ; otherwise invalid 
00002A42                          2979          
00002A42                          2980  opLSRWI 
00002A42  43F9 00003F5A           2981              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002A48  103C 000E               2982              MOVE.B      #14, D0             ; command for trap call to display message
00002A4C  4E4F                    2983              TRAP        #15                 ; trap call
00002A4E                          2984      
00002A4E  43F9 00003F7C           2985              LEA         dispWord, A1        ; display word
00002A54  103C 000E               2986              MOVE.B      #14, D0             ; command for trap call to display message
00002A58  4E4F                    2987              TRAP        #15                 ; trap call
00002A5A                          2988          
00002A5A  4EB9 00002E36           2989              JSR         PrntImm             ; jump to PrntImm
00002A60                          2990          
00002A60  6000 E5F6               2991              BRA         LOOP                ; branch back to LOOP
00002A64                          2992              
00002A64                          2993  opLSLWI 
00002A64  43F9 00003F5E           2994              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002A6A  103C 000E               2995              MOVE.B      #14, D0             ; command for trap call to display message
00002A6E  4E4F                    2996              TRAP        #15                 ; trap call
00002A70                          2997  
00002A70  43F9 00003F7C           2998              LEA         dispWord, A1        ; display word
00002A76  103C 000E               2999              MOVE.B      #14, D0             ; command for trap call to display message
00002A7A  4E4F                    3000              TRAP        #15                 ; trap call
00002A7C                          3001          
00002A7C  4EB9 00002E36           3002              JSR         PrntImm             ; jump to PrntImm
00002A82                          3003          
00002A82  6000 E5D4               3004              BRA         LOOP                ; branch back to LOOP
00002A86                          3005              
00002A86                          3006  opLSWR  
00002A86  4242                    3007              CLR         D2                  ; clear D2
00002A88  3401                    3008              MOVE.W      D1, D2              ; move word from D1 to D2
00002A8A  E042                    3009              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002A8C  C47C 0001               3010              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002A90                          3011      
00002A90  B43C 0000               3012              CMP.B       #zero, D2           ; compare 0 to D2 
00002A94  6700 000E               3013              BEQ         opLSRWR             ; if true, branch to LSRWR for right
00002A98  B43C 0001               3014              CMP.B       #one, D2            ; compare 1 to D2
00002A9C  6700 0028               3015              BEQ         opLSLWR             ; if true, branch to LSLWR for left
00002AA0  6000 11D8               3016              BRA         printInvalid        ; otherwise invalid
00002AA4                          3017          
00002AA4                          3018  opLSRWR 
00002AA4  43F9 00003F5A           3019              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002AAA  103C 000E               3020              MOVE.B      #14, D0             ; command for trap call to display message
00002AAE  4E4F                    3021              TRAP        #15                 ; trap call
00002AB0                          3022  
00002AB0  43F9 00003F7C           3023              LEA         dispWord, A1        ; display word
00002AB6  103C 000E               3024              MOVE.B      #14, D0             ; command for trap call to display message
00002ABA  4E4F                    3025              TRAP        #15                 ; trap call
00002ABC                          3026          
00002ABC  4EB9 00002E92           3027              JSR         PrntReg             ; jump to PrntReg
00002AC2                          3028          
00002AC2  6000 E594               3029              BRA         LOOP                ; branch back to LOOP
00002AC6                          3030          
00002AC6                          3031  opLSLWR 
00002AC6  43F9 00003F5E           3032              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002ACC  103C 000E               3033              MOVE.B      #14, D0             ; command for trap call to display message
00002AD0  4E4F                    3034              TRAP        #15                 ; trap call
00002AD2                          3035  
00002AD2  43F9 00003F7C           3036              LEA         dispWord, A1        ; display word
00002AD8  103C 000E               3037              MOVE.B      #14, D0             ; command for trap call to display message
00002ADC  4E4F                    3038              TRAP        #15                 ; trap call
00002ADE                          3039          
00002ADE  4EB9 00002E92           3040              JSR         PrntReg             ; jump to PrntReg
00002AE4                          3041          
00002AE4  6000 E572               3042              BRA         LOOP                ; branch back to LOOP
00002AE8                          3043  
00002AE8                          3044  opROWI  
00002AE8  4242                    3045              CLR         D2                  ; clear D2
00002AEA  3401                    3046              MOVE.W      D1, D2              ; move word from D1 to D2
00002AEC  E042                    3047              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002AEE  C47C 0001               3048              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002AF2                          3049      
00002AF2  B43C 0000               3050              CMP.B       #zero, D2           ; compare 0 to D2
00002AF6  6700 000E               3051              BEQ         opRORWI             ; if true, branch to RORWI for right
00002AFA  B43C 0001               3052              CMP.B       #one, D2            ; compare 1 to D2
00002AFE  6700 0028               3053              BEQ         opROLWI             ; if true, branch to ROLWI for left
00002B02  6000 1176               3054              BRA         printInvalid        ; otherwise invalid
00002B06                          3055          
00002B06                          3056  opRORWI 
00002B06  43F9 00003F6A           3057              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002B0C  103C 000E               3058              MOVE.B      #14, D0             ; command for trap call to display message
00002B10  4E4F                    3059              TRAP        #15                 ; trap call
00002B12                          3060  
00002B12  43F9 00003F7C           3061              LEA         dispWord, A1        ; display word
00002B18  103C 000E               3062              MOVE.B      #14, D0             ; command for trap call to display message
00002B1C  4E4F                    3063              TRAP        #15                 ; trap call
00002B1E                          3064          
00002B1E  4EB9 00002E36           3065              JSR         PrntImm             ; jump to PrntImm
00002B24                          3066          
00002B24  6000 E532               3067              BRA         LOOP                ; branch back to LOOP
00002B28                          3068  
00002B28                          3069  opROLWI     
00002B28  43F9 00003F6E           3070              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002B2E                          3071          
00002B2E  103C 000E               3072              MOVE.B      #14, D0             ; command for trap call to display message
00002B32  4E4F                    3073              TRAP        #15                 ; trap call
00002B34                          3074  
00002B34  43F9 00003F7C           3075              LEA         dispWord, A1        ; display word
00002B3A  103C 000E               3076              MOVE.B      #14, D0             ; command for trap call to display message
00002B3E  4E4F                    3077              TRAP        #15                 ; trap call
00002B40                          3078          
00002B40  4EB9 00002E36           3079              JSR         PrntImm             ; jump to PrntImm
00002B46                          3080          
00002B46  6000 E510               3081              BRA         LOOP                ; branch back to LOOP
00002B4A                          3082  
00002B4A                          3083  opROWR      
00002B4A  4242                    3084              CLR         D2                  ; clear D2
00002B4C  3401                    3085              MOVE.W      D1, D2              ; move word from D1 to D2
00002B4E  E042                    3086              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002B50  C47C 0001               3087              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002B54                          3088      
00002B54  B43C 0000               3089              CMP.B       #zero, D2           ; compare 0 to D2 
00002B58  6700 000E               3090              BEQ         opRORWR             ; if true, branch to RORWR for right
00002B5C  B43C 0001               3091              CMP.B       #one, D2            ; compare 1 to D2
00002B60  6700 0028               3092              BEQ         opROLWR             ; if true, branch to ROLWR for left
00002B64  6000 1114               3093              BRA         printInvalid        ; otherwise invalid     
00002B68                          3094          
00002B68                          3095  opRORWR 
00002B68  43F9 00003F6A           3096              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002B6E  103C 000E               3097              MOVE.B      #14, D0             ; command for trap call to display message
00002B72  4E4F                    3098              TRAP        #15                 ; trap call
00002B74                          3099      
00002B74  43F9 00003F7C           3100              LEA         dispWord, A1        ; display word
00002B7A  103C 000E               3101              MOVE.B      #14, D0             ; command for trap call to display message
00002B7E  4E4F                    3102              TRAP        #15                 ; trap call
00002B80                          3103          
00002B80  4EB9 00002E92           3104              JSR         PrntReg             ; jump to PrntReg
00002B86                          3105          
00002B86  6000 E4D0               3106              BRA         LOOP                ; branch back to LOOP
00002B8A                          3107  
00002B8A                          3108  opROLWR 
00002B8A  43F9 00003F6E           3109              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002B90  103C 000E               3110              MOVE.B      #14, D0             ; command for trap call to display message
00002B94  4E4F                    3111              TRAP        #15                 ; trap call
00002B96                          3112  
00002B96  43F9 00003F7C           3113              LEA         dispWord, A1        ; display word
00002B9C  103C 000E               3114              MOVE.B      #14, D0             ; command for trap call to display message
00002BA0  4E4F                    3115              TRAP        #15                 ; trap call
00002BA2                          3116          
00002BA2  4EB9 00002E92           3117              JSR         PrntReg             ; jump to PrntReg
00002BA8                          3118          
00002BA8  6000 E4AE               3119              BRA         LOOP                ; branch back to LOOP
00002BAC                          3120  
00002BAC                          3121  memSL   
00002BAC  4242                    3122              CLR         D2                  ; clear D2
00002BAE  1401                    3123              MOVE.B      D1,D2               ; move D1 to D2
00002BB0  E642                    3124              ASR         #three, D2          ; shift D2 by 3 bits to get i/r
00002BB2                          3125              
00002BB2  C47C 0007               3126              AND         #$07, D2            ; and D2 by 3 bits 
00002BB6                          3127          
00002BB6  B43C 0000               3128              CMP.B       #zero, D2           ; compare 0 to D2
00002BBA  6700 002E               3129              BEQ         opASLI              ; if true, branch to ASLI for immediate
00002BBE  B43C 0004               3130              CMP.B       #four, D2           ; compare 4 to D2 
00002BC2  6700 0088               3131              BEQ         opASLR              ; if true, branch to ASLR for register
00002BC6  B43C 0001               3132              CMP.B       #one, D2            ; compare 1 to D2
00002BCA  6700 00E2               3133              BEQ         opLSLI              ; if true, branch to LSLI for immediate
00002BCE  B43C 0005               3134              CMP.B       #five, D2           ; compare 5 to D2
00002BD2  6700 013C               3135              BEQ         opLSLR              ; if true, branch to LSLR for register
00002BD6  B43C 0003               3136              CMP.B       #three, D2          ; compare 3 to D2
00002BDA  6700 0196               3137              BEQ         opROLI              ; if true, branch to ROLI for immediate
00002BDE  B43C 0007               3138              CMP.B       #seven, D2          ; compare 7 to D2
00002BE2  6700 01F0               3139              BEQ         opROLR              ; if true, branch to ROLR for register
00002BE6  6000 1092               3140              BRA         printInvalid        ; otherwise invalid
00002BEA                          3141          
00002BEA                          3142  opASLI  
00002BEA  4242                    3143              CLR         D2                  ; clear D2
00002BEC  3401                    3144              MOVE.W      D1, D2              ; move word from D1 to D2
00002BEE  E042                    3145              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002BF0  C47C 0001               3146              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002BF4                          3147      
00002BF4  B43C 0000               3148              CMP.B       #zero, D2           ; compare 0 to D2
00002BF8  6700 000E               3149              BEQ         opASRLI             ; if true, branch to ASRLI for right
00002BFC  B43C 0001               3150              CMP.B       #one, D2            ; compare 1 to D2
00002C00  6700 0028               3151              BEQ         opASLLI             ; if true, branch to ASLLI for left
00002C04  6000 1074               3152              BRA         printInvalid        ; otherwise invalid
00002C08                          3153          
00002C08                          3154  opASRLI 
00002C08  43F9 00003F62           3155              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002C0E  103C 000E               3156              MOVE.B      #14, D0             ; command for trap call to display message
00002C12  4E4F                    3157              TRAP        #15                 ; trap call
00002C14                          3158  
00002C14  43F9 00003F7F           3159              LEA         dispLong, A1        ; display long
00002C1A  103C 000E               3160              MOVE.B      #14, D0             ; command for trap call to display message
00002C1E  4E4F                    3161              TRAP        #15                 ; trap call
00002C20                          3162          
00002C20  4EB9 00002E36           3163              JSR         PrntImm             ; jump to PrntImm
00002C26                          3164          
00002C26  6000 E430               3165              BRA         LOOP                ; branch back to LOOP
00002C2A                          3166  
00002C2A                          3167  opASLLI 
00002C2A  43F9 00003F66           3168              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
00002C30  103C 000E               3169              MOVE.B      #14, D0             ; command for trap call to display message
00002C34  4E4F                    3170              TRAP        #15                 ; trap call
00002C36                          3171  
00002C36  43F9 00003F7F           3172              LEA         dispLong, A1        ; display long
00002C3C  103C 000E               3173              MOVE.B      #14, D0             ; command for trap call to display message
00002C40  4E4F                    3174              TRAP        #15                 ; trap call
00002C42                          3175          
00002C42  4EB9 00002E36           3176              JSR         PrntImm             ; jump to PrntImm
00002C48                          3177          
00002C48  6000 E40E               3178              BRA         LOOP                ; branch back to LOOP
00002C4C                          3179  
00002C4C                          3180  opASLR  
00002C4C  4242                    3181              CLR         D2                  ; clear D2
00002C4E  3401                    3182              MOVE.W      D1, D2              ; move word from D1 to D2
00002C50  E042                    3183              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002C52  C47C 0001               3184              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002C56                          3185      
00002C56  B43C 0000               3186              CMP.B       #zero, D2           ; compare 0 to D2 
00002C5A  6700 000E               3187              BEQ         opASRLR             ; if true, branch to ASRLR for right
00002C5E  B43C 0001               3188              CMP.B       #one, D2            ; compare 1 to D2
00002C62  6700 0028               3189              BEQ         opASLLR             ; if true, branch to ASLLR for left
00002C66  6000 1012               3190              BRA         printInvalid        ; otherwise invalid 
00002C6A                          3191          
00002C6A                          3192  opASRLR 
00002C6A  43F9 00003F62           3193              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002C70  103C 000E               3194              MOVE.B      #14, D0             ; command for trap call to display message
00002C74  4E4F                    3195              TRAP        #15                 ; trap call
00002C76                          3196  
00002C76  43F9 00003F7F           3197              LEA         dispLong, A1        ; display long
00002C7C  103C 000E               3198              MOVE.B      #14, D0             ; command for trap call to display message
00002C80  4E4F                    3199              TRAP        #15                 ; trap call
00002C82                          3200          
00002C82  4EB9 00002E92           3201              JSR         PrntReg             ; jump to PrntReg
00002C88                          3202          
00002C88  6000 E3CE               3203              BRA         LOOP                ; branch back to LOOP
00002C8C                          3204  
00002C8C                          3205  opASLLR 
00002C8C  43F9 00003F66           3206              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
00002C92  103C 000E               3207              MOVE.B      #14, D0             ; command for trap call to display message
00002C96  4E4F                    3208              TRAP        #15                 ; trap call
00002C98                          3209  
00002C98  43F9 00003F7F           3210              LEA         dispLong, A1        ; display long
00002C9E  103C 000E               3211              MOVE.B      #14, D0             ; command for trap call to display message
00002CA2  4E4F                    3212              TRAP        #15                 ; trap call
00002CA4                          3213          
00002CA4  4EB9 00002E92           3214              JSR         PrntReg             ; jump to PrntReg
00002CAA                          3215          
00002CAA  6000 E3AC               3216              BRA         LOOP                ; branch back to LOOP
00002CAE                          3217  
00002CAE                          3218  opLSLI  
00002CAE  4242                    3219              CLR         D2                  ; clear D2
00002CB0  3401                    3220              MOVE.W      D1, D2              ; move word from D1 to D2
00002CB2  E042                    3221              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002CB4  C47C 0001               3222              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002CB8                          3223      
00002CB8  B43C 0000               3224              CMP.B       #zero, D2           ; compare 0 to D2 
00002CBC  6700 000E               3225              BEQ         opLSRLI             ; if true, branch to LSRLI for right
00002CC0  B43C 0001               3226              CMP.B       #one, D2            ; compare 1 to D2
00002CC4  6700 0028               3227              BEQ         opLSLLI             ; if true, branch to LSLLI for left
00002CC8  6000 0FB0               3228              BRA         printInvalid        ; otherwise invalid  
00002CCC                          3229          
00002CCC                          3230  opLSRLI 
00002CCC  43F9 00003F5A           3231              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002CD2  103C 000E               3232              MOVE.B      #14, D0             ; command for trap call to display message
00002CD6  4E4F                    3233              TRAP        #15                 ; trap call
00002CD8                          3234  
00002CD8  43F9 00003F7F           3235              LEA         dispLong, A1        ; display long
00002CDE  103C 000E               3236              MOVE.B      #14, D0             ; command for trap call to display message
00002CE2  4E4F                    3237              TRAP        #15                 ; trap call
00002CE4                          3238          
00002CE4  4EB9 00002E36           3239              JSR         PrntImm             ; jump to PrntImm
00002CEA                          3240          
00002CEA  6000 E36C               3241              BRA         LOOP                ; branch back to LOOP
00002CEE                          3242  
00002CEE                          3243  
00002CEE                          3244  opLSLLI 
00002CEE  43F9 00003F5E           3245              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002CF4  103C 000E               3246              MOVE.B      #14, D0             ; command for trap call to display message
00002CF8  4E4F                    3247              TRAP        #15                 ; trap call
00002CFA                          3248  
00002CFA  43F9 00003F7F           3249              LEA         dispLong, A1        ; display long
00002D00  103C 000E               3250              MOVE.B      #14, D0             ; command for trap call to display message
00002D04  4E4F                    3251              TRAP        #15                 ; trap call
00002D06                          3252          
00002D06  4EB9 00002E36           3253              JSR         PrntImm             ; jump to PrntImm
00002D0C                          3254          
00002D0C  6000 E34A               3255              BRA         LOOP                ; branch back to LOOP
00002D10                          3256  
00002D10                          3257  opLSLR  
00002D10  4242                    3258              CLR         D2                  ; clear D2
00002D12  3401                    3259              MOVE.W      D1, D2              ; move word from D1 to D2
00002D14  E042                    3260              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002D16  C47C 0001               3261              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002D1A                          3262      
00002D1A  B43C 0000               3263              CMP.B       #zero, D2           ; compare 0 to D2 
00002D1E  6700 000E               3264              BEQ         opLSRLR             ; if true, branch to LSRLR for right
00002D22  B43C 0001               3265              CMP.B       #one, D2            ; compare 1 to D2
00002D26  6700 0028               3266              BEQ         opLSLLR             ; if true, branch to LSLLR for left
00002D2A  6000 0F4E               3267              BRA         printInvalid        ; otherwise invalid
00002D2E                          3268          
00002D2E                          3269  opLSRLR 
00002D2E  43F9 00003F5A           3270              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002D34  103C 000E               3271              MOVE.B      #14, D0             ; command for trap call to display message
00002D38  4E4F                    3272              TRAP        #15                 ; trap call
00002D3A                          3273  
00002D3A  43F9 00003F7F           3274              LEA         dispLong, A1        ; display long
00002D40  103C 000E               3275              MOVE.B      #14, D0             ; command for trap call to display message
00002D44  4E4F                    3276              TRAP        #15                 ; trap call
00002D46                          3277          
00002D46  4EB9 00002E92           3278              JSR         PrntReg             ; jump to PrntReg
00002D4C                          3279          
00002D4C  6000 E30A               3280              BRA         LOOP                ; branch back to LOOP
00002D50                          3281          
00002D50                          3282  opLSLLR 
00002D50  43F9 00003F5E           3283              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002D56  103C 000E               3284              MOVE.B      #14, D0             ; command for trap call to display message
00002D5A  4E4F                    3285              TRAP        #15                 ; trap call
00002D5C                          3286  
00002D5C  43F9 00003F7F           3287              LEA         dispLong, A1        ; display long
00002D62  103C 000E               3288              MOVE.B      #14, D0             ; command for trap call to display message
00002D66  4E4F                    3289              TRAP        #15                 ; trap call
00002D68                          3290          
00002D68  4EB9 00002E92           3291              JSR         PrntReg             ; jump to PrntReg
00002D6E                          3292          
00002D6E  6000 E2E8               3293              BRA         LOOP                ; branch back to LOOP
00002D72                          3294              
00002D72                          3295  opROLI  
00002D72  4242                    3296              CLR         D2                  ; clear D2
00002D74  3401                    3297              MOVE.W      D1, D2              ; move word from D1 to D2
00002D76  E042                    3298              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002D78  C47C 0001               3299              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002D7C                          3300      
00002D7C  B43C 0000               3301              CMP.B       #zero, D2           ; compare 0 to D2
00002D80  6700 000E               3302              BEQ         opRORLI             ; if true, branch to RORLI for right
00002D84  B43C 0001               3303              CMP.B       #one, D2            ; compare 1 to D2
00002D88  6700 0028               3304              BEQ         opROLLI             ; if true, branch to ROLLI for left
00002D8C  6000 0EEC               3305              BRA         printInvalid        ; otherwise invalid
00002D90                          3306          
00002D90                          3307  opRORLI 
00002D90  43F9 00003F6A           3308              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002D96  103C 000E               3309              MOVE.B      #14, D0             ; command for trap call to display message
00002D9A  4E4F                    3310              TRAP        #15                 ; trap call
00002D9C                          3311  
00002D9C  43F9 00003F7F           3312              LEA         dispLong, A1        ; display long
00002DA2  103C 000E               3313              MOVE.B      #14, D0             ; command for trap call to display message
00002DA6  4E4F                    3314              TRAP        #15                 ; trap call
00002DA8                          3315          
00002DA8  4EB9 00002E36           3316              JSR         PrntImm             ; jump to PrntImm
00002DAE                          3317          
00002DAE  6000 E2A8               3318              BRA         LOOP                ; branch back to LOOP
00002DB2                          3319  
00002DB2                          3320  opROLLI 
00002DB2  43F9 00003F6E           3321              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002DB8  103C 000E               3322              MOVE.B      #14, D0             ; command for trap call to display message
00002DBC  4E4F                    3323              TRAP        #15                 ; trap call
00002DBE                          3324  
00002DBE  43F9 00003F7F           3325              LEA         dispLong, A1        ; display long
00002DC4  103C 000E               3326              MOVE.B      #14, D0             ; command for trap call to display message
00002DC8  4E4F                    3327              TRAP        #15                 ; trap call
00002DCA                          3328          
00002DCA  4EB9 00002E36           3329              JSR         PrntImm             ; jump to PrntImm
00002DD0                          3330          
00002DD0  6000 E286               3331              BRA         LOOP                ; branch back to LOOP
00002DD4                          3332  
00002DD4                          3333  opROLR  
00002DD4  4242                    3334              CLR         D2                  ; clear D2
00002DD6  3401                    3335              MOVE.W      D1, D2              ; move word from D1 to D2
00002DD8  E042                    3336              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002DDA  C47C 0001               3337              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002DDE                          3338      
00002DDE  B43C 0000               3339              CMP.B       #zero, D2           ; compare 0 to D2 
00002DE2  6700 000E               3340              BEQ         opRORLR             ; if true, branch to RORLR for right
00002DE6  B43C 0001               3341              CMP.B       #one, D2            ; compare 1 to D2
00002DEA  6700 0028               3342              BEQ         opROLLR             ; if true, branch to ROLLR for left
00002DEE  6000 0E8A               3343              BRA         printInvalid        ; otherwise invalid     
00002DF2                          3344          
00002DF2                          3345  opRORLR 
00002DF2  43F9 00003F6A           3346              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002DF8  103C 000E               3347              MOVE.B      #14, D0             ; command for trap call to display message
00002DFC  4E4F                    3348              TRAP        #15                 ; trap call
00002DFE                          3349  
00002DFE  43F9 00003F7F           3350              LEA         dispLong, A1        ; display long
00002E04  103C 000E               3351              MOVE.B      #14, D0             ; command for trap call to display message
00002E08  4E4F                    3352              TRAP        #15                 ; trap call
00002E0A                          3353          
00002E0A  4EB9 00002E92           3354              JSR         PrntReg             ; jump to PrntReg
00002E10                          3355          
00002E10  6000 E246               3356              BRA         LOOP                ; branch back to LOOP
00002E14                          3357  
00002E14                          3358  opROLLR     
00002E14  43F9 00003F6E           3359              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002E1A  103C 000E               3360              MOVE.B      #14, D0             ; command for trap call to display message
00002E1E  4E4F                    3361              TRAP        #15                 ; trap call
00002E20                          3362      
00002E20  43F9 00003F7F           3363              LEA         dispLong, A1        ; display long
00002E26  103C 000E               3364              MOVE.B      #14, D0             ; command for trap call to display message
00002E2A  4E4F                    3365              TRAP        #15                 ; trap call
00002E2C                          3366          
00002E2C  4EB9 00002E92           3367              JSR         PrntReg             ; jump to PrntReg
00002E32                          3368          
00002E32  6000 E224               3369              BRA         LOOP                ; branch back to LOOP
00002E36                          3370          
00002E36                          3371  ***********************************************************************************************************
00002E36                          3372  *                       Immediate Data Subroutine Part 1
00002E36                          3373  *
00002E36                          3374  * The following subroutine displays the immediate number to shift and the data register that is being shifted. 
00002E36                          3375  * This subroutine calls two printing immediate subroutine first, the the ea print subroutine.        
00002E36                          3376  *
00002E36                          3377  ***********************************************************************************************************
00002E36                          3378  
00002E36                          3379  PrntImm 
00002E36  48E7 FF7E               3380              MOVEM.L     D0-D7/A1-A6, -(SP)  ; callee saved registers
00002E3A                          3381              
00002E3A  43F9 00003EDF           3382              LEA         space, A1           ; display space
00002E40  103C 000E               3383              MOVE.B      #14, D0             ; command for trap call to display message
00002E44  4E4F                    3384              TRAP        #15                 ; trap call
00002E46                          3385              
00002E46  43F9 00003EE2           3386              LEA         hashTag, A1         ; display #
00002E4C  103C 000E               3387              MOVE.B      #14, D0             ; command for trap call to display message
00002E50  4E4F                    3388              TRAP        #15                 ; trap call
00002E52                          3389              
00002E52  4242                    3390              CLR         D2                  ; clear D2
00002E54  3401                    3391              MOVE.W      D1, D2              ; move word from D1 to D2
00002E56  E042                    3392              ASR         #eight, D2          ; shift D2 by 8 bits
00002E58  E242                    3393              ASR         #one, D2            ; shift D2 by one bit
00002E5A  C47C 0007               3394              AND         #$07, D2            ; and D2 to get just first 3 bits
00002E5E                          3395          
00002E5E  4EB9 00002EE4           3396              JSR         MemShiftImm         ; jump to MemShiftImm
00002E64                          3397          
00002E64  43F9 00003EE6           3398              LEA         comma, A1           ; display comma
00002E6A  103C 000E               3399              MOVE.B      #14, D0             ; command for trap call to display message
00002E6E  4E4F                    3400              TRAP        #15                 ; trap call
00002E70                          3401          
00002E70  4242                    3402              CLR         D2                  ; clear D2 since destination mode must be data register
00002E72  4243                    3403              CLR         D3                  ; clear D3 to get register
00002E74  1601                    3404              MOVE.B      D1,D3               ; move byte from D1 to D3
00002E76  C67C 0007               3405              AND         #$07, D3            ; and D3 to get first 3 bits only
00002E7A                          3406          
00002E7A  4EB9 00002F0E           3407              JSR         printEA             ; jump to printEA
00002E80                          3408          
00002E80  43F9 00003EDB           3409              LEA         newLine, A1         ; create new line
00002E86  103C 000E               3410              MOVE.B      #14, D0             ; command for trap call to display message
00002E8A  4E4F                    3411              TRAP        #15                 ; trap call
00002E8C                          3412          
00002E8C  4CDF 7EFF               3413              MOVEM.L     (SP)+, D0-D7/A1-A6  ; pop saved registers from stack
00002E90  4E75                    3414              RTS                             ; return
00002E92                          3415              
00002E92                          3416  ***********************************************************************************************************
00002E92                          3417  *
00002E92                          3418  *                       Shifting Helping Function
00002E92                          3419  *
00002E92                          3420  * The following subroutine determines the correct data register to display, and sets the values of D2 and 
00002E92                          3421  *       D3 accordingly to display the data register.
00002E92                          3422  * after setting the values, it calls another subroutine to actually display the data register.        
00002E92                          3423  *
00002E92                          3424  ***********************************************************************************************************
00002E92                          3425  
00002E92                          3426  PrntReg     
00002E92  48E7 FF7E               3427              MOVEM.L     D0-D7/A1-A6, -(SP)  ; callee saved
00002E96                          3428          
00002E96  43F9 00003EDF           3429              LEA         space, A1           ; display space
00002E9C  103C 000E               3430              MOVE.B      #14, D0             ; command for trap call to display message
00002EA0  4E4F                    3431              TRAP        #15                 ; trap call
00002EA2                          3432          
00002EA2  4242                    3433              CLR         D2                  ; clear D2
00002EA4  4243                    3434              CLR         D3                  ; clear D3
00002EA6  3601                    3435              MOVE.W      D1, D3              ; move word from D1 to D3
00002EA8  E043                    3436              ASR         #eight, D3          ; shift D3 by 8 bits
00002EAA  E243                    3437              ASR         #one, D3            ; shift D3 by 1 bit
00002EAC  C67C 0007               3438              AND         #$07, D3            ; and D3 to get first 3 bits only
00002EB0                          3439          
00002EB0  4EB9 00002F0E           3440              JSR         printEA             ; jump to printEA
00002EB6                          3441          
00002EB6  43F9 00003EE6           3442              LEA         comma, A1           ; display comma
00002EBC  103C 000E               3443              MOVE.B      #14, D0             ; command for trap call to display message
00002EC0  4E4F                    3444              TRAP        #15                 ; trap call
00002EC2                          3445          
00002EC2  4242                    3446              CLR         D2                  ; clear D2
00002EC4  4243                    3447              CLR         D3                  ; clear D3
00002EC6  1601                    3448              MOVE.B      D1,D3               ; move byte from D1 to D3
00002EC8  C67C 0007               3449              AND         #$07, D3            ; and D3 to get first 3 bits only
00002ECC                          3450          
00002ECC  4EB9 00002F0E           3451              JSR         printEA             ; jump to printEA
00002ED2                          3452          
00002ED2  43F9 00003EDB           3453              LEA         newLine, A1         ; newline
00002ED8  103C 000E               3454              MOVE.B      #14, D0             ; command for trap call to display message
00002EDC  4E4F                    3455              TRAP        #15                 ; trap call
00002EDE                          3456          
00002EDE  4CDF 7EFF               3457              MOVEM.L     (SP)+, D0-D7/A1-A6  ; pop saved registers from stack
00002EE2  4E75                    3458              RTS                             ; return
00002EE4                          3459  
00002EE4                          3460  ***********************************************************************************************************
00002EE4                          3461  *
00002EE4                          3462  *                       Immediate Data Subroutine Part 2
00002EE4                          3463  *
00002EE4                          3464  * The following subroutine is used to display the number between 1-8 for the bit vount for the shift/rotate opcode
00002EE4                          3465  * It displays it by storing the appropriate number in D1 and running trap task 3.
00002EE4                          3466  *
00002EE4                          3467  ***********************************************************************************************************
00002EE4                          3468  
00002EE4                          3469  MemShiftImm     
00002EE4  48E7 FF7E               3470              MOVEM.L     D0-D7/A1-A6, -(SP)  ; callee saved data
00002EE8  4241                    3471              CLR         D1                  ; clear D1
00002EEA                          3472                 
00002EEA  1202                    3473              MOVE.B      D2, D1              ; move byte from D2 to D1
00002EEC  B23C 0000               3474              CMP.B       #zero, D1           ; compare 0 to D1
00002EF0  6700 000C               3475              BEQ         displayEight        ; if true, branch to displayEight
00002EF4                          3476                  
00002EF4  103C 0003               3477              MOVE.B      #3, D0              ; trap task command to display decimal
00002EF8  4E4F                    3478              TRAP        #15                 ; trap call
00002EFA  6000 000C               3479              BRA         endSubroutine       ; branch to endSubroutine
00002EFE                          3480                  
00002EFE                          3481  displayEight    
00002EFE  123C 0008               3482              MOVE.B      #$08, D1            ; move 8 to D1
00002F02  103C 0003               3483              MOVE.B      #3, D0              ; trap task command to display decimal
00002F06  4E4F                    3484              TRAP        #15                 ; trap call
00002F08                          3485              
00002F08                          3486  endSubroutine
00002F08  4CDF 7EFF               3487              MOVEM.L     (SP)+, D0-D7/A1-A6  ; pop saved registers from stack
00002F0C  4E75                    3488              RTS                             ; return
00002F0E                          3489          
00002F0E                          3490  ***********************************************************************************************************
00002F0E                          3491  *
00002F0E                          3492  *                       EA Print Subroutine
00002F0E                          3493  *
00002F0E                          3494  ***********************************************************************************************************
00002F0E                          3495  
00002F0E                          3496  printEA     
00002F0E  48E7 FF7E               3497              MOVEM.L  D0-D7/A1-A6, -(SP)     ; callee saved data
00002F12                          3498  
00002F12  B43C 0000               3499              CMP.B       #zero, D2           ; compare D2 or Mode to 0
00002F16  6700 002E               3500              BEQ         pDataReg            ; if true, branch to pDataReg
00002F1A  B43C 0001               3501              CMP.B       #one, D2            ; compare mode to 1
00002F1E  6700 00E6               3502              BEQ         pAddrReg            ; if true, branch to pAddrReg
00002F22  B43C 0002               3503              CMP.B       #two, D2            ; compare mode to 2
00002F26  6700 019E               3504              BEQ         pAddrDir            ; if true, branch to pAddrDir
00002F2A  B43C 0003               3505              CMP.B       #three, D2          ; compare mode to 3
00002F2E  6700 02C2               3506              BEQ         pAddrPost           ; if true, branch to pAddrPost
00002F32  B43C 0004               3507              CMP.B       #four, D2           ; compare mode to 4
00002F36  6700 0446               3508              BEQ         pAddrDec            ; if true, branch to pAddrDec
00002F3A  B43C 0007               3509              CMP.B       #seven, D2          ; compare mode to 7
00002F3E  6700 0576               3510              BEQ         pHex                ; if true, branch to pHex
00002F42  6000 0642               3511              BRA         invalid             ; otherwise invalid
00002F46                          3512  
00002F46                          3513  ***********************************************************************************************************
00002F46                          3514  * Data Register        
00002F46                          3515  pDataReg    
00002F46  B63C 0000               3516              CMP.B       #zero,D3            ; compare D3 or Register to 0
00002F4A  6700 003A               3517              BEQ         displayD0           ; if true, branch to displayD0
00002F4E  B63C 0001               3518              CMP.B       #one,D3             ; compare D3 or Register to 1
00002F52  6700 0042               3519              BEQ         displayD1           ; if true, branch to displayD1
00002F56  B63C 0002               3520              CMP.B       #two,D3             ; compare D3 or Register to 2
00002F5A  6700 004A               3521              BEQ         displayD2           ; if true, branch to displayD2
00002F5E  B63C 0003               3522              CMP.B       #three,D3           ; compare D3 or Register to 3
00002F62  6700 0052               3523              BEQ         displayD3           ; if true, branch to displayD3
00002F66  B63C 0004               3524              CMP.B       #four,D3            ; compare D3 or Register to 4
00002F6A  6700 005A               3525              BEQ         displayD4           ; if true, branch to displayD4
00002F6E  B63C 0005               3526              CMP.B       #five,D3            ; compare D3 or Register to 5
00002F72  6700 0062               3527              BEQ         displayD5           ; if true, branch to displayD5
00002F76  B63C 0006               3528              CMP.B       #six,D3             ; compare D3 or Register to 6
00002F7A  6700 006A               3529              BEQ         displayD6           ; if true, branch to displayD6
00002F7E  B63C 0007               3530              CMP.B       #seven,D3           ; compare D3 or Register to 7
00002F82  6700 0072               3531              BEQ         displayD7           ; if true, branch to displayD7
00002F86                          3532              
00002F86  43F9 00003F9C           3533  displayD0   LEA         dispD0, A1          ; Display D0
00002F8C  103C 000E               3534              MOVE.B      #14, D0             ; command for trap call to display message
00002F90  4E4F                    3535              TRAP        #15                 ; trap call
00002F92  6000 05F2               3536              BRA         endSUB              ; go to the end of the subroutine
00002F96                          3537              
00002F96  43F9 00003F9F           3538  displayD1   LEA         dispD1, A1          ; Display D1
00002F9C  103C 000E               3539              MOVE.B      #14, D0             ; command for trap call to display message
00002FA0  4E4F                    3540              TRAP        #15                 ; trap call
00002FA2  6000 05E2               3541              BRA         endSUB              ; go to the end of the subroutine
00002FA6                          3542  
00002FA6  43F9 00003FA2           3543  displayD2   LEA         dispD2, A1          ; Display D2
00002FAC  103C 000E               3544              MOVE.B      #14, D0             ; command for trap call to display message
00002FB0  4E4F                    3545              TRAP        #15                 ; trap call
00002FB2  6000 05D2               3546              BRA         endSUB              ; go to the end of the subroutine
00002FB6                          3547  
00002FB6  43F9 00003FA5           3548  displayD3   LEA         dispD3, A1          ; Display D3
00002FBC  103C 000E               3549              MOVE.B      #14, D0             ; command for trap call to display message
00002FC0  4E4F                    3550              TRAP        #15                 ; trap call
00002FC2  6000 05C2               3551              BRA         endSUB              ; go to the end of the subroutine
00002FC6                          3552  
00002FC6  43F9 00003FA8           3553  displayD4   LEA         dispD4, A1          ; Display D4
00002FCC  103C 000E               3554              MOVE.B      #14, D0             ; command for trap call to display message
00002FD0  4E4F                    3555              TRAP        #15                 ; trap call
00002FD2  6000 05B2               3556              BRA         endSUB              ; go to the end of the subroutine
00002FD6                          3557  
00002FD6  43F9 00003FAB           3558  displayD5   LEA         dispD5, A1          ; Display D5
00002FDC  103C 000E               3559              MOVE.B      #14, D0             ; command for trap call to display message
00002FE0  4E4F                    3560              TRAP        #15                 ; trap call
00002FE2  6000 05A2               3561              BRA         endSUB              ; go to the end of the subroutine
00002FE6                          3562  
00002FE6  43F9 00003FAE           3563  displayD6   LEA         dispD6, A1          ; Display D6
00002FEC  103C 000E               3564              MOVE.B      #14, D0             ; command for trap call to display message
00002FF0  4E4F                    3565              TRAP        #15                 ; trap call
00002FF2  6000 0592               3566              BRA         endSUB              ; go to the end of the subroutine
00002FF6                          3567  
00002FF6  43F9 00003FB1           3568  displayD7   LEA         dispD7, A1          ; Display D7
00002FFC  103C 000E               3569              MOVE.B      #14, D0             ; command for trap call to display message
00003000  4E4F                    3570              TRAP        #15                 ; trap call
00003002  6000 0582               3571              BRA         endSUB              ; go to the end of the subroutine
00003006                          3572              
00003006                          3573  ***********************************************************************************************************
00003006                          3574  * Address Register
00003006                          3575  
00003006  B63C 0000               3576  pAddrReg    CMP.B       #zero,D3            ; compare D3 or Register to 0
0000300A  6700 003A               3577              BEQ         displayA0           ; if true, branch to displayA0
0000300E  B63C 0001               3578              CMP.B       #one,D3             ; compare D3 or Register to 1
00003012  6700 0042               3579              BEQ         displayA1           ; if true, branch to displayA1
00003016  B63C 0002               3580              CMP.B       #two,D3             ; compare D3 or Register to 2
0000301A  6700 004A               3581              BEQ         displayA2           ; if true, branch to displayA2
0000301E  B63C 0003               3582              CMP.B       #three,D3           ; compare D3 or Register to 3
00003022  6700 0052               3583              BEQ         displayA3           ; if true, branch to displayA3
00003026  B63C 0004               3584              CMP.B       #four,D3            ; compare D3 or Register to 4
0000302A  6700 005A               3585              BEQ         displayA4           ; if true, branch to displayA4
0000302E  B63C 0005               3586              CMP.B       #five,D3            ; compare D3 or Register to 5
00003032  6700 0062               3587              BEQ         displayA5           ; if true, branch to displayA5
00003036  B63C 0006               3588              CMP.B       #six,D3             ; compare D3 or Register to 6
0000303A  6700 006A               3589              BEQ         displayA6           ; if true, branch to displayA6
0000303E  B63C 0007               3590              CMP.B       #seven,D3           ; compare D3 or Register to 7
00003042  6700 0072               3591              BEQ         displayA7           ; if true, branch to displayA7
00003046                          3592              
00003046  43F9 00003F82           3593  displayA0   LEA         dispA0, A1          ; Display A0
0000304C  103C 000E               3594              MOVE.B      #14, D0             ; command for trap call to display message
00003050  4E4F                    3595              TRAP        #15                 ; trap call
00003052  6000 0532               3596              BRA         endSUB              ; go to the end of the subroutine
00003056                          3597              
00003056  43F9 00003F85           3598  displayA1   LEA         dispA1, A1          ; Display A1
0000305C  103C 000E               3599              MOVE.B      #14, D0             ; command for trap call to display message
00003060  4E4F                    3600              TRAP        #15                 ; trap call
00003062  6000 0522               3601              BRA         endSUB              ; go to the end of the subroutine
00003066                          3602  
00003066  43F9 00003F88           3603  displayA2   LEA         dispA2, A1          ; Display A2
0000306C  103C 000E               3604              MOVE.B      #14, D0             ; command for trap call to display message
00003070  4E4F                    3605              TRAP        #15                 ; trap call
00003072  6000 0512               3606              BRA         endSUB              ; go to the end of the subroutine
00003076                          3607  
00003076  43F9 00003F8B           3608  displayA3   LEA         dispA3, A1          ; Display A3
0000307C  103C 000E               3609              MOVE.B      #14, D0             ; command for trap call to display message
00003080  4E4F                    3610              TRAP        #15                 ; trap call
00003082  6000 0502               3611              BRA         endSUB              ; go to the end of the subroutine
00003086                          3612  
00003086  43F9 00003F8E           3613  displayA4   LEA         dispA4, A1          ; Display A4
0000308C  103C 000E               3614              MOVE.B      #14, D0             ; command for trap call to display message
00003090  4E4F                    3615              TRAP        #15                 ; trap call
00003092  6000 04F2               3616              BRA         endSUB              ; go to the end of the subroutine
00003096                          3617  
00003096  43F9 00003F91           3618  displayA5   LEA         dispA5, A1          ; Display A5
0000309C  103C 000E               3619              MOVE.B      #14, D0             ; command for trap call to display message
000030A0  4E4F                    3620              TRAP        #15                 ; trap call
000030A2  6000 04E2               3621              BRA         endSUB              ; go to the end of the subroutine
000030A6                          3622  
000030A6  43F9 00003F94           3623  displayA6   LEA         dispA6, A1          ; Display A6
000030AC  103C 000E               3624              MOVE.B      #14, D0             ; command for trap call to display message
000030B0  4E4F                    3625              TRAP        #15                 ; trap call
000030B2  6000 04D2               3626              BRA         endSUB              ; go to the end of the subroutine
000030B6                          3627  
000030B6  43F9 00003F97           3628  displayA7   LEA         dispA7, A1          ; Display A7
000030BC  103C 000E               3629              MOVE.B      #14, D0             ; command for trap call to display message
000030C0  4E4F                    3630              TRAP        #15                 ; trap call
000030C2  6000 04C2               3631              BRA         endSUB              ; go to the end of the subroutine
000030C6                          3632  
000030C6                          3633  ***********************************************************************************************************
000030C6                          3634  * Address Register Direct
000030C6                          3635  
000030C6  43F9 00003EE8           3636  pAddrDir    LEA         opPer, A1           ; Display open parenthesis
000030CC  103C 000E               3637              MOVE.B      #14, D0             ; command for trap call to display message
000030D0  4E4F                    3638              TRAP        #15                 ; trap call
000030D2                          3639              
000030D2  B63C 0000               3640              CMP.B       #zero,D3            ; compare D3 or Register to 0
000030D6  6700 003A               3641              BEQ         displayA0A          ; if true, branch to displayA0A
000030DA  B63C 0001               3642              CMP.B       #one,D3             ; compare D3 or Register to 1
000030DE  6700 004E               3643              BEQ         displayA1A          ; if true, branch to displayA1A
000030E2  B63C 0002               3644              CMP.B       #two,D3             ; compare D3 or Register to 2
000030E6  6700 0062               3645              BEQ         displayA2A          ; if true, branch to displayA2A
000030EA  B63C 0003               3646              CMP.B       #three,D3           ; compare D3 or Register to 3
000030EE  6700 0076               3647              BEQ         displayA3A          ; if true, branch to displayA3A
000030F2  B63C 0004               3648              CMP.B       #four,D3            ; compare D3 or Register to 4
000030F6  6700 008A               3649              BEQ         displayA4A          ; if true, branch to displayA4A
000030FA  B63C 0005               3650              CMP.B       #five,D3            ; compare D3 or Register to 5
000030FE  6700 009E               3651              BEQ         displayA5A          ; if true, branch to displayA5A
00003102  B63C 0006               3652              CMP.B       #six,D3             ; compare D3 or Register to 6
00003106  6700 00B2               3653              BEQ         displayA6A          ; if true, branch to displayA6A
0000310A  B63C 0007               3654              CMP.B       #seven,D3           ; compare D3 or Register to 7
0000310E  6700 00C6               3655              BEQ         displayA7A          ; if true, branch to displayA7A
00003112                          3656              
00003112  43F9 00003F82           3657  displayA0A  LEA         dispA0, A1          ; Display A0
00003118  103C 000E               3658              MOVE.B      #14, D0             ; command for trap call to display message
0000311C  4E4F                    3659              TRAP        #15                 ; trap call
0000311E  43F9 00003EEA           3660              LEA         clPer, A1           ; Display closing parenthesis
00003124  103C 000E               3661              MOVE.B      #14, D0             ; command for trap call to display message
00003128  4E4F                    3662              TRAP        #15                 ; trap call
0000312A  6000 045A               3663              BRA         endSUB              ; go to the end of the subroutine
0000312E                          3664              
0000312E  43F9 00003F85           3665  displayA1A  LEA         dispA1, A1          ; Display A1
00003134  103C 000E               3666              MOVE.B      #14, D0             ; command for trap call to display message
00003138  4E4F                    3667              TRAP        #15                 ; trap call
0000313A  43F9 00003EEA           3668              LEA         clPer, A1           ; Display closing parenthesis
00003140  103C 000E               3669              MOVE.B      #14, D0             ; command for trap call to display message
00003144  4E4F                    3670              TRAP        #15                 ; trap call
00003146  6000 043E               3671              BRA         endSUB              ; go to the end of the subroutine
0000314A                          3672  
0000314A  43F9 00003F88           3673  displayA2A  LEA         dispA2, A1          ; Display A2
00003150  103C 000E               3674              MOVE.B      #14, D0             ; command for trap call to display message
00003154  4E4F                    3675              TRAP        #15                 ; trap call
00003156  43F9 00003EEA           3676              LEA         clPer, A1           ; Display closing parenthesis
0000315C  103C 000E               3677              MOVE.B      #14, D0             ; command for trap call to display message
00003160  4E4F                    3678              TRAP        #15                 ; trap call
00003162  6000 0422               3679              BRA         endSUB              ; go to the end of the subroutine
00003166                          3680  
00003166  43F9 00003F8B           3681  displayA3A  LEA         dispA3, A1          ; Display A3
0000316C  103C 000E               3682              MOVE.B      #14, D0             ; command for trap call to display message
00003170  4E4F                    3683              TRAP        #15                 ; trap call
00003172  43F9 00003EEA           3684              LEA         clPer, A1           ; Display closing parenthesis
00003178  103C 000E               3685              MOVE.B      #14, D0             ; command for trap call to display message
0000317C  4E4F                    3686              TRAP        #15                 ; trap call
0000317E  6000 0406               3687              BRA         endSUB              ; go to the end of the subroutine
00003182                          3688  
00003182  43F9 00003F8E           3689  displayA4A  LEA         dispA4, A1          ; Display A4
00003188  103C 000E               3690              MOVE.B      #14, D0             ; command for trap call to display message
0000318C  4E4F                    3691              TRAP        #15                 ; trap call
0000318E  43F9 00003EEA           3692              LEA         clPer, A1           ; Display closing parenthesis
00003194  103C 000E               3693              MOVE.B      #14, D0             ; command for trap call to display message
00003198  4E4F                    3694              TRAP        #15                 ; trap call
0000319A  6000 03EA               3695              BRA         endSUB              ; go to the end of the subroutine
0000319E                          3696  
0000319E  43F9 00003F91           3697  displayA5A  LEA         dispA5, A1          ; Display A5
000031A4  103C 000E               3698              MOVE.B      #14, D0             ; command for trap call to display message
000031A8  4E4F                    3699              TRAP        #15                 ; trap call
000031AA  43F9 00003EEA           3700              LEA         clPer, A1           ; Display closing parenthesis
000031B0  103C 000E               3701              MOVE.B      #14, D0             ; command for trap call to display message
000031B4  4E4F                    3702              TRAP        #15                 ; trap call
000031B6  6000 03CE               3703              BRA         endSUB              ; go to the end of the subroutine
000031BA                          3704  
000031BA  43F9 00003F94           3705  displayA6A  LEA         dispA6, A1          ; Display A6
000031C0  103C 000E               3706              MOVE.B      #14, D0             ; command for trap call to display message
000031C4  4E4F                    3707              TRAP        #15                 ; trap call
000031C6  43F9 00003EEA           3708              LEA         clPer, A1           ; Display closing parenthesis
000031CC  103C 000E               3709              MOVE.B      #14, D0             ; command for trap call to display message
000031D0  4E4F                    3710              TRAP        #15                 ; trap call
000031D2  6000 03B2               3711              BRA         endSUB              ; go to the end of the subroutine
000031D6                          3712  
000031D6  43F9 00003F97           3713  displayA7A  LEA         dispA7, A1          ; Display A7
000031DC  103C 000E               3714              MOVE.B      #14, D0             ; command for trap call to display message
000031E0  4E4F                    3715              TRAP        #15                 ; trap call
000031E2  43F9 00003EEA           3716              LEA         clPer, A1           ; Display closing parenthesis
000031E8  103C 000E               3717              MOVE.B      #14, D0             ; command for trap call to display message
000031EC  4E4F                    3718              TRAP        #15                 ; trap call
000031EE  6000 0396               3719              BRA         endSUB              ; go to the end of the subroutine
000031F2                          3720              
000031F2                          3721  ***********************************************************************************************************
000031F2                          3722  * Addr Post-increment
000031F2                          3723              
000031F2  43F9 00003EE8           3724  pAddrPost   LEA         opPer, A1           ; Display open parenthesis
000031F8  103C 000E               3725              MOVE.B      #14, D0             ; command for trap call to display message
000031FC  4E4F                    3726              TRAP        #15                 ; trap call
000031FE                          3727              
000031FE  B63C 0000               3728              CMP.B       #zero,D3            ; compare D3 or Register to 0
00003202  6700 003A               3729              BEQ         displayA0P          ; if true, branch to displayA0P
00003206  B63C 0001               3730              CMP.B       #one,D3             ; compare D3 or Register to 1
0000320A  6700 005A               3731              BEQ         displayA1P          ; if true, branch to displayA1P
0000320E  B63C 0002               3732              CMP.B       #two,D3             ; compare D3 or Register to 2
00003212  6700 007A               3733              BEQ         displayA2P          ; if true, branch to displayA2P
00003216  B63C 0003               3734              CMP.B       #three,D3           ; compare D3 or Register to 3
0000321A  6700 009A               3735              BEQ         displayA3P          ; if true, branch to displayA3P
0000321E  B63C 0004               3736              CMP.B       #four,D3            ; compare D3 or Register to 4
00003222  6700 00BA               3737              BEQ         displayA4P          ; if true, branch to displayA4P
00003226  B63C 0005               3738              CMP.B       #five,D3            ; compare D3 or Register to 5
0000322A  6700 00DA               3739              BEQ         displayA5P          ; if true, branch to displayA5P
0000322E  B63C 0006               3740              CMP.B       #six,D3             ; compare D3 or Register to 6
00003232  6700 00FA               3741              BEQ         displayA6P          ; if true, branch to displayA6P
00003236  B63C 0007               3742              CMP.B       #seven,D3           ; compare D3 or Register to 7
0000323A  6700 011A               3743              BEQ         displayA7P          ; if true, branch to displayA7P
0000323E                          3744              
0000323E  43F9 00003F82           3745  displayA0P  LEA         dispA0, A1          ; Display A0
00003244  103C 000E               3746              MOVE.B      #14, D0             ; command for trap call to display message
00003248  4E4F                    3747              TRAP        #15                 ; trap call
0000324A  43F9 00003EEA           3748              LEA         clPer, A1           ; Display closing parenthesis
00003250  103C 000E               3749              MOVE.B      #14, D0             ; command for trap call to display message
00003254  4E4F                    3750              TRAP        #15                 ; trap call
00003256  43F9 00003EEE           3751              LEA         inc, A1             ; Display +
0000325C  103C 000E               3752              MOVE.B      #14, D0             ; command for trap call to display message
00003260  4E4F                    3753              TRAP        #15                 ; trap call
00003262  6000 0322               3754              BRA         endSUB              ; go to the end of the subroutine
00003266                          3755              
00003266  43F9 00003F85           3756  displayA1P  LEA         dispA1, A1          ; Display A1
0000326C  103C 000E               3757              MOVE.B      #14, D0             ; command for trap call to display message
00003270  4E4F                    3758              TRAP        #15                 ; trap call
00003272  43F9 00003EEA           3759              LEA         clPer, A1           ; Display closing parenthesis
00003278  103C 000E               3760              MOVE.B      #14, D0             ; command for trap call to display message
0000327C  4E4F                    3761              TRAP        #15                 ; trap call
0000327E  43F9 00003EEE           3762              LEA         inc, A1             ; Display +
00003284  103C 000E               3763              MOVE.B      #14, D0             ; command for trap call to display message
00003288  4E4F                    3764              TRAP        #15                 ; trap call
0000328A  6000 02FA               3765              BRA         endSUB              ; go to the end of the subroutine
0000328E                          3766  
0000328E  43F9 00003F88           3767  displayA2P  LEA         dispA2, A1          ; Display A2
00003294  103C 000E               3768              MOVE.B      #14, D0             ; command for trap call to display message
00003298  4E4F                    3769              TRAP        #15                 ; trap call
0000329A  43F9 00003EEA           3770              LEA         clPer, A1           ; Display closing parenthesis
000032A0  103C 000E               3771              MOVE.B      #14, D0             ; command for trap call to display message
000032A4  4E4F                    3772              TRAP        #15                 ; trap call
000032A6  43F9 00003EEE           3773              LEA         inc, A1             ; Display +
000032AC  103C 000E               3774              MOVE.B      #14, D0             ; command for trap call to display message
000032B0  4E4F                    3775              TRAP        #15                 ; trap call
000032B2  6000 02D2               3776              BRA         endSUB              ; go to the end of the subroutine
000032B6                          3777  
000032B6  43F9 00003F8B           3778  displayA3P  LEA         dispA3, A1          ; Display A3
000032BC  103C 000E               3779              MOVE.B      #14, D0             ; command for trap call to display message
000032C0  4E4F                    3780              TRAP        #15                 ; trap call
000032C2  43F9 00003EEA           3781              LEA         clPer, A1           ; Display closing parenthesis
000032C8  103C 000E               3782              MOVE.B      #14, D0             ; command for trap call to display message
000032CC  4E4F                    3783              TRAP        #15                 ; trap call
000032CE  43F9 00003EEE           3784              LEA         inc, A1             ; Display +
000032D4  103C 000E               3785              MOVE.B      #14, D0             ; command for trap call to display message
000032D8  4E4F                    3786              TRAP        #15                 ; trap call
000032DA  6000 02AA               3787              BRA         endSUB              ; go to the end of the subroutine
000032DE                          3788  
000032DE  43F9 00003F8E           3789  displayA4P  LEA         dispA4, A1          ; Display A4
000032E4  103C 000E               3790              MOVE.B      #14, D0             ; command for trap call to display message
000032E8  4E4F                    3791              TRAP        #15                 ; trap call
000032EA  43F9 00003EEA           3792              LEA         clPer, A1           ; Display closing parenthesis
000032F0  103C 000E               3793              MOVE.B      #14, D0             ; command for trap call to display message
000032F4  4E4F                    3794              TRAP        #15                 ; trap call
000032F6  43F9 00003EEE           3795              LEA         inc, A1             ; Display +
000032FC  103C 000E               3796              MOVE.B      #14, D0             ; command for trap call to display message
00003300  4E4F                    3797              TRAP        #15                 ; trap call
00003302  6000 0282               3798              BRA         endSUB              ; go to the end of the subroutine
00003306                          3799  
00003306  43F9 00003F91           3800  displayA5P  LEA         dispA5, A1          ; Display A5
0000330C  103C 000E               3801              MOVE.B      #14, D0             ; command for trap call to display message
00003310  4E4F                    3802              TRAP        #15                 ; trap call
00003312  43F9 00003EEA           3803              LEA         clPer, A1           ; Display closing parenthesis
00003318  103C 000E               3804              MOVE.B      #14, D0             ; command for trap call to display message
0000331C  4E4F                    3805              TRAP        #15                 ; trap call
0000331E  43F9 00003EEE           3806              LEA         inc, A1             ; Display +
00003324  103C 000E               3807              MOVE.B      #14, D0             ; command for trap call to display message
00003328  4E4F                    3808              TRAP        #15                 ; trap call
0000332A  6000 025A               3809              BRA         endSUB              ; go to the end of the subroutine
0000332E                          3810  
0000332E  43F9 00003F94           3811  displayA6P  LEA         dispA6, A1          ; Display A6
00003334  103C 000E               3812              MOVE.B      #14, D0             ; command for trap call to display message
00003338  4E4F                    3813              TRAP        #15                 ; trap call
0000333A  43F9 00003EEA           3814              LEA         clPer, A1           ; Display closing parenthesis
00003340  103C 000E               3815              MOVE.B      #14, D0             ; command for trap call to display message
00003344  4E4F                    3816              TRAP        #15                 ; trap call
00003346  43F9 00003EEE           3817              LEA         inc, A1             ; Display +
0000334C  103C 000E               3818              MOVE.B      #14, D0             ; command for trap call to display message
00003350  4E4F                    3819              TRAP        #15                 ; trap call
00003352  6000 0232               3820              BRA         endSUB              ; go to the end of the subroutine
00003356                          3821  
00003356  43F9 00003F97           3822  displayA7P  LEA         dispA7, A1          ; Display A7
0000335C  103C 000E               3823              MOVE.B      #14, D0             ; command for trap call to display message
00003360  4E4F                    3824              TRAP        #15                 ; trap call
00003362  43F9 00003EEA           3825              LEA         clPer, A1           ; Display closing parenthesis
00003368  103C 000E               3826              MOVE.B      #14, D0             ; command for trap call to display message
0000336C  4E4F                    3827              TRAP        #15                 ; trap call
0000336E  43F9 00003EEE           3828              LEA         inc, A1             ; Display +
00003374  103C 000E               3829              MOVE.B      #14, D0             ; command for trap call to display message
00003378  4E4F                    3830              TRAP        #15                 ; trap call
0000337A  6000 020A               3831              BRA         endSUB              ; go to the end of the subroutine
0000337E                          3832  
0000337E                          3833  ***********************************************************************************************************
0000337E                          3834  * Addr Post-decrement
0000337E                          3835  
0000337E                          3836  pAddrDec    
0000337E  43F9 00003EEC           3837              LEA         dec, A1             ; Display -
00003384  103C 000E               3838              MOVE.B      #14, D0             ; command for trap call to display message
00003388  4E4F                    3839              TRAP        #15                 ; trap call
0000338A                          3840              
0000338A  43F9 00003EE8           3841              LEA         opPer, A1           ; Display open parenthesis
00003390  103C 000E               3842              MOVE.B      #14, D0             ; command for trap call to display message
00003394  4E4F                    3843              TRAP        #15                 ; trap call
00003396                          3844              
00003396  B63C 0000               3845              CMP.B       #zero,D3            ; compare D3 or Register to 0
0000339A  6700 003A               3846              BEQ         displayA0D          ; if true, branch to displayA0D
0000339E  B63C 0001               3847              CMP.B       #one,D3             ; compare D3 or Register to 1
000033A2  6700 004E               3848              BEQ         displayA1D          ; if true, branch to displayA1D
000033A6  B63C 0002               3849              CMP.B       #two,D3             ; compare D3 or Register to 2
000033AA  6700 0062               3850              BEQ         displayA2D          ; if true, branch to displayA2D
000033AE  B63C 0003               3851              CMP.B       #three,D3           ; compare D3 or Register to 3
000033B2  6700 0076               3852              BEQ         displayA3D          ; if true, branch to displayA3D
000033B6  B63C 0004               3853              CMP.B       #four,D3            ; compare D3 or Register to 4
000033BA  6700 008A               3854              BEQ         displayA4D          ; if true, branch to displayA4D
000033BE  B63C 0005               3855              CMP.B       #five,D3            ; compare D3 or Register to 5
000033C2  6700 009E               3856              BEQ         displayA5D          ; if true, branch to displayA5D
000033C6  B63C 0006               3857              CMP.B       #six,D3             ; compare D3 or Register to 6
000033CA  6700 00B2               3858              BEQ         displayA6D          ; if true, branch to displayA6D
000033CE  B63C 0007               3859              CMP.B       #seven,D3           ; compare D3 or Register to 7
000033D2  6700 00C6               3860              BEQ         displayA7D          ; if true, branch to displayA7D
000033D6                          3861              
000033D6                          3862  displayA0D  
000033D6  43F9 00003F82           3863              LEA         dispA0, A1          ; Display A0
000033DC  103C 000E               3864              MOVE.B      #14, D0             ; command for trap call to display message
000033E0  4E4F                    3865              TRAP        #15                 ; trap call
000033E2  43F9 00003EEA           3866              LEA         clPer, A1           ; Display closing parenthesis
000033E8  103C 000E               3867              MOVE.B      #14, D0             ; command for trap call to display message
000033EC  4E4F                    3868              TRAP        #15                 ; trap call
000033EE  6000 0196               3869              BRA         endSUB              ; go to the end of the subroutine
000033F2                          3870              
000033F2                          3871  displayA1D  
000033F2  43F9 00003F85           3872              LEA         dispA1, A1          ; Display A1
000033F8  103C 000E               3873              MOVE.B      #14, D0             ; command for trap call to display message
000033FC  4E4F                    3874              TRAP        #15                 ; trap call
000033FE  43F9 00003EEA           3875              LEA         clPer, A1           ; Display closing parenthesis
00003404  103C 000E               3876              MOVE.B      #14, D0             ; command for trap call to display message
00003408  4E4F                    3877              TRAP        #15                 ; trap call
0000340A  6000 017A               3878              BRA         endSUB              ; go to the end of the subroutine
0000340E                          3879  
0000340E                          3880  displayA2D  
0000340E  43F9 00003F88           3881              LEA         dispA2, A1          ; Display A2
00003414  103C 000E               3882              MOVE.B      #14, D0             ; command for trap call to display message
00003418  4E4F                    3883              TRAP        #15                 ; trap call
0000341A  43F9 00003EEA           3884              LEA         clPer, A1           ; Display closing parenthesis
00003420  103C 000E               3885              MOVE.B      #14, D0             ; command for trap call to display message
00003424  4E4F                    3886              TRAP        #15                 ; trap call
00003426  6000 015E               3887              BRA         endSUB              ; go to the end of the subroutine
0000342A                          3888  
0000342A                          3889  displayA3D  
0000342A  43F9 00003F8B           3890              LEA         dispA3, A1          ; Display A3
00003430  103C 000E               3891              MOVE.B      #14, D0             ; command for trap call to display message
00003434  4E4F                    3892              TRAP        #15                 ; trap call
00003436  43F9 00003EEA           3893              LEA         clPer, A1           ; Display closing parenthesis
0000343C  103C 000E               3894              MOVE.B      #14, D0             ; command for trap call to display message
00003440  4E4F                    3895              TRAP        #15                 ; trap call
00003442  6000 0142               3896              BRA         endSUB              ; go to the end of the subroutine
00003446                          3897  
00003446                          3898  displayA4D  
00003446  43F9 00003F8E           3899              LEA         dispA4, A1          ; Display A4
0000344C  103C 000E               3900              MOVE.B      #14, D0             ; command for trap call to display message
00003450  4E4F                    3901              TRAP        #15                 ; trap call
00003452  43F9 00003EEA           3902              LEA         clPer, A1           ; Display closing parenthesis
00003458  103C 000E               3903              MOVE.B      #14, D0             ; command for trap call to display message
0000345C  4E4F                    3904              TRAP        #15                 ; trap call
0000345E  6000 0126               3905              BRA         endSUB              ; go to the end of the subroutine
00003462                          3906  
00003462                          3907  displayA5D  
00003462  43F9 00003F91           3908              LEA         dispA5, A1          ; Display A5
00003468  103C 000E               3909              MOVE.B      #14, D0             ; command for trap call to display message
0000346C  4E4F                    3910              TRAP        #15                 ; trap call
0000346E  43F9 00003EEA           3911              LEA         clPer, A1           ; Display closing parenthesis
00003474  103C 000E               3912              MOVE.B      #14, D0             ; command for trap call to display message
00003478  4E4F                    3913              TRAP        #15                 ; trap call
0000347A  6000 010A               3914              BRA         endSUB              ; go to the end of the subroutine
0000347E                          3915  
0000347E                          3916  displayA6D  
0000347E  43F9 00003F94           3917              LEA         dispA6, A1          ; Display A6
00003484  103C 000E               3918              MOVE.B      #14, D0             ; command for trap call to display message
00003488  4E4F                    3919              TRAP        #15                 ; trap call
0000348A  43F9 00003EEA           3920              LEA         clPer, A1           ; Display closing parenthesis
00003490  103C 000E               3921              MOVE.B      #14, D0             ; command for trap call to display message
00003494  4E4F                    3922              TRAP        #15                 ; trap call
00003496  6000 00EE               3923              BRA         endSUB              ; go to the end of the subroutine
0000349A                          3924  
0000349A                          3925  displayA7D  
0000349A  43F9 00003F97           3926              LEA         dispA7, A1          ; Display A7
000034A0  103C 000E               3927              MOVE.B      #14, D0             ; command for trap call to display message
000034A4  4E4F                    3928              TRAP        #15                 ; trap call
000034A6  43F9 00003EEA           3929              LEA         clPer, A1           ; Display closing parenthesis
000034AC  103C 000E               3930              MOVE.B      #14, D0             ; command for trap call to display message
000034B0  4E4F                    3931              TRAP        #15                 ; trap call
000034B2  6000 00D2               3932              BRA         endSUB              ; go to the end of the subroutine
000034B6                          3933  
000034B6                          3934  ***********************************************************************************************************
000034B6                          3935  * Display Hex
000034B6                          3936  
000034B6                          3937  pHex        
000034B6  B63C 0000               3938              CMP.B       #zero, D3           ; compare D3 or Register to 0
000034BA  6700 0012               3939              BEQ         AbsShort            ; if true, branch to AbsShort
000034BE  B63C 0001               3940              CMP.B       #one, D3            ; compare D3 or Register to 1
000034C2  6700 0042               3941              BEQ         AbsLong             ; if true, branch to AbsLong
000034C6  B63C 0004               3942              CMP.B       #four, D3           ; compare D3 or Register to 4
000034CA  6700 0072               3943              BEQ         DispImm             ; if true, branch to DispImm
000034CE                          3944              
000034CE                          3945  AbsShort    
000034CE  43F9 00003EE8           3946              LEA         opPer, A1           ; Display open parenthesis
000034D4  103C 000E               3947              MOVE.B      #14, D0             ; command for trap call to display message
000034D8  4E4F                    3948              TRAP        #15                 ; trap call
000034DA                          3949              
000034DA  43F9 00003EE4           3950              LEA         dispHex, A1         ; Display $
000034E0  103C 000E               3951              MOVE.B      #14, D0             ; command for trap call to display message
000034E4  4E4F                    3952              TRAP        #15                 ; trap call
000034E6                          3953              
000034E6  4241                    3954              CLR         D1                  ; clear D1
000034E8  3218                    3955              MOVE.W      (A0)+, D1           ; move next word in memory to D1
000034EA  4240                    3956              CLR         D0                  ; clear D0
000034EC  103C 0004               3957              MOVE.B      #4, D0              ; move the number of hexes to decode
000034F0                          3958              
000034F0  4EB9 00003AAE           3959              JSR         outHex              ; jump to outHex
000034F6                          3960              
000034F6  43F9 00003EEA           3961              LEA         clPer, A1           ; Display closing parenthesis
000034FC  103C 000E               3962              MOVE.B      #14, D0             ; command for trap call to display message
00003500  4E4F                    3963              TRAP        #15                 ; trap call
00003502                          3964              
00003502  6000 0082               3965              BRA         endSub              ; go to the end of the subroutine
00003506                          3966              
00003506                          3967  AbsLong     
00003506  43F9 00003EE8           3968              LEA         opPer, A1           ; Display open parenthesis
0000350C  103C 000E               3969              MOVE.B      #14, D0             ; command for trap call to display message
00003510  4E4F                    3970              TRAP        #15                 ; trap call
00003512                          3971              
00003512  43F9 00003EE4           3972              LEA         dispHex, A1         ; Display $
00003518  103C 000E               3973              MOVE.B      #14, D0             ; command for trap call to display message
0000351C  4E4F                    3974              TRAP        #15                 ; trap call
0000351E                          3975              
0000351E  4241                    3976              CLR         D1                  ; clear D1
00003520  2218                    3977              MOVE.L      (A0)+, D1           ; move next long-word in memory to D1
00003522  4240                    3978              CLR         D0                  ; clear D0
00003524  103C 0008               3979              MOVE.B      #8, D0              ; move the number of hexes to decode
00003528                          3980              
00003528  4EB9 00003AAE           3981              JSR         outHex              ; jump to outHex
0000352E                          3982              
0000352E  43F9 00003EEA           3983              LEA         clPer, A1           ; Display closing parenthesis
00003534  103C 000E               3984              MOVE.B      #14, D0             ; command for trap call to display message
00003538  4E4F                    3985              TRAP        #15                 ; trap call
0000353A                          3986              
0000353A  6000 004A               3987              BRA         endSub              ; go to the end of the subroutine
0000353E                          3988  
0000353E                          3989  DispImm     
0000353E  43F9 00003EE2           3990              LEA         hashTag, A1         ; Display #
00003544  103C 000E               3991              MOVE.B      #14, D0             ; command for trap call to display message
00003548  4E4F                    3992              TRAP        #15                 ; trap call
0000354A                          3993  
0000354A  43F9 00003EE4           3994              LEA         dispHex, A1         ; Display $
00003550  103C 000E               3995              MOVE.B      #14, D0             ; command for trap call to display message
00003554  4E4F                    3996              TRAP        #15                 ; trap call
00003556                          3997              
00003556  BC3C 0001               3998              CMP.B       #1,D6               ; compare 1 to D6 for this determines if long immediate needs printing
0000355A  6700 0016               3999              BEQ         ImmLong             ; if true, branch to ImmLong
0000355E                          4000              
0000355E  4241                    4001              CLR         D1                  ; clear D1
00003560  3218                    4002              MOVE.W      (A0)+, D1           ; move next word to D1
00003562  4240                    4003              CLR         D0                  ; clear D0
00003564  103C 0004               4004              MOVE.B      #4, D0              ; move the number of hexes to decode
00003568  4EB9 00003AAE           4005              JSR         outHex              ; jump to outHex
0000356E  6000 0012               4006              BRA         LongSkip            ; branch over printing a long-word
00003572                          4007              
00003572                          4008  ImmLong     
00003572  4241                    4009              CLR         D1                  ; clear D1
00003574  2218                    4010              MOVE.L      (A0)+, D1           ; move next long-word to D1
00003576  4240                    4011              CLR         D0                  ; clear D0
00003578  103C 0008               4012              MOVE.B      #8, D0              ; move the number of hexes to decode
0000357C  4EB9 00003AAE           4013              JSR         outHex              ; jump to outHex 
00003582                          4014  
00003582                          4015  LongSkip
00003582  6000 0002               4016              BRA         endSub              ; go to end of the subroutine
00003586                          4017  
00003586                          4018  invalid     
00003586                          4019  
00003586                          4020  endSUB        
00003586  4CDF 7EFF               4021              MOVEM.L     (SP)+, D0-D7/A1-A6  ; pop registers off the stack
0000358A  4E75                    4022              RTS                             ; return
0000358C                          4023  
0000358C                          4024  ***********************************************************************************************************
0000358C                          4025  *
0000358C                          4026  *                       MOVEM Helper Function
0000358C                          4027  *       This function is dedicated to printing out the address and data register for MOVEM. The 
0000358C                          4028  *       function starts by identifying the size and then identifying the dr field. If the dr field
0000358C                          4029  *       is 1, then the program goes to print before print out the address and data register for MOVEM. If dr
0000358C                          4030  *       field is zero, program goes to print out the address and data register before printing out the
0000358C                          4031  *       post increment or immediate data.
0000358C                          4032  *
0000358C                          4033  ***********************************************************************************************************
0000358C                          4034  
0000358C                          4035  MOVEMBRA    
0000358C  48E7 FF7E               4036              MOVEM.L     D0-D7/A1-A6, -(SP)  ; Branches off depending on size bit
00003590  BA7C 0000               4037              CMP         #zero,D5            ; Checks the size to see if it word
00003594  6700 000E               4038              BEQ         MOVEMW              ; Branches if it is equal to word
00003598  BA7C 0001               4039              CMP         #one, D5            ; Compares bits to long.
0000359C  6700 0022               4040              BEQ         MOVEML              ; Branches if it is equal to long size.
000035A0  6000 06D8               4041              BRA         printInvalid        ; Is invalid if it is not equal to either
000035A4                          4042              
000035A4                          4043  MOVEMW     
000035A4  43F9 00003F7C           4044              LEA         dispWord, A1        ; Prints a W to symbolize word
000035AA  103C 000E               4045              MOVE.B      #14, D0             ; command for trap call to display message
000035AE  4E4F                    4046              TRAP        #15                 ; trap call
000035B0                          4047  
000035B0  43F9 00003EDF           4048              LEA         space, A1           ; Print a space
000035B6  103C 000E               4049              MOVE.B      #14, D0             ; command for trap call to display message
000035BA  4E4F                    4050              TRAP        #15                 ; trap call
000035BC                          4051              
000035BC  6000 001E               4052              BRA         CheckDR             ; Branch to CheckDR
000035C0                          4053  
000035C0                          4054  MOVEML   
000035C0  43F9 00003F7F           4055              LEA         dispLong, A1        ; we know that the opcode will be MOVEML, so load A1 to print message
000035C6  103C 000E               4056              MOVE.B      #14, D0             ; command for trap call to display message
000035CA  4E4F                    4057              TRAP        #15                 ; trap call
000035CC                          4058  
000035CC  43F9 00003EDF           4059              LEA         space, A1           ; Print a space
000035D2  103C 000E               4060              MOVE.B      #14, D0             ; command for trap call to display message
000035D6  4E4F                    4061              TRAP        #15                 ; trap call
000035D8                          4062           
000035D8                          4063  
000035D8  6000 0002               4064              BRA         CheckDR             ; Branch to CheckDR
000035DC                          4065  
000035DC                          4066  CheckDR     
000035DC  3218                    4067              MOVE.W      (A0)+, D1           ; Taking in next word
000035DE  BC7C 0000               4068              CMP         #zero,D6            ; Check if dr is 0, then print out data/address first
000035E2  6700 0020               4069              BEQ         printRegMem         ; branch to printRegMem
000035E6  BC7C 0001               4070              CMP         #one,D6             ; dr field is one, must print stack pointer first
000035EA  6700 0004               4071              BEQ         printStack          ; Go to print stack pointer
000035EE  6096                    4072              BRA         invalid             ; Go to invalid if equal to neither
000035F0                          4073              
000035F0                          4074  printStack 
000035F0  4EB8 2F0E               4075              JSR         printEA             ; Prints out the stack pointer
000035F4                          4076              
000035F4  43F9 00003EE6           4077              LEA         comma,A1            ; Prints out comma
000035FA  103C 000E               4078              MOVE.B      #14, D0             ; command for trap call to display message
000035FE  4E4F                    4079              TRAP        #15                 ; trap call
00003600                          4080              
00003600                          4081              
00003600  6000 0002               4082              BRA         printRegMem
00003604                          4083             
00003604                          4084  printRegMem 
00003604  4244                    4085              CLR         D4                  ; Using D4 to store predecrement mode addresses
00003606  1801                    4086              MOVE.B      D1,D4               ; Stores bits for D0-D7
00003608                          4087              
00003608  4245                    4088              CLR         D5                  ; Clear data register
0000360A  1A01                    4089              MOVE.B      D1,D5               ; Move bits containing information on filled data to D5
0000360C  CA7C 0001               4090              AND         #mask1,D5           ; Use a bit mask to mask every bit except for the first bit
00003610  BA7C 0001               4091              CMP         #mask1,D5           ; Check if certain bit is 1 or 0
00003614  6700 0076               4092              BEQ         DataReg0            ; If comparison matches, then data register that is being put on stack starts her
00003618                          4093              
00003618  4245                    4094              CLR         D5                  ; Clear data register
0000361A  1A01                    4095              MOVE.B      D1,D5               ; Move bits containing information on filled data to D5
0000361C  CA7C 0002               4096              AND         #mask2,D5           ; Use a bit mask to mask every bit except for the second bit
00003620  BA7C 0002               4097              CMP         #mask2,D5           ; Check if certain bit is 1 or 0
00003624  6700 0096               4098              BEQ         DataReg1            ; If comparison matches, then data register that is being put on stack starts here
00003628                          4099  
00003628  4245                    4100              CLR         D5                  ; Clear data register
0000362A  1A01                    4101              MOVE.B      D1,D5               ; Move bits containing information on filled data to D5
0000362C  CA7C 0004               4102              AND         #mask3,D5           ; Use a bit mask to mask every bit except for the third bit
00003630  BA7C 0004               4103              CMP         #mask3,D5           ; Check if certain bit is 1 or 0
00003634  6700 00C6               4104              BEQ         DataReg2            ; If comparison matches, then data register that is being put on stack starts her
00003638                          4105              
00003638  4245                    4106              CLR         D5                  ; Clear data register
0000363A  1A01                    4107              MOVE.B      D1,D5               ; Move bits containing information on filled data to D5
0000363C  CA7C 0008               4108              AND         #mask4,D5           ; Use a bit mask to mask every bit except for the fourth
00003640  BA7C 0008               4109              CMP         #mask4,D5           ; Check if certain bit is 1 or 0
00003644  6700 00F6               4110              BEQ         DataReg3            ; If comparison matches, then data register that is being put on stack starts her
00003648                          4111              
00003648  4245                    4112              CLR         D5                  ; Clear data register
0000364A  1A01                    4113              MOVE.B      D1,D5               ; Move bits containing information on filled address/data to D5
0000364C  CA7C 0010               4114              AND         #mask5,D5           ; Use a bit mask to mask every bit except for the fifth bit
00003650  BA7C 0010               4115              CMP         #mask5,D5           ; Check if certain bit is 1 or 0
00003654  6700 0126               4116              BEQ         DataReg4            ; If comparison matches, then data register that is being put on stack starts her
00003658                          4117  
00003658  4245                    4118              CLR         D5                  ; Clear data register
0000365A  1A01                    4119              MOVE.B      D1,D5               ; Move bits containing information on filled address/data to D5
0000365C  CA7C 0020               4120              AND         #mask6,D5           ; Use a bit mask to mask every bit except for the sixth bit
00003660  BA7C 0020               4121              CMP         #mask6,D5           ; Check if certain bit is 1 or 0
00003664  6700 0156               4122              BEQ         DataReg5            ; If comparison matches, then data register that is being put on stack starts her
00003668                          4123  
00003668  4245                    4124              CLR         D5                  ; Clear data register
0000366A  1A01                    4125              MOVE.B      D1,D5               ; Move bits containing information on filled address/data to D5
0000366C  CA7C 0040               4126              AND         #mask7,D5           ; Use a bit mask to mask every bit except for the seventh
00003670  BA7C 0040               4127              CMP         #mask7,D5           ; Check if certain bit is 1 or 0
00003674  6700 0186               4128              BEQ         DataReg6            ; If comparison matches, then data register that is being put on stack starts her
00003678                          4129  
00003678  4245                    4130              CLR         D5                  ; Clear data register
0000367A  1A01                    4131              MOVE.B      D1,D5               ; Move bits containing information on filled address/data to D5
0000367C  CA7C 0080               4132              AND         #mask8,D5           ; Use a bit mask to mask every bit except for the seventh
00003680  BA7C 0080               4133              CMP         #mask8,D5           ; Check if certain bit is 1 or 0
00003684  6700 01B6               4134              BEQ         DataReg7            ; If comparison matches, then only D7 is being used
00003688                          4135              
00003688  6000 FEFC               4136              BRA         invalid             ; If comaparisons fail then this is not MOVEM. Branch out.
0000368C                          4137              
0000368C                          4138  DataReg0
0000368C  43F9 00003F9C           4139              LEA         dispD0, A1          ; Output string D0
00003692  103C 000E               4140              MOVE.B      #14, D0             ; command for trap call to display message
00003696  4E4F                    4141              TRAP        #15                 ; trap call
00003698                          4142              
00003698  4245                    4143              CLR         D5                  ; Clear data register
0000369A  1A01                    4144              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
0000369C  CA7C 0002               4145              AND         #mask2,D5           ; Uses mask to check for valid after current bit
000036A0  BA7C 0002               4146              CMP         #mask2,D5           ; Check if there are anymore data registers used
000036A4  6700 0006               4147              BEQ         Reg0Cont            ; Continues to check for last register used if so
000036A8  6000 01A2               4148              BRA         printMem            ; Else it will continue on to print the address/memory
000036AC                          4149              
000036AC                          4150  Reg0Cont        
000036AC  43F9 00003EEC           4151              LEA         dec, A1             ; Output -
000036B2  103C 000E               4152              MOVE.B      #14, D0             ; command for trap call to display message
000036B6  4E4F                    4153              TRAP        #15                 ; trap call        
000036B8  6000 0002               4154              BRA         DataReg1            ; Found starting register move on to find ending register
000036BC                          4155  
000036BC                          4156  DataReg1
000036BC  4245                    4157              CLR         D5                  ; Clear data register
000036BE  1A01                    4158              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000036C0  CA7C 0005               4159              AND         #maskA,D5           ; Uses mask to check for valid bits before and after current bit
000036C4  BA7C 0005               4160              CMP         #maskA,D5           ; Check if there are bits before and after current masked bit
000036C8  6700 0032               4161              BEQ         DataReg2            ; Branch to skip printing until the end register is found
000036CC                          4162              
000036CC  43F9 00003F9F           4163              LEA         dispD1, A1          ; Output string D0
000036D2  103C 000E               4164              MOVE.B      #14, D0             ; command for trap call to display message
000036D6  4E4F                    4165              TRAP        #15                 ; trap call
000036D8                          4166              
000036D8  4245                    4167              CLR         D5                  ; Clear data register
000036DA  1A01                    4168              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000036DC  CA7C 0004               4169              AND         #mask3,D5           ; Bitmasking to check if next bit is used or not
000036E0  BA7C 0004               4170              CMP         #mask3,D5           ; Checking if next bit is use
000036E4  6700 0006               4171              BEQ         Reg1Cont            ; Continues to check for last register used if so
000036E8  6000 0162               4172              BRA         printMem            ; Else it will continue on to print the address/memory
000036EC                          4173              
000036EC                          4174  Reg1Cont        
000036EC  43F9 00003EEC           4175              LEA         dec, A1             ; Output -
000036F2  103C 000E               4176              MOVE.B      #14, D0             ; command for trap call to display message
000036F6  4E4F                    4177              TRAP        #15                 ; trap call        
000036F8  6000 0002               4178              BRA         DataReg2            ; Found starting register move on to find ending registe
000036FC                          4179  
000036FC                          4180  DataReg2
000036FC  4245                    4181              CLR         D5                  ; Clear data register
000036FE  1A01                    4182              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003700  CA7C 000A               4183              AND         #maskB,D5           ; Uses mask to check for valid bits before and after current bit
00003704  BA7C 000A               4184              CMP         #maskB,D5           ; Check if there are bits before and after current masked bit
00003708  6700 0032               4185              BEQ         DataReg3            ; If there are bits before and after, skip to next register to find ending
0000370C                          4186              
0000370C                          4187              
0000370C  43F9 00003FA2           4188              LEA         dispD2, A1          ; Output D2
00003712  103C 000E               4189              MOVE.B      #14, D0             ; command for trap call to display message
00003716  4E4F                    4190              TRAP        #15                 ; trap call
00003718                          4191              
00003718  4245                    4192              CLR         D5                  ; Clear data register
0000371A  1A01                    4193              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
0000371C  CA7C 0008               4194              AND         #mask4,D5           ; Bitmasking to check if next bit is used or not
00003720  BA7C 0008               4195              CMP         #mask4,D5           ; Checking if next bit is used
00003724  6700 0006               4196              BEQ         Reg2Cont            ; Continues to check for last register used if so
00003728  6000 0122               4197              BRA         printMem            ; Else it will continue on to print the address/memory
0000372C                          4198              
0000372C                          4199  Reg2Cont        
0000372C  43F9 00003EEC           4200              LEA         dec, A1             ; Output -
00003732  103C 000E               4201              MOVE.B      #14, D0             ; command for trap call to display message
00003736  4E4F                    4202              TRAP        #15                 ; trap call        
00003738  6000 0002               4203              BRA         DataReg3            ; Found starting register move on to find ending registe
0000373C                          4204  
0000373C                          4205  DataReg3
0000373C  4245                    4206              CLR         D5                  ; Clear data register
0000373E  1A01                    4207              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003740  CA7C 0014               4208              AND         #maskC,D5           ; Uses mask to check for valid bits before and after current bit
00003744  BA7C 0014               4209              CMP         #maskC,D5           ; Check if there are bits before and after current masked bit
00003748  6700 0032               4210              BEQ         DataReg4            ; If there are bits before and after, skip to next register to find ending
0000374C                          4211      
0000374C                          4212              
0000374C  43F9 00003FA5           4213              LEA         dispD3, A1          ; Output string D0
00003752  103C 000E               4214              MOVE.B      #14, D0             ; command for trap call to display message
00003756  4E4F                    4215              TRAP        #15                 ; trap call
00003758                          4216              
00003758  4245                    4217              CLR         D5                  ; Clear data register
0000375A  1A01                    4218              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
0000375C  CA7C 0010               4219              AND         #mask5,D5           ; Bitmasking to check if next bit is used or not
00003760  BA7C 0010               4220              CMP         #mask5,D5
00003764  6700 0006               4221              BEQ         Reg3Cont            ; Continues to check for last register used if so
00003768  6000 00E2               4222              BRA         printMem            ; Else it will continue on to print the address/memory
0000376C                          4223              
0000376C                          4224  Reg3Cont        
0000376C  43F9 00003EEC           4225              LEA         dec, A1             ; Output -
00003772  103C 000E               4226              MOVE.B      #14, D0             ; command for trap call to display message
00003776  4E4F                    4227              TRAP        #15                 ; trap call        
00003778  6000 0002               4228              BRA         DataReg4            ; Found starting register move on to find ending registe
0000377C                          4229  
0000377C                          4230  DataReg4
0000377C  4245                    4231              CLR         D5                  ; Clear data register
0000377E  1A01                    4232              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003780  CA7C 0028               4233              AND         #maskD,D5           ; Uses mask to check for valid bits before and after current bit
00003784  BA7C 0028               4234              CMP         #maskD,D5           ; Check if there are bits before and after current masked bit
00003788  6700 0032               4235              BEQ         DataReg5            ; If there are bits before and after, skip to next register to find ending
0000378C                          4236              
0000378C  43F9 00003FA8           4237              LEA         dispD4, A1          ; Output string D0
00003792  103C 000E               4238              MOVE.B      #14, D0             ; command for trap call to display message
00003796  4E4F                    4239              TRAP        #15                 ; trap call
00003798                          4240              
00003798  4245                    4241              CLR         D5                  ; Clear data register
0000379A  1A01                    4242              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
0000379C  CA7C 0020               4243              AND         #mask6,D5           ; Bitmasking to check if next bit is used or not
000037A0  BA7C 0020               4244              CMP         #mask6,D5           ; Checking if next bit is use
000037A4  6700 0006               4245              BEQ         Reg4Cont            ; Continues to check for last register used if so
000037A8  6000 00A2               4246              BRA         printMem            ; Else it will continue on to print the address/memory
000037AC                          4247              
000037AC                          4248  Reg4Cont        
000037AC  43F9 00003EEC           4249              LEA         dec, A1             ; Output -
000037B2  103C 000E               4250              MOVE.B      #14, D0             ; command for trap call to display message
000037B6  4E4F                    4251              TRAP        #15                 ; trap call        
000037B8  6000 0002               4252              BRA         DataReg5            ; Found starting register move on to find ending registe
000037BC                          4253  
000037BC                          4254  DataReg5
000037BC  4245                    4255              CLR         D5                  ; Clear data register
000037BE  1A01                    4256              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000037C0  CA7C 0050               4257              AND         #maskE,D5           ; Uses mask to check for valid bits before and after current bit
000037C4  BA7C 0050               4258              CMP         #maskE,D5           ; Check if there are bits before and after current masked bit
000037C8  6700 0032               4259              BEQ         DataReg6            ; If there are bits before and after, skip to next register to find ending
000037CC                          4260              
000037CC  43F9 00003FAB           4261              LEA         dispD5, A1          ; Output string D0
000037D2  103C 000E               4262              MOVE.B      #14, D0             ; command for trap call to display message
000037D6  4E4F                    4263              TRAP        #15                 ; trap call
000037D8                          4264              
000037D8  4245                    4265              CLR         D5                  ; Clear data register
000037DA  1A01                    4266              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000037DC  CA7C 0040               4267              AND         #mask7,D5           ; Bitmasking to check if next bit is used or not
000037E0  BA7C 0040               4268              CMP         #mask7,D5           ; Checking if next bit is use
000037E4  6700 0006               4269              BEQ         Reg5Cont            ; Continues to check for last register used if so
000037E8  6000 0062               4270              BRA         printMem            ; Else it will continue on to print the address/memory
000037EC                          4271              
000037EC                          4272  Reg5Cont        
000037EC  43F9 00003EEC           4273              LEA         dec, A1             ; Output -
000037F2  103C 000E               4274              MOVE.B      #14, D0             ; command for trap call to display message
000037F6  4E4F                    4275              TRAP        #15                 ; trap call        
000037F8  6000 0042               4276              BRA         DataReg7            ; Found starting register move on to find ending registe
000037FC                          4277  
000037FC                          4278  DataReg6
000037FC  4245                    4279              CLR         D5                  ; Clear data register
000037FE  1A01                    4280              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003800  CA7C 00A0               4281              AND         #maskF,D5           ; Uses mask to check for valid bits before and after current bit
00003804  BA7C 00A0               4282              CMP         #maskF,D5           ; Check if there are bits before and after current masked bit
00003808  6700 0032               4283              BEQ         DataReg7            ; If there are bits before and after, skip to next register to find ending
0000380C                          4284  
0000380C  43F9 00003FAE           4285              LEA         dispD6, A1          ; Output string D0
00003812  103C 000E               4286              MOVE.B      #14, D0             ; command for trap call to display message
00003816  4E4F                    4287              TRAP        #15                 ; trap call
00003818                          4288              
00003818  4245                    4289              CLR         D5                  ; Clear data register
0000381A  1A01                    4290              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
0000381C  CA7C 0080               4291              AND         #mask8,D5           ; Bitmasking to check if next bit is used or not
00003820  BA7C 0080               4292              CMP         #mask8,D5           ; Checking if next bit is use
00003824  6700 0006               4293              BEQ         Reg6Cont            ; Continues to check for last register used if so
00003828  6000 0022               4294              BRA         printMem            ; Else it will continue on to print the address/memory
0000382C                          4295              
0000382C                          4296  Reg6Cont        
0000382C  43F9 00003EEC           4297              LEA         dec, A1             ; Output -
00003832  103C 000E               4298              MOVE.B      #14, D0             ; command for trap call to display message
00003836  4E4F                    4299              TRAP        #15                 ; trap call        
00003838  6000 0002               4300              BRA         DataReg7            ; Found starting register move on to find ending registe
0000383C                          4301  
0000383C                          4302  DataReg7    
0000383C  43F9 00003FB1           4303              LEA         dispD7, A1          ; Output -
00003842  103C 000E               4304              MOVE.B      #14, D0             ; command for trap call to display message
00003846  4E4F                    4305              TRAP        #15                 ; trap call        
00003848  6000 0002               4306              BRA         printMem            ; Last check, branch to print out the address register     
0000384C                          4307              
0000384C                          4308  printMem                                    ; Made this function in order to reuse if DR is 1
0000384C  6000 0002               4309              BRA         printMemNow         ; Branch out to printMemNow
00003850                          4310              
00003850                          4311  printMemNow                           
00003850  43F9 00003F72           4312              LEA         slash, A1           ; Display slash
00003856  103C 000E               4313              MOVE.B      #14, D0             ; command for trap call to display message
0000385A  4E4F                    4314              TRAP        #15                 ; trap call
0000385C                          4315           
0000385C  4244                    4316              CLR         D4                  ; Using D4 to store predecrement mode addresses
0000385E  3801                    4317              MOVE.W      D1,D4               ; Stores bits for D0-D7
00003860  E044                    4318              ASR         #eight,D4           ; Rotate to the right, to create space for next byte
00003862                          4319              
00003862  4245                    4320              CLR         D5                  ; Clear space
00003864  1A04                    4321              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
00003866  CA7C 0001               4322              AND         #mask1,D5           ; Use a bit mask to mask every bit except for the first bit
0000386A  BA7C 0001               4323              CMP         #mask1,D5           ; Check if certain bit is 1 or 0
0000386E  6700 0072               4324              BEQ         AddrReg0            ; If comparison matches, then address register that is being put on stack starts here
00003872                          4325              
00003872  4245                    4326              CLR         D5                  ; Clear data register 
00003874  1A04                    4327              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
00003876  CA7C 0002               4328              AND         #mask2,D5           ; Use a bit mask to mask every bit except for the second bit
0000387A  BA7C 0002               4329              CMP         #mask2,D5           ; Check if certain bit is 1 or 0
0000387E  6700 0092               4330              BEQ         AddrReg1            ; If comparison matches, then address register that is being put on stack starts here
00003882                          4331  
00003882  4245                    4332              CLR         D5                  ; Clear data register
00003884  1A04                    4333              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
00003886  CA7C 0004               4334              AND         #mask3,D5           ; Use a bit mask to mask every bit except for the third
0000388A  BA7C 0004               4335              CMP         #mask3,D5           ; Check if certain bit is 1 or 0
0000388E  6700 00C2               4336              BEQ         AddrReg2            ; If comparison matches, then address register that is being put on stack starts here         
00003892                          4337              
00003892  4245                    4338              CLR         D5                  ; Clear data register
00003894  1A04                    4339              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
00003896  CA7C 0008               4340              AND         #mask4,D5           ; Use a bit mask to mask every bit except for the fourth bit
0000389A  BA7C 0008               4341              CMP         #mask4,D5           ; Check if certain bit is 1 or 0
0000389E  6700 00F2               4342              BEQ         AddrReg3            ; If comparison matches, then address register that is being put on stack starts here     
000038A2                          4343                  
000038A2  4245                    4344              CLR         D5                  ; Clear data register
000038A4  1A04                    4345              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
000038A6  CA7C 0010               4346              AND         #mask5,D5           ; Use a bit mask to mask every bit except for the fifth bit
000038AA  BA7C 0010               4347              CMP         #mask5,D5           ; Check if certain bit is 1 or 0
000038AE  6700 0122               4348              BEQ         AddrReg4            ; If comparison matches, then address register that is being put on stack starts here
000038B2                          4349  
000038B2  4245                    4350              CLR         D5                  ; Clear data register
000038B4  1A04                    4351              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
000038B6  CA7C 0020               4352              AND         #mask6,D5           ; Use a bit mask to mask every bit except for the sixth bit
000038BA  BA7C 0020               4353              CMP         #mask6,D5           ; Check if certain bit is 1 or 0
000038BE  6700 0152               4354              BEQ         AddrReg5            ; If comparison matches, then address register that is being put on stack starts here
000038C2                          4355  
000038C2  4245                    4356              CLR         D5                  ; Clear data register
000038C4  1A04                    4357              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
000038C6  CA7C 0040               4358              AND         #mask7,D5           ; Use a bit mask to mask every bit except for the seventh bit
000038CA  BA7C 0040               4359              CMP         #mask7,D5           ; Check if certain bit is 1 or 0
000038CE  6700 0182               4360              BEQ         AddrReg6            ; If comparison matches, then address register that is being put on stack starts here
000038D2                          4361  
000038D2  4245                    4362              CLR         D5                  ; Clear data register
000038D4  1A04                    4363              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
000038D6  CA7C 0080               4364              AND         #mask8,D5           ; Use a bit mask to mask every bit except for the last bit
000038DA  BA7C 0080               4365              CMP         #mask8,D5           ; Check if certain bit is 1 or 0
000038DE  6700 01B2               4366              BEQ         AddrReg7            ; If comparison matches, then address register that is being put on stack starts here
000038E2                          4367              
000038E2                          4368  AddrReg0
000038E2                          4369  
000038E2  43F9 00003F82           4370              LEA         dispA0, A1          ; Output string D0
000038E8  103C 000E               4371              MOVE.B      #14, D0             ; command for trap call to display message
000038EC  4E4F                    4372              TRAP        #15                 ; trap call
000038EE                          4373              
000038EE  4245                    4374              CLR         D5                  ; Clear data register
000038F0  1A01                    4375              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000038F2  CA7C 0002               4376              AND         #mask2,D5           ; Bitmasking to check if next bit is used or not
000038F6  BA7C 0002               4377              CMP         #mask2,D5           ; Checking if next bit is use
000038FA  6700 0006               4378              BEQ         Addr0Cont           ; Continues to check for last register used if so
000038FE  6000 01A2               4379              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
00003902                          4380              
00003902                          4381  Addr0Cont        
00003902  43F9 00003EEC           4382              LEA         dec, A1             ; Output -
00003908  103C 000E               4383              MOVE.B      #14, D0             ; command for trap call to display message
0000390C  4E4F                    4384              TRAP        #15                 ; trap call        
0000390E  6000 0002               4385              BRA         AddrReg1            ; Branch to second address
00003912                          4386  
00003912                          4387  AddrReg1
00003912  4245                    4388              CLR         D5                  ; Clear data register
00003914  1A04                    4389              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003916  CA7C 0005               4390              AND         #maskA,D5           ; Uses mask to check for valid bits before and after current bit
0000391A  BA7C 0005               4391              CMP         #maskA,D5           ; Check if there are bits before and after current masked bit
0000391E  6700 0032               4392              BEQ         AddrReg2            ; Skip print and move to next address to check if it the last address used
00003922                          4393              
00003922  43F9 00003F85           4394              LEA         dispA1, A1          ; Output string D0
00003928  103C 000E               4395              MOVE.B      #14, D0             ; command for trap call to display message
0000392C  4E4F                    4396              TRAP        #15                 ; trap call
0000392E                          4397              
0000392E  4245                    4398              CLR         D5                  ; Clear data register
00003930  1A04                    4399              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003932  CA7C 0004               4400              AND         #mask3,D5           ; Bitmasking to check if next bit is used or not
00003936  BA7C 0004               4401              CMP         #mask3,D5           ; Checking if next bit is use
0000393A  6700 0006               4402              BEQ         Addr1Cont           ; Continues to check for last register used if so
0000393E  6000 0162               4403              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
00003942                          4404              
00003942                          4405  Addr1Cont        
00003942  43F9 00003EEC           4406              LEA         dec, A1             ; Output -
00003948  103C 000E               4407              MOVE.B      #14, D0             ; command for trap call to display message
0000394C  4E4F                    4408              TRAP        #15                 ; trap call        
0000394E  6000 0002               4409              BRA         AddrReg2            ; Skip print and move to next address to check if it the last address used    
00003952                          4410  
00003952                          4411  AddrReg2
00003952  4245                    4412              CLR         D5                  ; Clear data register
00003954  1A04                    4413              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003956  CA7C 000A               4414              AND         #maskB,D5           ; Uses mask to check for valid bits before and after current bit
0000395A  BA7C 000A               4415              CMP         #maskB,D5           ; Check if there are bits before and after current masked bit
0000395E  6700 0032               4416              BEQ         AddrReg3            ; If there are bits before and after, skip to next register to find ending
00003962                          4417  
00003962                          4418              
00003962  43F9 00003F88           4419              LEA         dispA2, A1          ; Output string D0
00003968  103C 000E               4420              MOVE.B      #14, D0             ; command for trap call to display message
0000396C  4E4F                    4421              TRAP        #15                 ; trap call
0000396E                          4422              
0000396E  4245                    4423              CLR         D5                  ; Clear data register
00003970  1A04                    4424              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003972  CA7C 0008               4425              AND         #mask4,D5           ; Bitmasking to check if next bit is used or not
00003976  BA7C 0008               4426              CMP         #mask4,D5           ; Checking if next bit is use
0000397A  6700 0006               4427              BEQ         Addr2Cont           ; Continues to check for last register used if so
0000397E  6000 0122               4428              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
00003982                          4429              
00003982                          4430  Addr2Cont        
00003982  43F9 00003EEC           4431              LEA         dec, A1             ; Output -
00003988  103C 000E               4432              MOVE.B      #14, D0             ; command for trap call to display message
0000398C  4E4F                    4433              TRAP        #15                 ; trap call        
0000398E  6000 0002               4434              BRA         AddrReg3            ; Skip print and move to next address to check if it the last address used
00003992                          4435  
00003992                          4436  AddrReg3
00003992  4245                    4437              CLR         D5                  ; Clear data register
00003994  1A04                    4438              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003996  CA7C 0014               4439              AND         #maskC,D5           ; Uses mask to check for valid bits before and after current bit
0000399A  BA7C 0014               4440              CMP         #maskC,D5           ; Check if there are bits before and after current masked bit
0000399E  6700 0032               4441              BEQ         AddrReg4            ; If there are bits before and after, skip to next register to find ending
000039A2                          4442              
000039A2  43F9 00003F8B           4443              LEA         dispA3, A1          ; Output string D0
000039A8  103C 000E               4444              MOVE.B      #14, D0             ; command for trap call to display message
000039AC  4E4F                    4445              TRAP        #15                 ; trap call
000039AE                          4446              
000039AE  4245                    4447              CLR         D5                  ; Clear data register
000039B0  1A04                    4448              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
000039B2  CA7C 0010               4449              AND         #mask5,D5           ; Bitmasking to check if next bit is used or not  
000039B6  BA7C 0010               4450              CMP         #mask5,D5           ; Checking if next bit is use
000039BA  6700 0006               4451              BEQ         Addr3Cont           ; Continues to check for last register used if so
000039BE  6000 00E2               4452              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
000039C2                          4453              
000039C2                          4454  Addr3Cont        
000039C2  43F9 00003EEC           4455              LEA         dec, A1             ; Output -
000039C8  103C 000E               4456              MOVE.B      #14, D0             ; command for trap call to display message
000039CC  4E4F                    4457              TRAP        #15                 ; trap call        
000039CE  6000 0002               4458              BRA         AddrReg4
000039D2                          4459  
000039D2                          4460  AddrReg4
000039D2  4245                    4461              CLR         D5                  ; Clear data register
000039D4  1A04                    4462              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
000039D6  CA7C 0028               4463              AND         #maskD,D5           ; Uses mask to check for valid bits before and after current bit
000039DA  BA7C 0028               4464              CMP         #maskD,D5           ; Check if there are bits before and after current masked bit
000039DE  6700 0032               4465              BEQ         AddrReg5            ; If there are bits before and after, skip to next register to find ending
000039E2                          4466              
000039E2  43F9 00003F8E           4467              LEA         dispA4, A1          ; Output string D0
000039E8  103C 000E               4468              MOVE.B      #14, D0             ; command for trap call to display message
000039EC  4E4F                    4469              TRAP        #15                 ; trap call
000039EE                          4470              
000039EE  4245                    4471              CLR         D5                  ; Clear data register
000039F0  1A04                    4472              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
000039F2  CA7C 0020               4473              AND         #mask6,D5           ; Bitmasking to check if next bit is used or not 
000039F6  BA7C 0020               4474              CMP         #mask6,D5           ; Checking if next bit is use
000039FA  6700 0006               4475              BEQ         Addr4Cont           ; Continues to check for last register used if so
000039FE  6000 00A2               4476              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
00003A02                          4477              
00003A02                          4478  Addr4Cont        
00003A02  43F9 00003EEC           4479              LEA         dec, A1             ; Output -
00003A08  103C 000E               4480              MOVE.B      #14, D0             ; command for trap call to display message
00003A0C  4E4F                    4481              TRAP        #15                 ; trap call        
00003A0E  6000 0002               4482              BRA         AddrReg5
00003A12                          4483  AddrReg5
00003A12  4245                    4484              CLR         D5                  ; Clear data register
00003A14  1A04                    4485              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003A16  CA7C 0050               4486              AND         #maskE,D5           ; Uses mask to check for valid bits before and after current bit
00003A1A  BA7C 0050               4487              CMP         #maskE,D5           ; Check if there are bits before and after current masked bit
00003A1E  6700 0032               4488              BEQ         AddrReg6            ; If there are bits before and after, skip to next register to find ending
00003A22                          4489              
00003A22  43F9 00003F91           4490              LEA         dispA5, A1          ; Output string D0
00003A28  103C 000E               4491              MOVE.B      #14, D0             ; command for trap call to display message
00003A2C  4E4F                    4492              TRAP        #15                 ; trap call
00003A2E                          4493              
00003A2E  4245                    4494              CLR         D5                  ; Clear data register
00003A30  1A04                    4495              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003A32  CA7C 0040               4496              AND         #mask7,D5           ; Bitmasking to check if next bit is used or not
00003A36  BA7C 0040               4497              CMP         #mask7,D5           ; Checking if next bit is use
00003A3A  6700 0006               4498              BEQ         Addr5Cont           ; Continues to check for last register used if so
00003A3E  6000 0062               4499              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
00003A42                          4500              
00003A42                          4501  Addr5Cont        
00003A42  43F9 00003EEC           4502              LEA         dec, A1             ; Output -
00003A48  103C 000E               4503              MOVE.B      #14, D0             ; command for trap call to display message
00003A4C  4E4F                    4504              TRAP        #15                 ; trap call        
00003A4E  6000 0042               4505              BRA         AddrReg7
00003A52                          4506  
00003A52                          4507  AddrReg6
00003A52  4245                    4508              CLR         D5                  ; Clear data register
00003A54  1A04                    4509              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003A56  CA7C 00A0               4510              AND         #maskF,D5           ; Uses mask to check for valid bits before and after current bit
00003A5A  BA7C 00A0               4511              CMP         #maskF,D5           ; Check if there are bits before and after current masked bit
00003A5E  6700 0032               4512              BEQ         AddrReg7            ; If there are bits before and after, skip to next register to find ending
00003A62                          4513  
00003A62  43F9 00003F94           4514              LEA         dispA6, A1          ; Output string D0
00003A68  103C 000E               4515              MOVE.B      #14, D0             ; command for trap call to display message
00003A6C  4E4F                    4516              TRAP        #15                 ; trap call
00003A6E                          4517              
00003A6E  4245                    4518              CLR         D5                  ; Clear data register
00003A70  1A04                    4519              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003A72  CA7C 0080               4520              AND         #mask8,D5           ; Bitmasking to check if next bit is used or not
00003A76  BA7C 0080               4521              CMP         #mask8,D5           ; Checking if next bit is use
00003A7A  6700 0006               4522              BEQ         Addr6Cont           ; Continues to check for last register used if so
00003A7E  6000 0022               4523              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
00003A82                          4524              
00003A82                          4525  Addr6Cont        
00003A82  43F9 00003EEC           4526              LEA         dec, A1             ; Output -
00003A88  103C 000E               4527              MOVE.B      #14, D0             ; command for trap call to display message
00003A8C  4E4F                    4528              TRAP        #15                 ; trap call        
00003A8E  6000 0002               4529              BRA         AddrReg7            ; Skip print and move to next address to check if it the last address used
00003A92                          4530  
00003A92                          4531  AddrReg7    
00003A92  43F9 00003F97           4532              LEA         dispA7, A1          ; Output -
00003A98  103C 000E               4533              MOVE.B      #14, D0             ; command for trap call to display message
00003A9C  4E4F                    4534              TRAP        #15                 ; trap call        
00003A9E  6000 0002               4535              BRA         endMOVE             ; Skip print and move to next address to check if it the last address used
00003AA2                          4536          
00003AA2                          4537  endMOVE
00003AA2  4CDF 7EFF               4538              MOVEM.L  (SP)+, D0-D7/A1-A6     ; Pops all data and address register off the stack
00003AA6  4E75                    4539              RTS
00003AA8                          4540  endMove1                                    ; Used if MOVEM has DR is 1
00003AA8  4CDF 7EFF               4541              MOVEM.L  (SP)+, D0-D7/A1-A6
00003AAC  4E75                    4542              RTS
00003AAE                          4543  ***********************************************************************************************************
00003AAE                          4544  *
00003AAE                          4545  *                       Hex Decode
00003AAE                          4546  *
00003AAE                          4547  *this subroutine displays hex code stored in D1. It displays based on the number of 
00003AAE                          4548  *It displays based on the number of hex to display which is stored in D0. If it is a
00003AAE                          4549  *long or word to display, it will figure out the ascii character and add $37 if it
00003AAE                          4550  *is a letter, and $30 if its a number. It will then load the character into D1 and 
00003AAE                          4551  *display it via trap task 6 and loop however many times is needed, 4 or 8. If a word
00003AAE                          4552  *needs to be displayed, it will roll the bits over so that, the hex are shifted by a word.
00003AAE                          4553  *
00003AAE                          4554  ***********************************************************************************************************
00003AAE                          4555  
00003AAE                          4556  outHex      
00003AAE  48E7 FF7E               4557              MOVEM.L     D0-D7/A1-A6, -(SP)  ; callee saved data
00003AB2  4243                    4558              CLR         D3                  ; clear D3  
00003AB4  4244                    4559              CLR         D4                  ; clear D2
00003AB6  1800                    4560              MOVE.B      D0, D4              ; copy number of hexes to decode from D0 to D4
00003AB8  2601                    4561              MOVE.L      D1, D3              ; copy data to be converted to display from D1 to D3 
00003ABA  B03C 0004               4562              CMP.B       #4, D0              ; compare 4 to D0 for number of hexes to decode
00003ABE  6700 0006               4563              BEQ         moveOver            ; if true, branch to moveOver
00003AC2  6000 0006               4564              BRA         dispLOOP            ; otherwise branch to dispLOOP
00003AC6                          4565              
00003AC6                          4566  moveOver    
00003AC6  E19B                    4567              ROL.L       #8,D3               ; roll over bits in D3 by 8
00003AC8  E19B                    4568              ROL.L       #8,D3               ; repeat again to get word at the end of D3
00003ACA                          4569              
00003ACA                          4570  dispLOOP    
00003ACA  B83C 0000               4571              CMP.B       #0, D4              ; compare 0 to counter or D4
00003ACE  6700 0042               4572              BEQ         endDispSub          ; it true, branch to endDispSub
00003AD2  E99B                    4573              ROL.L       #4, D3              ; roll 4 bits to get Hex
00003AD4  4245                    4574              CLR         D5                  ; clear D5
00003AD6  1A03                    4575              MOVE.B      D3, D5              ; move the byte from D3 to D5
00003AD8  CABC 0000000F           4576              AND.L       #$0F, D5            ; and D5 by F to get just one nibble
00003ADE  BA3C 000A               4577              CMP.B       #10, D5             ; compare 10 by D5
00003AE2  6D00 0006               4578              BLT         DLnine              ; if less than, branch to print numbers
00003AE6  6000 0016               4579              BRA         DLetters            ; otherwise branch to print letters
00003AEA                          4580              
00003AEA                          4581  DLnine      
00003AEA  0645 0030               4582              ADD         #$30, D5            ; add 30 to D5 to get ascii character
00003AEE  4241                    4583              CLR         D1                  ; clear D1
00003AF0  1205                    4584              MOVE.B      D5, D1              ; copy D5 to D1
00003AF2  4240                    4585              CLR         D0                  ; clear D0
00003AF4  103C 0006               4586              MOVE.B      #6, D0              ; move trap task 6 to D0 to print single character
00003AF8  4E4F                    4587              TRAP        #15                 ; trap call
00003AFA  5344                    4588              SUB         #1, D4              ; decrement counter
00003AFC  60CC                    4589              BRA         dispLOOP            ; branch back to dispLOOP
00003AFE                          4590   
00003AFE                          4591  DLetters    
00003AFE  0645 0037               4592              ADD         #$37, D5            ; add 37 to D5 to get ascii character
00003B02  4241                    4593              CLR         D1                  ; clear D1
00003B04  1205                    4594              MOVE.B      D5, D1              ; copy D5 to D1
00003B06  4240                    4595              CLR         D0                  ; clear D0
00003B08  103C 0006               4596              MOVE.B      #6, D0              ; move trap task 6 to D0 to print single character
00003B0C  4E4F                    4597              TRAP        #15                 ; trap call
00003B0E  5344                    4598              SUB         #1, D4              ; decrement counter
00003B10  60B8                    4599              BRA         dispLOOP            ; branch back to dispLOOP       
00003B12                          4600  
00003B12                          4601  endDispSub  
00003B12  4CDF 7EFF               4602              MOVEM.L     (SP)+, D0-D7/A1-A6  ; pop registers from stack
00003B16  4E75                    4603              RTS                             ; return
00003B18                          4604              
00003B18                          4605  ***********************************************************************************************************
00003B18                          4606  *
00003B18                          4607  *                       IO Subroutine
00003B18                          4608  *
00003B18                          4609  *
00003B18                          4610  *   the following subroutine gets the string address from the user
00003B18                          4611  *   and converts it to Hex for a starting/ending address. it is done 
00003B18                          4612  *   by checking each byte at address A1, and converting it from ascii to 
00003B18                          4613  *   hex number. If the user enters an invalid character string, the
00003B18                          4614  *   program will have a simhalt.
00003B18                          4615  *
00003B18                          4616  ***********************************************************************************************************
00003B18                          4617  
00003B18                          4618  Address     
00003B18  48E7 1F3E               4619              MOVEM.L     D3-D7/A2-A6, -(SP)  ; callee saved data
00003B1C                          4620  
00003B1C                          4621  Retry       
00003B1C  4242                    4622              CLR         D2                  ; clear D2
00003B1E  4243                    4623              CLR         D3                  ; clear D3
00003B20  B23C 0004               4624              CMP.B       #4, D1              ; compare 4 to D1 or number of ascii inputs to decode
00003B24  6700 000E               4625              BEQ         subLOOP             ; if true, branch to subLOOP
00003B28  B23C 0008               4626              CMP.B       #8, D1              ; compare 8 to D1 or number of ascii inputs to decode
00003B2C  6700 0006               4627              BEQ         subLOOP             ; if true, branch to subLOOP
00003B30  6000 012A               4628              BRA         ADDinvalid          ; otherwise invalid
00003B34                          4629          
00003B34                          4630  subLOOP     
00003B34  E85C                    4631              ROR         #4, D4              ; rotate D4 by 4 bits
00003B36  1404                    4632              MOVE.B      D4, D2              ; move byte from D4 to D2
00003B38  4244                    4633              CLR         D4                  ; clear D4
00003B3A  4245                    4634              CLR         D5                  ; clear D5
00003B3C  B601                    4635              CMP.B       D1, D3              ; compare counter D3 to total count D1
00003B3E  6700 0134               4636              BEQ         endLOOP             ; if equal branch to endLOOP
00003B42  5443                    4637              ADD.W       #2, D3              ; add 2 to D3
00003B44  E19A                    4638              ROL.L       #8, D2              ; rotate D2 by 8 bits
00003B46                          4639          
00003B46                          4640  bytLOOP     
00003B46  E95C                    4641              ROL         #4, D4              ; rotate D4 by 4 bits 
00003B48                          4642          
00003B48  0C11 0030               4643              CMP.B       #$30, (A1)          ; compare hex value 30 to A1's location
00003B4C  6700 007E               4644              BEQ         hZero               ; if true, branch to hZero
00003B50  0C11 0031               4645              CMP.B       #$31, (A1)          ; compare hex value 31 to A1's location
00003B54  6700 007E               4646              BEQ         hOne                ; if true, branch to hOne
00003B58  0C11 0032               4647              CMP.B       #$32, (A1)          ; compare hex value 32 to A1's location
00003B5C  6700 007E               4648              BEQ         hTwo                ; if true, branch to hTwo
00003B60  0C11 0033               4649              CMP.B       #$33, (A1)          ; compare hex value 33 to A1's location
00003B64  6700 007E               4650              BEQ         hThree              ; if true, branch to hThree
00003B68  0C11 0034               4651              CMP.B       #$34, (A1)          ; compare hex value 34 to A1's location
00003B6C  6700 007E               4652              BEQ         hFour               ; if true, branch to hFour
00003B70  0C11 0035               4653              CMP.B       #$35, (A1)          ; compare hex value 35 to A1's location
00003B74  6700 007E               4654              BEQ         hFive               ; if true, branch to hFive
00003B78  0C11 0036               4655              CMP.B       #$36, (A1)          ; compare hex value 36 to A1's location
00003B7C  6700 007E               4656              BEQ         hSix                ; if true, branch to hSix
00003B80  0C11 0037               4657              CMP.B       #$37, (A1)          ; compare hex value 37 to A1's location
00003B84  6700 007E               4658              BEQ         hSeven              ; if true, branch to hSeven
00003B88  0C11 0038               4659              CMP.B       #$38, (A1)          ; compare hex value 38 to A1's location
00003B8C  6700 007E               4660              BEQ         hEight              ; if true, branch to hEight
00003B90  0C11 0039               4661              CMP.B       #$39, (A1)          ; compare hex value 39 to A1's location
00003B94  6700 007E               4662              BEQ         hNine               ; if true, branch to hNine
00003B98  0C11 0041               4663              CMP.B       #$41, (A1)          ; compare hex value 41 to A1's location
00003B9C  6700 007E               4664              BEQ         hA                  ; if true, branch to hA
00003BA0  0C11 0042               4665              CMP.B       #$42, (A1)          ; compare hex value 42 to A1's location
00003BA4  6700 007E               4666              BEQ         hB                  ; if true, branch to hB
00003BA8  0C11 0043               4667              CMP.B       #$43, (A1)          ; compare hex value 43 to A1's location
00003BAC  6700 007E               4668              BEQ         hC                  ; if true, branch to hC
00003BB0  0C11 0044               4669              CMP.B       #$44, (A1)          ; compare hex value 44 to A1's location
00003BB4  6700 007E               4670              BEQ         hD                  ; if true, branch to hD
00003BB8  0C11 0045               4671              CMP.B       #$45, (A1)          ; compare hex value 45 to A1's location
00003BBC  6700 007E               4672              BEQ         hE                  ; if true, branch to hE
00003BC0  0C11 0046               4673              CMP.B       #$46, (A1)          ; compare hex value 46 to A1's location
00003BC4  6700 007E               4674              BEQ         hF                  ; if true, branch to hF
00003BC8  6000 0092               4675              BRA         ADDinvalid          ; otherwise invalid
00003BCC                          4676              
00003BCC                          4677  hZero       
00003BCC  183C 0000               4678              MOVE.B      #$00, D4            ; move byte 00 to D4
00003BD0  6000 007A               4679              BRA         nextH               ; branch to next hex
00003BD4                          4680              
00003BD4                          4681  hOne        
00003BD4  183C 0010               4682              MOVE.B      #$10, D4            ; move byte 10 to D4
00003BD8  6000 0072               4683              BRA         nextH               ; branch to next hex
00003BDC                          4684  hTwo        
00003BDC  183C 0020               4685              MOVE.B      #$20, D4            ; move byte 20 to D4
00003BE0  6000 006A               4686              BRA         nextH               ; branch to next hex
00003BE4                          4687              
00003BE4                          4688  hThree      
00003BE4  183C 0030               4689              MOVE.B      #$30, D4            ; move byte 30 to D4
00003BE8  6000 0062               4690              BRA         nextH               ; branch to next hex
00003BEC                          4691              
00003BEC  183C 0040               4692  hFour       MOVE.B      #$40, D4            ; move byte 40 to D4
00003BF0  6000 005A               4693              BRA         nextH               ; branch to next hex
00003BF4                          4694              
00003BF4                          4695  hFive       
00003BF4  183C 0050               4696              MOVE.B      #$50, D4            ; move byte 50 to D4
00003BF8  6000 0052               4697              BRA         nextH               ; branch to next hex
00003BFC                          4698              
00003BFC                          4699  hSix        
00003BFC  183C 0060               4700              MOVE.B      #$60, D4            ; move byte 60 to D4
00003C00  6000 004A               4701              BRA         nextH               ; branch to next hex
00003C04                          4702              
00003C04                          4703  hSeven      
00003C04  183C 0070               4704              MOVE.B      #$70, D4            ; move byte 70 to D4
00003C08  6000 0042               4705              BRA         nextH               ; branch to next hex
00003C0C                          4706              
00003C0C                          4707  hEight      
00003C0C  183C 0080               4708              MOVE.B      #$80, D4            ; move byte 80 to D4
00003C10  6000 003A               4709              BRA         nextH               ; branch to next hex
00003C14                          4710              
00003C14                          4711  hNine       
00003C14  183C 0090               4712              MOVE.B      #$90, D4            ; move byte 90 to D4
00003C18  6000 0032               4713              BRA         nextH               ; branch to next hex
00003C1C                          4714          
00003C1C                          4715  hA          
00003C1C  183C 00A0               4716              MOVE.B      #$A0, D4            ; move byte A0 to D4
00003C20  6000 002A               4717              BRA         nextH               ; branch to next hex
00003C24                          4718              
00003C24                          4719  hB          
00003C24  183C 00B0               4720              MOVE.B      #$B0, D4            ; move byte B0 to D4
00003C28  6000 0022               4721              BRA         nextH               ; branch to next hex
00003C2C                          4722              
00003C2C                          4723  hC          
00003C2C  183C 00C0               4724              MOVE.B      #$C0, D4            ; move byte C0 to D4
00003C30  6000 001A               4725              BRA         nextH               ; branch to next hex
00003C34                          4726              
00003C34                          4727  hD          
00003C34  183C 00D0               4728              MOVE.B      #$D0, D4            ; move byte D0 to D4
00003C38  6000 0012               4729              BRA         nextH               ; branch to next hex
00003C3C                          4730              
00003C3C                          4731  hE          
00003C3C  183C 00E0               4732              MOVE.B      #$E0, D4            ; move byte E0 to D4
00003C40  6000 000A               4733              BRA         nextH               ; branch to next hex
00003C44                          4734              
00003C44                          4735  hF          
00003C44  183C 00F0               4736              MOVE.B      #$F0, D4            ; move byte F0 to D4
00003C48  6000 0002               4737              BRA         nextH               ; branch to next hex
00003C4C                          4738  
00003C4C                          4739  nextH       
00003C4C  1019                    4740              MOVE.B      (A1)+, D0           ; move A1's location by a byte
00003C4E  5245                    4741              ADD         #1, D5              ; add 1 to D5
00003C50  BA3C 0002               4742              CMP.B       #2, D5              ; compare 2 to D5
00003C54  6700 FEDE               4743              BEQ         subLOOP             ; if true, branch back to subLOOP
00003C58  6000 FEEC               4744              BRA         bytLOOP             ; otherwise branch to bytLOOP
00003C5C                          4745          
00003C5C                          4746  ADDinvalid  
00003C5C  43F9 00003EBC           4747              LEA         errorMessage, A1    ; load error message to A1
00003C62  103C 000E               4748              MOVE.B      #14, D0             ; move trap task 14 to display message
00003C66  4E4F                    4749              TRAP        #15                 ; trap call
00003C68                          4750      
00003C68  4241                    4751              CLR         D1                  ; clear D1
00003C6A  103C 0002               4752              MOVE.B      #2, D0              ; trap task to get input
00003C6E  4E4F                    4753              TRAP        #15                 ; trap call
00003C70                          4754  
00003C70  6000 FEAA               4755              BRA         Retry               ; branch to retry
00003C74                          4756     
00003C74                          4757  endLOOP     
00003C74  4CDF 7CF8               4758              MOVEM.L     (SP)+, D3-D7/A2-A6  ; pop data from stack
00003C78  4E75                    4759              RTS                             ; return
00003C7A                          4760  ***********************************************************************************************************
00003C7A                          4761  
00003C7A                          4762  printInvalid
00003C7A  1218                    4763              MOVE.B      (A0)+,D1            ; in case of invalid, increment A0 by byte 
00003C7C  6000 D3DA               4764              BRA         LOOP                ; branch back to loop
00003C80                          4765  
00003C80                          4766  endPROG    
00003C80                          4767  
00003C80  FFFF FFFF               4768      SIMHALT                                 ; halt simulator
00003C84                          4769  
00003C84                          4770  ***********************************************************************************************************
00003C84                          4771  *
00003C84                          4772  *                       IO Strings
00003C84                          4773  *           
00003C84                          4774  *       This section holds all of the various strings to output to the console.
00003C84                          4775  *
00003C84                          4776  ***********************************************************************************************************
00003C84                          4777  
00003C84                          4778  Title       
00003C84= 20 20 20 20 2A 2A ...   4779              DC.B                '    ***********      *********    ****       ****',CR,LF
00003CB7= 20 20 20 20 2A 2A ...   4780              DC.B                '    ***    *****   *********      *****     *****',CR,LF
00003CEA= 20 20 20 20 2A 2A ...   4781              DC.B                '    ***       *** ************    ******* *******',CR,LF
00003D1D= 20 20 20 20 2A 2A ...   4782              DC.B                '    ***       *** *************** ***************',CR,LF
00003D50= 20 20 20 20 2A 2A ...   4783              DC.B                '    ***      ***         ******** ****   *   ****',CR,LF
00003D83= 20 20 20 20 2A 2A ...   4784              DC.B                '    ***    *****       ********   ****       ****',CR,LF
00003DB6= 20 20 20 20 2A 2A ...   4785              DC.B                '    ***********      *********    ****       ****',CR,LF,LF
00003DEA= 44 69 73 73 65 6D ...   4786              DC.B        'Dissembler will only take addresses 4000 or higher',CR,LF
00003E1E= 2D 2D 2D 2D 2D 2D ...   4787              DC.B        '-----------------------------------------------------------------------------------------',CR,LF,0
00003E7A                          4788  
00003E7A= 45 6E 74 65 72 20 ...   4789  startingMessage DC.B    'Enter Starting Address (in hex): ', 0
00003E9C= 45 6E 74 65 72 20 ...   4790  endingMessage   DC.B    'Enter Ending Address (in hex): ', 0
00003EBC= 49 6E 63 6F 72 72 ...   4791  errorMessage    DC.B    'Incorrect Address, try again: ', 0
00003EDB                          4792  
00003EDB= 20 0D 0A 00             4793  newLine         DC.B    ' ', CR, LF, 0
00003EDF= 20 20 00                4794  space           DC.B    '  ', 0
00003EE2                          4795  
00003EE2= 23 00                   4796  hashTag         DC.B    '#', 0
00003EE4= 24 00                   4797  dispHex         DC.B    '$', 0
00003EE6= 2C 00                   4798  comma           DC.B    ',', 0
00003EE8                          4799  
00003EE8= 28 00                   4800  opPer           DC.B    '(', 0
00003EEA= 29 00                   4801  clPer           DC.B    ')', 0
00003EEC= 2D 00                   4802  dec             DC.B    '-', 0
00003EEE= 2B 00                   4803  inc             DC.B    '+', 0
00003EF0                          4804  
00003EF0= 4F 52 49 00             4805  ORImatch        DC.B    'ORI', 0
00003EF4= 43 4D 50 49 00          4806  CMPImatch       DC.B    'CMPI', 0
00003EF9= 42 43 4C 52 00          4807  BCLRmatch       DC.B    'BCLR', 0
00003EFE= 4D 4F 56 45 00          4808  MOVEmatch       DC.B    'MOVE', 0
00003F03= 4D 4F 56 45 41 00       4809  MOVEAmatch      DC.B    'MOVEA', 0
00003F09= 4E 45 47 00             4810  NEGmatch        DC.B    'NEG', 0
00003F0D= 52 54 53 00             4811  RTSmatch        DC.B    'RTS', 0
00003F11= 4A 53 52 00             4812  JSRmatch        DC.B    'JSR', 0
00003F15= 4D 4F 56 45 4D 00       4813  MOVEMmatch      DC.B    'MOVEM', 0
00003F1B= 4C 45 41 00             4814  LEAmatch        DC.B    'LEA', 0
00003F1F= 53 55 42 51 00          4815  SUBQmatch       DC.B    'SUBQ', 0
00003F24= 42 52 41 00             4816  BRAmatch        DC.B    'BRA', 0
00003F28= 42 43 53 00             4817  BCSmatch        DC.B    'BCS', 0
00003F2C= 42 56 43 00             4818  BVCmatch        DC.B    'BVC', 0
00003F30= 42 47 45 00             4819  BGEmatch        DC.B    'BGE', 0
00003F34= 42 4C 54 00             4820  BLTmatch        DC.B    'BLT', 0
00003F38= 44 49 56 53 00          4821  DIVSmatch       DC.B    'DIVS', 0
00003F3D= 4F 52 00                4822  ORmatch         DC.B    'OR', 0
00003F40= 53 55 42 00             4823  SUBmatch        DC.B    'SUB', 0
00003F44= 45 4F 52 00             4824  EORmatch        DC.B    'EOR', 0
00003F48= 43 4D 50 00             4825  CMPmatch        DC.B    'CMP', 0
00003F4C= 4D 55 4C 53 00          4826  MULSmatch       DC.B    'MULS', 0
00003F51= 41 44 44 00             4827  ADDmatch        DC.B    'ADD', 0
00003F55= 41 44 44 41 00          4828  ADDAmatch       DC.B    'ADDA', 0
00003F5A= 4C 53 52 00             4829  LSRmatch        DC.B    'LSR', 0
00003F5E= 4C 53 4C 00             4830  LSLmatch        DC.B    'LSL', 0
00003F62= 41 53 52 00             4831  ASRmatch        DC.B    'ASR', 0
00003F66= 41 53 4C 00             4832  ASLmatch        DC.B    'ASL', 0
00003F6A= 52 4F 52 00             4833  RORmatch        DC.B    'ROR', 0
00003F6E= 52 4F 4C 00             4834  ROLmatch        DC.B    'ROL', 0
00003F72                          4835  
00003F72= 2F 00                   4836  slash           DC.B    '/', 0
00003F74= 28 53 50 29 00          4837  stack           DC.B    '(SP)', 0
00003F79                          4838   
00003F79= 2E 42 00                4839  dispByte        DC.B    '.B', 0
00003F7C= 2E 57 00                4840  dispWord        DC.B    '.W', 0
00003F7F= 2E 4C 00                4841  dispLong        DC.B    '.L', 0
00003F82                          4842  
00003F82= 41 30 00                4843  dispA0          DC.B    'A0', 0
00003F85= 41 31 00                4844  dispA1          DC.B    'A1', 0
00003F88= 41 32 00                4845  dispA2          DC.B    'A2', 0
00003F8B= 41 33 00                4846  dispA3          DC.B    'A3', 0
00003F8E= 41 34 00                4847  dispA4          DC.B    'A4', 0
00003F91= 41 35 00                4848  dispA5          DC.B    'A5', 0
00003F94= 41 36 00                4849  dispA6          DC.B    'A6', 0
00003F97= 41 37 00                4850  dispA7          DC.B    'A7', 0
00003F9A                          4851  
00003F9A= 44 00                   4852  dispD           DC.B    'D',0
00003F9C= 44 30 00                4853  dispD0          DC.B    'D0', 0
00003F9F= 44 31 00                4854  dispD1          DC.B    'D1', 0
00003FA2= 44 32 00                4855  dispD2          DC.B    'D2', 0
00003FA5= 44 33 00                4856  dispD3          DC.B    'D3', 0
00003FA8= 44 34 00                4857  dispD4          DC.B    'D4', 0
00003FAB= 44 35 00                4858  dispD5          DC.B    'D5', 0
00003FAE= 44 36 00                4859  dispD6          DC.B    'D6', 0
00003FB1= 44 37 00                4860  dispD7          DC.B    'D7', 0 
00003FB4                          4861   
00003FB4                          4862             END    START                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             3506
ABSSHORT            34CE
ADDAMATCH           3F55
ADDINVALID          3C5C
ADDMATCH            3F51
ADDR0CONT           3902
ADDR1CONT           3942
ADDR2CONT           3982
ADDR3CONT           39C2
ADDR4CONT           3A02
ADDR5CONT           3A42
ADDR6CONT           3A82
ADDRESS             3B18
ADDRREG0            38E2
ADDRREG1            3912
ADDRREG2            3952
ADDRREG3            3992
ADDRREG4            39D2
ADDRREG5            3A12
ADDRREG6            3A52
ADDRREG7            3A92
ASLMATCH            3F66
ASRMATCH            3F62
BCLRMATCH           3EF9
BCSMATCH            3F28
BGEMATCH            3F30
BLTMATCH            3F34
BRAEIGHT            1162
BRAELEVEN           1180
BRAFIVE             112A
BRAFOUR             110E
BRAFOURTEEN         11F0
BRAMATCH            3F24
BRANINE             117C
BRAONE              1102
BRASIX              112E
BRATHIRTEEN         119E
BRATHREE            110A
BRATWELVE           119A
BRATWO              1106
BRAZERO             10D2
BVCMATCH            3F2C
BYTLOOP             3B46
CHECKDR             35DC
CLPER               3EEA
CMPIMATCH           3EF4
CMPMATCH            3F48
COMMA               3EE6
CR                  D
DATAREG0            368C
DATAREG1            36BC
DATAREG2            36FC
DATAREG3            373C
DATAREG4            377C
DATAREG5            37BC
DATAREG6            37FC
DATAREG7            383C
DEC                 3EEC
DISPA0              3F82
DISPA1              3F85
DISPA2              3F88
DISPA3              3F8B
DISPA4              3F8E
DISPA5              3F91
DISPA6              3F94
DISPA7              3F97
DISPBYTE            3F79
DISPD               3F9A
DISPD0              3F9C
DISPD1              3F9F
DISPD2              3FA2
DISPD3              3FA5
DISPD4              3FA8
DISPD5              3FAB
DISPD6              3FAE
DISPD7              3FB1
DISPHEX             3EE4
DISPIMM             353E
DISPLAYA0           3046
DISPLAYA0A          3112
DISPLAYA0D          33D6
DISPLAYA0P          323E
DISPLAYA1           3056
DISPLAYA1A          312E
DISPLAYA1D          33F2
DISPLAYA1P          3266
DISPLAYA2           3066
DISPLAYA2A          314A
DISPLAYA2D          340E
DISPLAYA2P          328E
DISPLAYA3           3076
DISPLAYA3A          3166
DISPLAYA3D          342A
DISPLAYA3P          32B6
DISPLAYA4           3086
DISPLAYA4A          3182
DISPLAYA4D          3446
DISPLAYA4P          32DE
DISPLAYA5           3096
DISPLAYA5A          319E
DISPLAYA5D          3462
DISPLAYA5P          3306
DISPLAYA6           30A6
DISPLAYA6A          31BA
DISPLAYA6D          347E
DISPLAYA6P          332E
DISPLAYA7           30B6
DISPLAYA7A          31D6
DISPLAYA7D          349A
DISPLAYA7P          3356
DISPLAYD0           2F86
DISPLAYD1           2F96
DISPLAYD2           2FA6
DISPLAYD3           2FB6
DISPLAYD4           2FC6
DISPLAYD5           2FD6
DISPLAYD6           2FE6
DISPLAYD7           2FF6
DISPLAYEIGHT        2EFE
DISPLONG            3F7F
DISPLOOP            3ACA
DISPWORD            3F7C
DIVSMATCH           3F38
DLETTERS            3AFE
DLNINE              3AEA
EIGHT               8
ELEVEN              B
ENDDISPSUB          3B12
ENDINGMESSAGE       3E9C
ENDLOOP             3C74
ENDMOVE             3AA2
ENDMOVE1            3AA8
ENDPROG             3C80
ENDSUB              3586
ENDSUBROUTINE       2F08
EORMATCH            3F44
ERRORMESSAGE        3EBC
FIRSTNIB            F0
FIVE                5
FOUR                4
FOURTEEN            E
HA                  3C1C
HASHTAG             3EE2
HB                  3C24
HC                  3C2C
HD                  3C34
HE                  3C3C
HEIGHT              3C0C
HF                  3C44
HFIVE               3BF4
HFOUR               3BEC
HNINE               3C14
HONE                3BD4
HSEVEN              3C04
HSIX                3BFC
HTHREE              3BE4
HTWO                3BDC
HZERO               3BCC
IMMLONG             3572
INC                 3EEE
INVALID             3586
JSRMATCH            3F11
LEAMATCH            3F1B
LF                  A
LONGSKIP            3582
LOOP                1058
LSLMATCH            3F5E
LSRMATCH            3F5A
MASK0               0
MASK1               1
MASK2               2
MASK3               4
MASK4               8
MASK5               10
MASK6               20
MASK7               40
MASK8               80
MASKA               5
MASKB               A
MASKC               14
MASKD               28
MASKE               50
MASKF               A0
MEMSB               2698
MEMSHIFTIMM         2EE4
MEMSHIFTS           120A
MEMSL               2BAC
MEMSW               2922
MOVEAMATCH          3F03
MOVEMATCH           3EFE
MOVEMBRA            358C
MOVEML              35C0
MOVEMMATCH          3F15
MOVEMW              35A4
MOVEOVER            3AC6
MULSMATCH           3F4C
NEGMATCH            3F09
NEWLINE             3EDB
NEXTH               3C4C
NINE                9
ONE                 1
OPADDAL             2460
OPADDAW             23F0
OPADDB              22A4
OPADDL              237C
OPADDW              2310
OPASBI              26D6
OPASBR              2738
OPASL               24D0
OPASLBI             2716
OPASLBR             2778
OPASLI              2BEA
OPASLLI             2C2A
OPASLLR             2C8C
OPASLR              2C4C
OPASLWI             29A0
OPASLWR             2A02
OPASR               251C
OPASRBI             26F4
OPASRBR             2756
OPASRLI             2C08
OPASRLR             2C6A
OPASRWI             297E
OPASRWR             29E0
OPASWI              2960
OPASWR              29C2
OPBCLR              154E
OPBCS               20E8
OPBGE               2158
OPBLT               2190
OPBRA               20B0
OPBVC               2120
OPCMP               1E18
OPCMPB              1E4A
OPCMPI              13C4
OPCMPIB             13E6
OPCMPIL             14DC
OPCMPIW             1458
OPCMPL              1EFE
OPCMPW              1EA4
OPDIVS              1C70
OPDYNBCLR           15B2
OPEOR               1CCA
OPEORB              1CF8
OPEORL              1DB8
OPEORW              1D58
OPJSR               199E
OPLEA               1AA2
OPLSBI              279A
OPLSBR              27FC
OPLSL               2568
OPLSLBI             27DA
OPLSLBR             283C
OPLSLI              2CAE
OPLSLLI             2CEE
OPLSLLR             2D50
OPLSLR              2D10
OPLSLWI             2A64
OPLSLWR             2AC6
OPLSR               25B4
OPLSRBI             27B8
OPLSRBR             281A
OPLSRLI             2CCC
OPLSRLR             2D2E
OPLSRWI             2A42
OPLSRWR             2AA4
OPLSWI              2A24
OPLSWR              2A86
OPMOVEAL            1738
OPMOVEAW            182E
OPMOVEB             1620
OPMOVEL             16A4
OPMOVEM             1A18
OPMOVEMLEA          19FC
OPMOVEW             17A0
OPMULS              2240
OPNEG               1896
OPNEGB              18C4
OPNEGL              1904
OPNEGW              1944
OPOR                1B22
OPORB               1B62
OPORI               1264
OPORIB              1292
OPORIL              135E
OPORIW              12F8
OPORL               1C16
OPORW               1BBC
OPPER               3EE8
OPROBI              285E
OPROBR              28C0
OPROL               2600
OPROLBI             289E
OPROLBR             2900
OPROLI              2D72
OPROLLI             2DB2
OPROLLR             2E14
OPROLR              2DD4
OPROLWI             2B28
OPROLWR             2B8A
OPROR               264C
OPRORBI             287C
OPRORBR             28DE
OPRORLI             2D90
OPRORLR             2DF2
OPRORWI             2B06
OPRORWR             2B68
OPROWI              2AE8
OPROWR              2B4A
OPRTS               19E0
OPRTSJSR            1984
OPSUB               1F58
OPSUBB              1FA2
OPSUBL              2056
OPSUBQ              21C8
OPSUBQB             21F8
OPSUBQL             2224
OPSUBQW             220E
OPSUBW              1FFC
ORIMATCH            3EF0
ORMATCH             3F3D
OUTHEX              3AAE
PADDRDEC            337E
PADDRDIR            30C6
PADDRPOST           31F2
PADDRREG            3006
PDATAREG            2F46
PHEX                34B6
PRINTEA             2F0E
PRINTINVALID        3C7A
PRINTMEM            384C
PRINTMEMNOW         3850
PRINTREGMEM         3604
PRINTSTACK          35F0
PRNTIMM             2E36
PRNTREG             2E92
REG0CONT            36AC
REG1CONT            36EC
REG2CONT            372C
REG3CONT            376C
REG4CONT            37AC
REG5CONT            37EC
REG6CONT            382C
REGSHIFTS           1248
RETRY               3B1C
RETRYEADD           102E
RETRYSADD           100C
ROLMATCH            3F6E
RORMATCH            3F6A
RTSMATCH            3F0D
SECNIB              F
SEVEN               7
SIX                 6
SKIPPRINTEA         1A92
SLASH               3F72
SPACE               3EDF
STACK               3F74
START               1000
STARTINGMESSAGE     3E7A
SUBLOOP             3B34
SUBMATCH            3F40
SUBQMATCH           3F1F
THIRTEEN            D
THREE               3
TITLE               3C84
TWELVE              C
TWO                 2
ZERO                0
