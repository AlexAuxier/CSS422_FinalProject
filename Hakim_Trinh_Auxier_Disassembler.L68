00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 2014-12-12 14:56:35

00000000                             1                                     
00000000                             2      ****       ****  *******     ****    ***      ***
00000000                             3      ****       **** *******    ********  ***     ***
00000000                             4      *****     ***** ***       ***    *** ***    ***
00000000                             5      ******   ****** ***       ***    *** ***   ***
00000000                             6      ******* ******* ***        ********  ***  ***
00000000                             7      *************** *******     ******   ********
00000000                             8      ****  ***  **** ********   ********  ***  ***
00000000                             9      ****   *   **** ***   *** ***    *** ***   ***
00000000                            10      ****       **** ***   *** ***    *** ***    ***
00000000                            11      ****       **** ***   ***  ********  ***     ***
00000000                            12      ****       ****  *******     ****    ***      ***
00000000                            13      
00000000                            14              *********          ********** ****       ****
00000000                            15              ***********      *********    ****       ****
00000000                            16              ***    *****   *********      *****     *****
00000000                            17              ***      **** ********        ******   ******
00000000                            18              ***       *** ************    ******* *******
00000000                            19              ***       *** *************** ***************
00000000                            20              ***       ***    ************ ****  ***  ****
00000000                            21              ***      ***         ******** ****   *   ****
00000000                            22              ***    *****       ********   ****       ****
00000000                            23              ***********      *********    ****       ****
00000000                            24              *********     **********      ****       ****
00000000                            25          
00000000                            26  *----------------------------------------------------------------------
00000000                            27  * Title      :  Motorola 68k Instruction Disassembler (DSM)
00000000                            28  * Written by :  Abdul Hakim, David Trinh, Alexander Auxier
00000000                            29  * Date       :  2014-12-11
00000000                            30  * Description:  The following code is for a partial M68k instruction
00000000                            31  *               disassembler. The opcodes that are supported are part
00000000                            32  *               of the base M68k processor.
00000000                            33  *               
00000000                            34  *               List of Supported Opcodes:
00000000                            35  *               * MOVE, MOVEA, MOVEM
00000000                            36  *               * ADD, ADDA
00000000                            37  *               * MULS, DIVS
00000000                            38  *               * LEA
00000000                            39  *               * OR, ORI, EOR
00000000                            40  *               * NEG
00000000                            41  *               * LSL, LSR
00000000                            42  *               * ASL, ASR
00000000                            43  *               * ROL, ROR
00000000                            44  *               * BCLR
00000000                            45  *               * BRA, JSR, RTS
00000000                            46  *               * Bcc with the following condition codes (cc)
00000000                            47  *                   * CS, VS, GE, LT
00000000                            48  *
00000000                            49  *               Supported Effective Addressing Modes:
00000000                            50  *               * Data Register Direct: Dn
00000000                            51  *               * Address Register Direct: An
00000000                            52  *               * Address Register Indirect: (An)
00000000                            53  *               * Address Register Indirect w/ Post Increment: (A0)+
00000000                            54  *               * Address Register Indirect w/ Pre Decrement: -(SP)
00000000                            55  *               * Immediate Data: #
00000000                            56  *               * Absolute Long Address: (xxx).L
00000000                            57  *               * Absolute Word Address: (xxx).W
00000000                            58  *               
00000000                            59  *               Let it be known that our program makes assumptions in
00000000                            60  *               order to run. That being, our disassembler will not
00000000                            61  *               accept an of the unsupported opcodes/EA modes.
00000000                            62  *               We also assume that the user starts the disassembler
00000000                            63  *               at an address that is 4000 (in hex) or higher.
00000000                            64  *----------------------------------------------------------------------
00000000                            65  
00000000  =0000000D                 66  CR          EQU     $0D     
00000000  =0000000A                 67  LF          EQU     $0A
00000000                            68       
00000000  =00000000                 69  zero        EQU     $00                     ; defined hex value 0
00000000  =00000001                 70  one         EQU     $01                     ; defined hex value 1 
00000000  =00000002                 71  two         EQU     $02                     ; defined hex value 2
00000000  =00000003                 72  three       EQU     $03                     ; defined hex value 3
00000000  =00000004                 73  four        EQU     $04                     ; defined hex value 4
00000000  =00000005                 74  five        EQU     $05                     ; defined hex value 5
00000000  =00000006                 75  six         EQU     $06                     ; defined hex value 6
00000000  =00000007                 76  seven       EQU     $07                     ; defined hex value 7
00000000  =00000008                 77  eight       EQU     $08                     ; defined hex value 8
00000000  =00000009                 78  nine        EQU     $09                     ; defined hex value 9
00000000  =0000000B                 79  eleven      EQU     $0B                     ; defined hex value 11
00000000  =0000000C                 80  twelve      EQU     $0C                     ; defined hex value 12
00000000  =0000000D                 81  thirteen    EQU     $0D                     ; defined hex value 13
00000000  =0000000E                 82  fourteen    EQU     $0E                     ; defined hex value 14
00000000                            83  
00000000  =00000000                 84  mask0       EQU     %00000000
00000000  =00000001                 85  mask1       EQU     %00000001
00000000  =00000002                 86  mask2       EQU     %00000010
00000000  =00000004                 87  mask3       EQU     %00000100
00000000  =00000008                 88  mask4       EQU     %00001000
00000000  =00000010                 89  mask5       EQU     %00010000
00000000  =00000020                 90  mask6       EQU     %00100000
00000000  =00000040                 91  mask7       EQU     %01000000
00000000  =00000080                 92  mask8       EQU     %10000000
00000000                            93  
00000000  =00000005                 94  maskA       EQU     %00000101
00000000  =0000000A                 95  maskB       EQU     %00001010
00000000  =00000014                 96  maskC       EQU     %00010100
00000000  =00000028                 97  maskD       EQU     %00101000
00000000  =00000050                 98  maskE       EQU     %01010000
00000000  =000000A0                 99  maskF       EQU     %10100000
00000000                           100  
00000000  =000000F0                101  firstNib    EQU     $F0
00000000  =0000000F                102  secNib      EQU     $0F
00000000                           103               
00001000                           104              ORG     $1000
00001000                           105  START: 
00001000                           106  ***********************************************************************************************************
00001000                           107  *
00001000                           108  *                   Dissassembler Start
00001000                           109  *
00001000                           110  ***********************************************************************************************************
00001000                           111              ; Dissassemble Start, obtain addr range
00001000                           112              
00001000                           113  RetrySAdd   
00001000  43F9 00003C78            114              LEA         startingMessage, A1 ; load starting message to A1
00001006  103C 000E                115              MOVE.B      #14, D0             ; trap task to display message
0000100A  4E4F                     116              TRAP        #15                 ; trap call
0000100C  103C 0002                117              MOVE.B      #2, D0              ; trap task to read input 
00001010  4E4F                     118              TRAP        #15                 ; trap call
00001012                           119      
00001012  4EB9 00003B0C            120              JSR         Address             ; jump to Address
00001018  B4BC 00004000            121              CMP.L       #$00004000, D2      ; compare minimum starting address to D2
0000101E  6DE0                     122              BLT         RetrySAdd           ; if less than, branch back up to starting address
00001020  2042                     123              MOVEA.L     D2, A0              ; move starting address to A0
00001022                           124          
00001022                           125  RetryEAdd   
00001022  43F9 00003C9A            126              LEA         endingMessage, A1   ; load ending address message to A1
00001028  103C 000E                127              MOVE.B      #14, D0             ; trap task to display message
0000102C  4E4F                     128              TRAP        #15                 ; trap call
0000102E                           129          
0000102E  103C 0002                130              MOVE.B      #2, D0              ; trap task to read input 
00001032  4E4F                     131              TRAP        #15                 ; trap call
00001034                           132      
00001034  4EB9 00003B0C            133              JSR         Address             ; jump to Address
0000103A  B488                     134              CMP.L       A0, D2              ; compare starting address to D2
0000103C  6DE4                     135              BLT         RetryEAdd           ; if less than, branch back up to ending address
0000103E  2442                     136              MOVEA.L     D2, A2              ; move ending address to A2
00001040                           137          
00001040  43F9 00003CD9            138              LEA         newline, A1         ; display new line
00001046  103C 000E                139              MOVE.B      #14, D0             ; trap task to display message
0000104A  4E4F                     140              TRAP        #15                 ; trap call
0000104C                           141            
0000104C                           142  ***********************************************************************************************************
0000104C                           143  *
0000104C                           144  *                   Control Loop
0000104C                           145  *
0000104C                           146  *       This loop cycles and branches our code by the first nibble of OPCODE binary
0000104C                           147  *
0000104C                           148  ***********************************************************************************************************
0000104C                           149            
0000104C  4241                     150  LOOP        CLR         D1                  ; clear out D1
0000104E  4242                     151              CLR         D2                  ; clear out D2
00001050  B1CA                     152              CMPA.L      A2, A0              ; compare starting and ending addresses
00001052  6E00 2C20                153              BGT         endProg             ; if A0 > A1, we've finished, end program
00001056  1218                     154              MOVE.B      (A0)+, D1           ; load byte to D1 and increment A0 to next byte
00001058  1401                     155              MOVE.B      D1, D2              ; copy byte to D2 for manipulation
0000105A  E882                     156              ASR.L       #four, D2           ; get first nibble in D2
0000105C                           157          
0000105C  B43C 0000                158              CMP.B       #zero, D2           ; compare with 0
00001060  6700 0064                159              BEQ         braZero             ; branch out to zero method
00001064  B43C 0001                160              CMP.B       #one, D2            ; compare with 1
00001068  6700 008C                161              BEQ         braOne              ; branch out to one method
0000106C  B43C 0002                162              CMP.B       #two, D2            ; compare with 2    
00001070  6700 0088                163              BEQ         braTwo              ; branch out to two method
00001074  B43C 0003                164              CMP.B       #three, D2          ; compare with 3
00001078  6700 0084                165              BEQ         braThree            ; branch out to three method
0000107C  B43C 0004                166              CMP.B       #four, D2           ; compare with 4
00001080  6700 0080                167              BEQ         braFour             ; branch out to four method
00001084  B43C 0005                168              CMP.B       #five, D2           ; compare with 5
00001088  6700 0094                169              BEQ         braFive             ; branch out to five method
0000108C  B43C 0006                170              CMP.B       #six, D2            ; compare with 6
00001090  6700 0090                171              BEQ         braSix              ; branch out to six method
00001094  B43C 0008                172              CMP.B       #eight, D2          ; compare with 8
00001098  6700 00BC                173              BEQ         braEight            ; branch out to eight method
0000109C  B43C 0009                174              CMP.B       #nine, D2           ; compare with 9
000010A0  6700 00CE                175              BEQ         braNine             ; branch out to nine method
000010A4  B43C 000B                176              CMP.B       #eleven, D2         ; compare with 11
000010A8  6700 00CA                177              BEQ         braEleven           ; branch out to eleven method
000010AC  B43C 000C                178              CMP.B       #twelve, D2         ; compare with 12
000010B0  6700 00DC                179              BEQ         braTwelve           ; branch out to twelve method
000010B4  B43C 000D                180              CMP.B       #thirteen, D2       ; compare with 13
000010B8  6700 00D8                181              BEQ         braThirteen         ; branch out to thirteen method
000010BC  B43C 000E                182              CMP.B       #fourteen, D2       ; compare with 14
000010C0  6700 0122                183              BEQ         braFourteen         ; branch out to fourteen method
000010C4  6086                     184              BRA         loop
000010C6                           185  
000010C6                           186  ***********************************************************************************************************
000010C6                           187  *
000010C6                           188  *                   Nibble Branch Section
000010C6                           189  *
000010C6                           190  *       This section decides which nibble goes to the corresponding opcode
000010C6                           191  *
000010C6                           192  *********************************************************************************************************** 
000010C6                           193          
000010C6                           194  braZero     
000010C6  4242                     195              CLR         D2                  ; first nibble is 0, 3 opcodes are possible 
000010C8  1401                     196              MOVE.B      D1, D2              ; clear out D2 and copy D1 back in
000010CA  C43C 000F                197              AND.B       #secNib, D2         ; set first nibble to 0
000010CE                           198  
000010CE  B43C 0000                199              CMP.B       #zero, D2           ; compare second nibble to 0
000010D2  6700 0184                200              BEQ         opORI               ; branch to ORI method
000010D6  B43C 000C                201              CMP.B       #twelve, D2         ; compare second nibble to 12
000010DA  6700 02DC                202              BEQ         opCMPI              ; branch to CMPI method
000010DE  B43C 0008                203              CMP.B       #eight,D2           ; Test for static BCLR
000010E2  6700 045E                204              BEQ         opBCLR
000010E6  C47C 0001                205              AND         #one,D2             ; Sets all bits to 0 except for first bit if it is 1
000010EA  B43C 0001                206              CMP.B       #one,D2             ; if it is one then there is a chance it is dynamic BCLR
000010EE  6700 04B6                207              BEQ         opDynBCLR
000010F2  6000 2B7A                208              BRA         printInvalid
000010F6                           209          
000010F6                           210  braOne      
000010F6  6000 051C                211              BRA         opMOVEB             ; we know that there is only one opcode that is MOVE.B
000010FA                           212  
000010FA                           213  braTwo      
000010FA  6000 059C                214              BRA         opMOVEL             ; there are two opCodes available, MOVE.L, or MOVEA.L
000010FE                           215  
000010FE                           216  braThree                                    ; there are two opCodes available, MOVE.W, or MOVEA.W
000010FE  6000 0694                217              BRA         opMOVEW
00001102                           218  
00001102  4242                     219  braFour     CLR         D2                  ; first nibble is 4, 5 opcodes are possible 
00001104  1401                     220              MOVE.B      D1, D2              ; clear out D2 and copy D1 back in
00001106  C43C 000F                221              AND.B       #secNib, D2         ; set first nibble to 0
0000110A                           222   
0000110A  B43C 0004                223              CMP.B       #four, D2           ; compare second nibble to 4
0000110E  6700 077A                224              BEQ         opNEG               ; branch to NEG method
00001112  B43C 000E                225              CMP.B       #fourteen, D2       ; compare second nibble to E
00001116  6700 0860                226              BEQ         opRTSJSR            ; branch to JSR or RTS method
0000111A  6000 08D4                227              BRA         opMOVEMLEA          ; otherwise, branch to MOVEM or LEA method
0000111E                           228  
0000111E                           229  braFive     
0000111E  6000 109C                230              BRA         opSUBQ              ; we know that there is only one opcode that is SUBQ
00001122                           231  
00001122                           232  braSix      
00001122  4242                     233              CLR         D2                  ; first nibble is 6, 5 opcodes are possible 
00001124  1401                     234              MOVE.B      D1, D2              ; clear out D2 and copy D1 back in
00001126  C43C 000F                235              AND.B       #$0F, D2             ; set first nibble to 0
0000112A                           236   
0000112A  B43C 0000                237              CMP.B       #zero, D2           ; compare second nibble to 0
0000112E  6700 0F74                238              BEQ         opBRA               ; branch to BRA method
00001132  B43C 0005                239              CMP.B       #five, D2           ; compare second nibble to 5
00001136  6700 0FA4                240              BEQ         opBCS               ; branch to BCS method
0000113A  B43C 0008                241              CMP.B       #eight, D2          ; compare second nibble to 8
0000113E  6700 0FD4                242              BEQ         opBVC               ; branch to BCS method
00001142  B43C 000C                243              CMP.B       #twelve, D2         ; compare second nibble to 12
00001146  6700 1004                244              BEQ         opBGE               ; branch to BGE method
0000114A  B43C 000D                245              CMP.B       #thirteen,D2        ; compare second nibble to 13
0000114E  6700 1034                246              BEQ         opBLT               ; branch to BLT method
00001152  6000 2B1A                247              BRA         printInvalid        ; found an un-supported opcode
00001156                           248  
00001156                           249  braEight                                    ; there are two opCodes available DIVS, or OR
00001156  4242                     250              CLR         D2                  ; clear D2 for use
00001158  E141                     251              ASL         #8,D1               ; Shift by eight 
0000115A  1218                     252              MOVE.B      (A0)+,D1            ; Move the instruction byte into D1
0000115C  3401                     253              MOVE.W      D1,D2               ; Load D2 with the word from D1
0000115E  EC42                     254              ASR         #six,D2             ; Shift by 6 to find second nibble
00001160  C47C 0007                255              AND         #$07,D2             ; AND by 7 to remove unwanted bits
00001164  B43C 0007                256              CMP.B       #seven,D2           ; Compare second nibble to 7
00001168  6700 0AFA                257              BEQ         opDIVS              ; If bits 8 - 6 are equal to 7, we have DIVS
0000116C  6000 09A8                258              BRA         opOR                ; else opcode is OR
00001170                           259  
00001170                           260  braNine     
00001170  6000 0DDA                261              BRA         opSUB               ; we know that there is only one opcode that is SUB
00001174                           262  
00001174                           263  braEleven                                   ; there are two opCodes available EOR, or CMP
00001174  4242                     264              CLR         D2                  ; clear D2 for use
00001176  E141                     265              ASL         #8,D1               ; Shift by eight for
00001178  1218                     266              MOVE.B      (A0)+,D1            ; Re-load the instruction byte into D1
0000117A  3401                     267              MOVE.W      D1,D2               ; Move the word into D2 for the comparison
0000117C  EC42                     268              ASR         #six,D2             ; Shift by 6 to find second nibble
0000117E  C47C 0007                269              AND         #$07,D2             ; AND by 7 to remove unwanted bits
00001182  B43C 0003                270              CMP.B       #three,D2           ; Compare second nibble to 3
00001186  6D00 0C84                271              BLT         opCMP               ; If opmode bits are less than 3, we have CMP
0000118A  6E00 0B32                272              BGT         opEOR               ; Else its EOR
0000118E                           273  
0000118E                           274  braTwelve   
0000118E  6000 10A4                275              BRA         opMULS              ; we know that there is only one opcode that is MULS    
00001192                           276    
00001192                           277  braThirteen 
00001192  E141                     278              ASL         #eight, D1          ; we need the whole word to compare between add and adda, so move over the current byte 
00001194  1218                     279              MOVE.B      (A0)+, D1           ; load the remaining byte to D1
00001196                           280              
00001196  4242                     281              CLR         D2                  ; clear D2
00001198  3401                     282              MOVE.W      D1, D2              ; copy opcode to D2
0000119A  EC42                     283              ASR         #six, D2            ; shift the bits right to get size and type
0000119C  C47C 0007                284              AND         #seven,D2           ; clear out all but first 3 bits
000011A0                           285              
000011A0  B43C 0000                286              CMP.B       #zero,D2            ; compare 0 to D2
000011A4  6700 10F2                287              BEQ         opADDB              ; we know its ADDB
000011A8  B43C 0001                288              CMP.B       #one, D2            ; compare 1 to D2
000011AC  6700 1156                289              BEQ         opADDW              ; we know its ADDW
000011B0  B43C 0002                290              CMP.B       #two, D2            ; compare 2 to D2
000011B4  6700 11BA                291              BEQ         opADDL              ; we know its ADDL
000011B8  B43C 0003                292              CMP.B       #three, D2          ; compare 3 to D2
000011BC  6700 1226                293              BEQ         opADDAW             ; we know its ADDAW
000011C0  B43C 0004                294              CMP.B       #four, D2           ; compare 4 to D2
000011C4  6700 10D2                295              BEQ         opADDB              ; we know its ADDB
000011C8  B43C 0005                296              CMP.B       #five, D2           ; compare 5 to D2
000011CC  6700 1136                297              BEQ         opADDW              ; we know its ADDW
000011D0  B43C 0006                298              CMP.B       #six, D2            ; compare 6 to D2
000011D4  6700 119A                299              BEQ         opADDL              ; we know its ADDL
000011D8  B43C 0007                300              CMP.B       #seven, D2          ; compare 7 to D2
000011DC  6700 1276                301              BEQ         opADDAL             ; we know its ADDAL
000011E0  6000 2A8C                302              BRA         printInvalid        ; invalid opcode
000011E4                           303               
000011E4                           304  braFourteen 
000011E4  E141                     305              ASL.W       #eight,D1           ; we need the whole word to compare between add and adda, so move over the current byte
000011E6  1218                     306              MOVE.B      (A0)+, D1           ; load the remaining byte to D1
000011E8                           307              
000011E8  4242                     308              CLR         D2                  ; clear D2
000011EA  3401                     309              MOVE.W      D1, D2              ; copy opcode to D2
000011EC  EC42                     310              ASR         #six, D2            ; shift the bits right to get size
000011EE  C47C 0003                311              AND         #03,D2
000011F2                           312          
000011F2  B43C 0003                313              CMP.B       #three, D2          ; if the size is three, we are shifting memory
000011F6  6700 0006                314              BEQ         memShifts           ; go to memory shift
000011FA  6000 0040                315              BRA         regShifts           ; else go to register shift
000011FE                           316  
000011FE                           317  memShifts   
000011FE  4242                     318              CLR         D2             
00001200  3401                     319              MOVE.W      D1, D2              ; clear out D2 and copy D1 back in
00001202  E082                     320              ASR.L       #eight,D2           ; move to get first byte back
00001204  C47C 000F                321              AND         #secNib, D2         ; set first nibble to 0
00001208                           322   
00001208  B43C 0000                323              CMP.B       #zero, D2           ; compare second nibble to 0
0000120C  6700 1302                324              BEQ         opASR               ; branch to ASR method
00001210  B43C 0001                325              CMP.B       #one, D2            ; compare second nibble to 1
00001214  6700 12AE                326              BEQ         opASL               ; branch to ASL method
00001218  B43C 0002                327              CMP.B       #two, D2            ; compare second nibble to 2
0000121C  6700 138A                328              BEQ         opLSR               ; branch to LSR method
00001220  B43C 0003                329              CMP.B       #three, D2          ; compare second nibble to 3
00001224  6700 1336                330              BEQ         opLSL               ; branch to LSL method
00001228  B43C 0006                331              CMP.B       #six, D2            ; compare second nibble to 6
0000122C  6700 1412                332              BEQ         opROR               ; branch to ROR method
00001230  B43C 0007                333              CMP.B       #seven, D2          ; compare second nibble to 7
00001234  6700 13BE                334              BEQ         opROL               ; branch to ROL method
00001238  6000 2A34                335              BRA         printInvalid        ; otherwise, invalid
0000123C                           336              
0000123C                           337  regShifts   
0000123C  B43C 0000                338              CMP.B       #zero, D2           ; if size is 0, we are shifting a byte
00001240  6700 144A                339              BEQ         memSB               ; branch to register shift byte
00001244  B43C 0001                340              CMP.B       #one, D2            ; if size is 1, we are shifting a word
00001248  6700 16CC                341              BEQ         memSW               ; branch to register shift word
0000124C  B43C 0002                342              CMP.B       #two, D2            ; if size is 1, we are shifting a long
00001250  6700 194E                343              BEQ         memSL               ; branch to register shift long
00001254  6000 2A18                344              BRA         printInvalid        ; otherwise, invalid
00001258                           345              
00001258                           346  ***********************************************************************************************************
00001258                           347  *
00001258                           348  *                   ORI OPCODE
00001258                           349  *       ORI starts out with size branching. Will compare sizes and branch to appropriate size.
00001258                           350  *       Once size is found, code will print out ORI and continue to find mode and register and print it out
00001258                           351  *
00001258                           352  ***********************************************************************************************************
00001258                           353  
00001258                           354  opORI       
00001258  43F9 00003CEE            355              LEA         ORImatch, A1        ; we know that the opcode will be ORI, so load A1 to print message
0000125E  103C 000E                356              MOVE.B      #14, D0             ; command for trap call to display message
00001262  4E4F                     357              TRAP        #15                 ; trap call
00001264                           358          
00001264  1218                     359              MOVE.B      (A0)+, D1
00001266  1401                     360              MOVE.B      D1,D2               ; copy data over
00001268  EC42                     361              ASR         #6,D2               ; shifts 6 bits over to read just the size        
0000126A  B43C 0000                362              CMP.B       #zero,D2            ; Size is 0, must be byte
0000126E  6700 0016                363              BEQ         opORIB              ; Branch to ORIB to print and deal with the byte
00001272  B43C 0001                364              CMP.B       #one,D2             ; Compare size to one
00001276  6700 0074                365              BEQ         opORIW              ; If size is one, then ORI is dealing with a word.
0000127A  B43C 0002                366              CMP.B       #two,D2             ; Compare size to two
0000127E  6700 00D2                367              BEQ         opORIL              ; If size is two then move onto deal with long in opORIL
00001282                           368          
00001282  6000 29EA                369              BRA         printInvalid        ; None matches, invalid code. Branch off.
00001286                           370          
00001286                           371  opORIB      
00001286  43F9 00003D77            372              LEA         dispByte, A1        ; Display byte
0000128C  103C 000E                373              MOVE.B      #14, D0             ; command for trap call to display message
00001290  4E4F                     374              TRAP        #15                 ; trap call
00001292                           375          
00001292  43F9 00003CDD            376              LEA         space, A1           ; Display space
00001298  103C 000E                377              MOVE.B      #14, D0             ; command for trap call to display message
0000129C  4E4F                     378              TRAP        #15                 ; trap call
0000129E                           379          
0000129E  4244                     380              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
000012A0  1801                     381              MOVE.B      D1,D4               ; Move byte over to D4 to use
000012A2  E644                     382              ASR         #three,D4           ; Moves out insignifcant bits to find mode
000012A4  C87C 0007                383              AND         #seven,D4           ; Clear other bits besides mode
000012A8  4245                     384              CLR         D5                  ; Use D5 as temporary register for destination regsiter
000012AA  1A01                     385              MOVE.B      D1,D5               ; Move data over to isolate mode
000012AC  CA7C 0007                386              AND         #seven,D5           ; Isolate the mode
000012B0                           387          
000012B0  4243                     388              CLR         D3                  ; Clear D3 to move register into it
000012B2  4242                     389              CLR         D2                  ; Clear D2 to move mode into it
000012B4  163C 0004                390              MOVE.B      #four,D3            ; Set values to be used in printEA
000012B8  143C 0007                391              MOVE.B      #seven,D2           ; Set values to be used in printEA
000012BC                           392      
000012BC  4EB9 00002F02            393              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000012C2                           394          
000012C2  43F9 00003CE4            395              LEA         comma, A1           ; Display space
000012C8  103C 000E                396              MOVE.B      #14, D0             ; command for trap call to display message
000012CC  4E4F                     397              TRAP        #15                 ; trap call
000012CE                           398          
000012CE  4242                     399              CLR         D2                  ; Clear out D2 to move destination mode in
000012D0  4243                     400              CLR         D3                  ; Clear out D3 to move destintion register in
000012D2  1404                     401              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
000012D4  1605                     402              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA
000012D6                           403          
000012D6  4EB9 00002F02            404              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000012DC                           405          
000012DC  43F9 00003CD9            406              LEA         newLine, A1           ; Display space
000012E2  103C 000E                407              MOVE.B      #14, D0             ; command for trap call to display message
000012E6  4E4F                     408              TRAP        #15                 ; trap call
000012E8                           409          
000012E8  6000 FD62                410              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000012EC                           411          
000012EC                           412  opORIW      
000012EC  43F9 00003D7A            413              LEA         dispWord, A1        ; Display byte
000012F2  103C 000E                414              MOVE.B      #14, D0             ; command for trap call to display message
000012F6  4E4F                     415              TRAP        #15                 ; trap call
000012F8                           416          
000012F8  43F9 00003CDD            417              LEA         space, A1           ; Display space
000012FE  103C 000E                418              MOVE.B      #14, D0             ; command for trap call to display message
00001302  4E4F                     419              TRAP        #15                 ; trap call
00001304                           420          
00001304  4244                     421              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
00001306  1801                     422              MOVE.B      D1,D4               ; Move byte over to D4 to use
00001308  E644                     423              ASR         #three,D4           ; Moves out insignifcant bits to find mode
0000130A  C87C 0007                424              AND         #seven,D4           ; Clear other bits besides mode
0000130E  4245                     425              CLR         D5                  ; Use D5 as temporary register for destination regsiter
00001310  1A01                     426              MOVE.B      D1,D5               ; Move data over to isolate mode
00001312  CA7C 0007                427              AND         #seven,D5           ; Isolate the mode
00001316                           428          
00001316  4243                     429              CLR         D3                  ; Clear D3 to move register into it
00001318  4242                     430              CLR         D2                  ; Clear D2 to move mode into it
0000131A  163C 0004                431              MOVE.B      #four,D3            ; Set values to be used in printEA
0000131E  143C 0007                432              MOVE.B      #seven,D2           ; Set values to be used in printEA
00001322                           433          
00001322  4EB9 00002F02            434              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001328                           435          
00001328  43F9 00003CE4            436              LEA         comma, A1           ; Display space
0000132E  103C 000E                437              MOVE.B      #14, D0             ; command for trap call to display message
00001332  4E4F                     438              TRAP        #15                 ; trap call
00001334                           439          
00001334  4242                     440              CLR         D2                  ; Clear out D2 to move destination mode in
00001336  4243                     441              CLR         D3                  ; Clear out D3 to move destintion register in
00001338  1404                     442              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
0000133A  1605                     443              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA
0000133C                           444                  
0000133C  4EB9 00002F02            445              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001342                           446          
00001342  43F9 00003CD9            447              LEA         newLine, A1           ; Display space
00001348  103C 000E                448              MOVE.B      #14, D0             ; command for trap call to display message
0000134C  4E4F                     449              TRAP        #15                 ; trap call
0000134E                           450          
0000134E  6000 FCFC                451              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001352                           452       
00001352                           453  opORIL      
00001352  43F9 00003D7D            454              LEA         dispLong, A1        ; Display byte
00001358  103C 000E                455              MOVE.B      #14, D0             ; command for trap call to display message
0000135C  4E4F                     456              TRAP        #15                 ; trap call
0000135E                           457          
0000135E  43F9 00003CDD            458              LEA         space, A1           ; Display space
00001364  103C 000E                459              MOVE.B      #14, D0             ; command for trap call to display message
00001368  4E4F                     460              TRAP        #15                 ; trap call
0000136A                           461          
0000136A  4244                     462              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
0000136C  1801                     463              MOVE.B      D1,D4               ; Move byte over to D4 to use
0000136E  E644                     464              ASR         #three,D4           ; Moves out insignifcant bits to find mode
00001370  C87C 0007                465              AND         #seven,D4           ; Clear other bits besides mode
00001374  4245                     466              CLR         D5                  ; Use D5 as temporary register for destination regsiter
00001376  1A01                     467              MOVE.B      D1,D5               ; Move data over to isolate mode
00001378  CA7C 0007                468              AND         #seven,D5           ; Isolate the mode
0000137C                           469          
0000137C  4243                     470              CLR         D3                  ; Clear D3 to move register into it
0000137E  4242                     471              CLR         D2                  ; Clear D2 to move mode into it
00001380  163C 0004                472              MOVE.B      #four,D3            ; Set values to be used in printEA
00001384  143C 0007                473              MOVE.B      #seven,D2           ; Set values to be used in printEA
00001388                           474          
00001388  4EB9 00002F02            475              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000138E                           476          
0000138E  4242                     477              CLR         D2                  ; Clear out D2 to move destination mode in
00001390  4243                     478              CLR         D3                  ; Clear out D3 to move destintion register in
00001392  1404                     479              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
00001394  1605                     480              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA
00001396                           481          
00001396  43F9 00003CE4            482              LEA         comma, A1           ; Display space
0000139C  103C 000E                483              MOVE.B      #14, D0             ; command for trap call to display message
000013A0  4E4F                     484              TRAP        #15                 ; trap call
000013A2                           485          
000013A2  4EB9 00002F02            486              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000013A8                           487          
000013A8  43F9 00003CD9            488              LEA         newLine, A1           ; Display space
000013AE  103C 000E                489              MOVE.B      #14, D0             ; command for trap call to display message
000013B2  4E4F                     490              TRAP        #15                 ; trap call
000013B4                           491          
000013B4  6000 FC96                492              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000013B8                           493          
000013B8                           494  ***********************************************************************************************************
000013B8                           495  *
000013B8                           496  *                   CMPI OPCODE
000013B8                           497  *       This section is dedicated to the compare (CMPI) instruction. Its determined in the control loop
000013B8                           498  *       that the first nibble is 0 for CMPI, and the second nibble is 12.
000013B8                           499  *       The type of CMPI, or the opmode, is used to determined what we output to our console next.
000013B8                           500  *       From that point, we load the correct size/opmode, and then route to the EA subroutine to output
000013B8                           501  *       EA related register information.
000013B8                           502  *       The process for finding the operand register info (EA info) is similar for all opmodes.
000013B8                           503  *
000013B8                           504  ***********************************************************************************************************
000013B8                           505          
000013B8                           506  opCMPI           
000013B8  1218                     507              MOVE.B      (A0)+, D1
000013BA  1401                     508              MOVE.B      D1,D2               ; copy data over
000013BC  EC42                     509              ASR         #6,D2               ; shifts 6 bits over to read just the size        
000013BE  B43C 0000                510              CMP.B       #zero,D2            ; Check if size is 0 which is byte
000013C2  6700 0016                511              BEQ         opCMPIB             ; Moves to CMPIB if it is 0
000013C6  B43C 0001                512              CMP.B       #one,D2             ; Check if size is 0 which is word
000013CA  6700 0080                513              BEQ         opCMPIW             ; Branch to CMPIW
000013CE  B43C 0002                514              CMP.B       #two,D2             ; Check if size is 2 which is long
000013D2  6700 00FC                515              BEQ         opCMPIL             ; Branch to CMPIL
000013D6  6000 21A2                516              BRA         invalid             ; Size is invalid, therefore code is invalid.
000013DA                           517  
000013DA                           518  opCMPIB 
000013DA  43F9 00003CF2            519              LEA         CMPImatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
000013E0  103C 000E                520              MOVE.B      #14, D0             ; command for trap call to display message
000013E4  4E4F                     521              TRAP        #15                 ; trap call
000013E6                           522          
000013E6  43F9 00003D77            523              LEA         dispByte, A1        ; Display byte
000013EC  103C 000E                524              MOVE.B      #14, D0             ; command for trap call to display message
000013F0  4E4F                     525              TRAP        #15                 ; trap call
000013F2                           526          
000013F2  43F9 00003CDD            527              LEA         space, A1           ; Display space
000013F8  103C 000E                528              MOVE.B      #14, D0             ; command for trap call to display message
000013FC  4E4F                     529              TRAP        #15                 ; trap call
000013FE                           530          
000013FE  4244                     531              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
00001400  1801                     532              MOVE.B      D1,D4               ; Move byte over to D4 to use
00001402  E644                     533              ASR         #three,D4           ; Moves out insignifcant bits to find mode
00001404  C87C 0007                534              AND         #seven,D4           ; Clear other bits besides mode
00001408  4245                     535              CLR         D5                  ; Use D5 as temporary register for destination regsiter
0000140A  1A01                     536              MOVE.B      D1,D5               ; Move data over to isolate mode
0000140C  CA7C 0007                537              AND         #seven,D5           ; Isolate the mode
00001410                           538          
00001410  4243                     539              CLR         D3                  ; Clear D3 to move register into it
00001412  4242                     540              CLR         D2                  ; Clear D2 to move mode into it
00001414  163C 0004                541              MOVE.B      #four,D3            ; Set values to be used in printEA
00001418  143C 0007                542              MOVE.B      #seven,D2           ; Set values to be used in printEA  
0000141C                           543          
0000141C  4EB9 00002F02            544              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001422                           545              
00001422  43F9 00003CE4            546              LEA         comma, A1           ; Display space
00001428  103C 000E                547              MOVE.B      #14, D0             ; command for trap call to display message
0000142C  4E4F                     548              TRAP        #15                 ; trap call
0000142E                           549          
0000142E  4242                     550              CLR         D2                  ; Clear out D2 to move destination mode in
00001430  4243                     551              CLR         D3                  ; Clear out D3 to move destintion register in
00001432  1404                     552              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
00001434  1605                     553              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA    
00001436                           554          
00001436  4EB9 00002F02            555              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000143C                           556          
0000143C  43F9 00003CD9            557              LEA         newLine, A1         ; Display space
00001442  103C 000E                558              MOVE.B      #14, D0             ; command for trap call to display message
00001446  4E4F                     559              TRAP        #15                 ; trap call
00001448                           560  
00001448  6000 FC02                561              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
0000144C                           562  
0000144C                           563  opCMPIW 
0000144C  43F9 00003CF2            564              LEA         CMPImatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
00001452  103C 000E                565              MOVE.B      #14, D0             ; command for trap call to display message
00001456  4E4F                     566              TRAP        #15                 ; trap call
00001458                           567          
00001458  43F9 00003D7A            568              LEA         dispWord, A1        ; Display byte
0000145E  103C 000E                569              MOVE.B      #14, D0             ; command for trap call to display message
00001462  4E4F                     570              TRAP        #15                 ; trap call
00001464                           571          
00001464  43F9 00003CDD            572              LEA         space, A1           ; Display space
0000146A  103C 000E                573              MOVE.B      #14, D0             ; command for trap call to display message
0000146E  4E4F                     574              TRAP        #15                 ; trap call
00001470                           575          
00001470  4244                     576              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
00001472  1801                     577              MOVE.B      D1,D4               ; Move byte over to D4 to use
00001474  E644                     578              ASR         #three,D4           ; Moves out insignifcant bits to find mode
00001476  C87C 0007                579              AND         #seven,D4           ; Clear other bits besides mode
0000147A  4245                     580              CLR         D5                  ; Use D5 as temporary register for destination regsiter
0000147C  1A01                     581              MOVE.B      D1,D5               ; Move data over to isolate mode
0000147E  CA7C 0007                582              AND         #seven,D5           ; Isolate the mode
00001482                           583          
00001482  4243                     584              CLR         D3                  ; Clear D3 to move register into it
00001484  4242                     585              CLR         D2                  ; Clear D2 to move mode into it
00001486  163C 0004                586              MOVE.B      #four,D3            ; Set values to be used in printEA
0000148A  143C 0007                587              MOVE.B      #seven,D2           ; Set values to be used in printEA      
0000148E                           588          
0000148E  4EB9 00002F02            589              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001494                           590          
00001494  43F9 00003CE0            591              LEA         hashTag, A1         ; Display space
0000149A  103C 000E                592              MOVE.B      #14, D0             ; command for trap call to display message
0000149E  4E4F                     593              TRAP        #15                 ; trap call
000014A0                           594          
000014A0  103C 0003                595              MOVE.B      #3, D0              ; Move 3 into D0 to output
000014A4  4E4F                     596              TRAP        #15                 ; Use TRAP #15 to output the immediate data
000014A6                           597          
000014A6  43F9 00003CE4            598              LEA         comma, A1           ; Display space
000014AC  103C 000E                599              MOVE.B      #14, D0             ; command for trap call to display message
000014B0  4E4F                     600              TRAP        #15                 ; trap call
000014B2                           601  
000014B2  4242                     602              CLR         D2                  ; Clear out D2 to move destination mode in
000014B4  4243                     603              CLR         D3                  ; Clear out D3 to move destintion register in
000014B6  1404                     604              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
000014B8  1605                     605              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA    
000014BA                           606          
000014BA  4EB9 00002F02            607              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000014C0                           608          
000014C0  43F9 00003CD9            609              LEA         newLine, A1           ; Display space
000014C6  103C 000E                610              MOVE.B      #14, D0             ; command for trap call to display message
000014CA  4E4F                     611              TRAP        #15                 ; trap call
000014CC  6000 FB7E                612              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000014D0                           613  
000014D0                           614  opCMPIL 
000014D0  43F9 00003CF2            615              LEA         CMPImatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
000014D6  103C 000E                616              MOVE.B      #14, D0             ; command for trap call to display message
000014DA  4E4F                     617              TRAP        #15                 ; trap call
000014DC                           618          
000014DC  43F9 00003D7D            619              LEA         dispLong, A1        ; Display byte
000014E2  103C 000E                620              MOVE.B      #14, D0             ; command for trap call to display message
000014E6  4E4F                     621              TRAP        #15                 ; trap call
000014E8                           622          
000014E8  43F9 00003CDD            623              LEA         space, A1           ; Display space
000014EE  103C 000E                624              MOVE.B      #14, D0             ; command for trap call to display message
000014F2  4E4F                     625              TRAP        #15                 ; trap call
000014F4                           626              
000014F4  4244                     627              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
000014F6  1801                     628              MOVE.B      D1,D4               ; Move byte over to D4 to use
000014F8  E644                     629              ASR         #three,D4           ; Moves out insignifcant bits to find mode
000014FA  C87C 0007                630              AND         #seven,D4           ; Clear other bits besides mode
000014FE  4245                     631              CLR         D5                  ; Use D5 as temporary register for destination regsiter
00001500  1A01                     632              MOVE.B      D1,D5               ; Move data over to isolate mode
00001502  CA7C 0007                633              AND         #seven,D5           ; Isolate the mode
00001506                           634          
00001506  4243                     635              CLR         D3                  ; Clear D3 to move register into it
00001508  4242                     636              CLR         D2                  ; Clear D2 to move mode into it
0000150A  163C 0004                637              MOVE.B      #four,D3            ; Set values to be used in printEA
0000150E  143C 0007                638              MOVE.B      #seven,D2           ; Set values to be used in printEA  
00001512                           639          
00001512  4EB9 00002F02            640              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001518                           641          
00001518  43F9 00003CE4            642              LEA         comma, A1           ; Display space
0000151E  103C 000E                643              MOVE.B      #14, D0             ; command for trap call to display message
00001522  4E4F                     644              TRAP        #15                 ; trap call
00001524                           645          
00001524  4242                     646              CLR         D2                  ; Clear out D2 to move destination mode in
00001526  4243                     647              CLR         D3                  ; Clear out D3 to move destintion register in
00001528  1404                     648              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
0000152A  1605                     649              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA                
0000152C                           650          
0000152C  4EB9 00002F02            651              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001532                           652          
00001532  43F9 00003CD9            653              LEA         newLine, A1         ; Display space
00001538  103C 000E                654              MOVE.B      #14, D0             ; command for trap call to display message
0000153C  4E4F                     655              TRAP        #15                 ; trap call
0000153E                           656          
0000153E  6000 FB0C                657              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001542                           658          
00001542                           659  ***********************************************************************************************************
00001542                           660  *
00001542                           661  *                   BCLR OPCODE
00001542                           662  *       This section is dedicated to the compare BCLR instruction. The first nibble is 0 and the second
00001542                           663  *       nibble is 2. Once both checks are passed then code goes to print BCLR and its EA.
00001542                           664  *       
00001542                           665  ***********************************************************************************************************
00001542                           666  
00001542                           667  opBCLR      
00001542  43F9 00003CF7            668              LEA         BCLRmatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
00001548  103C 000E                669              MOVE.B      #14, D0             ; command for trap call to display message
0000154C  4E4F                     670              TRAP        #15                 ; trap call
0000154E                           671  
0000154E  43F9 00003CDD            672              LEA         space, A1           ; Display space
00001554  103C 000E                673              MOVE.B      #14, D0             ; command for trap call to display message
00001558  4E4F                     674              TRAP        #15                 ; trap call
0000155A                           675                  
0000155A  4242                     676              CLR         D2                  ; Clear data register
0000155C  1218                     677              MOVE.B      (A0)+, D1           ; Move byte over to D1 to be used
0000155E  1401                     678              MOVE.B      D1,D2               ; copy data over
00001560  E642                     679              ASR         #three,D2           ; Shift to the right to remove register
00001562  C47C 0007                680              AND         #seven,D2           ; Sets other bits to 0 and leave Mode the same
00001566                           681                  
00001566  4243                     682              CLR         D3                  ; Clear D3 so we can move D1 in
00001568  1601                     683              MOVE.B      D1,D3               ; Move othr byte in
0000156A  C67C 0007                684              AND         #seven,D3           ; Set everything besides register to 0
0000156E                           685                 
0000156E  4241                     686              CLR         D1                  ; Clear out data register
00001570  3218                     687              MOVE.W      (A0)+, D1           ; Take in next nibble that contains data
00001572                           688                 
00001572                           689                  
00001572  43F9 00003CE0            690              LEA         hashTag, A1         ; Display space
00001578  103C 000E                691              MOVE.B      #14, D0             ; command for trap call to display message
0000157C  4E4F                     692              TRAP        #15                 ; trap call
0000157E                           693          
0000157E  103C 0003                694              MOVE.B      #3, D0
00001582  4E4F                     695              TRAP        #15
00001584                           696          
00001584  43F9 00003CE4            697              LEA         comma, A1           ; Display space
0000158A  103C 000E                698              MOVE.B      #14, D0             ; command for trap call to display message
0000158E  4E4F                     699              TRAP        #15                 ; trap call
00001590                           700                  
00001590  4EB9 00002F02            701              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001596                           702          
00001596  43F9 00003CD9            703              LEA         newLine, A1           ; Display space
0000159C  103C 000E                704              MOVE.B      #14, D0             ; command for trap call to display message
000015A0  4E4F                     705              TRAP        #15                 ; trap call
000015A2                           706                  
000015A2  6000 FAA8                707              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits   
000015A6                           708          
000015A6                           709  opDynBCLR       
000015A6  4241                     710              CLR         D1
000015A8  1218                     711              MOVE.B      (A0)+,D1            ; Copy second byte in
000015AA  1601                     712              MOVE.B      D1,D3               ; Will use D4 to store in the source register
000015AC  E243                     713              ASR         #one,D3             ; Shift register over to the end
000015AE  C67C 0007                714              AND         #seven,D3           ; Change all bits except for the register to 0. Source Register is now in D4
000015B2                           715                  
000015B2  1401                     716              MOVE.B      D1,D2
000015B4  EC42                     717              ASR         #six,D2             ; Removing mode and register to check BCLR bits
000015B6  B47C 0002                718              CMP         #two,D2             ; Checking the static bits to make sure it is BCLR
000015BA  6600 26B2                719              BNE         printInvalid        ; If not equal, than this is not BCLR or any other mode we're dealing with
000015BE                           720  
000015BE                           721                  
000015BE  43F9 00003CF7            722              LEA         BCLRmatch, A1       ; we now know that the opcode will be BCLR, so load A1 to print message
000015C4  103C 000E                723              MOVE.B      #14, D0             ; command for trap call to display message
000015C8  4E4F                     724              TRAP        #15                 ; trap call  
000015CA                           725                  
000015CA  43F9 00003CDD            726              LEA         space, A1           ; Display space
000015D0  103C 000E                727              MOVE.B      #14, D0             ; command for trap call to display message
000015D4  4E4F                     728              TRAP        #15                 ; trap call
000015D6                           729                  
000015D6  143C 0000                730              MOVE.B      #zero,D2            ; Move 0 into D2 to print out data register in printEA   
000015DA  4EB9 00002F02            731              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000015E0                           732                  
000015E0  43F9 00003CE4            733              LEA         comma, A1           ; Display space
000015E6  103C 000E                734              MOVE.B      #14, D0             ; command for trap call to display message
000015EA  4E4F                     735              TRAP        #15                 ; trap call
000015EC                           736                
000015EC  4242                     737              CLR         D2
000015EE  1401                     738              MOVE.B      D1,D2               ; Using D2 to store EA mode
000015F0  E642                     739              ASR         #three,D2           ; Remove/shift the register out
000015F2  C47C 0007                740              AND         #seven,D2           ; Change all bits except for the mode bits to 0
000015F6                           741                  
000015F6  4243                     742              CLR         D3                  ; Clearing D3 to avoid mashing data
000015F8  1601                     743              MOVE.B      D1,D3               ; Moving byte into D3. Using D3 to store EA register
000015FA  C67C 0007                744              AND         #seven,D3           ; Change all bits except for register bits to 0
000015FE                           745              
000015FE  4EB9 00002F02            746              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001604                           747          
00001604  43F9 00003CD9            748              LEA         newLine, A1         ; Display space
0000160A  103C 000E                749              MOVE.B      #14, D0             ; command for trap call to display message
0000160E  4E4F                     750              TRAP        #15                 ; trap call            
00001610                           751  
00001610                           752  
00001610  6000 FA3A                753              BRA         LOOP                ; go back to the loop   
00001614                           754                  
00001614                           755  ***********************************************************************************************************
00001614                           756  *
00001614                           757  *                   MOVE OPCODE
00001614                           758  *                   MOVEA OPCODE
00001614                           759  *       This section of code is dedication to MOVE and MOVEA opcode instructions. MOVEA is determined by
00001614                           760  *       its static bits at 8, 7, and 6. Once those static bits are confirmed, the code branches off to 
00001614                           761  *       MOVEA, else it continues into MOVE.
00001614                           762  *
00001614                           763  ***********************************************************************************************************
00001614                           764   
00001614                           765  opMOVEB 
00001614  43F9 00003CFC            766              LEA         MOVEmatch, A1       ; we know that the opcode will be MOVE.B, so load A1 to print message
0000161A  103C 000E                767              MOVE.B      #14, D0             ; command for trap call to display message
0000161E  4E4F                     768              TRAP        #15                 ; trap call
00001620  43F9 00003D77            769              LEA         dispByte, A1        ; display byte
00001626  103C 000E                770              MOVE.B      #14, D0             ; command for trap call to display message
0000162A  4E4F                     771              TRAP        #15                 ; trap call
0000162C  43F9 00003CDD            772              LEA         space, A1           ; create spaces
00001632  103C 000E                773              MOVE.B      #14, D0             ; command for trap call to display message
00001636  4E4F                     774              TRAP        #15                 ; trap call
00001638                           775          
00001638                           776          
00001638  4245                     777              CLR         D5                  ; Clear D5
0000163A  1A01                     778              MOVE.B      D1,D5               ; Copying byte over to D5. Will use D5 to store destination Register
0000163C  E245                     779              ASR         #one,D5             ; shifted mode out. Register is now stored into D5
0000163E  CA7C 0007                780              AND         #seven,D5
00001642                           781          
00001642  4244                     782              CLR         D4                  ; Clear out D4
00001644  1801                     783              MOVE.B      D1,D4               ; Copy byte over to store destination mode
00001646  C87C 0001                784              AND         #one,D4             ; Set all the other bits to 0, leave the bit for the destination mode alone.
0000164A                           785          
0000164A  4241                     786              CLR          D1                 ; Clear data register
0000164C  4242                     787              CLR          D2                 ; Clear data register
0000164E  1218                     788              MOVE.B      (A0)+,D1            ; Copy byte into D1
00001650  1401                     789              MOVE.B      D1,D2
00001652  EC42                     790              ASR         #6,D2               ; Shifts source mode and register out to get destination mode
00001654  D842                     791              ADD         D2,D4               ; Adds the remaining bits to D4
00001656                           792          
00001656  4242                     793              CLR         D2                  ; Clear data register
00001658  1401                     794              MOVE.B      D1,D2               ; Copy new byte over to D2
0000165A  E642                     795              ASR         #three,D2           ; Shift source register out
0000165C  C47C 0007                796              AND         #seven,D2           ; Set everything to 0 except for the mode
00001660                           797          
00001660  4243                     798              CLR         D3                  ; Clear Data register 3
00001662  1601                     799              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
00001664  C67C 0007                800              AND         #seven,D3           ; Sets up everything to 0 except for the register bits
00001668                           801          
00001668  4EB9 00002F02            802              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000166E                           803          
0000166E  43F9 00003CE4            804              LEA         comma, A1           ; Display space
00001674  103C 000E                805              MOVE.B      #14, D0             ; command for trap call to display message
00001678  4E4F                     806              TRAP        #15                 ; trap call
0000167A                           807          
0000167A  4242                     808              CLR         D2                  ; Clear data register
0000167C  4243                     809              CLR         D3                  ; Clear data register
0000167E  1404                     810              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
00001680  1605                     811              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
00001682                           812          
00001682  4EB9 00002F02            813              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001688                           814          
00001688  43F9 00003CD9            815              LEA         newLine, A1         ; Display space
0000168E  103C 000E                816              MOVE.B      #14, D0             ; command for trap call to display message
00001692  4E4F                     817              TRAP        #15                 ; trap call            
00001694                           818  
00001694  6000 F9B6                819              BRA         LOOP                ; go back to the loop
00001698                           820          
00001698                           821  opMOVEL     
00001698  4245                     822              CLR         D5                  ; Clear D5
0000169A  1A01                     823              MOVE.B      D1,D5               ; Copying byte over to D5. Will use D5 to store destination Register
0000169C  E245                     824              ASR         #one,D5             ; shifted mode out. Register is now stored into D5
0000169E  CA7C 0007                825              AND         #seven,D5
000016A2                           826          
000016A2  4244                     827              CLR         D4                  ; Clear out D4
000016A4  1801                     828              MOVE.B      D1,D4               ; Copy byte over to store destination mode
000016A6  C87C 0001                829              AND         #one,D4             ; Set all the other bits to 0, leave the bit for the destination mode alone.
000016AA                           830          
000016AA  4241                     831              CLR          D1                 ; Clear data register
000016AC  4242                     832              CLR          D2                 ; Clear data register
000016AE  1218                     833              MOVE.B      (A0)+,D1            ; Copy byte into D1
000016B0  1401                     834              MOVE.B      D1,D2
000016B2  EC42                     835              ASR         #6,D2               ; Shifts source mode and register out to get destination mode
000016B4  D842                     836              ADD         D2,D4               ; Adds the remaining bits to D4
000016B6                           837          
000016B6  B87C 0001                838              CMP         #one,D4             ; Check if it is MOVEA
000016BA  6700 0070                839              BEQ         opMOVEAL            ; If it is, branch off
000016BE                           840              
000016BE  43F9 00003CFC            841              LEA         MOVEmatch, A1       ; we know that the opcode will be MOVE.L OR MOVEA.L, so load A1 to print message
000016C4  103C 000E                842              MOVE.B      #14, D0             ; command for trap call to display message
000016C8  4E4F                     843              TRAP        #15                 ; trap call  
000016CA                           844              
000016CA  43F9 00003D7D            845              LEA         dispLong,A1         ; Prints out L to display a long
000016D0  103C 000E                846              MOVE.B      #14, D0             ; command for trap call to display message
000016D4  4E4F                     847              TRAP        #15                 ; trap call
000016D6                           848              
000016D6  43F9 00003CDD            849              LEA         space, A1           ; create spaces
000016DC  103C 000E                850              MOVE.B      #14, D0             ; command for trap call to display message
000016E0  4E4F                     851              TRAP        #15                 ; trap call
000016E2                           852          
000016E2  4242                     853              CLR         D2                  ; Clear data register
000016E4  1401                     854              MOVE.B      D1,D2               ; Copy new byte over to D2
000016E6  E642                     855              ASR         #three,D2           ; Shift source register out
000016E8  C47C 0007                856              AND         #seven,D2           ; Set everything to 0 except for the mode
000016EC                           857          
000016EC  4243                     858              CLR         D3                  ; Clear Data register 3
000016EE  1601                     859              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
000016F0  C67C 0007                860              AND         #seven,D3           ; Sets up everything to 0 except for the register bits      
000016F4                           861              
000016F4  4246                     862              CLR         D6                  ; Clear data register
000016F6  1C3C 0001                863              MOVE.B      #1,D6               ; Moves 1 into D6 to be used in printEA to display long
000016FA  4EB9 00002F02            864              JSR         printEA             ; Prints out EA
00001700  4246                     865              CLR         D6
00001702                           866              
00001702  43F9 00003CE4            867              LEA         comma, A1           ; Display comma
00001708  103C 000E                868              MOVE.B      #14, D0             ; command for trap call to display message
0000170C  4E4F                     869              TRAP        #15                 ; trap call
0000170E                           870          
0000170E  4242                     871              CLR         D2                  ; Clear data register            
00001710  4243                     872              CLR         D3                  ; Clear data register
00001712  1404                     873              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
00001714  1605                     874              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
00001716                           875          
00001716  4EB9 00002F02            876              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000171C                           877  
0000171C  43F9 00003CD9            878              LEA         newLine, A1         ; Display space
00001722  103C 000E                879              MOVE.B      #14, D0             ; command for trap call to display message
00001726  4E4F                     880              TRAP        #15                 ; trap call            
00001728                           881  
00001728  6000 F922                882              BRA         LOOP                ; go back to the loop
0000172C                           883              
0000172C                           884  opMOVEAL
0000172C  43F9 00003D01            885              LEA         MOVEAmatch,A1       ; MOVEA has been determined. Print out MOVEA
00001732  103C 000E                886              MOVE.B      #14, D0             ; command for trap call to display message
00001736  4E4F                     887              TRAP        #15                 ; trap call
00001738                           888              
00001738  43F9 00003D7D            889              LEA         dispLong,A1         ; Prints out L
0000173E  103C 000E                890              MOVE.B      #14, D0             ; command for trap call to display message
00001742  4E4F                     891              TRAP        #15                 ; trap call
00001744                           892              
00001744                           893  
00001744  43F9 00003CDD            894              LEA         space, A1           ; create spaces
0000174A  103C 000E                895              MOVE.B      #14, D0             ; command for trap call to display message
0000174E  4E4F                     896              TRAP        #15                 ; trap call
00001750                           897              
00001750  4242                     898              CLR         D2                  ; Clear data register
00001752  1401                     899              MOVE.B      D1,D2               ; Copy new byte over to D2
00001754  E642                     900              ASR         #three,D2           ; Shift source register out
00001756  C47C 0007                901              AND         #seven,D2           ; Set everything to 0 except for the mode
0000175A                           902          
0000175A  4243                     903              CLR         D3                  ; Clear Data register 3
0000175C  1601                     904              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
0000175E  C67C 0007                905              AND         #seven,D3           ; Sets up everything to 0 except for the register bits    
00001762                           906              
00001762  4241                     907              CLR         D1                  ; Clear D1
00001764                           908              
00001764  4EB9 00002F02            909              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000176A                           910              
0000176A  43F9 00003CE4            911              LEA         comma, A1           ; Display comma
00001770  103C 000E                912              MOVE.B      #14, D0             ; command for trap call to display message
00001774  4E4F                     913              TRAP        #15                 ; trap call
00001776                           914  
00001776  4242                     915              CLR         D2                  ; Clear data register
00001778  4243                     916              CLR         D3                  ; Clear data register
0000177A  1404                     917              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
0000177C  1605                     918              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
0000177E                           919          
0000177E  4EB9 00002F02            920              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001784                           921          
00001784  43F9 00003CD9            922              LEA         newLine, A1         ; Display space
0000178A  103C 000E                923              MOVE.B      #14, D0             ; command for trap call to display message
0000178E  4E4F                     924              TRAP        #15                 ; trap call            
00001790                           925  
00001790  6000 F8BA                926              BRA         LOOP                ; go back to the loop
00001794                           927  
00001794                           928  opMOVEW
00001794  4245                     929              CLR         D5                  ; Clear D5
00001796  1A01                     930              MOVE.B      D1,D5               ; Copying byte over to D5. Will use D5 to store destination Register
00001798  E245                     931              ASR         #one,D5             ; shifted mode out. Register is now stored into D5
0000179A  CA7C 0007                932              AND         #seven,D5
0000179E                           933          
0000179E  4244                     934              CLR         D4                  ; Clear out D4
000017A0  1801                     935              MOVE.B      D1,D4               ; Copy byte over to store destination mode
000017A2  C87C 0001                936              AND         #one,D4             ; Set all the other bits to 0, leave the bit for the destination mode alone.
000017A6                           937          
000017A6  4241                     938              CLR          D1                 ; Clear data register
000017A8  4242                     939              CLR          D2                 ; Clear data register
000017AA  1218                     940              MOVE.B      (A0)+,D1            ; Copy byte into D1
000017AC  1401                     941              MOVE.B      D1,D2
000017AE  EC42                     942              ASR         #6,D2               ; Shifts source mode and register out to get destination mode
000017B0  D842                     943              ADD         D2,D4               ; Adds the remaining bits to D4
000017B2                           944          
000017B2  B87C 0001                945              CMP         #one,D4             ; Check if it is MOVEA
000017B6  6700 006A                946              BEQ         opMOVEAW            ; If it is, branch off
000017BA                           947              
000017BA  43F9 00003CFC            948              LEA         MOVEmatch, A1       ; we know that the opcode will be MOVE.L OR MOVEA.L, so load A1 to print message
000017C0  103C 000E                949              MOVE.B      #14, D0             ; command for trap call to display message
000017C4  4E4F                     950              TRAP        #15                 ; trap call  
000017C6                           951              
000017C6  43F9 00003D7A            952              LEA         dispWord,A1         ; Prints out a W after the opcode
000017CC  103C 000E                953              MOVE.B      #14, D0             ; command for trap call to display message
000017D0  4E4F                     954              TRAP        #15                 ; trap call
000017D2                           955              
000017D2  43F9 00003CDD            956              LEA         space, A1           ; create spaces
000017D8  103C 000E                957              MOVE.B      #14, D0             ; command for trap call to display message
000017DC  4E4F                     958              TRAP        #15                 ; trap call
000017DE                           959          
000017DE  4242                     960              CLR         D2
000017E0  1401                     961              MOVE.B      D1,D2               ; Copy new byte over to D2
000017E2  E642                     962              ASR         #three,D2           ; Shift source register out
000017E4  C47C 0007                963              AND         #seven,D2           ; Set everything to 0 except for the mode
000017E8                           964          
000017E8  4243                     965              CLR         D3                  ; Clear Data register 3
000017EA  1601                     966              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
000017EC  C67C 0007                967              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
000017F0                           968              
000017F0  4241                     969              CLR         D1                  ; Clear D1
000017F2                           970              
000017F2  4EB9 00002F02            971              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000017F8                           972              
000017F8  43F9 00003CE4            973              LEA         comma, A1           ; Display comma
000017FE  103C 000E                974              MOVE.B      #14, D0             ; command for trap call to display message
00001802  4E4F                     975              TRAP        #15                 ; trap call
00001804                           976          
00001804  4242                     977              CLR         D2                  ; Clear data register 
00001806  4243                     978              CLR         D3                  ; Clear data register
00001808  1404                     979              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
0000180A  1605                     980              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
0000180C  4EB9 00002F02            981              JSR         printEA
00001812                           982          
00001812  43F9 00003CD9            983              LEA         newLine, A1         ; Display space
00001818  103C 000E                984              MOVE.B      #14, D0             ; command for trap call to display message
0000181C  4E4F                     985              TRAP        #15                 ; trap call            
0000181E                           986  
0000181E  6000 F82C                987              BRA         LOOP                ; go back to the loop
00001822                           988              
00001822                           989  opMOVEAW  
00001822  43F9 00003D01            990              LEA         MOVEAmatch,A1       ; Prints out MOVEA
00001828  103C 000E                991              MOVE.B      #14, D0             ; command for trap call to display message
0000182C  4E4F                     992              TRAP        #15                 ; trap call
0000182E                           993                  
0000182E  43F9 00003D7A            994              LEA         dispWord,A1         ; Prints out W
00001834  103C 000E                995              MOVE.B      #14, D0             ; command for trap call to display message
00001838  4E4F                     996              TRAP        #15                 ; trap call
0000183A                           997              
0000183A  43F9 00003CDD            998              LEA         space, A1           ; create spaces
00001840  103C 000E                999              MOVE.B      #14, D0             ; command for trap call to display message
00001844  4E4F                    1000              TRAP        #15                 ; trap call
00001846                          1001              
00001846  4242                    1002              CLR         D2                  ; Clear data register
00001848  1401                    1003              MOVE.B      D1,D2               ; Copy new byte over to D2
0000184A  E642                    1004              ASR         #three,D2           ; Shift source register out
0000184C  C47C 0007               1005              AND         #seven,D2           ; Set everything to 0 except for the mode
00001850                          1006          
00001850  4243                    1007              CLR         D3                  ; Clear Data register 3
00001852  1601                    1008              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
00001854  C67C 0007               1009              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
00001858                          1010              
00001858  4241                    1011              CLR         D1                  ; Clear D1      
0000185A                          1012              
0000185A  4EB9 00002F02           1013              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001860                          1014              
00001860  43F9 00003CE4           1015              LEA         comma, A1           ; Display comma
00001866  103C 000E               1016              MOVE.B      #14, D0             ; command for trap call to display message
0000186A  4E4F                    1017              TRAP        #15                 ; trap call
0000186C                          1018  
0000186C  4242                    1019              CLR         D2                  ; Clear data register
0000186E  4243                    1020              CLR         D3                  ; Clear data register
00001870  1404                    1021              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
00001872  1605                    1022              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
00001874                          1023          
00001874  4EB9 00002F02           1024              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000187A                          1025          
0000187A  43F9 00003CD9           1026              LEA         newLine, A1         ; Display space
00001880  103C 000E               1027              MOVE.B      #14, D0             ; command for trap call to display message
00001884  4E4F                    1028              TRAP        #15                 ; trap call            
00001886                          1029  
00001886  6000 F7C4               1030              BRA         LOOP                ; go back to the loop
0000188A                          1031  
0000188A                          1032  ***********************************************************************************************************
0000188A                          1033  *
0000188A                          1034  *                   NEG OPCODE
0000188A                          1035  *       This section is dedicated to the NEG opmode instruction. NEG is determined by the first and
0000188A                          1036  *       the second nibble. The first nibble is 4 and the second nibble is equal to 0. Once that has been
0000188A                          1037  *       determined. NEG is printed out.
0000188A                          1038  ***********************************************************************************************************
0000188A                          1039  
0000188A                          1040  opNEG   
0000188A  43F9 00003D07           1041              LEA         NEGmatch, A1        ; we know that the opcode will be NEG, so load A1 to print message
00001890  103C 000E               1042              MOVE.B      #14, D0             ; command for trap call to display message
00001894  4E4F                    1043              TRAP        #15                 ; trap call
00001896                          1044          
00001896                          1045          
00001896  1218                    1046              MOVE.B      (A0)+, D1           ; Move data into D1 for use 
00001898  1401                    1047              MOVE.B      D1,D2               ; copy data over
0000189A  EC42                    1048              ASR         #six,D2             ; Moves six bits over to read the size
0000189C                          1049              
0000189C  B47C 0000               1050              CMP         #zero,D2            ; Compare size
000018A0  6700 0016               1051              BEQ         opNEGB              ; Branch to NEG if size is byte
000018A4  B47C 0001               1052              CMP         #one,D2             ; Compare size with one, 
000018A8  6700 008E               1053              BEQ         opNEGW              ; If equal, size is a word. Branch to NEGW
000018AC  B47C 0002               1054              CMP         #two,D2             ; Compare size with two
000018B0  6700 0046               1055              BEQ         opNEGL              ; If size is two, NEG size is long. Branch to NEGL
000018B4  6000 1CC4               1056              BRA         invalid             ; If size is neither, code is invalid. Branch to deal with invalid code.
000018B8                          1057              
000018B8                          1058  opNEGB
000018B8  43F9 00003D77           1059              LEA         dispByte, A1        ; we know that the opcode will be NEG, so load A1 to print message
000018BE  103C 000E               1060              MOVE.B      #14, D0             ; command for trap call to display message
000018C2  4E4F                    1061              TRAP        #15                 ; trap call
000018C4                          1062          
000018C4  43F9 00003CDD           1063              LEA         space, A1           ; we know that the opcode will be NEG, so load A1 to print message
000018CA  103C 000E               1064              MOVE.B      #14, D0             ; command for trap call to display message
000018CE  4E4F                    1065              TRAP        #15                 ; trap call
000018D0                          1066          
000018D0  4242                    1067              CLR         D2                  ; Clear Data register 2
000018D2  3401                    1068              MOVE        D1,D2               ; Move byte into D2
000018D4  E642                    1069              ASR         #three,D2           ; Shift mode into place and moves mode into place
000018D6  C47C 0007               1070              AND         #seven,D2           ; Stores mode
000018DA                          1071              
000018DA  4243                    1072              CLR         D3                  ; Clear Data register 3
000018DC  1601                    1073              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
000018DE  C67C 0007               1074              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
000018E2                          1075              
000018E2  4EB9 00002F02           1076              JSR         printEA
000018E8                          1077                  
000018E8  43F9 00003CD9           1078              LEA         newLine, A1         ; Display space
000018EE  103C 000E               1079              MOVE.B      #14, D0             ; command for trap call to display message
000018F2  4E4F                    1080              TRAP        #15                 ; trap call  
000018F4                          1081          
000018F4  6000 F756               1082              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000018F8                          1083  
000018F8                          1084  opNEGL
000018F8  43F9 00003D7D           1085              LEA         dispLong, A1        ; we know that the opcode will be NEG, so load A1 to print message
000018FE  103C 000E               1086              MOVE.B      #14, D0             ; command for trap call to display message
00001902  4E4F                    1087              TRAP        #15                 ; trap call
00001904                          1088  
00001904  43F9 00003CDD           1089              LEA         space, A1           ; we know that the opcode will be NEG, so load A1 to print message
0000190A  103C 000E               1090              MOVE.B      #14, D0             ; command for trap call to display message
0000190E  4E4F                    1091              TRAP        #15                 ; trap call
00001910                          1092                  
00001910  4242                    1093              CLR         D2                  ; Clear Data register 2
00001912  3401                    1094              MOVE        D1,D2               ; Move byte into D2
00001914  E642                    1095              ASR         #three,D2           ; Shift mode into place and moves mode into place
00001916  C47C 0007               1096              AND         #seven,D2           ; Stores mode
0000191A                          1097          
0000191A  4243                    1098              CLR         D3                  ; Clear Data register 3
0000191C  1601                    1099              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
0000191E  C67C 0007               1100              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
00001922                          1101          
00001922  4EB9 00002F02           1102              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001928                          1103                      
00001928  43F9 00003CD9           1104              LEA         newLine, A1         ; Display space
0000192E  103C 000E               1105              MOVE.B      #14, D0             ; command for trap call to display message
00001932  4E4F                    1106              TRAP        #15                 ; trap call  
00001934                          1107          
00001934  6000 F716               1108              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001938                          1109  
00001938                          1110  opNEGW
00001938  43F9 00003D7A           1111              LEA         dispWord, A1        ; we know that the opcode will be NEG, so load A1 to print message
0000193E  103C 000E               1112              MOVE.B      #14, D0             ; command for trap call to display message
00001942  4E4F                    1113              TRAP        #15                 ; trap call
00001944                          1114          
00001944  43F9 00003CDD           1115              LEA         space, A1           ; we know that the opcode will be NEG, so load A1 to print message
0000194A  103C 000E               1116              MOVE.B      #14, D0             ; command for trap call to display message
0000194E  4E4F                    1117              TRAP        #15                 ; trap call        
00001950                          1118                  
00001950  4242                    1119              CLR         D2                  ; Clear Data register 2
00001952  3401                    1120              MOVE        D1,D2               ; Move byte into D2
00001954  E642                    1121              ASR         #three,D2           ; Shift mode into place and moves mode into place
00001956  C47C 0007               1122              AND         #seven,D2           ; Stores mode
0000195A                          1123          
0000195A  4243                    1124              CLR         D3                  ; Clear Data register 3
0000195C  1601                    1125              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
0000195E  C67C 0007               1126              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
00001962                          1127          
00001962  4EB9 00002F02           1128              JSR         printEA
00001968                          1129              
00001968  43F9 00003CD9           1130              LEA         newLine, A1         ; Display space
0000196E  103C 000E               1131              MOVE.B      #14, D0             ; command for trap call to display message
00001972  4E4F                    1132              TRAP        #15                 ; trap call  
00001974                          1133          
00001974  6000 F6D6               1134              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001978                          1135              
00001978                          1136  ***********************************************************************************************************
00001978                          1137  *
00001978                          1138  *                   RTS_JSR Helper Function
00001978                          1139  *       Compare byte with static bits from JSR and RTS. If data is not equal to either, then data is
00001978                          1140  *       considered an invalid opcode and branches off to invalid.
00001978                          1141  *
00001978                          1142  ***********************************************************************************************************
00001978                          1143  
00001978                          1144  opRTSJSR
00001978  1218                    1145              MOVE.B      (A0)+, D1           ; Move byte into D1 and increment.
0000197A                          1146              
0000197A  1401                    1147              MOVE.B      D1,D2               ; copy data over
0000197C  B47C 0075               1148              CMP         #117,D2             ; 117 is the decimal value of RTS.
00001980  6700 0052               1149              BEQ         opRTS               ; If equal, branch to RTS to print out.
00001984                          1150              
00001984  EC42                    1151              ASR         #six,D2             ; Moving bits over to check if it matches the two static bits in JSR
00001986  B47C 0002               1152              CMP         #two,D2             ; Checking if it is JSR
0000198A  6700 0006               1153              BEQ         opJSR               ; It is equal, so branch off to opJSR
0000198E                          1154  
0000198E  6000 1BEA               1155              BRA         invalid             ; Branch to invalid to deal with invalid data.
00001992                          1156              
00001992                          1157  ***********************************************************************************************************
00001992                          1158  *
00001992                          1159  *                   JSR OPCODE
00001992                          1160  *       This section is dedicated to the JSR opmode instruction. JSR is determined by the 9 static bits.
00001992                          1161  *       Once the bits have matched the disassembled code, the code passes through and prints out JSR along
00001992                          1162  *       with its EA.               
00001992                          1163  *
00001992                          1164  ***********************************************************************************************************
00001992                          1165  
00001992                          1166  opJSR
00001992  43F9 00003D0F           1167              LEA         JSRMatch, A1        ; we know that the opcode will be JSR, so load A1 to print message
00001998  103C 000E               1168              MOVE.B      #14, D0             ; command for trap call to display message
0000199C  4E4F                    1169              TRAP        #15                 ; trap call
0000199E                          1170              
0000199E  43F9 00003CDD           1171              LEA         space, A1           ; we know that the opcode will be NEG, so load A1 to print message
000019A4  103C 000E               1172              MOVE.B      #14, D0             ; command for trap call to display message
000019A8  4E4F                    1173              TRAP        #15                 ; trap call
000019AA                          1174              
000019AA  4242                    1175              CLR         D2                  ; Clearing data register 
000019AC  4243                    1176              CLR         D3                  ; Clearing data register 
000019AE                          1177              
000019AE  1401                    1178              MOVE.B      D1,D2               ; Move D1 data to D2 to find the EA mode
000019B0  E642                    1179              ASR         #three,D2           ; Move mode over to the end in order to read
000019B2  C47C 0007               1180              AND         #seven,D2           ; Set every bit to 0 except for mode bits
000019B6                          1181              
000019B6  4243                    1182              CLR         D3
000019B8  1601                    1183              MOVE.B      D1,D3               ; Move bits over to D3 to find register
000019BA  C67C 0007               1184              AND         #seven,D3           ; Sets every bit to 0 except for register bits
000019BE                          1185              
000019BE  4EB9 00002F02           1186              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000019C4                          1187              
000019C4  43F9 00003CD9           1188              LEA         newLine, A1         ; Display space
000019CA  103C 000E               1189              MOVE.B      #14, D0             ; command for trap call to display message
000019CE  4E4F                    1190              TRAP        #15                 ; trap call  
000019D0                          1191              
000019D0  6000 F67A               1192              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000019D4                          1193  
000019D4                          1194  ***********************************************************************************************************
000019D4                          1195  *
000019D4                          1196  *                   RTS OPCODE
000019D4                          1197  *       Function prints out RTS. Does not need to check in here as it is done beforehand. Branches back
000019D4                          1198  *       into loop afterwards.
000019D4                          1199  *
000019D4                          1200  ***********************************************************************************************************
000019D4                          1201  
000019D4                          1202  opRTS
000019D4  43F9 00003D0B           1203              LEA         RTSMatch, A1        ; we know that the opcode will be RTS, so load A1 to print message
000019DA  103C 000E               1204              MOVE.B      #14, D0             ; command for trap call to display message
000019DE  4E4F                    1205              TRAP        #15                 ; trap call
000019E0                          1206              
000019E0  43F9 00003CD9           1207              LEA         newLine, A1         ; Display space
000019E6  103C 000E               1208              MOVE.B      #14, D0             ; command for trap call to display message
000019EA  4E4F                    1209              TRAP        #15                 ; trap call 
000019EC                          1210              
000019EC  6000 F65E               1211              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000019F0                          1212              
000019F0                          1213  ***********************************************************************************************************
000019F0                          1214  *
000019F0                          1215  *                   MOVEM_LEA OPCODE
000019F0                          1216  *       This part of the code is used to branch to either MOVEM or LEA depending on the second nibble.
000019F0                          1217  *
000019F0                          1218  ***********************************************************************************************************
000019F0                          1219  
000019F0                          1220  opMOVEMLEA
000019F0  4242                    1221              CLR         D2                  ; Clear D2
000019F2  1401                    1222              MOVE.B      D1,D2               ; Copy byte over
000019F4  C47C 000F               1223              AND         #secNib,D2          ; Check only the second nibble
000019F8  B47C 000C               1224              CMP         #twelve,D2          ; Compare the second nibble to twelve
000019FC  6700 000E               1225              BEQ         opMOVEM             ; If it is twelve, then it is MOVEM
00001A00  B47C 0008               1226              CMP         #eight,D2           ; Compare the second nibble to eight
00001A04  6700 0006               1227              BEQ         opMOVEM             ; If it is eight, then it is also MOVEM
00001A08  6000 008C               1228              BRA         opLEA               ; Otherwise branch to OPLEA and check for invalid in there
00001A0C                          1229              
00001A0C                          1230  ***********************************************************************************************************
00001A0C                          1231  *
00001A0C                          1232  *                   MOVEM OPCODE
00001A0C                          1233  *       MOVEM has 7 static bits. Before anything is done, static bits are checked and the dr field is stored
00001A0C                          1234  *       into D6 to be used later on for specific branching. After the static bits have confirmed this is
00001A0C                          1235  *       indeed MOVEM that is being disassembled, the code will print out MOVEM and goes into the subroutine
00001A0C                          1236  *       to print out the data and address registers.
00001A0C                          1237  *
00001A0C                          1238  ***********************************************************************************************************
00001A0C                          1239  
00001A0C                          1240  opMOVEM            
00001A0C  4246                    1241              CLR         D6                  ; Clearing D4 to store dr field
00001A0E  1C01                    1242              MOVE.B      D1,D6               ; Moving byte to find dr field
00001A10  E446                    1243              ASR         #two,D6             ; Moving dr field to readable spot
00001A12  CC7C 0001               1244              AND         #one,D6             ; seting everything except dr to 0
00001A16                          1245  
00001A16  4241                    1246              CLR         D1  
00001A18  1218                    1247              MOVE.B      (A0)+, D1           ; Taking in next byte
00001A1A                          1248              
00001A1A  4245                    1249              CLR         D5
00001A1C  1A01                    1250              MOVE.B      D1,D5               ; Using D6 to check if this is indeed MOVEM
00001A1E  EE45                    1251              ASR         #seven,D5
00001A20  CA7C 0001               1252              AND         #one,D5
00001A24  BA7C 0001               1253              CMP         #one,D5             ; This bit should be one if this is MOVEM
00001A28  6600 1B50               1254              BNE         invalid             ; If this is not 1 then this is not moveM
00001A2C  4245                    1255              CLR         D5
00001A2E                          1256              
00001A2E  43F9 00003D13           1257              LEA         MOVEMMatch, A1       ; we know that the opcode will be MOVEM, so load A1 to print message
00001A34  103C 000E               1258              MOVE.B      #14, D0             ; command for trap call to display message
00001A38  4E4F                    1259              TRAP        #15                 ; trap call
00001A3A                          1260              
00001A3A  4245                    1261              CLR         D5                  ; Clearing D5 to store size
00001A3C  1A01                    1262              MOVE.B      D1,D5               ; Moving byte that contains bit for size
00001A3E  EC45                    1263              ASR         #six,D5             ; Moving size bit to the very right to read
00001A40  CA7C 0001               1264              AND         #one,D5             ; Isolating the one bit for size
00001A44                          1265              
00001A44  4242                    1266              CLR         D2                  ; Clear Data register 2
00001A46  3401                    1267              MOVE        D1,D2               ; Move byte into D2
00001A48  E642                    1268              ASR         #three,D2           ; Shift mode into place and moves mode into place
00001A4A  C47C 0007               1269              AND         #seven,D2           ; Stores mode
00001A4E                          1270              
00001A4E  4243                    1271              CLR         D3                  ; Storing EA register into D3
00001A50  1601                    1272              MOVE.B      D1,D3               ; Move bits over to D3 to find register
00001A52  C67C 0007               1273              AND         #seven,D3           ; Sets every bit to 0 except for register bits
00001A56                          1274              
00001A56  4EB9 00003580           1275              JSR         MOVEMBRA            ; Jumps to subroutine that prints out the data and address registers
00001A5C                          1276              
00001A5C  B47C 0003               1277              CMP         #three,D2           ; Checks if this is post increment
00001A60  6700 0024               1278              BEQ         skipPrintEA         ; If it is, skipping printing EA again, because it is printed already in JSR
00001A64                          1279              
00001A64  43F9 00003CE4           1280              LEA         comma, A1           ; Display comma
00001A6A  103C 000E               1281              MOVE.B      #14, D0             ; command for trap call to display message
00001A6E  4E4F                    1282              TRAP        #15                 ; trap call
00001A70                          1283              
00001A70  4EB9 00002F02           1284              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001A76                          1285              
00001A76  43F9 00003CD9           1286              LEA         newline, A1         ; we know that the opcode will be MOVEM, so load A1 to print message
00001A7C  103C 000E               1287              MOVE.B      #14, D0             ; command for trap call to display message
00001A80  4E4F                    1288              TRAP        #15                 ; trap call            
00001A82                          1289  
00001A82  6000 F5C8               1290              BRA         loop                ; Branch back to outer most loop that finds the first four bits
00001A86                          1291  
00001A86                          1292  skipPrintEA 
00001A86  43F9 00003CD9           1293              LEA         newline, A1         ; Prints out new line or carraige return
00001A8C  103C 000E               1294              MOVE.B      #14, D0             ; command for trap call to display message
00001A90  4E4F                    1295              TRAP        #15                 ; trap call            
00001A92                          1296  
00001A92  6000 F5B8               1297              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001A96                          1298              
00001A96                          1299  ***********************************************************************************************************
00001A96                          1300  *
00001A96                          1301  *               LEA OPCODE
00001A96                          1302  *
00001A96                          1303  *       This section is dedicated to the LEA opcode. This is determined that the first nibble is 4 nibbles as
00001A96                          1304  *       well as the three static nibbles on 8,7, and 6. Once both have been checked, the code prints out
00001A96                          1305  *       LEA and goes on to print its effective address.
00001A96                          1306  *
00001A96                          1307  ***********************************************************************************************************
00001A96                          1308  
00001A96                          1309  opLEA
00001A96  4244                    1310              CLR         D4                  ; Clearing space for source register
00001A98  1801                    1311              MOVE.B      D1,D4               ; Moving byte to isolate register
00001A9A  E244                    1312              ASR         #one,D4
00001A9C  C87C 0007               1313              AND         #seven,D4           ; Isolated register
00001AA0                          1314  
00001AA0  4245                    1315              CLR         D5                  ; Clearing D5 to check if bits match LEA static bits
00001AA2  1A01                    1316              MOVE.B      D1,D5               ; Stores destination register in temporary data register for later use
00001AA4  CA7C 0001               1317              AND         #one,D5             ; Setting all other bits to one except for mode register
00001AA8  E545                    1318              ASL         #two,D5             ; Shifts the two register bits over to correct spot
00001AAA                          1319              
00001AAA  1218                    1320              MOVE.B      (A0)+, D1           ; Taking in next byte
00001AAC                          1321              
00001AAC  1C01                    1322              MOVE.B      D1,D6               
00001AAE  EC46                    1323              ASR         #six,D6             ; Shifts 6 bits over to move register
00001AB0  DA46                    1324              ADD         D6,D5               ; Add the remaining bits to the register
00001AB2  4246                    1325              CLR         D6                  ; Clear out the temporary register
00001AB4                          1326  
00001AB4  BA7C 0007               1327              CMP         #seven,D5           ; Checks the seven static bits to see if it is LEA
00001AB8  6600 1AC0               1328              BNE         invalid             ; If it is not equal then this is not LEA
00001ABC                          1329              
00001ABC  43F9 00003D19           1330              LEA         LEAmatch, A1        ; we know that the opcode will be LEA, so load A1 to print message
00001AC2  103C 000E               1331              MOVE.B      #14, D0             ; command for trap call to display message
00001AC6  4E4F                    1332              TRAP        #15                 ; trap call            
00001AC8                          1333  
00001AC8  43F9 00003CDD           1334              LEA         space, A1           ; we know that the opcode will be MOVEM, so load A1 to print message
00001ACE  103C 000E               1335              MOVE.B      #14, D0             ; command for trap call to display message
00001AD2  4E4F                    1336              TRAP        #15                 ; trap call            
00001AD4                          1337              
00001AD4  4242                    1338              CLR         D2                  ; Clear Data register 2
00001AD6  3401                    1339              MOVE        D1,D2               ; Move byte into D2
00001AD8  E642                    1340              ASR         #three,D2           ; Shift mode into place and moves mode into place
00001ADA  C47C 0007               1341              AND         #seven,D2           ; Stores mode
00001ADE                          1342              
00001ADE  4243                    1343              CLR         D3
00001AE0  1601                    1344              MOVE.B      D1,D3               ; Move bits over to D3 to find register
00001AE2  C67C 0007               1345              AND         #seven,D3           ; Sets every bit to 0 except for register bits
00001AE6                          1346              
00001AE6  4EB9 00002F02           1347              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001AEC                          1348              
00001AEC  43F9 00003CE4           1349              LEA         comma, A1           ; we know that the opcode will be MOVEM, so load A1 to print message
00001AF2  103C 000E               1350              MOVE.B      #14, D0             ; command for trap call to display message
00001AF6  4E4F                    1351              TRAP        #15                 ; trap call            
00001AF8                          1352              
00001AF8                          1353              
00001AF8  4243                    1354              CLR         D3                  ; Clears D3 to move effective address into it
00001AFA  1604                    1355              MOVE.B      D4,D3               ; Moves data with EA register
00001AFC  143C 0001               1356              MOVE.B      #one,D2             ; Puts 1 into D2 to print an An within printEA
00001B00                          1357              
00001B00  4EB9 00002F02           1358              JSR         printEA             ; Prints out source address
00001B06                          1359              
00001B06  43F9 00003CD9           1360              LEA         newline, A1         ; Prints new line
00001B0C  103C 000E               1361              MOVE.B      #14, D0             ; command for trap call to display message
00001B10  4E4F                    1362              TRAP        #15                 ; trap call
00001B12                          1363  
00001B12  6000 F538               1364              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits                 
00001B16                          1365  
00001B16                          1366  ***********************************************************************************************************
00001B16                          1367  *
00001B16                          1368  *                   OR OPCODE
00001B16                          1369  *
00001B16                          1370  *       This section is dedicated to the OR opcode. This is determined that the first nibble is 8, and the
00001B16                          1371  *       second nibble is not 7 (or we would have DIVS), we must have OR.
00001B16                          1372  *       OR is varied by the operand direction. We have and EA to Dn, and DN to EA operation.
00001B16                          1373  *       These operand directions determine our opmode, which we use to disassemble.
00001B16                          1374  *
00001B16                          1375  ***********************************************************************************************************
00001B16                          1376              
00001B16                          1377  opOR                                        ; Assumed we found OR, begin disassemble
00001B16  43F9 00003D3B           1378              LEA         ORmatch,A1          ; Output OR to the IO console
00001B1C  103C 000E               1379              MOVE.B      #14,D0              ; Use trap 14
00001B20  4E4F                    1380              TRAP        #15                 ; Halt for IO
00001B22                          1381              
00001B22  E141                    1382              ASL         #eight,D1           ; Shift D1 by eight to find opmode
00001B24  1401                    1383              MOVE.B      D1,D2               ; Load D2 with the resulting byte
00001B26                          1384              
00001B26                          1385              ; These are for EA to Dn direction
00001B26  B43C 0000               1386              CMP.B       #zero,D2            ; Check for a byte
00001B2A  6700 002A               1387              BEQ         opORB               ; Byte in opmode
00001B2E  B43C 0001               1388              CMP.B       #one,D2             ; Check for a word
00001B32  6700 007C               1389              BEQ         opORW               ; Word in opmode
00001B36  B43C 0002               1390              CMP.B       #two,D2             ; Check for a long
00001B3A  6700 00CE               1391              BEQ         opORL               ; Long in opmode
00001B3E                          1392              
00001B3E                          1393              ; These are for Dn to EA direction
00001B3E  B43C 0004               1394              CMP.B       #four,D2            ; Check for a byte
00001B42  6700 0012               1395              BEQ         opORB               ; Byte in opmode
00001B46  B43C 0005               1396              CMP.B       #five,D2            ; Check for a word
00001B4A  6700 0064               1397              BEQ         opORW               ; Word in opmode
00001B4E  B43C 0006               1398              CMP.B       #six,D2             ; Check for a long
00001B52  6700 00B6               1399              BEQ         opORL               ; Long in opmode
00001B56                          1400              
00001B56                          1401  opORB                                       ; Byte determined, find operands from here
00001B56  43F9 00003D77           1402              LEA         dispByte,A1         ; Display our byte info
00001B5C  103C 000E               1403              MOVE.B      #14,D0              ; Trap #14 for our IO
00001B60  4E4F                    1404              TRAP        #15                 ; Halt for IO
00001B62                          1405              
00001B62  43F9 00003CDD           1406              LEA         space, A1           ; Display space
00001B68  103C 000E               1407              MOVE.B      #14, D0             ; command for trap call to display message
00001B6C  4E4F                    1408              TRAP        #15                 ; trap call
00001B6E                          1409              
00001B6E                          1410  
00001B6E  1401                    1411              MOVE.B      D1,D2               ; Load D2 again with the byte in D1
00001B70  E642                    1412              ASR         #3,D2               ; Shift by 3 for finding 1 operand
00001B72  C47C 0007               1413              AND         #$07,D2             ; AND by 7 to remove extras
00001B76  1601                    1414              MOVE.B      D1,D3               ; Load D3 with more necessary EA info
00001B78  C67C 0007               1415              AND         #$07,D3             ; AND by 7 to remove extra bits
00001B7C  4EB9 00002F02           1416              JSR         printEA             ; Determines the "left" operand register
00001B82                          1417              
00001B82  43F9 00003CE4           1418              LEA         comma, A1           ; Display space
00001B88  103C 000E               1419              MOVE.B      #14, D0             ; command for trap call to display message
00001B8C  4E4F                    1420              TRAP        #15                 ; trap call
00001B8E                          1421              
00001B8E  4242                    1422              CLR         D2                  ; Clear D2 for use
00001B90  3601                    1423              MOVE.W      D1,D3               ; Move our word into D3 for EA use
00001B92  E043                    1424              ASR         #eight,D3           ; Shift by 8 to isolate EA info
00001B94  E243                    1425              ASR         #one,D3             ; We need additional shift, so total shifts is by 9
00001B96  C67C 0007               1426              AND         #$07,D3             ; AND to remove extra data
00001B9A  4EB9 00002F02           1427              JSR         printEA             ; Redirect to EA subroutine to find EA operand info
00001BA0                          1428              
00001BA0  43F9 00003CD9           1429              LEA         newLine,A1          ; Prime a new line for the next instruction
00001BA6  103C 000E               1430              MOVE.B      #14,D0              ; Send it to the console
00001BAA  4E4F                    1431              TRAP        #15                 ; IO halt here
00001BAC                          1432              
00001BAC  6000 F49E               1433              BRA         LOOP                ; Return to control loop to find additional instructions
00001BB0                          1434              
00001BB0                          1435              
00001BB0                          1436  opORW                                       ; Word opmode has been found
00001BB0  43F9 00003D7A           1437              LEA         dispWord,A1         ; Display our word info
00001BB6  103C 000E               1438              MOVE.B      #14,D0              ; Trap #14 for our IO
00001BBA  4E4F                    1439              TRAP        #15                 ; Halt for IO
00001BBC                          1440              
00001BBC  43F9 00003CDD           1441              LEA         space, A1           ; Display space
00001BC2  103C 000E               1442              MOVE.B      #14, D0             ; command for trap call to display message
00001BC6  4E4F                    1443              TRAP        #15                 ; trap call
00001BC8                          1444              
00001BC8                          1445  
00001BC8  1401                    1446              MOVE.B      D1,D2               ; Load D2 again with the byte in D1
00001BCA  E642                    1447              ASR         #3,D2               ; Shift by 3 for finding 1 operand
00001BCC  C47C 0007               1448              AND         #$07,D2             ; AND by 7 to remove extras
00001BD0  1601                    1449              MOVE.B      D1,D3               ; Load D3 with more necessary EA info
00001BD2  C67C 0007               1450              AND         #$07,D3             ; AND by 7 to remove extra bits
00001BD6  4EB9 00002F02           1451              JSR         printEA             ; Determines the "left" operand register
00001BDC                          1452              
00001BDC  43F9 00003CE4           1453              LEA         comma, A1           ; Display space
00001BE2  103C 000E               1454              MOVE.B      #14, D0             ; command for trap call to display message
00001BE6  4E4F                    1455              TRAP        #15                 ; trap call
00001BE8                          1456              
00001BE8  4242                    1457              CLR         D2                  ; Clear D2 for use
00001BEA  3601                    1458              MOVE.W      D1,D3               ; Move our word into D3 for EA use
00001BEC  E043                    1459              ASR         #eight,D3           ; Shift by 8 to isolate EA info
00001BEE  E243                    1460              ASR         #one,D3             ; We need additional shift, so total shifts is by 9
00001BF0  C67C 0007               1461              AND         #$07,D3             ; AND to remove extra data
00001BF4  4EB9 00002F02           1462              JSR         printEA             ; Redirect to EA subroutine to find EA operand info
00001BFA                          1463              
00001BFA  43F9 00003CD9           1464              LEA         newLine,A1          ; Prime a new line for the next instruction
00001C00  103C 000E               1465              MOVE.B      #14,D0              ; Send it to the console
00001C04  4E4F                    1466              TRAP        #15                 ; IO halt here
00001C06                          1467              
00001C06  6000 F444               1468              BRA         LOOP                ; Return to control loop to find additional instructions
00001C0A                          1469              
00001C0A                          1470  opORL                                       ; Long value has been found for OR
00001C0A  43F9 00003D7D           1471              LEA         dispLong,A1         ; Display our long info
00001C10  103C 000E               1472              MOVE.B      #14,D0              ; Trap #14 for our IO
00001C14  4E4F                    1473              TRAP        #15                 ; Halt for IO
00001C16                          1474              
00001C16  43F9 00003CDD           1475              LEA         space, A1           ; Display space
00001C1C  103C 000E               1476              MOVE.B      #14, D0             ; command for trap call to display message
00001C20  4E4F                    1477              TRAP        #15                 ; trap call
00001C22                          1478              
00001C22                          1479  
00001C22  1401                    1480              MOVE.B      D1,D2               ; Load D2 again with the byte in D1
00001C24  E642                    1481              ASR         #3,D2               ; Shift by 3 for finding 1 operand
00001C26  C47C 0007               1482              AND         #$07,D2             ; AND by 7 to remove extras
00001C2A  1601                    1483              MOVE.B      D1,D3               ; Load D3 with more necessary EA info
00001C2C  C67C 0007               1484              AND         #$07,D3             ; AND by 7 to remove extra bits
00001C30  4EB9 00002F02           1485              JSR         printEA             ; Determines the "left" operand register
00001C36                          1486              
00001C36  43F9 00003CE4           1487              LEA         comma, A1           ; Display space
00001C3C  103C 000E               1488              MOVE.B      #14, D0             ; command for trap call to display message
00001C40  4E4F                    1489              TRAP        #15                 ; trap call
00001C42                          1490              
00001C42  4242                    1491              CLR         D2                  ; Clear D2 for use
00001C44  3601                    1492              MOVE.W      D1,D3               ; Move our word into D3 for EA use
00001C46  E043                    1493              ASR         #eight,D3           ; Shift by 8 to isolate EA info
00001C48  E243                    1494              ASR         #one,D3             ; We need additional shift, so total shifts is by 9
00001C4A  C67C 0007               1495              AND         #$07,D3             ; AND to remove extra data
00001C4E  4EB9 00002F02           1496              JSR         printEA             ; Redirect to EA subroutine to find EA operand info
00001C54                          1497              
00001C54  43F9 00003CD9           1498              LEA         newLine,A1          ; Prime a new line for the next instruction
00001C5A  103C 000E               1499              MOVE.B      #14,D0              ; Send it to the console
00001C5E  4E4F                    1500              TRAP        #15                 ; IO halt here
00001C60                          1501              
00001C60  6000 F3EA               1502              BRA         LOOP                ; Return to control loop to find additional instructions
00001C64                          1503              
00001C64                          1504  ***********************************************************************************************************
00001C64                          1505  *
00001C64                          1506  *                   DIVS OPCODE
00001C64                          1507  *
00001C64                          1508  *       This section is dedicate to the DIVS instruction, which is determined by a 8 in the first nibble
00001C64                          1509  *       and a 7 in the second nibble of the instruction.
00001C64                          1510  *       DIVSL is not supported, so the following code only accounts for the case of DIVS, which is short
00001C64                          1511  *       instead of a long
00001C64                          1512  *
00001C64                          1513  ***********************************************************************************************************
00001C64                          1514  
00001C64                          1515  opDIVS                                      ; Second nibble determined that the instruction was DIVS
00001C64  43F9 00003D36           1516              LEA         DIVSmatch,A1        ; Load DIVS into A1 for output console
00001C6A  103C 000E               1517              MOVE.B      #14,D0              ; Get trap task #14 for IO
00001C6E  4E4F                    1518              TRAP        #15                 ; Trap call to halt
00001C70                          1519              
00001C70  43F9 00003CDD           1520              LEA         space, A1           ; Display space
00001C76  103C 000E               1521              MOVE.B      #14, D0             ; command for trap call to display message
00001C7A  4E4F                    1522              TRAP        #15                 ; trap to halt
00001C7C                          1523              
00001C7C  1401                    1524              MOVE.B      D1,D2               ; Move our byte from D1 to D2 to manipulate
00001C7E  E642                    1525              ASR         #3,D2               ; Shift by 3 to find register
00001C80  C47C 0007               1526              AND         #$07,D2             ; AND by 7 to clear unnecessary bits
00001C84  1601                    1527              MOVE.B      D1,D3               ; Load the byte into D3 for EA comparison
00001C86  C67C 0007               1528              AND         #$07,D3             ; AND by 7 to clear unnecessary bits
00001C8A  4EB9 00002F02           1529              JSR         printEA             ; Call our EA subroutine to obtain EA bits from instruction
00001C90                          1530              
00001C90  43F9 00003CE4           1531              LEA         comma, A1           ; Display space
00001C96  103C 000E               1532              MOVE.B      #14, D0             ; command for trap call to display message
00001C9A  4E4F                    1533              TRAP        #15                 ; trap to halt call
00001C9C                          1534              
00001C9C  4242                    1535              CLR         D2                  ; Clear old data from D2 to avoid errors
00001C9E  3601                    1536              MOVE.W      D1,D3               ; Move word into D3 for EA subroutine
00001CA0  E043                    1537              ASR         #eight,D3           ; Shift by 8 to find to find the remaining EA components
00001CA2  E243                    1538              ASR         #one,D3             ; Additional shift by 1 to get proper bits
00001CA4  C67C 0007               1539              AND         #$07,D3             ; AND to clear unwanted bits
00001CA8  4EB9 00002F02           1540              JSR         printEA             ; Obtain other operand info
00001CAE                          1541              
00001CAE  43F9 00003CD9           1542              LEA         newLine,A1          ; Prepare new line for next instruction
00001CB4  103C 000E               1543              MOVE.B      #14,D0              ; Utilize trap task 14
00001CB8  4E4F                    1544              TRAP        #15                 ; Halt for IO
00001CBA                          1545              
00001CBA  6000 F390               1546              BRA         LOOP                ; Return to control loop
00001CBE                          1547              
00001CBE                          1548  **********************************************************************************************************
00001CBE                          1549  *
00001CBE                          1550  *                   EOR OPCODE
00001CBE                          1551  *
00001CBE                          1552  *       This sectioon is dedicated to the EOR opcode. We determine this with an 11 in the first nibble, and
00001CBE                          1553  *       a value higher than 3 in the second nibble.
00001CBE                          1554  *       The opmode fields is used to differ this instruction from CMP.
00001CBE                          1555  *       Dissassembly acquires opmode field info, which is similar to size, and to different EA related
00001CBE                          1556  *       operands.
00001CBE                          1557  *
00001CBE                          1558  ***********************************************************************************************************
00001CBE                          1559  
00001CBE                          1560  opEOR                                       ; We found EOR, begin disassembly
00001CBE  43F9 00003D42           1561              LEA         EORmatch,A1         ; Load A1 with our EOR output
00001CC4  103C 000E               1562              MOVE.B      #14,D0              ; Prime trap task #14
00001CC8  4E4F                    1563              TRAP        #15                 ; Halt for IO
00001CCA                          1564              
00001CCA  4242                    1565              CLR         D2                  ; Clear D2 for use again
00001CCC                          1566              
00001CCC  1401                    1567              MOVE.B      D1,D2               ; Move byte used in D1 to D2 for opmode check
00001CCE  EE42                    1568              ASR         #seven,D2           ; Move bits 7 places over to find opmode
00001CD0  C47C 0007               1569              AND         #$07,D2             ; AND by 7 to clear extra bits
00001CD4  B43C 0005               1570              CMP.B       #five,D2            ; Check for a byte in opmode
00001CD8  6D00 0012               1571              BLT         opEORB              ; Byte in opmode
00001CDC  B43C 0005               1572              CMP.B       #five,D2            ; Check for a word in opmode
00001CE0  6700 006A               1573              BEQ         opEORW              ; Word in opmode
00001CE4  B43C 0005               1574              CMP.B       #five,D2            ; Check for a long in opmode
00001CE8  6E00 00C2               1575              BGT         opEORL              ; Long in opmode
00001CEC                          1576              
00001CEC                          1577  opEORB                                      ; Determine instruction is a byte operation
00001CEC  43F9 00003D77           1578              LEA         dispByte,A1         ; Send out the byte info for the instruction
00001CF2  103C 000E               1579              MOVE.B      #14,D0              ; Utilize trap task 14
00001CF6  4E4F                    1580              TRAP        #15                 ; Halt for IO
00001CF8                          1581              
00001CF8  43F9 00003CDD           1582              LEA         space, A1           ; Display space
00001CFE  103C 000E               1583              MOVE.B      #14, D0             ; command for trap call to display message
00001D02  4E4F                    1584              TRAP        #15                 ; trap call to halt
00001D04                          1585              
00001D04  4242                    1586              CLR         D2                  ; Clear D2 again for use
00001D06  4243                    1587              CLR         D3                  ; Remove anything from D3
00001D08  3601                    1588              MOVE.W      D1,D3               ; Move word to D3 to find an operand
00001D0A  E043                    1589              ASR         #eight,D3           ; Shift by eight to ensure correct portion of instruction
00001D0C  E243                    1590              ASR         #one,D3             ; Needs to be shifted by an additional 1
00001D0E  C67C 0007               1591              AND         #$07,D3             ; Clear extra bits 
00001D12  4EB9 00002F02           1592              JSR         printEA             ; Use EA subroutine to print operand
00001D18                          1593              
00001D18  43F9 00003CE4           1594              LEA         comma, A1           ; Display space
00001D1E  103C 000E               1595              MOVE.B      #14, D0             ; command for trap call to display message
00001D22  4E4F                    1596              TRAP        #15                 ; trap call
00001D24                          1597              
00001D24  4242                    1598              CLR         D2                  ; Clear D2 again
00001D26  4243                    1599              CLR         D3                  ; Clear D3 again
00001D28  1401                    1600              MOVE.B      D1,D2               ; Move the byte value in D1 to D2 for EA use
00001D2A  E642                    1601              ASR         #three,D2           ; Shift by 3 to find EA info
00001D2C  C47C 0007               1602              AND         #seven,D2           ; AND by 7 to remove extra bits
00001D30  1601                    1603              MOVE.B      D1,D3               ; Move byte value from D1 into D3
00001D32  C67C 0007               1604              AND         #$07,D3             ; AND by 7 for EA subroutine
00001D36  4EB9 00002F02           1605              JSR         printEA             ; Determines remained operand EA info to print
00001D3C                          1606              
00001D3C  43F9 00003CD9           1607              LEA         newLine,A1          ; Print new line for next instruction
00001D42  103C 000E               1608              MOVE.B      #14,D0              ; Use trap 14 to output to console
00001D46  4E4F                    1609              TRAP        #15                 ; Halt for IO
00001D48                          1610              
00001D48  6000 F302               1611              BRA         LOOP                ; Return to control loop
00001D4C                          1612               
00001D4C                          1613  opEORW                                      ; Word opmode has been determined
00001D4C  43F9 00003D7A           1614              LEA         dispWord,A1         ; Send out the word info for the instruction
00001D52  103C 000E               1615              MOVE.B      #14,D0              ; Utilize trap task 14
00001D56  4E4F                    1616              TRAP        #15                 ; Halt for IO
00001D58                          1617              
00001D58  43F9 00003CDD           1618              LEA         space, A1           ; Display space
00001D5E  103C 000E               1619              MOVE.B      #14, D0             ; command for trap call to display message
00001D62  4E4F                    1620              TRAP        #15                 ; trap call to halt
00001D64                          1621              
00001D64  4242                    1622              CLR         D2                  ; Clear D2 again for use
00001D66  4243                    1623              CLR         D3                  ; Remove anything from D3
00001D68  3601                    1624              MOVE.W      D1,D3               ; Move word to D3 to find an operand
00001D6A  E043                    1625              ASR         #eight,D3           ; Shift by eight to ensure correct portion of instruction
00001D6C  E243                    1626              ASR         #one,D3             ; Needs to be shifted by an additional 1
00001D6E  C67C 0007               1627              AND         #$07,D3             ; Clear extra bits 
00001D72  4EB9 00002F02           1628              JSR         printEA             ; Use EA subroutine to print operand
00001D78                          1629              
00001D78  43F9 00003CE4           1630              LEA         comma, A1           ; Display space
00001D7E  103C 000E               1631              MOVE.B      #14, D0             ; command for trap call to display message
00001D82  4E4F                    1632              TRAP        #15                 ; trap call
00001D84                          1633              
00001D84  4242                    1634              CLR         D2                  ; Clear D2 again
00001D86  4243                    1635              CLR         D3                  ; Clear D3 again
00001D88  1401                    1636              MOVE.B      D1,D2               ; Move the byte value in D1 to D2 for EA use
00001D8A  E642                    1637              ASR         #three,D2           ; Shift by 3 to find EA info
00001D8C  C47C 0007               1638              AND         #seven,D2           ; AND by 7 to remove extra bits
00001D90  1601                    1639              MOVE.B      D1,D3               ; Move byte value from D1 into D3
00001D92  C67C 0007               1640              AND         #$07,D3             ; AND by 7 for EA subroutine
00001D96  4EB9 00002F02           1641              JSR         printEA             ; Determines remained operand EA info to print
00001D9C                          1642              
00001D9C  43F9 00003CD9           1643              LEA         newLine,A1          ; Print new line for next instruction
00001DA2  103C 000E               1644              MOVE.B      #14,D0              ; Use trap 14 to output to console
00001DA6  4E4F                    1645              TRAP        #15                 ; Halt for IO
00001DA8                          1646              
00001DA8  6000 F2A2               1647              BRA         LOOP                ; Return to control loop
00001DAC                          1648              
00001DAC                          1649  opEORL                                      ; Long has been determined
00001DAC  43F9 00003D7D           1650              LEA         dispLong,A1         ; Send out the long word info for the instruction
00001DB2  103C 000E               1651              MOVE.B      #14,D0              ; Utilize trap task 14
00001DB6  4E4F                    1652              TRAP        #15                 ; Halt for IO
00001DB8                          1653              
00001DB8  43F9 00003CDD           1654              LEA         space, A1           ; Display space
00001DBE  103C 000E               1655              MOVE.B      #14, D0             ; command for trap call to display message
00001DC2  4E4F                    1656              TRAP        #15                 ; trap call to halt
00001DC4                          1657              
00001DC4  4242                    1658              CLR         D2                  ; Clear D2 again for use
00001DC6  4243                    1659              CLR         D3                  ; Remove anything from D3
00001DC8  3601                    1660              MOVE.W      D1,D3               ; Move word to D3 to find an operand
00001DCA  E043                    1661              ASR         #eight,D3           ; Shift by eight to ensure correct portion of instruction
00001DCC  E243                    1662              ASR         #one,D3             ; Needs to be shifted by an additional 1
00001DCE  C67C 0007               1663              AND         #$07,D3             ; Clear extra bits 
00001DD2  4EB9 00002F02           1664              JSR         printEA             ; Use EA subroutine to print operand
00001DD8                          1665              
00001DD8  43F9 00003CE4           1666              LEA         comma, A1           ; Display space
00001DDE  103C 000E               1667              MOVE.B      #14, D0             ; command for trap call to display message
00001DE2  4E4F                    1668              TRAP        #15                 ; trap call
00001DE4                          1669              
00001DE4  4242                    1670              CLR         D2                  ; Clear D2 again
00001DE6  4243                    1671              CLR         D3                  ; Clear D3 again
00001DE8  1401                    1672              MOVE.B      D1,D2               ; Move the byte value in D1 to D2 for EA use
00001DEA  E642                    1673              ASR         #three,D2           ; Shift by 3 to find EA info
00001DEC  C47C 0007               1674              AND         #seven,D2           ; AND by 7 to remove extra bits
00001DF0  1601                    1675              MOVE.B      D1,D3               ; Move byte value from D1 into D3
00001DF2  C67C 0007               1676              AND         #$07,D3             ; AND by 7 for EA subroutine
00001DF6  4EB9 00002F02           1677              JSR         printEA             ; Determines remained operand EA info to print
00001DFC                          1678              
00001DFC  43F9 00003CD9           1679              LEA         newLine,A1          ; Print new line for next instruction
00001E02  103C 000E               1680              MOVE.B      #14,D0              ; Use trap 14 to output to console
00001E06  4E4F                    1681              TRAP        #15                 ; Halt for IO
00001E08                          1682              
00001E08  6000 F242               1683              BRA         LOOP                ; Return to the control loop
00001E0C                          1684  
00001E0C                          1685  ***********************************************************************************************************
00001E0C                          1686  *
00001E0C                          1687  *                   CMP OPCODE
00001E0C                          1688  *
00001E0C                          1689  *       This section is dedicated to the compare (CMP) instruction. Its determined in the control loop
00001E0C                          1690  *       that the first nibble is 11 for CMP, and the second nibble is 3.
00001E0C                          1691  *       The type of CMP, or the opmode, is used to determined what we output to our console next.
00001E0C                          1692  *       From that point, we load the correct size/opmode, and then route to the EA subroutine to output
00001E0C                          1693  *       EA related register information.
00001E0C                          1694  *       The process for finding the operand register info (EA info) is similar for all opmodes.
00001E0C                          1695  *
00001E0C                          1696  ***********************************************************************************************************
00001E0C                          1697  
00001E0C                          1698  opCMP       
00001E0C  43F9 00003D46           1699              LEA         CMPmatch,A1         ; We determined that the opcode is CMP, output to console
00001E12  103C 000E               1700              MOVE.B      #14,D0              ; Getting trap task #14 ready
00001E16  4E4F                    1701              TRAP        #15                 ; Trap 15 call for IO
00001E18                          1702              
00001E18  4242                    1703              CLR         D2                  ; D2 should be cleared for use later
00001E1A                          1704              
00001E1A  1401                    1705              MOVE.B      D1,D2               ; Get the next byte to manipulate
00001E1C  EC42                    1706              ASR         #six,D2             ; Move bits 7 places over to find opmode
00001E1E  C47C 0007               1707              AND         #$07,D2             ; AND by 7 allows us to compare properly on which opmode we need
00001E22  B43C 0000               1708              CMP.B       #zero,D2            ; Compare to zero to see if we have a byte
00001E26  6700 0016               1709              BEQ         opCMPB              ; Byte in opmode
00001E2A  B43C 0001               1710              CMP.B       #one,D2             ; Compare to one to see if we have a word
00001E2E  6700 0068               1711              BEQ         opCMPW              ; Word in opmode
00001E32  B43C 0002               1712              CMP.B       #two,D2             ; Compare to two to see if we have a long
00001E36  6700 00BA               1713              BEQ         opCMPL              ; Long in opmode
00001E3A                          1714              
00001E3A  6000 1E32               1715              BRA         printInvalid        ; Incorrect input
00001E3E                          1716  
00001E3E                          1717  opCMPB                                      ; Known we have CMP.B, find and output operands
00001E3E  43F9 00003D77           1718              LEA         dispByte,A1         ; Output the byte component of the instruction
00001E44  103C 000E               1719              MOVE.B      #14,D0              ; Trap task #14 for console out
00001E48  4E4F                    1720              TRAP        #15                 ; Halt for console out
00001E4A                          1721              
00001E4A  43F9 00003CDD           1722              LEA         space, A1           ; Display space for operands
00001E50  103C 000E               1723              MOVE.B      #14, D0             ; command for trap call to display message
00001E54  4E4F                    1724              TRAP        #15                 ; Console out/halt
00001E56                          1725              
00001E56  1401                    1726              MOVE.B      D1,D2               ; Move the byte for manipulation to D2
00001E58  E642                    1727              ASR         #3,D2               ; Shift right by 3 to find left operand register
00001E5A  C47C 0007               1728              AND         #$07,D2             ; AND for comparison later
00001E5E  1601                    1729              MOVE.B      D1,D3               ; Move the byte to D3 for use in our EA subroutine
00001E60  C67C 0007               1730              AND         #$07,D3             ; AND for comparison in subroutine
00001E64  4EB9 00002F02           1731              JSR         printEA             ; Use our EA subroutine to determine the left operand register
00001E6A                          1732              
00001E6A  43F9 00003CE4           1733              LEA         comma, A1           ; Display space
00001E70  103C 000E               1734              MOVE.B      #14, D0             ; command for trap call to display message
00001E74  4E4F                    1735              TRAP        #15                 ; trap call
00001E76                          1736              
00001E76  4242                    1737              CLR         D2                  ; D2 needs to be cleared for use later
00001E78  3601                    1738              MOVE.W      D1,D3               ; Move the entire word in D3 for shifting
00001E7A  E043                    1739              ASR         #eight,D3           ; Shift right by 8 to get EA bits from instruction
00001E7C  E243                    1740              ASR         #one,D3             ; Shift right once more to move the bits all the way
00001E7E  C67C 0007               1741              AND         #$07,D3             ; AND by 7 to clear unnecessary bits
00001E82  4EB9 00002F02           1742              JSR         printEA             ; EA subroutine call to get remaining operand sent to the console
00001E88                          1743              
00001E88  43F9 00003CD9           1744              LEA         newLine,A1          ; Prime A1 with our new line to output
00001E8E  103C 000E               1745              MOVE.B      #14,D0              ; Prime new line for next instruction
00001E92  4E4F                    1746              TRAP        #15                 ; Halt for IO
00001E94                          1747              
00001E94  6000 F1B6               1748              BRA         LOOP                ; Return to control loop for next disassembly
00001E98                          1749              
00001E98                          1750  opCMPW                                      ; Known we have CMP.W, find and output operands
00001E98  43F9 00003D7A           1751              LEA         dispWord,A1         ; Output the byte component of the instruction
00001E9E  103C 000E               1752              MOVE.B      #14,D0              ; Trap task #14 for console out
00001EA2  4E4F                    1753              TRAP        #15                 ; Halt for console out
00001EA4                          1754              
00001EA4  43F9 00003CDD           1755              LEA         space, A1           ; Display space for operands
00001EAA  103C 000E               1756              MOVE.B      #14, D0             ; command for trap call to display message
00001EAE  4E4F                    1757              TRAP        #15                 ; Console out/halt
00001EB0                          1758              
00001EB0  1401                    1759              MOVE.B      D1,D2               ; Move the byte for manipulation to D2
00001EB2  E642                    1760              ASR         #3,D2               ; Shift right by 3 to find left operand register
00001EB4  C47C 0007               1761              AND         #$07,D2             ; AND for comparison later
00001EB8  1601                    1762              MOVE.B      D1,D3               ; Move the byte to D3 for use in our EA subroutine
00001EBA  C67C 0007               1763              AND         #$07,D3             ; AND for comparison in subroutine
00001EBE  4EB9 00002F02           1764              JSR         printEA             ; Use our EA subroutine to determine the left operand register
00001EC4                          1765              
00001EC4  43F9 00003CE4           1766              LEA         comma, A1           ; Display space
00001ECA  103C 000E               1767              MOVE.B      #14, D0             ; command for trap call to display message
00001ECE  4E4F                    1768              TRAP        #15                 ; trap call
00001ED0                          1769              
00001ED0  4242                    1770              CLR         D2                  ; D2 needs to be cleared for use later
00001ED2  3601                    1771              MOVE.W      D1,D3               ; Move the entire word in D3 for shifting
00001ED4  E043                    1772              ASR         #eight,D3           ; Shift right by 8 to get EA bits from instruction
00001ED6  E243                    1773              ASR         #one,D3             ; Shift right once more to move the bits all the way
00001ED8  C67C 0007               1774              AND         #$07,D3             ; AND by 7 to clear unnecessary bits
00001EDC  4EB9 00002F02           1775              JSR         printEA             ; EA subroutine call to get remaining operand sent to the console
00001EE2                          1776              
00001EE2  43F9 00003CD9           1777              LEA         newLine,A1          ; Prime A1 with our new line to output
00001EE8  103C 000E               1778              MOVE.B      #14,D0              ; Prime new line for next instruction
00001EEC  4E4F                    1779              TRAP        #15                 ; Halt for IO
00001EEE                          1780              
00001EEE  6000 F15C               1781              BRA         LOOP                ; Return to control loop for next disassembly
00001EF2                          1782  
00001EF2                          1783  opCMPL                                      ; Known we have CMP.L, find and output operands
00001EF2  43F9 00003D7D           1784              LEA         dispLong,A1         ; Output the byte component of the instruction
00001EF8  103C 000E               1785              MOVE.B      #14,D0              ; Trap task #14 for console out
00001EFC  4E4F                    1786              TRAP        #15                 ; Halt for console out
00001EFE                          1787              
00001EFE  43F9 00003CDD           1788              LEA         space, A1           ; Display space for operands
00001F04  103C 000E               1789              MOVE.B      #14, D0             ; command for trap call to display message
00001F08  4E4F                    1790              TRAP        #15                 ; Console out/halt
00001F0A                          1791              
00001F0A  1401                    1792              MOVE.B      D1,D2               ; Move the byte for manipulation to D2
00001F0C  E642                    1793              ASR         #3,D2               ; Shift right by 3 to find left operand register
00001F0E  C47C 0007               1794              AND         #$07,D2             ; AND for comparison later
00001F12  1601                    1795              MOVE.B      D1,D3               ; Move the byte to D3 for use in our EA subroutine
00001F14  C67C 0007               1796              AND         #$07,D3             ; AND for comparison in subroutine
00001F18  4EB9 00002F02           1797              JSR         printEA             ; Use our EA subroutine to determine the left operand register
00001F1E                          1798              
00001F1E  43F9 00003CE4           1799              LEA         comma, A1           ; Display space
00001F24  103C 000E               1800              MOVE.B      #14, D0             ; command for trap call to display message
00001F28  4E4F                    1801              TRAP        #15                 ; trap call
00001F2A                          1802              
00001F2A  4242                    1803              CLR         D2                  ; D2 needs to be cleared for use later
00001F2C  3601                    1804              MOVE.W      D1,D3               ; Move the entire word in D3 for shifting
00001F2E  E043                    1805              ASR         #eight,D3           ; Shift right by 8 to get EA bits from instruction
00001F30  E243                    1806              ASR         #one,D3             ; Shift right once more to move the bits all the way
00001F32  C67C 0007               1807              AND         #$07,D3             ; AND by 7 to clear unnecessary bits
00001F36  4EB9 00002F02           1808              JSR         printEA             ; EA subroutine call to get remaining operand sent to the console
00001F3C                          1809              
00001F3C  43F9 00003CD9           1810              LEA         newLine,A1          ; Prime A1 with our new line to output
00001F42  103C 000E               1811              MOVE.B      #14,D0              ; Prime new line for next instruction
00001F46  4E4F                    1812              TRAP        #15                 ; Halt for IO
00001F48                          1813              
00001F48  6000 F102               1814              BRA         LOOP                ; Return to control loop for next disassembly
00001F4C                          1815  
00001F4C                          1816  ***********************************************************************************************************
00001F4C                          1817  *
00001F4C                          1818  *                   SUB OPCODE
00001F4C                          1819  *
00001F4C                          1820  *       This section is dedicated to disassembling the SUB opcode. We assume that the first nibble being 9
00001F4C                          1821  *       leads us to the SUB opcode.
00001F4C                          1822  *       SUB is differed by a operand direction, that being Dn - EA or EA - Dn.
00001F4C                          1823  *       These directions are deteremined as an opmode, and doubles up for each byte, long, and word mode.
00001F4C                          1824  *
00001F4C                          1825  ***********************************************************************************************************
00001F4C                          1826  
00001F4C                          1827  opSUB                                       ; We assume we found SUB, begin SUB disassemble
00001F4C  43F9 00003D3E           1828              LEA         SUBmatch, A1        ; Load A1 to print SUB found message
00001F52  103C 000E               1829              MOVE.B      #14, D0             ; command for trap call to display message
00001F56  4E4F                    1830              TRAP        #15                 ; trap call to halt
00001F58                          1831          
00001F58                          1832          
00001F58  E141                    1833              ASL         #eight,D1           ; Shift D1 to by 8 to find opmode
00001F5A  1218                    1834              MOVE.B      (A0)+,D1            ; Reload instruction
00001F5C  4242                    1835              CLR         D2                  ; Ensure D2 is clear
00001F5E                          1836              
00001F5E  3401                    1837              MOVE.W      D1,D2               ; Load our word into D2 to manipulate
00001F60  EC42                    1838              ASR         #six,D2             ; Move bits 7 places over to find opmode
00001F62  C47C 0007               1839              AND         #seven,D2           ; AND by 7 to remove extra bits
00001F66                          1840              
00001F66                          1841              ; These are for Dn - EA
00001F66  B43C 0000               1842              CMP.B       #zero,D2            ; Check for byte
00001F6A  6700 002A               1843              BEQ         opSUBB              ; Byte in opmode
00001F6E  B43C 0001               1844              CMP.B       #one,D2             ; Check for word
00001F72  6700 007C               1845              BEQ         opSUBW              ; Word in opmode
00001F76  B43C 0002               1846              CMP.B       #two,D2             ; Check for long
00001F7A  6700 00CE               1847              BEQ         opSUBL              ; Long in opmode
00001F7E                          1848              
00001F7E                          1849              ; These are for EA - Dn
00001F7E  B43C 0004               1850              CMP.B       #four,D2            ; Check for byte
00001F82  6700 0012               1851              BEQ         opSUBB              ; Byte in opmode
00001F86  B43C 0005               1852              CMP.B       #five,D2            ; Check for word
00001F8A  6700 0064               1853              BEQ         opSUBW              ; Word in opmode
00001F8E  B43C 0006               1854              CMP.B       #six,D2             ; Check for long
00001F92  6700 00B6               1855              BEQ         opSUBL              ; Long in opmode
00001F96                          1856              
00001F96                          1857  opSUBB                                      ; Byte has been found, find operands
00001F96  43F9 00003D77           1858              LEA         dispByte,A1         ; Output the byte info to the console
00001F9C  103C 000E               1859              MOVE.B      #14,D0              ; Use trap task 14 for IO
00001FA0  4E4F                    1860              TRAP        #15                 ; Halt for IO
00001FA2                          1861              
00001FA2  43F9 00003CDD           1862              LEA         space, A1           ; Display space
00001FA8  103C 000E               1863              MOVE.B      #14, D0             ; command for trap call to display message
00001FAC  4E4F                    1864              TRAP        #15                 ; trap call         
00001FAE                          1865              
00001FAE  1401                    1866              MOVE.B      D1,D2               ; Load D2 with our D1 byte
00001FB0  E642                    1867              ASR         #3,D2               ; Shift by 3 to find an operand
00001FB2  C47C 0007               1868              AND         #$07,D2             ; AND by 7 to remove extra bits
00001FB6  3601                    1869              MOVE.W      D1,D3               ; Load D3 with our word in D1
00001FB8  C67C 0007               1870              AND         #$07,D3             ; AND by 7 to remove extra bits
00001FBC  4EB9 00002F02           1871              JSR         printEA             ; Use EA subroutine to find an operand
00001FC2                          1872              
00001FC2  43F9 00003CE4           1873              LEA         comma, A1           ; Display space
00001FC8  103C 000E               1874              MOVE.B      #14, D0             ; command for trap call to display message
00001FCC  4E4F                    1875              TRAP        #15                 ; trap call
00001FCE                          1876              
00001FCE  4242                    1877              CLR         D2                  ; Empty D2 for use again
00001FD0  3601                    1878              MOVE.W      D1,D3               ; Load the word again into D3
00001FD2  E043                    1879              ASR         #eight,D3           ; Shift by 8 to find other operand
00001FD4  E243                    1880              ASR         #one,D3             ; Requires an additional shift
00001FD6  C67C 0007               1881              AND         #$07,D3             ; AND by 7 to remove extra bits
00001FDA  4EB9 00002F02           1882              JSR         printEA             ; EA subroutine finds our remaining operand
00001FE0                          1883              
00001FE0  43F9 00003CD9           1884              LEA         newLine,A1          ; Ready console with newline
00001FE6  103C 000E               1885              MOVE.B      #14,D0              ; Trap 14 for output
00001FEA  4E4F                    1886              TRAP        #15                 ; Halt for IO
00001FEC                          1887              
00001FEC  6000 F05E               1888              BRA         LOOP                ; Return to control loop
00001FF0                          1889              
00001FF0                          1890  opSUBW                                      ; Word has been found, find operands
00001FF0  43F9 00003D7A           1891              LEA         dispWord,A1         ; Output the word info to the console
00001FF6  103C 000E               1892              MOVE.B      #14,D0              ; Use trap task 14 for IO
00001FFA  4E4F                    1893              TRAP        #15                 ; Halt for IO
00001FFC                          1894              
00001FFC  43F9 00003CDD           1895              LEA         space, A1           ; Display space
00002002  103C 000E               1896              MOVE.B      #14, D0             ; command for trap call to display message
00002006  4E4F                    1897              TRAP        #15                 ; trap call         
00002008                          1898              
00002008  1401                    1899              MOVE.B      D1,D2               ; Load D2 with our D1 byte
0000200A  E642                    1900              ASR         #3,D2               ; Shift by 3 to find an operand
0000200C  C47C 0007               1901              AND         #$07,D2             ; AND by 7 to remove extra bits
00002010  3601                    1902              MOVE.W      D1,D3               ; Load D3 with our word in D1
00002012  C67C 0007               1903              AND         #$07,D3             ; AND by 7 to remove extra bits
00002016  4EB9 00002F02           1904              JSR         printEA             ; Use EA subroutine to find an operand
0000201C                          1905              
0000201C  43F9 00003CE4           1906              LEA         comma, A1           ; Display space
00002022  103C 000E               1907              MOVE.B      #14, D0             ; command for trap call to display message
00002026  4E4F                    1908              TRAP        #15                 ; trap call
00002028                          1909              
00002028  4242                    1910              CLR         D2                  ; Empty D2 for use again
0000202A  3601                    1911              MOVE.W      D1,D3               ; Load the word again into D3
0000202C  E043                    1912              ASR         #eight,D3           ; Shift by 8 to find other operand
0000202E  E243                    1913              ASR         #one,D3             ; Requires an additional shift
00002030  C67C 0007               1914              AND         #$07,D3             ; AND by 7 to remove extra bits
00002034  4EB9 00002F02           1915              JSR         printEA             ; EA subroutine finds our remaining operand
0000203A                          1916              
0000203A  43F9 00003CD9           1917              LEA         newLine,A1          ; Ready console with newline
00002040  103C 000E               1918              MOVE.B      #14,D0              ; Trap 14 for output
00002044  4E4F                    1919              TRAP        #15                 ; Halt for IO
00002046                          1920              
00002046  6000 F004               1921              BRA         LOOP                ; Return to control loop
0000204A                          1922              
0000204A                          1923  opSUBL                                      ; Long has been found, find operands
0000204A  43F9 00003D7D           1924              LEA         dispLong,A1         ; Output the long info to the console
00002050  103C 000E               1925              MOVE.B      #14,D0              ; Use trap task 14 for IO
00002054  4E4F                    1926              TRAP        #15                 ; Halt for IO
00002056                          1927              
00002056  43F9 00003CDD           1928              LEA         space, A1           ; Display space
0000205C  103C 000E               1929              MOVE.B      #14, D0             ; command for trap call to display message
00002060  4E4F                    1930              TRAP        #15                 ; trap call         
00002062                          1931              
00002062  1401                    1932              MOVE.B      D1,D2               ; Load D2 with our D1 byte
00002064  E642                    1933              ASR         #3,D2               ; Shift by 3 to find an operand
00002066  C47C 0007               1934              AND         #$07,D2             ; AND by 7 to remove extra bits
0000206A  3601                    1935              MOVE.W      D1,D3               ; Load D3 with our word in D1
0000206C  C67C 0007               1936              AND         #$07,D3             ; AND by 7 to remove extra bits
00002070  4EB9 00002F02           1937              JSR         printEA             ; Use EA subroutine to find an operand
00002076                          1938              
00002076  43F9 00003CE4           1939              LEA         comma, A1           ; Display space
0000207C  103C 000E               1940              MOVE.B      #14, D0             ; command for trap call to display message
00002080  4E4F                    1941              TRAP        #15                 ; trap call
00002082                          1942              
00002082  4242                    1943              CLR         D2                  ; Empty D2 for use again
00002084  3601                    1944              MOVE.W      D1,D3               ; Load the word again into D3
00002086  E043                    1945              ASR         #eight,D3           ; Shift by 8 to find other operand
00002088  E243                    1946              ASR         #one,D3             ; Requires an additional shift
0000208A  C67C 0007               1947              AND         #$07,D3             ; AND by 7 to remove extra bits
0000208E  4EB9 00002F02           1948              JSR         printEA             ; EA subroutine finds our remaining operand
00002094                          1949              
00002094  43F9 00003CD9           1950              LEA         newLine,A1          ; Ready console with newline
0000209A  103C 000E               1951              MOVE.B      #14,D0              ; Trap 14 for output
0000209E  4E4F                    1952              TRAP        #15                 ; Halt for IO
000020A0                          1953              
000020A0  6000 EFAA               1954              BRA         LOOP                ; Return to control loop
000020A4                          1955              
000020A4                          1956  ***********************************************************************************************************
000020A4                          1957  *
000020A4                          1958  *                   BRA OPCODE
000020A4                          1959  *       
000020A4                          1960  *       This section is dedicated to the BRA opcode, which is determined by having six in the first
000020A4                          1961  *       nibble of the instruction, and zero in the second nibble.
000020A4                          1962  *
000020A4                          1963  ***********************************************************************************************************
000020A4                          1964              
000020A4                          1965  opBRA       
000020A4  43F9 00003D22           1966              LEA         BRAmatch, A1        ; we know that the opcode will be BRA, so load A1 to print message
000020AA  103C 000E               1967              MOVE.B      #14, D0             ; Prime trap task #14 for output
000020AE  4E4F                    1968              TRAP        #15                 ; trap call to output BRA
000020B0                          1969          
000020B0  4242                    1970              CLR         D2                  ; Data register to needs to be cleared for use again
000020B2  4243                    1971              CLR         D3                  ; Data register to needs to be cleared for use again
000020B4                          1972  
000020B4  43F9 00003CDD           1973              LEA         space,A1            ; output a space for the IO console
000020BA  103C 000E               1974              MOVE.B      #14,D0              ; Prime trap task #14 for the output
000020BE  4E4F                    1975              TRAP        #15                 ; Call trap #15 with number 14 for our IO
000020C0                          1976          
000020C0  143C 0007               1977              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
000020C4  1218                    1978              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
000020C6  4EB9 00002F02           1979              JSR         printEA             ; this method handles the displacement hex values
000020CC                          1980          
000020CC  43F9 00003CD9           1981              LEA         newLine, A1         ; create new line for the IO console
000020D2  103C 000E               1982              MOVE.B      #14, D0             ; command for trap call to display message
000020D6  4E4F                    1983              TRAP        #15                 ; trap call ready console for next instruction
000020D8                          1984  
000020D8  6000 EF72               1985              BRA         LOOP                ; return back to our control loop to find next instruction
000020DC                          1986          
000020DC                          1987  ***********************************************************************************************************
000020DC                          1988  *
000020DC                          1989  *                   Bcc OPCODES
000020DC                          1990  *
000020DC                          1991  *       This section is dedicated to the conditional branching opcode. There are varying second nibble
000020DC                          1992  *       values, documented below, with the correspond cc code.
000020DC                          1993  *       BCC is similar to BRA, so we handle it in the same manner.
000020DC                          1994  *
000020DC                          1995  *       Supported cc condition codes:
000020DC                          1996  *           >Carry Clear        = CS        second nibble == 5
000020DC                          1997  *           >Overflow Set       = VC        second nibble == 8
000020DC                          1998  *           >Greater or EqualGE = GE        second nibble == 12
000020DC                          1999  *           >Less Than          = LT        second nibble == 13
000020DC                          2000  *
000020DC                          2001  ***********************************************************************************************************
000020DC                          2002  * CS Conition Code
000020DC                          2003  
000020DC                          2004  opBCS       
000020DC  43F9 00003D26           2005              LEA         BCSmatch, A1        ; we know that the opcode will be BCS, so load A1 to print message
000020E2  103C 000E               2006              MOVE.B      #14, D0             ; command for trap call to display message
000020E6  4E4F                    2007              TRAP        #15                 ; trap call
000020E8                          2008          
000020E8  4242                    2009              CLR         D2                  ; Data register to needs to be cleared for use again
000020EA  4243                    2010              CLR         D3                  ; Data register to needs to be cleared for use again
000020EC                          2011  
000020EC  43F9 00003CDD           2012              LEA         space,A1            ; output a space for the IO console
000020F2  103C 000E               2013              MOVE.B      #14,D0              ; Prime trap task #14 for the output
000020F6  4E4F                    2014              TRAP        #15                 ; Call trap #15 with number 14 for our IO
000020F8                          2015          
000020F8  143C 0007               2016              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
000020FC  1218                    2017              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
000020FE  4EB9 00002F02           2018              JSR         printEA             ; this method handles the displacement hex values
00002104                          2019          
00002104  43F9 00003CD9           2020              LEA         newLine, A1         ; create new line for the IO console
0000210A  103C 000E               2021              MOVE.B      #14, D0             ; command for trap call to display message
0000210E  4E4F                    2022              TRAP        #15                 ; trap call ready console for next instruction
00002110                          2023              
00002110  6000 EF3A               2024              BRA         LOOP                ; return to the control loop for next instruction
00002114                          2025  
00002114                          2026  ***********************************************************************************************************
00002114                          2027  * VC Condition Code
00002114                          2028  
00002114                          2029  opBVC       
00002114  43F9 00003D2A           2030              LEA         BVCmatch, A1        ; we know that the opcode will be BVC, so load A1 to print message
0000211A  103C 000E               2031              MOVE.B      #14, D0             ; command for trap call to display message
0000211E  4E4F                    2032              TRAP        #15                 ; trap call
00002120                          2033          
00002120  4242                    2034              CLR         D2                  ; Data register to needs to be cleared for use again
00002122  4243                    2035              CLR         D3                  ; Data register to needs to be cleared for use again
00002124                          2036  
00002124  43F9 00003CDD           2037              LEA         space,A1            ; output a space for the IO console
0000212A  103C 000E               2038              MOVE.B      #14,D0              ; Prime trap task #14 for the output
0000212E  4E4F                    2039              TRAP        #15                 ; Call trap #15 with number 14 for our IO
00002130                          2040          
00002130  143C 0007               2041              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
00002134  1218                    2042              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
00002136  4EB9 00002F02           2043              JSR         printEA             ; this method handles the displacement hex values
0000213C                          2044          
0000213C  43F9 00003CD9           2045              LEA         newLine, A1         ; create new line for the IO console
00002142  103C 000E               2046              MOVE.B      #14, D0             ; command for trap call to display message
00002146  4E4F                    2047              TRAP        #15                 ; trap call ready console for next instruction
00002148                          2048              
00002148  6000 EF02               2049              BRA         LOOP                ; return to the control loop for next instruction
0000214C                          2050  
0000214C                          2051  ***********************************************************************************************************
0000214C                          2052  * GE Conidtion Code     
0000214C                          2053          
0000214C                          2054  opBGE       
0000214C  43F9 00003D2E           2055              LEA         BGEmatch, A1        ; we know that the opcode will be BGE, so load A1 to print message
00002152  103C 000E               2056              MOVE.B      #14, D0             ; command for trap call to display message
00002156  4E4F                    2057              TRAP        #15                 ; trap call
00002158                          2058          
00002158  4242                    2059              CLR         D2                  ; Data register to needs to be cleared for use again
0000215A  4243                    2060              CLR         D3                  ; Data register to needs to be cleared for use again
0000215C                          2061  
0000215C  43F9 00003CDD           2062              LEA         space,A1            ; output a space for the IO console
00002162  103C 000E               2063              MOVE.B      #14,D0              ; Prime trap task #14 for the output
00002166  4E4F                    2064              TRAP        #15                 ; Call trap #15 with number 14 for our IO
00002168                          2065          
00002168  143C 0007               2066              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
0000216C  1218                    2067              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
0000216E  4EB9 00002F02           2068              JSR         printEA             ; this method handles the displacement hex values
00002174                          2069          
00002174  43F9 00003CD9           2070              LEA         newLine, A1         ; create new line for the IO console
0000217A  103C 000E               2071              MOVE.B      #14, D0             ; command for trap call to display message
0000217E  4E4F                    2072              TRAP        #15                 ; trap call ready console for next instruction
00002180                          2073              
00002180  6000 EECA               2074              BRA         LOOP                ; return to the control loop for next instruction
00002184                          2075  
00002184                          2076  ***********************************************************************************************************
00002184                          2077  * LT Conditions Code        
00002184                          2078          
00002184                          2079  opBLT   
00002184  43F9 00003D32           2080              LEA         BLTmatch, A1        ; we know that the opcode will be BLT, so load A1 to print message
0000218A  103C 000E               2081              MOVE.B      #14, D0             ; command for trap call to display message
0000218E  4E4F                    2082              TRAP        #15                 ; trap call
00002190                          2083          
00002190  4242                    2084              CLR         D2                  ; Data register to needs to be cleared for use again
00002192  4243                    2085              CLR         D3                  ; Data register to needs to be cleared for use again
00002194                          2086  
00002194  43F9 00003CDD           2087              LEA         space,A1            ; output a space for the IO console
0000219A  103C 000E               2088              MOVE.B      #14,D0              ; Prime trap task #14 for the output
0000219E  4E4F                    2089              TRAP        #15                 ; Call trap #15 with number 14 for our IO
000021A0                          2090          
000021A0  143C 0007               2091              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
000021A4  1218                    2092              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
000021A6  4EB9 00002F02           2093              JSR         printEA             ; this method handles the displacement hex values
000021AC                          2094          
000021AC  43F9 00003CD9           2095              LEA         newLine, A1         ; create new line for the IO console
000021B2  103C 000E               2096              MOVE.B      #14, D0             ; command for trap call to display message
000021B6  4E4F                    2097              TRAP        #15                 ; trap call ready console for next instruction
000021B8                          2098              
000021B8  6000 EE92               2099              BRA         LOOP                ; return to the control loop for next instruction
000021BC                          2100          
000021BC                          2101  ***********************************************************************************************************
000021BC                          2102  *
000021BC                          2103  *               SUBQ OPCODE
000021BC                          2104  *
000021BC                          2105  *       This section is for disassembling the SUBQ instruction, which is determined by a 5 in the first
000021BC                          2106  *       nibble.
000021BC                          2107  *       We assume there is only 1 opcode with 5 in the first nibble.
000021BC                          2108  *       SUBQ utilizes immediate data, so we use an alternate subroutine for operand output.
000021BC                          2109  *       The size field is used to branch to the subvariants of SUBQ, which we determine before hitting the
000021BC                          2110  *       final subroutines.
000021BC                          2111  *
000021BC                          2112  ***********************************************************************************************************
000021BC                          2113  
000021BC                          2114  opSUBQ                                      ; Assumed that we found SUBQ, begin disassemble
000021BC  43F9 00003D1D           2115              LEA         SUBQmatch, A1       ; Send out SUBQ message
000021C2  103C 000E               2116              MOVE.B      #14, D0             ; command for trap call to display message
000021C6  4E4F                    2117              TRAP        #15                 ; trap call to halt
000021C8                          2118              
000021C8  E141                    2119              ASL         #eight,D1           ; Shift by 8 to find size bits
000021CA  1218                    2120              MOVE.B      (A0)+,D1            ; Reload D1
000021CC  1401                    2121              MOVE.B      D1,D2               ; Move data in D2 to alter later
000021CE  EE42                    2122              ASR         #seven,D2           ; Move bits 7 places over to find size
000021D0  C47C 0007               2123              AND         #$07,D2             ; AND by 7 to remove uneeded bits
000021D4                          2124              
000021D4                          2125              ; Find size bits
000021D4  B43C 0000               2126              CMP.B       #zero,D2            ; Check for a byte
000021D8  6700 0012               2127              BEQ         opSUBQB             ; Byte in size
000021DC  B43C 0001               2128              CMP.B       #one,D2             ; Check for a word
000021E0  6700 0020               2129              BEQ         opSUBQW             ; Word in size
000021E4  B43C 0002               2130              CMP.B       #two,D2             ; Check for a long
000021E8  6700 002E               2131              BEQ         opSUBQL             ; Long in size
000021EC                          2132              
000021EC                          2133  opSUBQB                                     ; Found a byte in size, prepare for JSR
000021EC  43F9 00003D77           2134              LEA         dispByte,A1         ; Display the byte in the console
000021F2  103C 000E               2135              MOVE.B      #14,D0              ; Trap task 14 for IO
000021F6  4E4F                    2136              TRAP        #15                 ; Halt for IO
000021F8                          2137            
000021F8  4EB9 00002E2A           2138              JSR         PrntImm             ; Call immediate data subroutine to handle SUBQ operands
000021FE                          2139              
000021FE  6000 EE4C               2140              BRA         LOOP                ; Return to control loop
00002202                          2141              
00002202                          2142  opSUBQW                                     ; Found a word in size, prepare for JSR
00002202  43F9 00003D7A           2143              LEA         dispWord,A1         ; Display the word in the console
00002208  103C 000E               2144              MOVE.B      #14,D0              ; Trap task 14 for IO
0000220C  4E4F                    2145              TRAP        #15                 ; Halt for IO
0000220E                          2146            
0000220E  4EB9 00002E2A           2147              JSR         PrntImm             ; Call immediate data subroutine to handle SUBQ operands
00002214                          2148              
00002214  6000 EE36               2149              BRA         LOOP                ; Return to control loop
00002218                          2150              
00002218                          2151  opSUBQL                                     ; Found a long in size, prepare for JSR
00002218  43F9 00003D7D           2152              LEA         dispLong,A1         ; Display the long in the console
0000221E  103C 000E               2153              MOVE.B      #14,D0              ; Trap task 14 for IO
00002222  4E4F                    2154              TRAP        #15                 ; Halt for IO
00002224                          2155            
00002224  4246                    2156              CLR         D6                  ; In the long size case, we need to ensure D6 is clear for the JSR call
00002226  1C3C 0001               2157              MOVE.B      #1,D6               ; Needed to ensure proper immediate data is output to the console
0000222A                          2158            
0000222A  4EB9 00002E2A           2159              JSR         PrntImm             ; Call immediate data subroutine to handle SUBQ operands
00002230                          2160              
00002230  6000 EE1A               2161              BRA         LOOP                ; Return to control loop
00002234                          2162          
00002234                          2163  ***********************************************************************************************************
00002234                          2164  *
00002234                          2165  *                   MULS OPCODE
00002234                          2166  *
00002234                          2167  ***********************************************************************************************************
00002234                          2168  
00002234                          2169  opMULS  
00002234  43F9 00003D4A           2170              LEA         MULSmatch, A1       ; we know that the opcode will be MULS, so load A1 to print message
0000223A  103C 000E               2171              MOVE.B      #14, D0             ; command for trap call to display message
0000223E  4E4F                    2172              TRAP        #15                 ; trap call
00002240  43F9 00003CDD           2173              LEA         space, A1           ; create spaces
00002246  103C 000E               2174              MOVE.B      #14, D0             ; command for trap call to display message
0000224A  4E4F                    2175              TRAP        #15                 ; trap call
0000224C                          2176          
0000224C  E141                    2177              ASL         #eight, D1          ; move D1 over by a byte
0000224E  1218                    2178              MOVE.B      (A0)+, D1           ; copy the next byte into D1
00002250                          2179          
00002250  4242                    2180              CLR         D2                  ; clear D2
00002252  4243                    2181              CLR         D3                  ; clear D3
00002254  1401                    2182              MOVE.B      D1, D2              ; copy the byte from D1 to D2
00002256  E642                    2183              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
00002258  C47C 0007               2184              AND         #seven, D2          ; and D2 to get only first 3 bits
0000225C  1601                    2185              MOVE.B      D1, D3              ; copy D1 byte to D3
0000225E  C67C 0007               2186              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
00002262                          2187          
00002262  4EB9 00002F02           2188              JSR         printEA             ; jump to printEA
00002268                          2189          
00002268  43F9 00003CE4           2190              LEA         comma, A1           ; create comma
0000226E  103C 000E               2191              MOVE.B      #14, D0             ; command for trap call to display message
00002272  4E4F                    2192              TRAP        #15                 ; trap call
00002274                          2193  
00002274  4242                    2194              CLR         D2                  ; clear D2 since we know mode should be data register
00002276  4243                    2195              CLR         D3                  ; clear D3
00002278  3601                    2196              MOVE.W      D1, D3              ; Move D1 word to D3
0000227A  E043                    2197              ASR         #eight, D3          ; shift D3 by 8 bits
0000227C  E243                    2198              ASR         #one, D3            ; shift D3 by 1 bit
0000227E  C67C 0007               2199              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
00002282                          2200  
00002282  4EB9 00002F02           2201              JSR         printEA             ; jump to printEA
00002288                          2202          
00002288  43F9 00003CD9           2203              LEA         newLine, A1         ; create new line
0000228E  103C 000E               2204              MOVE.B      #14, D0             ; command for trap call to display message
00002292  4E4F                    2205              TRAP        #15                 ; trap call
00002294                          2206          
00002294  6000 EDB6               2207              BRA         LOOP                ; branch back to LOOP
00002298                          2208  
00002298                          2209  ***********************************************************************************************************
00002298                          2210  *
00002298                          2211  *                   ADD OPCODE
00002298                          2212  *
00002298                          2213  ***********************************************************************************************************   
00002298                          2214  
00002298                          2215  opADDB  
00002298  43F9 00003D4F           2216              LEA         ADDmatch, A1        ; we know that the opcode will be ADD, so load A1 to print message
0000229E  103C 000E               2217              MOVE.B      #14, D0             ; command for trap call to display message
000022A2  4E4F                    2218              TRAP        #15                 ; trap call
000022A4                          2219          
000022A4  43F9 00003D77           2220              LEA         dispByte, A1        ; display byte
000022AA  103C 000E               2221              MOVE.B      #14, D0             ; command for trap call to display message
000022AE  4E4F                    2222              TRAP        #15                 ; trap call
000022B0  43F9 00003CDD           2223              LEA         space, A1           ; create spaces
000022B6  103C 000E               2224              MOVE.B      #14, D0             ; command for trap call to display message
000022BA  4E4F                    2225              TRAP        #15                 ; trap call
000022BC                          2226          
000022BC  4242                    2227              CLR         D2                  ; clear D2
000022BE  4243                    2228              CLR         D3                  ; clear D3
000022C0  1401                    2229              MOVE.B      D1, D2              ; copy the byte from D1 to D2
000022C2  E642                    2230              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
000022C4  C47C 0007               2231              AND         #seven, D2          ; and D2 to get only first 3 bits
000022C8  1601                    2232              MOVE.B      D1, D3              ; copy D1 byte to D3
000022CA  C67C 0007               2233              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
000022CE                          2234          
000022CE  4EB9 00002F02           2235              JSR         printEA             ; jump to printEA
000022D4                          2236          
000022D4  43F9 00003CE4           2237              LEA         comma, A1           ; create comma
000022DA  103C 000E               2238              MOVE.B      #14, D0             ; command for trap call to display message
000022DE  4E4F                    2239              TRAP        #15                 ; trap call
000022E0                          2240  
000022E0  4242                    2241              CLR         D2                  ; clear D2 since we know mode should be data register
000022E2  4243                    2242              CLR         D3                  ; clear D3
000022E4  3601                    2243              MOVE.W      D1, D3              ; Move D1 word to D3
000022E6  E043                    2244              ASR         #eight, D3          ; shift D3 by 8 bits
000022E8  E243                    2245              ASR         #one, D3            ; shift D3 by 1 bit
000022EA  C67C 0007               2246              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
000022EE                          2247  
000022EE  4EB9 00002F02           2248              JSR         printEA             ; jump to printEA
000022F4                          2249          
000022F4  43F9 00003CD9           2250              LEA         newLine, A1         ; create new line
000022FA  103C 000E               2251              MOVE.B      #14, D0             ; command for trap call to display message
000022FE  4E4F                    2252              TRAP        #15                 ; trap call
00002300                          2253          
00002300  6000 ED4A               2254              BRA         LOOP                ; branch back to LOOP
00002304                          2255          
00002304                          2256  opADDW  
00002304  43F9 00003D4F           2257              LEA         ADDmatch, A1        ; we know that the opcode will be ADD, so load A1 to print message
0000230A  103C 000E               2258              MOVE.B      #14, D0             ; command for trap call to display message
0000230E  4E4F                    2259              TRAP        #15                 ; trap call
00002310                          2260  
00002310  43F9 00003D7A           2261              LEA         dispWord, A1        ; display word
00002316  103C 000E               2262              MOVE.B      #14, D0             ; command for trap call to display message
0000231A  4E4F                    2263              TRAP        #15                 ; trap call
0000231C  43F9 00003CDD           2264              LEA         space, A1           ; create spaces
00002322  103C 000E               2265              MOVE.B      #14, D0             ; command for trap call to display message
00002326  4E4F                    2266              TRAP        #15                 ; trap call
00002328                          2267          
00002328  4242                    2268              CLR         D2                  ; clear D2
0000232A  4243                    2269              CLR         D3                  ; clear D3
0000232C  1401                    2270              MOVE.B      D1, D2              ; copy the byte from D1 to D2
0000232E  E642                    2271              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
00002330  C47C 0007               2272              AND         #seven, D2          ; and D2 to get only first 3 bits
00002334  1601                    2273              MOVE.B      D1, D3              ; copy D1 byte to D3
00002336  C67C 0007               2274              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
0000233A                          2275          
0000233A  4EB9 00002F02           2276              JSR         printEA             ; jump to printEA
00002340                          2277          
00002340  43F9 00003CE4           2278              LEA         comma, A1           ; create comma
00002346  103C 000E               2279              MOVE.B      #14, D0             ; command for trap call to display message
0000234A  4E4F                    2280              TRAP        #15                 ; trap call
0000234C                          2281  
0000234C  4242                    2282              CLR         D2                  ; clear D2 since we know mode should be data register
0000234E  4243                    2283              CLR         D3                  ; clear D3
00002350  3601                    2284              MOVE.W      D1, D3              ; Move D1 word to D3
00002352  E043                    2285              ASR         #eight, D3          ; shift D3 by 8 bits
00002354  E243                    2286              ASR         #one, D3            ; shift D3 by 1 bit
00002356  C67C 0007               2287              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
0000235A                          2288  
0000235A  4EB9 00002F02           2289              JSR         printEA             ; jump to printEA
00002360                          2290          
00002360  43F9 00003CD9           2291              LEA         newLine, A1         ; create new line
00002366  103C 000E               2292              MOVE.B      #14, D0             ; command for trap call to display message
0000236A  4E4F                    2293              TRAP        #15                 ; trap call
0000236C                          2294          
0000236C  6000 ECDE               2295              BRA         LOOP                ; branch back to LOOP
00002370                          2296          
00002370                          2297  opADDL  
00002370  43F9 00003D4F           2298              LEA         ADDmatch, A1        ; we know that the opcode will be ADD, so load A1 to print message
00002376  103C 000E               2299              MOVE.B      #14, D0             ; command for trap call to display message
0000237A  4E4F                    2300              TRAP        #15                 ; trap call
0000237C                          2301          
0000237C  43F9 00003D7D           2302              LEA         dispLong, A1        ; display long
00002382  103C 000E               2303              MOVE.B      #14, D0             ; command for trap call to display message
00002386  4E4F                    2304              TRAP        #15                 ; trap call
00002388  43F9 00003CDD           2305              LEA         space, A1           ; create spaces
0000238E  103C 000E               2306              MOVE.B      #14, D0             ; command for trap call to display message
00002392  4E4F                    2307              TRAP        #15                 ; trap call
00002394                          2308          
00002394  4242                    2309              CLR         D2                  ; clear D2
00002396  4243                    2310              CLR         D3                  ; clear D3
00002398  1401                    2311              MOVE.B      D1, D2              ; copy the byte from D1 to D2
0000239A  E642                    2312              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
0000239C  C47C 0007               2313              AND         #seven, D2          ; and D2 to get only first 3 bits
000023A0  1601                    2314              MOVE.B      D1, D3              ; copy D1 byte to D3
000023A2  C67C 0007               2315              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
000023A6                          2316          
000023A6  4246                    2317              CLR         D6                  ; Clear D6
000023A8  1C3C 0001               2318              MOVE.B      #1, D6              ; move 1 to D6 in case source is printing immediate
000023AC                          2319          
000023AC  4EB9 00002F02           2320              JSR         printEA             ; jump to printEA
000023B2  4246                    2321              CLR         D6                  ; clear D6
000023B4                          2322          
000023B4  43F9 00003CE4           2323              LEA         comma, A1           ; create comma
000023BA  103C 000E               2324              MOVE.B      #14, D0             ; command for trap call to display message
000023BE  4E4F                    2325              TRAP        #15                 ; trap call
000023C0                          2326  
000023C0  4242                    2327              CLR         D2                  ; clear D2 since we know mode should be data register
000023C2  4243                    2328              CLR         D3                  ; clear D3
000023C4  3601                    2329              MOVE.W      D1, D3              ; Move D1 word to D3
000023C6  E043                    2330              ASR         #eight, D3          ; shift D3 by 8 bits
000023C8  E243                    2331              ASR         #one, D3            ; shift D3 by 1 bit
000023CA  C67C 0007               2332              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
000023CE                          2333  
000023CE  4EB9 00002F02           2334              JSR         printEA             ; jump to printEA
000023D4                          2335          
000023D4  43F9 00003CD9           2336              LEA         newLine, A1         ; create new line
000023DA  103C 000E               2337              MOVE.B      #14, D0             ; command for trap call to display message
000023DE  4E4F                    2338              TRAP        #15                 ; trap call
000023E0                          2339          
000023E0  6000 EC6A               2340              BRA         LOOP                ; branch back to LOOP
000023E4                          2341  
000023E4                          2342  ***********************************************************************************************************
000023E4                          2343  *
000023E4                          2344  *                   ADDA OPCODE
000023E4                          2345  *
000023E4                          2346  *********************************************************************************************************** 
000023E4                          2347  
000023E4                          2348  opADDAW 
000023E4  43F9 00003D53           2349              LEA         ADDAmatch, A1       ; we know that the opcode will be ADDA, so load A1 to print message
000023EA  103C 000E               2350              MOVE.B      #14, D0             ; command for trap call to display message
000023EE  4E4F                    2351              TRAP        #15                 ; trap call
000023F0                          2352          
000023F0  43F9 00003D7A           2353              LEA         dispWord, A1        ; display word
000023F6  103C 000E               2354              MOVE.B      #14, D0             ; command for trap call to display message
000023FA  4E4F                    2355              TRAP        #15                 ; trap call
000023FC  43F9 00003CDD           2356              LEA         space, A1           ; create spaces
00002402  103C 000E               2357              MOVE.B      #14, D0             ; command for trap call to display message
00002406  4E4F                    2358              TRAP        #15                 ; trap call
00002408                          2359          
00002408  4242                    2360              CLR         D2                  ; clear D2
0000240A  4243                    2361              CLR         D3                  ; clear D3
0000240C  1401                    2362              MOVE.B      D1, D2              ; copy the byte from D1 to D2
0000240E  E642                    2363              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
00002410  C47C 0007               2364              AND         #seven, D2          ; and D2 to get only first 3 bits
00002414  1601                    2365              MOVE.B      D1, D3              ; copy D1 byte to D3
00002416  C67C 0007               2366              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
0000241A                          2367          
0000241A  4EB9 00002F02           2368              JSR         printEA             ; jump to printEA 
00002420                          2369          
00002420  43F9 00003CE4           2370              LEA         comma, A1           ; create comma
00002426  103C 000E               2371              MOVE.B      #14, D0             ; command for trap call to display message
0000242A  4E4F                    2372              TRAP        #15                 ; trap call
0000242C                          2373  
0000242C  4242                    2374              CLR         D2                  ; clear D2 since we know mode should be data register
0000242E  4243                    2375              CLR         D3                  ; clear D3
00002430  143C 0001               2376              MOVE.B      #one, D2            ; move 1 to D2 since mode should be address
00002434  3601                    2377              MOVE.W      D1, D3              ; Move D1 word to D3
00002436  E043                    2378              ASR         #eight, D3          ; shift D3 by 8 bits
00002438  E243                    2379              ASR         #one, D3            ; shift D3 by 1 bit
0000243A  C67C 0007               2380              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
0000243E                          2381  
0000243E  4EB9 00002F02           2382              JSR         printEA             ; jump to printEA
00002444                          2383          
00002444  43F9 00003CD9           2384              LEA         newLine, A1         ; create new line
0000244A  103C 000E               2385              MOVE.B      #14, D0             ; command for trap call to display message
0000244E  4E4F                    2386              TRAP        #15                 ; trap call
00002450                          2387          
00002450  6000 EBFA               2388              BRA         LOOP                ; branch back to LOOP
00002454                          2389  
00002454                          2390  opADDAL 
00002454  43F9 00003D53           2391              LEA         ADDAmatch, A1       ; we know that the opcode will be ADDA, so load A1 to print message
0000245A  103C 000E               2392              MOVE.B      #14, D0             ; command for trap call to display message
0000245E  4E4F                    2393              TRAP        #15                 ; trap call
00002460                          2394  
00002460  43F9 00003D7D           2395              LEA         dispLong, A1        ; display long
00002466  103C 000E               2396              MOVE.B      #14, D0             ; command for trap call to display message
0000246A  4E4F                    2397              TRAP        #15                 ; trap call
0000246C  43F9 00003CDD           2398              LEA         space, A1           ; create spaces
00002472  103C 000E               2399              MOVE.B      #14, D0             ; command for trap call to display message
00002476  4E4F                    2400              TRAP        #15                 ; trap call
00002478                          2401          
00002478  4242                    2402              CLR         D2                  ; clear D2
0000247A  4243                    2403              CLR         D3                  ; clear D3
0000247C  1401                    2404              MOVE.B      D1, D2              ; copy the byte from D1 to D2
0000247E  E642                    2405              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
00002480  C47C 0007               2406              AND         #seven, D2          ; and D2 to get only first 3 bits
00002484  1601                    2407              MOVE.B      D1, D3              ; copy D1 byte to D3
00002486  C67C 0007               2408              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
0000248A                          2409          
0000248A  4EB9 00002F02           2410              JSR         printEA             ; jump to printEA 
00002490                          2411          
00002490  43F9 00003CE4           2412              LEA         comma, A1           ; create comma
00002496  103C 000E               2413              MOVE.B      #14, D0             ; command for trap call to display message
0000249A  4E4F                    2414              TRAP        #15                 ; trap call
0000249C                          2415  
0000249C  4242                    2416              CLR         D2                  ; clear D2 since we know mode should be data register
0000249E  4243                    2417              CLR         D3                  ; clear D3
000024A0  143C 0001               2418              MOVE.B      #one, D2            ; move 1 to D2 since mode should be address
000024A4  3601                    2419              MOVE.W      D1, D3              ; Move D1 word to D3
000024A6  E043                    2420              ASR         #eight, D3          ; shift D3 by 8 bits
000024A8  E243                    2421              ASR         #one, D3            ; shift D3 by 1 bit
000024AA  C67C 0007               2422              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
000024AE                          2423  
000024AE  4EB9 00002F02           2424              JSR         printEA             ; jump to printEA
000024B4                          2425          
000024B4  43F9 00003CD9           2426              LEA         newLine, A1         ; create new line
000024BA  103C 000E               2427              MOVE.B      #14, D0             ; command for trap call to display message
000024BE  4E4F                    2428              TRAP        #15                 ; trap call
000024C0                          2429          
000024C0  6000 EB8A               2430              BRA         LOOP                ; branch back to LOOP
000024C4                          2431          
000024C4                          2432  ***********************************************************************************************************
000024C4                          2433  *
000024C4                          2434  *                       Shifting OPCODES
000024C4                          2435  *
000024C4                          2436  ***********************************************************************************************************
000024C4                          2437  
000024C4                          2438  opASL       
000024C4  43F9 00003D64           2439              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
000024CA  103C 000E               2440              MOVE.B      #14, D0             ; command for trap call to display message
000024CE  4E4F                    2441              TRAP        #15                 ; trap call
000024D0                          2442          
000024D0  43F9 00003D7A           2443              LEA         dispWord, A1        ; display word
000024D6  103C 000E               2444              MOVE.B      #14, D0             ; command for trap call to display message
000024DA  4E4F                    2445              TRAP        #15                 ; trap call
000024DC                          2446          
000024DC  43F9 00003CDD           2447              LEA         space, A1           ; display space 
000024E2  103C 000E               2448              MOVE.B      #14, D0             ; command for trap call to display message
000024E6  4E4F                    2449              TRAP        #15                 ; trap call
000024E8                          2450          
000024E8  4242                    2451              CLR         D2                  ; clear D2
000024EA  4243                    2452              CLR         D3                  ; clear D3
000024EC  1401                    2453              MOVE.B      D1,D2               ; move byte from D1 to D2
000024EE  1601                    2454              MOVE.B      D1,D3               ; move byte from D1 to D3
000024F0                          2455          
000024F0  E602                    2456              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
000024F2  C47C 0007               2457              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
000024F6  C67C 0007               2458              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
000024FA                          2459          
000024FA  4EB9 00002F02           2460              JSR         printEA             ; jump to printEA
00002500                          2461          
00002500  43F9 00003CD9           2462              LEA         newLine, A1         ; Display newLine
00002506  103C 000E               2463              MOVE.B      #14, D0             ; command for trap call to display message
0000250A  4E4F                    2464              TRAP        #15                 ; trap call
0000250C                          2465          
0000250C  6000 EB3E               2466              BRA         LOOP                ; branch back to LOOP
00002510                          2467  
00002510                          2468  opASR   
00002510  43F9 00003D60           2469              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002516  103C 000E               2470              MOVE.B      #14, D0             ; command for trap call to display message
0000251A  4E4F                    2471              TRAP        #15                 ; trap call
0000251C                          2472          
0000251C  43F9 00003D7A           2473              LEA         dispWord, A1        ; display word
00002522  103C 000E               2474              MOVE.B      #14, D0             ; command for trap call to display message
00002526  4E4F                    2475              TRAP        #15                 ; trap call
00002528                          2476          
00002528  43F9 00003CDD           2477              LEA         space, A1           ; display space 
0000252E  103C 000E               2478              MOVE.B      #14, D0             ; command for trap call to display message
00002532  4E4F                    2479              TRAP        #15                 ; trap call
00002534                          2480          
00002534  4242                    2481              CLR         D2                  ; clear D2
00002536  4243                    2482              CLR         D3                  ; clear D3
00002538  1401                    2483              MOVE.B      D1,D2               ; move byte from D1 to D2
0000253A  1601                    2484              MOVE.B      D1,D3               ; move byte from D1 to D3
0000253C                          2485          
0000253C  E602                    2486              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
0000253E  C47C 0007               2487              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
00002542  C67C 0007               2488              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
00002546                          2489          
00002546  4EB9 00002F02           2490              JSR         printEA             ; jump to printEA
0000254C                          2491          
0000254C  43F9 00003CD9           2492              LEA         newLine, A1         ; Display newLine
00002552  103C 000E               2493              MOVE.B      #14, D0             ; command for trap call to display message
00002556  4E4F                    2494              TRAP        #15                 ; trap call
00002558                          2495          
00002558  6000 EAF2               2496              BRA         LOOP                ; branch back to LOOP
0000255C                          2497  
0000255C                          2498  opLSL       
0000255C  43F9 00003D5C           2499              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002562  103C 000E               2500              MOVE.B      #14, D0             ; command for trap call to display message
00002566  4E4F                    2501              TRAP        #15                 ; trap call
00002568                          2502              
00002568  43F9 00003D7A           2503              LEA         dispWord, A1        ; display word
0000256E  103C 000E               2504              MOVE.B      #14, D0             ; command for trap call to display message
00002572  4E4F                    2505              TRAP        #15                 ; trap call
00002574                          2506          
00002574  43F9 00003CDD           2507              LEA         space, A1           ; display space 
0000257A  103C 000E               2508              MOVE.B      #14, D0             ; command for trap call to display message
0000257E  4E4F                    2509              TRAP        #15                 ; trap call
00002580                          2510          
00002580  4242                    2511              CLR         D2                  ; clear D2
00002582  4243                    2512              CLR         D3                  ; clear D3
00002584  1401                    2513              MOVE.B      D1,D2               ; move byte from D1 to D2
00002586  1601                    2514              MOVE.B      D1,D3               ; move byte from D1 to D3
00002588                          2515          
00002588  E602                    2516              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
0000258A  C47C 0007               2517              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
0000258E  C67C 0007               2518              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
00002592                          2519          
00002592  4EB9 00002F02           2520              JSR         printEA             ; jump to printEA
00002598                          2521          
00002598  43F9 00003CD9           2522              LEA         newLine, A1         ; Display newLine
0000259E  103C 000E               2523              MOVE.B      #14, D0             ; command for trap call to display message
000025A2  4E4F                    2524              TRAP        #15                 ; trap call
000025A4                          2525          
000025A4  6000 EAA6               2526              BRA         LOOP                ; branch back to LOOP
000025A8                          2527  
000025A8                          2528  opLSR   
000025A8  43F9 00003D58           2529              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
000025AE  103C 000E               2530              MOVE.B      #14, D0             ; command for trap call to display message
000025B2  4E4F                    2531              TRAP        #15                 ; trap call
000025B4                          2532          
000025B4  43F9 00003D7A           2533              LEA         dispWord, A1        ; display word
000025BA  103C 000E               2534              MOVE.B      #14, D0             ; command for trap call to display message
000025BE  4E4F                    2535              TRAP        #15                 ; trap call
000025C0                          2536          
000025C0  43F9 00003CDD           2537              LEA         space, A1           ; display space 
000025C6  103C 000E               2538              MOVE.B      #14, D0             ; command for trap call to display message
000025CA  4E4F                    2539              TRAP        #15                 ; trap call
000025CC                          2540          
000025CC  4242                    2541              CLR         D2                  ; clear D2
000025CE  4243                    2542              CLR         D3                  ; clear D3
000025D0  1401                    2543              MOVE.B      D1,D2               ; move byte from D1 to D2
000025D2  1601                    2544              MOVE.B      D1,D3               ; move byte from D1 to D3
000025D4                          2545          
000025D4  E602                    2546              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
000025D6  C47C 0007               2547              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
000025DA  C67C 0007               2548              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
000025DE                          2549          
000025DE  4EB9 00002F02           2550              JSR         printEA             ; jump to printEA
000025E4                          2551          
000025E4  43F9 00003CD9           2552              LEA         newLine, A1         ; Display newLine
000025EA  103C 000E               2553              MOVE.B      #14, D0             ; command for trap call to display message
000025EE  4E4F                    2554              TRAP        #15                 ; trap call
000025F0                          2555          
000025F0  6000 EA5A               2556              BRA         LOOP                ; branch back to LOOP
000025F4                          2557  
000025F4                          2558  opROL   
000025F4  43F9 00003D6C           2559              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
000025FA  103C 000E               2560              MOVE.B      #14, D0             ; command for trap call to display message
000025FE  4E4F                    2561              TRAP        #15                 ; trap call
00002600                          2562          
00002600  43F9 00003D7A           2563              LEA         dispWord, A1        ; display word
00002606  103C 000E               2564              MOVE.B      #14, D0             ; command for trap call to display message
0000260A  4E4F                    2565              TRAP        #15                 ; trap call
0000260C                          2566          
0000260C  43F9 00003CDD           2567              LEA         space, A1           ; display space 
00002612  103C 000E               2568              MOVE.B      #14, D0             ; command for trap call to display message
00002616  4E4F                    2569              TRAP        #15                 ; trap call
00002618                          2570          
00002618  4242                    2571              CLR         D2                  ; clear D2
0000261A  4243                    2572              CLR         D3                  ; clear D3
0000261C  1401                    2573              MOVE.B      D1,D2               ; move byte from D1 to D2
0000261E  1601                    2574              MOVE.B      D1,D3               ; move byte from D1 to D3
00002620                          2575          
00002620  E602                    2576              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
00002622  C47C 0007               2577              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
00002626  C67C 0007               2578              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
0000262A                          2579          
0000262A  4EB9 00002F02           2580              JSR         printEA             ; jump to printEA
00002630                          2581          
00002630  43F9 00003CD9           2582              LEA         newLine, A1         ; Display newLine
00002636  103C 000E               2583              MOVE.B      #14, D0             ; command for trap call to display message
0000263A  4E4F                    2584              TRAP        #15                 ; trap call
0000263C                          2585          
0000263C  6000 EA0E               2586              BRA         LOOP                ; branch back to LOOP
00002640                          2587  
00002640                          2588  opROR   
00002640  43F9 00003D68           2589              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002646  103C 000E               2590              MOVE.B      #14, D0             ; command for trap call to display message
0000264A  4E4F                    2591              TRAP        #15                 ; trap call
0000264C                          2592          
0000264C  43F9 00003D7A           2593              LEA         dispWord, A1        ; display word
00002652  103C 000E               2594              MOVE.B      #14, D0             ; command for trap call to display message
00002656  4E4F                    2595              TRAP        #15                 ; trap call
00002658                          2596          
00002658  43F9 00003CDD           2597              LEA         space, A1           ; display space 
0000265E  103C 000E               2598              MOVE.B      #14, D0             ; command for trap call to display message
00002662  4E4F                    2599              TRAP        #15                 ; trap call
00002664                          2600          
00002664  4242                    2601              CLR         D2                  ; clear D2
00002666  4243                    2602              CLR         D3                  ; clear D3
00002668  1401                    2603              MOVE.B      D1,D2               ; move byte from D1 to D2
0000266A  1601                    2604              MOVE.B      D1,D3               ; move byte from D1 to D3
0000266C                          2605          
0000266C  E602                    2606              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
0000266E  C47C 0007               2607              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
00002672  C67C 0007               2608              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
00002676                          2609          
00002676  4EB9 00002F02           2610              JSR         printEA             ; jump to printEA
0000267C                          2611          
0000267C  43F9 00003CD9           2612              LEA         newLine, A1         ; Display newLine
00002682  103C 000E               2613              MOVE.B      #14, D0             ; command for trap call to display message
00002686  4E4F                    2614              TRAP        #15                 ; trap call
00002688                          2615          
00002688  6000 E9C2               2616              BRA         LOOP                ; branch back to LOOP
0000268C                          2617          
0000268C                          2618  memSB       
0000268C  4242                    2619              CLR         D2                  ; clear D2
0000268E  1401                    2620              MOVE.B      D1,D2               ; move D1 to D2
00002690  E642                    2621              ASR         #three, D2          ; shift D2 by 3 bits to get i/r
00002692                          2622              
00002692  C47C 0007               2623              AND         #$07, D2            ; and D2 by 3 bits 
00002696                          2624          
00002696  B43C 0000               2625              CMP.B       #zero, D2           ; compare 0 to D2
0000269A  6700 002E               2626              BEQ         opASBI              ; if true, branch to ASBI for immediate
0000269E  B43C 0004               2627              CMP.B       #four, D2           ; compare 4 to D2 
000026A2  6700 0088               2628              BEQ         opASBR              ; if true, branch to ASBR for register
000026A6  B43C 0001               2629              CMP.B       #one, D2            ; compare 1 to D2
000026AA  6700 00E2               2630              BEQ         opLSBI              ; if true, branch to LSBI for immediate
000026AE  B43C 0005               2631              CMP.B       #five, D2           ; compare 5 to D2
000026B2  6700 013C               2632              BEQ         opLSBR              ; if true, branch to LSBR for register
000026B6  B43C 0003               2633              CMP.B       #three, D2          ; compare 3 to D2
000026BA  6700 0196               2634              BEQ         opROBI              ; if true, branch to ROBI for immediate
000026BE  B43C 0007               2635              CMP.B       #seven, D2          ; compare 7 to D2
000026C2  6700 01F0               2636              BEQ         opROBR              ; if true, branch to ROBR for register
000026C6  6000 15A6               2637              BRA         printInvalid        ; otherwise invalid
000026CA                          2638          
000026CA                          2639  opASBI  
000026CA  4242                    2640              CLR         D2                  ; clear D2
000026CC  3401                    2641              MOVE.W      D1, D2              ; move word from D1 to D2
000026CE  E042                    2642              ASR         #eight, D2          ; shift D2 over by 8 bits 
000026D0  C47C 0001               2643              AND         #$01, D2            ; and D2 by 1 bit to get direction
000026D4                          2644      
000026D4  B43C 0000               2645              CMP.B       #zero, D2           ; compare 0 to D2
000026D8  6700 000E               2646              BEQ         opASRBI             ; if true, branch to ASRBI for right
000026DC  B43C 0001               2647              CMP.B       #one, D2            ; compare 1 to D2
000026E0  6700 0028               2648              BEQ         opASLBI             ; if true, branch to ASLBI for left
000026E4  6000 1588               2649              BRA         printInvalid        ; otherwise invalid
000026E8                          2650          
000026E8                          2651  opASRBI 
000026E8  43F9 00003D60           2652              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000026EE  103C 000E               2653              MOVE.B      #14, D0             ; command for trap call to display message
000026F2  4E4F                    2654              TRAP        #15                 ; trap call
000026F4                          2655  
000026F4  43F9 00003D77           2656              LEA         dispByte, A1        ; display byte
000026FA  103C 000E               2657              MOVE.B      #14, D0             ; command for trap call to display message
000026FE  4E4F                    2658              TRAP        #15                 ; trap call
00002700                          2659          
00002700  4EB9 00002E2A           2660              JSR         PrntImm             ; jump to PrntImm
00002706                          2661          
00002706  6000 E944               2662              BRA         LOOP                ; branch back to LOOP
0000270A                          2663  
0000270A                          2664  opASLBI 
0000270A  43F9 00003D64           2665              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
00002710  103C 000E               2666              MOVE.B      #14, D0             ; command for trap call to display message
00002714  4E4F                    2667              TRAP        #15                 ; trap call
00002716                          2668  
00002716  43F9 00003D77           2669              LEA         dispByte, A1        ; display byte
0000271C  103C 000E               2670              MOVE.B      #14, D0             ; command for trap call to display message
00002720  4E4F                    2671              TRAP        #15                 ; trap call
00002722                          2672          
00002722  4EB9 00002E2A           2673              JSR         PrntImm             ; jump to PrntImm
00002728                          2674          
00002728  6000 E922               2675              BRA         LOOP                ; branch back to LOOP
0000272C                          2676  
0000272C                          2677  opASBR  
0000272C  4242                    2678              CLR         D2                  ; clear D2
0000272E  3401                    2679              MOVE.W      D1, D2              ; move word from D1 to D2
00002730  E042                    2680              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002732  C47C 0001               2681              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002736                          2682      
00002736  B43C 0000               2683              CMP.B       #zero, D2           ; compare 0 to D2 
0000273A  6700 000E               2684              BEQ         opASRBR             ; if true, branch to ASRBR for right
0000273E  B43C 0001               2685              CMP.B       #one, D2            ; compare 1 to D2
00002742  6700 0028               2686              BEQ         opASLBR             ; if true, branch to ASLBR for left
00002746  6000 1526               2687              BRA         printInvalid        ; otherwise invalid
0000274A                          2688          
0000274A                          2689  opASRBR 
0000274A  43F9 00003D60           2690              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002750  103C 000E               2691              MOVE.B      #14, D0             ; command for trap call to display message
00002754  4E4F                    2692              TRAP        #15                 ; trap call
00002756                          2693  
00002756  43F9 00003D77           2694              LEA         dispByte, A1        ; display byte
0000275C  103C 000E               2695              MOVE.B      #14, D0             ; command for trap call to display message
00002760  4E4F                    2696              TRAP        #15                 ; trap call
00002762                          2697          
00002762  4EB9 00002E86           2698              JSR         PrntReg             ; jump to PrntReg
00002768                          2699          
00002768  6000 E8E2               2700              BRA         LOOP                ; branch back to LOOP
0000276C                          2701  
0000276C                          2702  opASLBR 
0000276C  43F9 00003D64           2703              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
00002772  103C 000E               2704              MOVE.B      #14, D0             ; command for trap call to display message
00002776  4E4F                    2705              TRAP        #15                 ; trap call
00002778                          2706  
00002778  43F9 00003D77           2707              LEA         dispByte, A1        ; display byte
0000277E  103C 000E               2708              MOVE.B      #14, D0             ; command for trap call to display message
00002782  4E4F                    2709              TRAP        #15                 ; trap call
00002784                          2710          
00002784  4EB9 00002E86           2711              JSR         PrntReg             ; jump to PrntReg
0000278A                          2712          
0000278A  6000 E8C0               2713              BRA         LOOP                ; branch back to LOOP
0000278E                          2714  
0000278E                          2715  opLSBI      
0000278E  4242                    2716              CLR         D2                  ; clear D2
00002790  3401                    2717              MOVE.W      D1, D2              ; move word from D1 to D2
00002792  E042                    2718              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002794  C47C 0001               2719              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002798                          2720      
00002798  B43C 0000               2721              CMP.B       #zero, D2           ; compare 0 to D2 
0000279C  6700 000E               2722              BEQ         opLSRBI             ; if true, branch to LSRBI for right
000027A0  B43C 0001               2723              CMP.B       #one, D2            ; compare 1 to D2
000027A4  6700 0028               2724              BEQ         opLSLBI             ; if true, branch to LSLBI for left
000027A8  6000 14C4               2725              BRA         printInvalid        ; otherwise invalid
000027AC                          2726          
000027AC                          2727  opLSRBI 
000027AC  43F9 00003D58           2728              LEA         LSRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000027B2  103C 000E               2729              MOVE.B      #14, D0             ; command for trap call to display message
000027B6  4E4F                    2730              TRAP        #15                 ; trap call
000027B8                          2731  
000027B8  43F9 00003D77           2732              LEA         dispByte, A1        ; display byte
000027BE  103C 000E               2733              MOVE.B      #14, D0             ; command for trap call to display message
000027C2  4E4F                    2734              TRAP        #15                 ; trap call
000027C4                          2735          
000027C4  4EB9 00002E2A           2736              JSR         PrntImm             ; jump to PrntImm
000027CA                          2737          
000027CA  6000 E880               2738              BRA         LOOP                ; branch back to LOOP
000027CE                          2739              
000027CE                          2740  opLSLBI     
000027CE  43F9 00003D5C           2741              LEA         LSLmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000027D4  103C 000E               2742              MOVE.B      #14, D0             ; command for trap call to display message
000027D8  4E4F                    2743              TRAP        #15                 ; trap call
000027DA                          2744  
000027DA  43F9 00003D77           2745              LEA         dispByte, A1        ; display byte
000027E0  103C 000E               2746              MOVE.B      #14, D0             ; command for trap call to display message
000027E4  4E4F                    2747              TRAP        #15                 ; trap call
000027E6                          2748          
000027E6  4EB9 00002E2A           2749              JSR         PrntImm             ; jump to PrntImm
000027EC                          2750          
000027EC  6000 E85E               2751              BRA         LOOP                ; branch back to LOOP
000027F0                          2752  
000027F0                          2753  opLSBR  
000027F0  4242                    2754              CLR         D2                  ; clear D2
000027F2  3401                    2755              MOVE.W      D1, D2              ; move word from D1 to D2
000027F4  E042                    2756              ASR         #eight, D2          ; shift D2 over by 8 bits 
000027F6  C47C 0001               2757              AND         #$01, D2            ; and D2 by 1 bit to get direction
000027FA                          2758      
000027FA  B43C 0000               2759              CMP.B       #zero, D2           ; compare 0 to D2 
000027FE  6700 000E               2760              BEQ         opLSRBR             ; if true, branch to LSRBR for right
00002802  B43C 0001               2761              CMP.B       #one, D2            ; compare 1 to D2
00002806  6700 0028               2762              BEQ         opLSLBR             ; if true, branch to LSLBR for left
0000280A  6000 1462               2763              BRA         printInvalid        ; otherwise invalid
0000280E                          2764          
0000280E                          2765  opLSRBR 
0000280E  43F9 00003D58           2766              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002814  103C 000E               2767              MOVE.B      #14, D0             ; command for trap call to display message
00002818  4E4F                    2768              TRAP        #15                 ; trap call
0000281A                          2769  
0000281A  43F9 00003D77           2770              LEA         dispByte, A1        ; display byte
00002820  103C 000E               2771              MOVE.B      #14, D0             ; command for trap call to display message
00002824  4E4F                    2772              TRAP        #15                 ; trap call
00002826                          2773          
00002826  4EB9 00002E86           2774              JSR         PrntReg             ; jump to PrntReg
0000282C                          2775          
0000282C  6000 E81E               2776              BRA         LOOP                ; branch back to LOOP
00002830                          2777          
00002830                          2778  opLSLBR     
00002830  43F9 00003D5C           2779              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002836  103C 000E               2780              MOVE.B      #14, D0             ; command for trap call to display message
0000283A  4E4F                    2781              TRAP        #15                 ; trap call
0000283C                          2782  
0000283C  43F9 00003D77           2783              LEA         dispByte, A1        ; display byte
00002842  103C 000E               2784              MOVE.B      #14, D0             ; command for trap call to display message
00002846  4E4F                    2785              TRAP        #15                 ; trap call
00002848                          2786          
00002848  4EB9 00002E86           2787              JSR         PrntReg             ; jump to PrntReg
0000284E                          2788          
0000284E  6000 E7FC               2789              BRA         LOOP                ; branch back to LOOP
00002852                          2790              
00002852                          2791  opROBI  
00002852  4242                    2792              CLR         D2                  ; clear D2
00002854  3401                    2793              MOVE.W      D1, D2              ; move word from D1 to D2
00002856  E042                    2794              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002858  C47C 0001               2795              AND         #$01, D2            ; and D2 by 1 bit to get direction
0000285C                          2796      
0000285C  B43C 0000               2797              CMP.B       #zero, D2           ; compare 0 to D2
00002860  6700 000E               2798              BEQ         opRORBI             ; if true, branch to RORBI for right
00002864  B43C 0001               2799              CMP.B       #one, D2            ; compare 1 to D2
00002868  6700 0028               2800              BEQ         opROLBI             ; if true, branch to ROLBI for left
0000286C  6000 1400               2801              BRA         printInvalid        ; otherwise invalid
00002870                          2802          
00002870                          2803  opRORBI 
00002870  43F9 00003D68           2804              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002876  103C 000E               2805              MOVE.B      #14, D0             ; command for trap call to display message
0000287A  4E4F                    2806              TRAP        #15                 ; trap call
0000287C                          2807  
0000287C  43F9 00003D77           2808              LEA         dispByte, A1        ; display byte
00002882  103C 000E               2809              MOVE.B      #14, D0             ; command for trap call to display message
00002886  4E4F                    2810              TRAP        #15                 ; trap call
00002888                          2811          
00002888  4EB9 00002E2A           2812              JSR         PrntImm             ; jump to PrntImm
0000288E                          2813          
0000288E  6000 E7BC               2814              BRA         LOOP                ; branch back to LOOP
00002892                          2815  
00002892                          2816  opROLBI 
00002892  43F9 00003D6C           2817              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002898  103C 000E               2818              MOVE.B      #14, D0             ; command for trap call to display message
0000289C  4E4F                    2819              TRAP        #15                 ; trap call
0000289E                          2820  
0000289E  43F9 00003D77           2821              LEA         dispByte, A1        ; display byte
000028A4  103C 000E               2822              MOVE.B      #14, D0             ; command for trap call to display message
000028A8  4E4F                    2823              TRAP        #15                 ; trap call
000028AA                          2824          
000028AA  4EB9 00002E2A           2825              JSR         PrntImm             ; jump to PrntImm
000028B0                          2826          
000028B0  6000 E79A               2827              BRA         LOOP                ; branch back to LOOP
000028B4                          2828  
000028B4                          2829  opROBR  
000028B4  4242                    2830              CLR         D2                  ; clear D2
000028B6  3401                    2831              MOVE.W      D1, D2              ; move word from D1 to D2
000028B8  E042                    2832              ASR         #eight, D2          ; shift D2 over by 8 bits 
000028BA  C47C 0001               2833              AND         #$01, D2            ; and D2 by 1 bit to get direction
000028BE                          2834      
000028BE  B43C 0000               2835              CMP.B       #zero, D2           ; compare 0 to D2 
000028C2  6700 000E               2836              BEQ         opRORBR             ; if true, branch to RORBR for right
000028C6  B43C 0001               2837              CMP.B       #one, D2            ; compare 1 to D2
000028CA  6700 0028               2838              BEQ         opROLBR             ; if true, branch to ROLBR for left
000028CE  6000 139E               2839              BRA         printInvalid        ; otherwise invalid    
000028D2                          2840          
000028D2                          2841  opRORBR 
000028D2  43F9 00003D68           2842              LEA         RORmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000028D8  103C 000E               2843              MOVE.B      #14, D0             ; command for trap call to display message
000028DC  4E4F                    2844              TRAP        #15                 ; trap call
000028DE                          2845  
000028DE  43F9 00003D77           2846              LEA         dispByte, A1        ; display byte
000028E4  103C 000E               2847              MOVE.B      #14, D0             ; command for trap call to display message
000028E8  4E4F                    2848              TRAP        #15                 ; trap call
000028EA                          2849          
000028EA  4EB9 00002E86           2850              JSR         PrntReg             ; jump to PrntReg
000028F0                          2851          
000028F0  6000 E75A               2852              BRA         LOOP                ; branch back to LOOP
000028F4                          2853  
000028F4                          2854  opROLBR 
000028F4  43F9 00003D6C           2855              LEA         ROLmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000028FA  103C 000E               2856              MOVE.B      #14, D0             ; command for trap call to display message
000028FE  4E4F                    2857              TRAP        #15                 ; trap call
00002900                          2858  
00002900  43F9 00003D77           2859              LEA         dispByte, A1        ; display byte
00002906  103C 000E               2860              MOVE.B      #14, D0             ; command for trap call to display message
0000290A  4E4F                    2861              TRAP        #15                 ; trap call
0000290C                          2862          
0000290C  4EB9 00002E86           2863              JSR         PrntReg             ; jump to PrntReg
00002912                          2864          
00002912  6000 E738               2865              BRA         LOOP                ; branch back to LOOP       
00002916                          2866  
00002916                          2867  memSW   
00002916  4242                    2868              CLR         D2                  ; clear D2
00002918  1401                    2869              MOVE.B      D1,D2               ; move D1 to D2
0000291A  E642                    2870              ASR         #three, D2          ; shift D2 by 3 bits to get i/r
0000291C                          2871              
0000291C  C47C 0007               2872              AND         #$07, D2            ; and D2 by 3 bits 
00002920                          2873          
00002920  B43C 0000               2874              CMP.B       #zero, D2           ; compare 0 to D2
00002924  6700 002E               2875              BEQ         opASWI              ; if true, branch to ASWI for immediate
00002928  B43C 0004               2876              CMP.B       #four, D2           ; compare 4 to D2 
0000292C  6700 0088               2877              BEQ         opASWR              ; if true, branch to ASWR for register
00002930  B43C 0001               2878              CMP.B       #one, D2            ; compare 1 to D2
00002934  6700 00E2               2879              BEQ         opLSWI              ; if true, branch to LSWI for immediate
00002938  B43C 0005               2880              CMP.B       #five, D2           ; compare 5 to D2
0000293C  6700 013C               2881              BEQ         opLSWR              ; if true, branch to LSWR for register
00002940  B43C 0003               2882              CMP.B       #three, D2          ; compare 3 to D2
00002944  6700 0196               2883              BEQ         opROWI              ; if true, branch to ROWI for immediate
00002948  B43C 0007               2884              CMP.B       #seven, D2          ; compare 7 to D2
0000294C  6700 01F0               2885              BEQ         opROWR              ; if true, branch to ROWR for register
00002950  6000 131C               2886              BRA         printInvalid        ; otherwise invalid
00002954                          2887          
00002954                          2888  opASWI  
00002954  4242                    2889              CLR         D2                  ; clear D2
00002956  3401                    2890              MOVE.W      D1, D2              ; move word from D1 to D2
00002958  E042                    2891              ASR         #eight, D2          ; shift D2 over by 8 bits 
0000295A  C47C 0001               2892              AND         #$01, D2            ; and D2 by 1 bit to get direction
0000295E                          2893      
0000295E  B43C 0000               2894              CMP.B       #zero, D2           ; compare 0 to D2
00002962  6700 000E               2895              BEQ         opASRWI             ; if true, branch to ASRWI for right
00002966  B43C 0001               2896              CMP.B       #one, D2            ; compare 1 to D2
0000296A  6700 0028               2897              BEQ         opASLWI             ; if true, branch to ASLWI for left
0000296E  6000 12FE               2898              BRA         printInvalid        ; otherwise invalid
00002972                          2899          
00002972                          2900  opASRWI 
00002972  43F9 00003D60           2901              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002978  103C 000E               2902              MOVE.B      #14, D0             ; command for trap call to display message
0000297C  4E4F                    2903              TRAP        #15                 ; trap call
0000297E                          2904  
0000297E  43F9 00003D7A           2905              LEA         dispWord, A1        ; display word
00002984  103C 000E               2906              MOVE.B      #14, D0             ; command for trap call to display message
00002988  4E4F                    2907              TRAP        #15                 ; trap call
0000298A                          2908          
0000298A  4EB9 00002E2A           2909              JSR         PrntImm             ; jump to PrntImm
00002990                          2910          
00002990  6000 E6BA               2911              BRA         LOOP                ; branch back to LOOP
00002994                          2912  
00002994                          2913  opASLWI 
00002994  43F9 00003D64           2914              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
0000299A  103C 000E               2915              MOVE.B      #14, D0             ; command for trap call to display message
0000299E  4E4F                    2916              TRAP        #15                 ; trap call
000029A0                          2917  
000029A0  43F9 00003D7A           2918              LEA         dispWord, A1        ; display word
000029A6  103C 000E               2919              MOVE.B      #14, D0             ; command for trap call to display message
000029AA  4E4F                    2920              TRAP        #15                 ; trap call
000029AC                          2921          
000029AC  4EB9 00002E2A           2922              JSR         PrntImm             ; jump to PrntImm
000029B2                          2923          
000029B2  6000 E698               2924              BRA         LOOP                ; branch back to LOOP
000029B6                          2925  
000029B6                          2926  opASWR  
000029B6  4242                    2927              CLR         D2                  ; clear D2
000029B8  3401                    2928              MOVE.W      D1, D2              ; move word from D1 to D2
000029BA  E042                    2929              ASR         #eight, D2          ; shift D2 over by 8 bits 
000029BC  C47C 0001               2930              AND         #$01, D2            ; and D2 by 1 bit to get direction
000029C0                          2931      
000029C0  B43C 0000               2932              CMP.B       #zero, D2           ; compare 0 to D2 
000029C4  6700 000E               2933              BEQ         opASRWR             ; if true, branch to ASRWR for right
000029C8  B43C 0001               2934              CMP.B       #one, D2            ; compare 1 to D2
000029CC  6700 0028               2935              BEQ         opASLWR             ; if true, branch to ASLWR for left
000029D0  6000 129C               2936              BRA         printInvalid        ; otherwise invalid
000029D4                          2937          
000029D4                          2938  opASRWR     
000029D4  43F9 00003D60           2939              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000029DA  103C 000E               2940              MOVE.B      #14, D0             ; command for trap call to display message
000029DE  4E4F                    2941              TRAP        #15                 ; trap call
000029E0                          2942  
000029E0  43F9 00003D7A           2943              LEA         dispWord, A1        ; display word
000029E6  103C 000E               2944              MOVE.B      #14, D0             ; command for trap call to display message
000029EA  4E4F                    2945              TRAP        #15                 ; trap call
000029EC                          2946          
000029EC  4EB9 00002E86           2947              JSR         PrntReg             ; jump to PrntReg
000029F2                          2948          
000029F2  6000 E658               2949              BRA         LOOP                ; branch back to LOOP
000029F6                          2950  
000029F6                          2951  opASLWR     
000029F6  43F9 00003D64           2952              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
000029FC  103C 000E               2953              MOVE.B      #14, D0             ; command for trap call to display message
00002A00  4E4F                    2954              TRAP        #15                 ; trap call
00002A02                          2955  
00002A02  43F9 00003D7A           2956              LEA         dispWord, A1        ; display word
00002A08  103C 000E               2957              MOVE.B      #14, D0             ; command for trap call to display message
00002A0C  4E4F                    2958              TRAP        #15                 ; trap call
00002A0E                          2959          
00002A0E  4EB9 00002E86           2960              JSR         PrntReg             ; jump to PrntReg
00002A14                          2961          
00002A14  6000 E636               2962              BRA         LOOP                ; branch back to LOOP
00002A18                          2963  
00002A18                          2964  opLSWI      
00002A18  4242                    2965              CLR         D2                  ; clear D2
00002A1A  3401                    2966              MOVE.W      D1, D2              ; move word from D1 to D2
00002A1C  E042                    2967              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002A1E  C47C 0001               2968              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002A22                          2969      
00002A22  B43C 0000               2970              CMP.B       #zero, D2           ; compare 0 to D2 
00002A26  6700 000E               2971              BEQ         opLSRWI             ; if true, branch to LSRWI for right
00002A2A  B43C 0001               2972              CMP.B       #one, D2            ; compare 1 to D2
00002A2E  6700 0028               2973              BEQ         opLSLWI             ; if true, branch to LSLWI for left
00002A32  6000 123A               2974              BRA         printInvalid        ; otherwise invalid 
00002A36                          2975          
00002A36                          2976  opLSRWI 
00002A36  43F9 00003D58           2977              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002A3C  103C 000E               2978              MOVE.B      #14, D0             ; command for trap call to display message
00002A40  4E4F                    2979              TRAP        #15                 ; trap call
00002A42                          2980      
00002A42  43F9 00003D7A           2981              LEA         dispWord, A1        ; display word
00002A48  103C 000E               2982              MOVE.B      #14, D0             ; command for trap call to display message
00002A4C  4E4F                    2983              TRAP        #15                 ; trap call
00002A4E                          2984          
00002A4E  4EB9 00002E2A           2985              JSR         PrntImm             ; jump to PrntImm
00002A54                          2986          
00002A54  6000 E5F6               2987              BRA         LOOP                ; branch back to LOOP
00002A58                          2988              
00002A58                          2989  opLSLWI 
00002A58  43F9 00003D5C           2990              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002A5E  103C 000E               2991              MOVE.B      #14, D0             ; command for trap call to display message
00002A62  4E4F                    2992              TRAP        #15                 ; trap call
00002A64                          2993  
00002A64  43F9 00003D7A           2994              LEA         dispWord, A1        ; display word
00002A6A  103C 000E               2995              MOVE.B      #14, D0             ; command for trap call to display message
00002A6E  4E4F                    2996              TRAP        #15                 ; trap call
00002A70                          2997          
00002A70  4EB9 00002E2A           2998              JSR         PrntImm             ; jump to PrntImm
00002A76                          2999          
00002A76  6000 E5D4               3000              BRA         LOOP                ; branch back to LOOP
00002A7A                          3001              
00002A7A                          3002  opLSWR  
00002A7A  4242                    3003              CLR         D2                  ; clear D2
00002A7C  3401                    3004              MOVE.W      D1, D2              ; move word from D1 to D2
00002A7E  E042                    3005              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002A80  C47C 0001               3006              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002A84                          3007      
00002A84  B43C 0000               3008              CMP.B       #zero, D2           ; compare 0 to D2 
00002A88  6700 000E               3009              BEQ         opLSRWR             ; if true, branch to LSRWR for right
00002A8C  B43C 0001               3010              CMP.B       #one, D2            ; compare 1 to D2
00002A90  6700 0028               3011              BEQ         opLSLWR             ; if true, branch to LSLWR for left
00002A94  6000 11D8               3012              BRA         printInvalid        ; otherwise invalid
00002A98                          3013          
00002A98                          3014  opLSRWR 
00002A98  43F9 00003D58           3015              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002A9E  103C 000E               3016              MOVE.B      #14, D0             ; command for trap call to display message
00002AA2  4E4F                    3017              TRAP        #15                 ; trap call
00002AA4                          3018  
00002AA4  43F9 00003D7A           3019              LEA         dispWord, A1        ; display word
00002AAA  103C 000E               3020              MOVE.B      #14, D0             ; command for trap call to display message
00002AAE  4E4F                    3021              TRAP        #15                 ; trap call
00002AB0                          3022          
00002AB0  4EB9 00002E86           3023              JSR         PrntReg             ; jump to PrntReg
00002AB6                          3024          
00002AB6  6000 E594               3025              BRA         LOOP                ; branch back to LOOP
00002ABA                          3026          
00002ABA                          3027  opLSLWR 
00002ABA  43F9 00003D5C           3028              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002AC0  103C 000E               3029              MOVE.B      #14, D0             ; command for trap call to display message
00002AC4  4E4F                    3030              TRAP        #15                 ; trap call
00002AC6                          3031  
00002AC6  43F9 00003D7A           3032              LEA         dispWord, A1        ; display word
00002ACC  103C 000E               3033              MOVE.B      #14, D0             ; command for trap call to display message
00002AD0  4E4F                    3034              TRAP        #15                 ; trap call
00002AD2                          3035          
00002AD2  4EB9 00002E86           3036              JSR         PrntReg             ; jump to PrntReg
00002AD8                          3037          
00002AD8  6000 E572               3038              BRA         LOOP                ; branch back to LOOP
00002ADC                          3039  
00002ADC                          3040  opROWI  
00002ADC  4242                    3041              CLR         D2                  ; clear D2
00002ADE  3401                    3042              MOVE.W      D1, D2              ; move word from D1 to D2
00002AE0  E042                    3043              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002AE2  C47C 0001               3044              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002AE6                          3045      
00002AE6  B43C 0000               3046              CMP.B       #zero, D2           ; compare 0 to D2
00002AEA  6700 000E               3047              BEQ         opRORWI             ; if true, branch to RORWI for right
00002AEE  B43C 0001               3048              CMP.B       #one, D2            ; compare 1 to D2
00002AF2  6700 0028               3049              BEQ         opROLWI             ; if true, branch to ROLWI for left
00002AF6  6000 1176               3050              BRA         printInvalid        ; otherwise invalid
00002AFA                          3051          
00002AFA                          3052  opRORWI 
00002AFA  43F9 00003D68           3053              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002B00  103C 000E               3054              MOVE.B      #14, D0             ; command for trap call to display message
00002B04  4E4F                    3055              TRAP        #15                 ; trap call
00002B06                          3056  
00002B06  43F9 00003D7A           3057              LEA         dispWord, A1        ; display word
00002B0C  103C 000E               3058              MOVE.B      #14, D0             ; command for trap call to display message
00002B10  4E4F                    3059              TRAP        #15                 ; trap call
00002B12                          3060          
00002B12  4EB9 00002E2A           3061              JSR         PrntImm             ; jump to PrntImm
00002B18                          3062          
00002B18  6000 E532               3063              BRA         LOOP                ; branch back to LOOP
00002B1C                          3064  
00002B1C                          3065  opROLWI     
00002B1C  43F9 00003D6C           3066              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002B22                          3067          
00002B22  103C 000E               3068              MOVE.B      #14, D0             ; command for trap call to display message
00002B26  4E4F                    3069              TRAP        #15                 ; trap call
00002B28                          3070  
00002B28  43F9 00003D7A           3071              LEA         dispWord, A1        ; display word
00002B2E  103C 000E               3072              MOVE.B      #14, D0             ; command for trap call to display message
00002B32  4E4F                    3073              TRAP        #15                 ; trap call
00002B34                          3074          
00002B34  4EB9 00002E2A           3075              JSR         PrntImm             ; jump to PrntImm
00002B3A                          3076          
00002B3A  6000 E510               3077              BRA         LOOP                ; branch back to LOOP
00002B3E                          3078  
00002B3E                          3079  opROWR      
00002B3E  4242                    3080              CLR         D2                  ; clear D2
00002B40  3401                    3081              MOVE.W      D1, D2              ; move word from D1 to D2
00002B42  E042                    3082              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002B44  C47C 0001               3083              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002B48                          3084      
00002B48  B43C 0000               3085              CMP.B       #zero, D2           ; compare 0 to D2 
00002B4C  6700 000E               3086              BEQ         opRORWR             ; if true, branch to RORWR for right
00002B50  B43C 0001               3087              CMP.B       #one, D2            ; compare 1 to D2
00002B54  6700 0028               3088              BEQ         opROLWR             ; if true, branch to ROLWR for left
00002B58  6000 1114               3089              BRA         printInvalid        ; otherwise invalid     
00002B5C                          3090          
00002B5C                          3091  opRORWR 
00002B5C  43F9 00003D68           3092              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002B62  103C 000E               3093              MOVE.B      #14, D0             ; command for trap call to display message
00002B66  4E4F                    3094              TRAP        #15                 ; trap call
00002B68                          3095      
00002B68  43F9 00003D7A           3096              LEA         dispWord, A1        ; display word
00002B6E  103C 000E               3097              MOVE.B      #14, D0             ; command for trap call to display message
00002B72  4E4F                    3098              TRAP        #15                 ; trap call
00002B74                          3099          
00002B74  4EB9 00002E86           3100              JSR         PrntReg             ; jump to PrntReg
00002B7A                          3101          
00002B7A  6000 E4D0               3102              BRA         LOOP                ; branch back to LOOP
00002B7E                          3103  
00002B7E                          3104  opROLWR 
00002B7E  43F9 00003D6C           3105              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002B84  103C 000E               3106              MOVE.B      #14, D0             ; command for trap call to display message
00002B88  4E4F                    3107              TRAP        #15                 ; trap call
00002B8A                          3108  
00002B8A  43F9 00003D7A           3109              LEA         dispWord, A1        ; display word
00002B90  103C 000E               3110              MOVE.B      #14, D0             ; command for trap call to display message
00002B94  4E4F                    3111              TRAP        #15                 ; trap call
00002B96                          3112          
00002B96  4EB9 00002E86           3113              JSR         PrntReg             ; jump to PrntReg
00002B9C                          3114          
00002B9C  6000 E4AE               3115              BRA         LOOP                ; branch back to LOOP
00002BA0                          3116  
00002BA0                          3117  memSL   
00002BA0  4242                    3118              CLR         D2                  ; clear D2
00002BA2  1401                    3119              MOVE.B      D1,D2               ; move D1 to D2
00002BA4  E642                    3120              ASR         #three, D2          ; shift D2 by 3 bits to get i/r
00002BA6                          3121              
00002BA6  C47C 0007               3122              AND         #$07, D2            ; and D2 by 3 bits 
00002BAA                          3123          
00002BAA  B43C 0000               3124              CMP.B       #zero, D2           ; compare 0 to D2
00002BAE  6700 002E               3125              BEQ         opASLI              ; if true, branch to ASLI for immediate
00002BB2  B43C 0004               3126              CMP.B       #four, D2           ; compare 4 to D2 
00002BB6  6700 0088               3127              BEQ         opASLR              ; if true, branch to ASLR for register
00002BBA  B43C 0001               3128              CMP.B       #one, D2            ; compare 1 to D2
00002BBE  6700 00E2               3129              BEQ         opLSLI              ; if true, branch to LSLI for immediate
00002BC2  B43C 0005               3130              CMP.B       #five, D2           ; compare 5 to D2
00002BC6  6700 013C               3131              BEQ         opLSLR              ; if true, branch to LSLR for register
00002BCA  B43C 0003               3132              CMP.B       #three, D2          ; compare 3 to D2
00002BCE  6700 0196               3133              BEQ         opROLI              ; if true, branch to ROLI for immediate
00002BD2  B43C 0007               3134              CMP.B       #seven, D2          ; compare 7 to D2
00002BD6  6700 01F0               3135              BEQ         opROLR              ; if true, branch to ROLR for register
00002BDA  6000 1092               3136              BRA         printInvalid        ; otherwise invalid
00002BDE                          3137          
00002BDE                          3138  opASLI  
00002BDE  4242                    3139              CLR         D2                  ; clear D2
00002BE0  3401                    3140              MOVE.W      D1, D2              ; move word from D1 to D2
00002BE2  E042                    3141              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002BE4  C47C 0001               3142              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002BE8                          3143      
00002BE8  B43C 0000               3144              CMP.B       #zero, D2           ; compare 0 to D2
00002BEC  6700 000E               3145              BEQ         opASRLI             ; if true, branch to ASRLI for right
00002BF0  B43C 0001               3146              CMP.B       #one, D2            ; compare 1 to D2
00002BF4  6700 0028               3147              BEQ         opASLLI             ; if true, branch to ASLLI for left
00002BF8  6000 1074               3148              BRA         printInvalid        ; otherwise invalid
00002BFC                          3149          
00002BFC                          3150  opASRLI 
00002BFC  43F9 00003D60           3151              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002C02  103C 000E               3152              MOVE.B      #14, D0             ; command for trap call to display message
00002C06  4E4F                    3153              TRAP        #15                 ; trap call
00002C08                          3154  
00002C08  43F9 00003D7D           3155              LEA         dispLong, A1        ; display long
00002C0E  103C 000E               3156              MOVE.B      #14, D0             ; command for trap call to display message
00002C12  4E4F                    3157              TRAP        #15                 ; trap call
00002C14                          3158          
00002C14  4EB9 00002E2A           3159              JSR         PrntImm             ; jump to PrntImm
00002C1A                          3160          
00002C1A  6000 E430               3161              BRA         LOOP                ; branch back to LOOP
00002C1E                          3162  
00002C1E                          3163  opASLLI 
00002C1E  43F9 00003D64           3164              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
00002C24  103C 000E               3165              MOVE.B      #14, D0             ; command for trap call to display message
00002C28  4E4F                    3166              TRAP        #15                 ; trap call
00002C2A                          3167  
00002C2A  43F9 00003D7D           3168              LEA         dispLong, A1        ; display long
00002C30  103C 000E               3169              MOVE.B      #14, D0             ; command for trap call to display message
00002C34  4E4F                    3170              TRAP        #15                 ; trap call
00002C36                          3171          
00002C36  4EB9 00002E2A           3172              JSR         PrntImm             ; jump to PrntImm
00002C3C                          3173          
00002C3C  6000 E40E               3174              BRA         LOOP                ; branch back to LOOP
00002C40                          3175  
00002C40                          3176  opASLR  
00002C40  4242                    3177              CLR         D2                  ; clear D2
00002C42  3401                    3178              MOVE.W      D1, D2              ; move word from D1 to D2
00002C44  E042                    3179              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002C46  C47C 0001               3180              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002C4A                          3181      
00002C4A  B43C 0000               3182              CMP.B       #zero, D2           ; compare 0 to D2 
00002C4E  6700 000E               3183              BEQ         opASRLR             ; if true, branch to ASRLR for right
00002C52  B43C 0001               3184              CMP.B       #one, D2            ; compare 1 to D2
00002C56  6700 0028               3185              BEQ         opASLLR             ; if true, branch to ASLLR for left
00002C5A  6000 1012               3186              BRA         printInvalid        ; otherwise invalid 
00002C5E                          3187          
00002C5E                          3188  opASRLR 
00002C5E  43F9 00003D60           3189              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002C64  103C 000E               3190              MOVE.B      #14, D0             ; command for trap call to display message
00002C68  4E4F                    3191              TRAP        #15                 ; trap call
00002C6A                          3192  
00002C6A  43F9 00003D7D           3193              LEA         dispLong, A1        ; display long
00002C70  103C 000E               3194              MOVE.B      #14, D0             ; command for trap call to display message
00002C74  4E4F                    3195              TRAP        #15                 ; trap call
00002C76                          3196          
00002C76  4EB9 00002E86           3197              JSR         PrntReg             ; jump to PrntReg
00002C7C                          3198          
00002C7C  6000 E3CE               3199              BRA         LOOP                ; branch back to LOOP
00002C80                          3200  
00002C80                          3201  opASLLR 
00002C80  43F9 00003D64           3202              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
00002C86  103C 000E               3203              MOVE.B      #14, D0             ; command for trap call to display message
00002C8A  4E4F                    3204              TRAP        #15                 ; trap call
00002C8C                          3205  
00002C8C  43F9 00003D7D           3206              LEA         dispLong, A1        ; display long
00002C92  103C 000E               3207              MOVE.B      #14, D0             ; command for trap call to display message
00002C96  4E4F                    3208              TRAP        #15                 ; trap call
00002C98                          3209          
00002C98  4EB9 00002E86           3210              JSR         PrntReg             ; jump to PrntReg
00002C9E                          3211          
00002C9E  6000 E3AC               3212              BRA         LOOP                ; branch back to LOOP
00002CA2                          3213  
00002CA2                          3214  opLSLI  
00002CA2  4242                    3215              CLR         D2                  ; clear D2
00002CA4  3401                    3216              MOVE.W      D1, D2              ; move word from D1 to D2
00002CA6  E042                    3217              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002CA8  C47C 0001               3218              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002CAC                          3219      
00002CAC  B43C 0000               3220              CMP.B       #zero, D2           ; compare 0 to D2 
00002CB0  6700 000E               3221              BEQ         opLSRLI             ; if true, branch to LSRLI for right
00002CB4  B43C 0001               3222              CMP.B       #one, D2            ; compare 1 to D2
00002CB8  6700 0028               3223              BEQ         opLSLLI             ; if true, branch to LSLLI for left
00002CBC  6000 0FB0               3224              BRA         printInvalid        ; otherwise invalid  
00002CC0                          3225          
00002CC0                          3226  opLSRLI 
00002CC0  43F9 00003D58           3227              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002CC6  103C 000E               3228              MOVE.B      #14, D0             ; command for trap call to display message
00002CCA  4E4F                    3229              TRAP        #15                 ; trap call
00002CCC                          3230  
00002CCC  43F9 00003D7D           3231              LEA         dispLong, A1        ; display long
00002CD2  103C 000E               3232              MOVE.B      #14, D0             ; command for trap call to display message
00002CD6  4E4F                    3233              TRAP        #15                 ; trap call
00002CD8                          3234          
00002CD8  4EB9 00002E2A           3235              JSR         PrntImm             ; jump to PrntImm
00002CDE                          3236          
00002CDE  6000 E36C               3237              BRA         LOOP                ; branch back to LOOP
00002CE2                          3238  
00002CE2                          3239  
00002CE2                          3240  opLSLLI 
00002CE2  43F9 00003D5C           3241              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002CE8  103C 000E               3242              MOVE.B      #14, D0             ; command for trap call to display message
00002CEC  4E4F                    3243              TRAP        #15                 ; trap call
00002CEE                          3244  
00002CEE  43F9 00003D7D           3245              LEA         dispLong, A1        ; display long
00002CF4  103C 000E               3246              MOVE.B      #14, D0             ; command for trap call to display message
00002CF8  4E4F                    3247              TRAP        #15                 ; trap call
00002CFA                          3248          
00002CFA  4EB9 00002E2A           3249              JSR         PrntImm             ; jump to PrntImm
00002D00                          3250          
00002D00  6000 E34A               3251              BRA         LOOP                ; branch back to LOOP
00002D04                          3252  
00002D04                          3253  opLSLR  
00002D04  4242                    3254              CLR         D2                  ; clear D2
00002D06  3401                    3255              MOVE.W      D1, D2              ; move word from D1 to D2
00002D08  E042                    3256              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002D0A  C47C 0001               3257              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002D0E                          3258      
00002D0E  B43C 0000               3259              CMP.B       #zero, D2           ; compare 0 to D2 
00002D12  6700 000E               3260              BEQ         opLSRLR             ; if true, branch to LSRLR for right
00002D16  B43C 0001               3261              CMP.B       #one, D2            ; compare 1 to D2
00002D1A  6700 0028               3262              BEQ         opLSLLR             ; if true, branch to LSLLR for left
00002D1E  6000 0F4E               3263              BRA         printInvalid        ; otherwise invalid
00002D22                          3264          
00002D22                          3265  opLSRLR 
00002D22  43F9 00003D58           3266              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002D28  103C 000E               3267              MOVE.B      #14, D0             ; command for trap call to display message
00002D2C  4E4F                    3268              TRAP        #15                 ; trap call
00002D2E                          3269  
00002D2E  43F9 00003D7D           3270              LEA         dispLong, A1        ; display long
00002D34  103C 000E               3271              MOVE.B      #14, D0             ; command for trap call to display message
00002D38  4E4F                    3272              TRAP        #15                 ; trap call
00002D3A                          3273          
00002D3A  4EB9 00002E86           3274              JSR         PrntReg             ; jump to PrntReg
00002D40                          3275          
00002D40  6000 E30A               3276              BRA         LOOP                ; branch back to LOOP
00002D44                          3277          
00002D44                          3278  opLSLLR 
00002D44  43F9 00003D5C           3279              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002D4A  103C 000E               3280              MOVE.B      #14, D0             ; command for trap call to display message
00002D4E  4E4F                    3281              TRAP        #15                 ; trap call
00002D50                          3282  
00002D50  43F9 00003D7D           3283              LEA         dispLong, A1        ; display long
00002D56  103C 000E               3284              MOVE.B      #14, D0             ; command for trap call to display message
00002D5A  4E4F                    3285              TRAP        #15                 ; trap call
00002D5C                          3286          
00002D5C  4EB9 00002E86           3287              JSR         PrntReg             ; jump to PrntReg
00002D62                          3288          
00002D62  6000 E2E8               3289              BRA         LOOP                ; branch back to LOOP
00002D66                          3290              
00002D66                          3291  opROLI  
00002D66  4242                    3292              CLR         D2                  ; clear D2
00002D68  3401                    3293              MOVE.W      D1, D2              ; move word from D1 to D2
00002D6A  E042                    3294              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002D6C  C47C 0001               3295              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002D70                          3296      
00002D70  B43C 0000               3297              CMP.B       #zero, D2           ; compare 0 to D2
00002D74  6700 000E               3298              BEQ         opRORLI             ; if true, branch to RORLI for right
00002D78  B43C 0001               3299              CMP.B       #one, D2            ; compare 1 to D2
00002D7C  6700 0028               3300              BEQ         opROLLI             ; if true, branch to ROLLI for left
00002D80  6000 0EEC               3301              BRA         printInvalid        ; otherwise invalid
00002D84                          3302          
00002D84                          3303  opRORLI 
00002D84  43F9 00003D68           3304              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002D8A  103C 000E               3305              MOVE.B      #14, D0             ; command for trap call to display message
00002D8E  4E4F                    3306              TRAP        #15                 ; trap call
00002D90                          3307  
00002D90  43F9 00003D7D           3308              LEA         dispLong, A1        ; display long
00002D96  103C 000E               3309              MOVE.B      #14, D0             ; command for trap call to display message
00002D9A  4E4F                    3310              TRAP        #15                 ; trap call
00002D9C                          3311          
00002D9C  4EB9 00002E2A           3312              JSR         PrntImm             ; jump to PrntImm
00002DA2                          3313          
00002DA2  6000 E2A8               3314              BRA         LOOP                ; branch back to LOOP
00002DA6                          3315  
00002DA6                          3316  opROLLI 
00002DA6  43F9 00003D6C           3317              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002DAC  103C 000E               3318              MOVE.B      #14, D0             ; command for trap call to display message
00002DB0  4E4F                    3319              TRAP        #15                 ; trap call
00002DB2                          3320  
00002DB2  43F9 00003D7D           3321              LEA         dispLong, A1        ; display long
00002DB8  103C 000E               3322              MOVE.B      #14, D0             ; command for trap call to display message
00002DBC  4E4F                    3323              TRAP        #15                 ; trap call
00002DBE                          3324          
00002DBE  4EB9 00002E2A           3325              JSR         PrntImm             ; jump to PrntImm
00002DC4                          3326          
00002DC4  6000 E286               3327              BRA         LOOP                ; branch back to LOOP
00002DC8                          3328  
00002DC8                          3329  opROLR  
00002DC8  4242                    3330              CLR         D2                  ; clear D2
00002DCA  3401                    3331              MOVE.W      D1, D2              ; move word from D1 to D2
00002DCC  E042                    3332              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002DCE  C47C 0001               3333              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002DD2                          3334      
00002DD2  B43C 0000               3335              CMP.B       #zero, D2           ; compare 0 to D2 
00002DD6  6700 000E               3336              BEQ         opRORLR             ; if true, branch to RORLR for right
00002DDA  B43C 0001               3337              CMP.B       #one, D2            ; compare 1 to D2
00002DDE  6700 0028               3338              BEQ         opROLLR             ; if true, branch to ROLLR for left
00002DE2  6000 0E8A               3339              BRA         printInvalid        ; otherwise invalid     
00002DE6                          3340          
00002DE6                          3341  opRORLR 
00002DE6  43F9 00003D68           3342              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002DEC  103C 000E               3343              MOVE.B      #14, D0             ; command for trap call to display message
00002DF0  4E4F                    3344              TRAP        #15                 ; trap call
00002DF2                          3345  
00002DF2  43F9 00003D7D           3346              LEA         dispLong, A1        ; display long
00002DF8  103C 000E               3347              MOVE.B      #14, D0             ; command for trap call to display message
00002DFC  4E4F                    3348              TRAP        #15                 ; trap call
00002DFE                          3349          
00002DFE  4EB9 00002E86           3350              JSR         PrntReg             ; jump to PrntReg
00002E04                          3351          
00002E04  6000 E246               3352              BRA         LOOP                ; branch back to LOOP
00002E08                          3353  
00002E08                          3354  opROLLR     
00002E08  43F9 00003D6C           3355              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002E0E  103C 000E               3356              MOVE.B      #14, D0             ; command for trap call to display message
00002E12  4E4F                    3357              TRAP        #15                 ; trap call
00002E14                          3358      
00002E14  43F9 00003D7D           3359              LEA         dispLong, A1        ; display long
00002E1A  103C 000E               3360              MOVE.B      #14, D0             ; command for trap call to display message
00002E1E  4E4F                    3361              TRAP        #15                 ; trap call
00002E20                          3362          
00002E20  4EB9 00002E86           3363              JSR         PrntReg             ; jump to PrntReg
00002E26                          3364          
00002E26  6000 E224               3365              BRA         LOOP                ; branch back to LOOP
00002E2A                          3366          
00002E2A                          3367  ***********************************************************************************************************
00002E2A                          3368  *                       Immediate Data Subroutine Part 1
00002E2A                          3369  *
00002E2A                          3370  * The following subroutine displays the immediate number to shift and the data register that is being shifted. 
00002E2A                          3371  * This subroutine calls two printing immediate subroutine first, the the ea print subroutine.        
00002E2A                          3372  *
00002E2A                          3373  ***********************************************************************************************************
00002E2A                          3374  
00002E2A                          3375  PrntImm 
00002E2A  48E7 FF7E               3376              MOVEM.L     D0-D7/A1-A6, -(SP)  ; callee saved registers
00002E2E                          3377              
00002E2E  43F9 00003CDD           3378              LEA         space, A1           ; display space
00002E34  103C 000E               3379              MOVE.B      #14, D0             ; command for trap call to display message
00002E38  4E4F                    3380              TRAP        #15                 ; trap call
00002E3A                          3381              
00002E3A  43F9 00003CE0           3382              LEA         hashTag, A1         ; display #
00002E40  103C 000E               3383              MOVE.B      #14, D0             ; command for trap call to display message
00002E44  4E4F                    3384              TRAP        #15                 ; trap call
00002E46                          3385              
00002E46  4242                    3386              CLR         D2                  ; clear D2
00002E48  3401                    3387              MOVE.W      D1, D2              ; move word from D1 to D2
00002E4A  E042                    3388              ASR         #eight, D2          ; shift D2 by 8 bits
00002E4C  E242                    3389              ASR         #one, D2            ; shift D2 by one bit
00002E4E  C47C 0007               3390              AND         #$07, D2            ; and D2 to get just first 3 bits
00002E52                          3391          
00002E52  4EB9 00002ED8           3392              JSR         MemShiftImm         ; jump to MemShiftImm
00002E58                          3393          
00002E58  43F9 00003CE4           3394              LEA         comma, A1           ; display comma
00002E5E  103C 000E               3395              MOVE.B      #14, D0             ; command for trap call to display message
00002E62  4E4F                    3396              TRAP        #15                 ; trap call
00002E64                          3397          
00002E64  4242                    3398              CLR         D2                  ; clear D2 since destination mode must be data register
00002E66  4243                    3399              CLR         D3                  ; clear D3 to get register
00002E68  1601                    3400              MOVE.B      D1,D3               ; move byte from D1 to D3
00002E6A  C67C 0007               3401              AND         #$07, D3            ; and D3 to get first 3 bits only
00002E6E                          3402          
00002E6E  4EB9 00002F02           3403              JSR         printEA             ; jump to printEA
00002E74                          3404          
00002E74  43F9 00003CD9           3405              LEA         newLine, A1         ; create new line
00002E7A  103C 000E               3406              MOVE.B      #14, D0             ; command for trap call to display message
00002E7E  4E4F                    3407              TRAP        #15                 ; trap call
00002E80                          3408          
00002E80  4CDF 7EFF               3409              MOVEM.L     (SP)+, D0-D7/A1-A6  ; pop saved registers from stack
00002E84  4E75                    3410              RTS                             ; return
00002E86                          3411              
00002E86                          3412  ***********************************************************************************************************
00002E86                          3413  *
00002E86                          3414  *                       Shifting Helping Function
00002E86                          3415  *
00002E86                          3416  * The following subroutine determines the correct data register to display, and sets the values of D2 and 
00002E86                          3417  *       D3 accordingly to display the data register.
00002E86                          3418  * after setting the values, it calls another subroutine to actually display the data register.        
00002E86                          3419  *
00002E86                          3420  ***********************************************************************************************************
00002E86                          3421  
00002E86                          3422  PrntReg     
00002E86  48E7 FF7E               3423              MOVEM.L     D0-D7/A1-A6, -(SP)  ; callee saved
00002E8A                          3424          
00002E8A  43F9 00003CDD           3425              LEA         space, A1           ; display space
00002E90  103C 000E               3426              MOVE.B      #14, D0             ; command for trap call to display message
00002E94  4E4F                    3427              TRAP        #15                 ; trap call
00002E96                          3428          
00002E96  4242                    3429              CLR         D2                  ; clear D2
00002E98  4243                    3430              CLR         D3                  ; clear D3
00002E9A  3601                    3431              MOVE.W      D1, D3              ; move word from D1 to D3
00002E9C  E043                    3432              ASR         #eight, D3          ; shift D3 by 8 bits
00002E9E  E243                    3433              ASR         #one, D3            ; shift D3 by 1 bit
00002EA0  C67C 0007               3434              AND         #$07, D3            ; and D3 to get first 3 bits only
00002EA4                          3435          
00002EA4  4EB9 00002F02           3436              JSR         printEA             ; jump to printEA
00002EAA                          3437          
00002EAA  43F9 00003CE4           3438              LEA         comma, A1           ; display comma
00002EB0  103C 000E               3439              MOVE.B      #14, D0             ; command for trap call to display message
00002EB4  4E4F                    3440              TRAP        #15                 ; trap call
00002EB6                          3441          
00002EB6  4242                    3442              CLR         D2                  ; clear D2
00002EB8  4243                    3443              CLR         D3                  ; clear D3
00002EBA  1601                    3444              MOVE.B      D1,D3               ; move byte from D1 to D3
00002EBC  C67C 0007               3445              AND         #$07, D3            ; and D3 to get first 3 bits only
00002EC0                          3446          
00002EC0  4EB9 00002F02           3447              JSR         printEA             ; jump to printEA
00002EC6                          3448          
00002EC6  43F9 00003CD9           3449              LEA         newLine, A1         ; newline
00002ECC  103C 000E               3450              MOVE.B      #14, D0             ; command for trap call to display message
00002ED0  4E4F                    3451              TRAP        #15                 ; trap call
00002ED2                          3452          
00002ED2  4CDF 7EFF               3453              MOVEM.L     (SP)+, D0-D7/A1-A6  ; pop saved registers from stack
00002ED6  4E75                    3454              RTS                             ; return
00002ED8                          3455  
00002ED8                          3456  ***********************************************************************************************************
00002ED8                          3457  *
00002ED8                          3458  *                       Immediate Data Subroutine Part 2
00002ED8                          3459  *
00002ED8                          3460  * The following subroutine is used to display the number between 1-8 for the bit vount for the shift/rotate opcode
00002ED8                          3461  * It displays it by storing the appropriate number in D1 and running trap task 3.
00002ED8                          3462  *
00002ED8                          3463  ***********************************************************************************************************
00002ED8                          3464  
00002ED8                          3465  MemShiftImm     
00002ED8  48E7 FF7E               3466              MOVEM.L     D0-D7/A1-A6, -(SP)  ; callee saved data
00002EDC  4241                    3467              CLR         D1                  ; clear D1
00002EDE                          3468                 
00002EDE  1202                    3469              MOVE.B      D2, D1              ; move byte from D2 to D1
00002EE0  B23C 0000               3470              CMP.B       #zero, D1           ; compare 0 to D1
00002EE4  6700 000C               3471              BEQ         displayEight        ; if true, branch to displayEight
00002EE8                          3472                  
00002EE8  103C 0003               3473              MOVE.B      #3, D0              ; trap task command to display decimal
00002EEC  4E4F                    3474              TRAP        #15                 ; trap call
00002EEE  6000 000C               3475              BRA         endSubroutine       ; branch to endSubroutine
00002EF2                          3476                  
00002EF2                          3477  displayEight    
00002EF2  123C 0008               3478              MOVE.B      #$08, D1            ; move 8 to D1
00002EF6  103C 0003               3479              MOVE.B      #3, D0              ; trap task command to display decimal
00002EFA  4E4F                    3480              TRAP        #15                 ; trap call
00002EFC                          3481              
00002EFC                          3482  endSubroutine
00002EFC  4CDF 7EFF               3483              MOVEM.L     (SP)+, D0-D7/A1-A6  ; pop saved registers from stack
00002F00  4E75                    3484              RTS                             ; return
00002F02                          3485          
00002F02                          3486  ***********************************************************************************************************
00002F02                          3487  *
00002F02                          3488  *                       EA Print Subroutine
00002F02                          3489  *
00002F02                          3490  ***********************************************************************************************************
00002F02                          3491  
00002F02                          3492  printEA     
00002F02  48E7 FF7E               3493              MOVEM.L  D0-D7/A1-A6, -(SP)     ; callee saved data
00002F06                          3494  
00002F06  B43C 0000               3495              CMP.B       #zero, D2           ; compare D2 or Mode to 0
00002F0A  6700 002E               3496              BEQ         pDataReg            ; if true, branch to pDataReg
00002F0E  B43C 0001               3497              CMP.B       #one, D2            ; compare mode to 1
00002F12  6700 00E6               3498              BEQ         pAddrReg            ; if true, branch to pAddrReg
00002F16  B43C 0002               3499              CMP.B       #two, D2            ; compare mode to 2
00002F1A  6700 019E               3500              BEQ         pAddrDir            ; if true, branch to pAddrDir
00002F1E  B43C 0003               3501              CMP.B       #three, D2          ; compare mode to 3
00002F22  6700 02C2               3502              BEQ         pAddrPost           ; if true, branch to pAddrPost
00002F26  B43C 0004               3503              CMP.B       #four, D2           ; compare mode to 4
00002F2A  6700 0446               3504              BEQ         pAddrDec            ; if true, branch to pAddrDec
00002F2E  B43C 0007               3505              CMP.B       #seven, D2          ; compare mode to 7
00002F32  6700 0576               3506              BEQ         pHex                ; if true, branch to pHex
00002F36  6000 0642               3507              BRA         invalid             ; otherwise invalid
00002F3A                          3508  
00002F3A                          3509  ***********************************************************************************************************
00002F3A                          3510  * Data Register        
00002F3A                          3511  pDataReg    
00002F3A  B63C 0000               3512              CMP.B       #zero,D3            ; compare D3 or Register to 0
00002F3E  6700 003A               3513              BEQ         displayD0           ; if true, branch to displayD0
00002F42  B63C 0001               3514              CMP.B       #one,D3             ; compare D3 or Register to 1
00002F46  6700 0042               3515              BEQ         displayD1           ; if true, branch to displayD1
00002F4A  B63C 0002               3516              CMP.B       #two,D3             ; compare D3 or Register to 2
00002F4E  6700 004A               3517              BEQ         displayD2           ; if true, branch to displayD2
00002F52  B63C 0003               3518              CMP.B       #three,D3           ; compare D3 or Register to 3
00002F56  6700 0052               3519              BEQ         displayD3           ; if true, branch to displayD3
00002F5A  B63C 0004               3520              CMP.B       #four,D3            ; compare D3 or Register to 4
00002F5E  6700 005A               3521              BEQ         displayD4           ; if true, branch to displayD4
00002F62  B63C 0005               3522              CMP.B       #five,D3            ; compare D3 or Register to 5
00002F66  6700 0062               3523              BEQ         displayD5           ; if true, branch to displayD5
00002F6A  B63C 0006               3524              CMP.B       #six,D3             ; compare D3 or Register to 6
00002F6E  6700 006A               3525              BEQ         displayD6           ; if true, branch to displayD6
00002F72  B63C 0007               3526              CMP.B       #seven,D3           ; compare D3 or Register to 7
00002F76  6700 0072               3527              BEQ         displayD7           ; if true, branch to displayD7
00002F7A                          3528              
00002F7A  43F9 00003D9A           3529  displayD0   LEA         dispD0, A1          ; Display D0
00002F80  103C 000E               3530              MOVE.B      #14, D0             ; command for trap call to display message
00002F84  4E4F                    3531              TRAP        #15                 ; trap call
00002F86  6000 05F2               3532              BRA         endSUB              ; go to the end of the subroutine
00002F8A                          3533              
00002F8A  43F9 00003D9D           3534  displayD1   LEA         dispD1, A1          ; Display D1
00002F90  103C 000E               3535              MOVE.B      #14, D0             ; command for trap call to display message
00002F94  4E4F                    3536              TRAP        #15                 ; trap call
00002F96  6000 05E2               3537              BRA         endSUB              ; go to the end of the subroutine
00002F9A                          3538  
00002F9A  43F9 00003DA0           3539  displayD2   LEA         dispD2, A1          ; Display D2
00002FA0  103C 000E               3540              MOVE.B      #14, D0             ; command for trap call to display message
00002FA4  4E4F                    3541              TRAP        #15                 ; trap call
00002FA6  6000 05D2               3542              BRA         endSUB              ; go to the end of the subroutine
00002FAA                          3543  
00002FAA  43F9 00003DA3           3544  displayD3   LEA         dispD3, A1          ; Display D3
00002FB0  103C 000E               3545              MOVE.B      #14, D0             ; command for trap call to display message
00002FB4  4E4F                    3546              TRAP        #15                 ; trap call
00002FB6  6000 05C2               3547              BRA         endSUB              ; go to the end of the subroutine
00002FBA                          3548  
00002FBA  43F9 00003DA6           3549  displayD4   LEA         dispD4, A1          ; Display D4
00002FC0  103C 000E               3550              MOVE.B      #14, D0             ; command for trap call to display message
00002FC4  4E4F                    3551              TRAP        #15                 ; trap call
00002FC6  6000 05B2               3552              BRA         endSUB              ; go to the end of the subroutine
00002FCA                          3553  
00002FCA  43F9 00003DA9           3554  displayD5   LEA         dispD5, A1          ; Display D5
00002FD0  103C 000E               3555              MOVE.B      #14, D0             ; command for trap call to display message
00002FD4  4E4F                    3556              TRAP        #15                 ; trap call
00002FD6  6000 05A2               3557              BRA         endSUB              ; go to the end of the subroutine
00002FDA                          3558  
00002FDA  43F9 00003DAC           3559  displayD6   LEA         dispD6, A1          ; Display D6
00002FE0  103C 000E               3560              MOVE.B      #14, D0             ; command for trap call to display message
00002FE4  4E4F                    3561              TRAP        #15                 ; trap call
00002FE6  6000 0592               3562              BRA         endSUB              ; go to the end of the subroutine
00002FEA                          3563  
00002FEA  43F9 00003DAF           3564  displayD7   LEA         dispD7, A1          ; Display D7
00002FF0  103C 000E               3565              MOVE.B      #14, D0             ; command for trap call to display message
00002FF4  4E4F                    3566              TRAP        #15                 ; trap call
00002FF6  6000 0582               3567              BRA         endSUB              ; go to the end of the subroutine
00002FFA                          3568              
00002FFA                          3569  ***********************************************************************************************************
00002FFA                          3570  * Address Register
00002FFA                          3571  
00002FFA  B63C 0000               3572  pAddrReg    CMP.B       #zero,D3            ; compare D3 or Register to 0
00002FFE  6700 003A               3573              BEQ         displayA0           ; if true, branch to displayA0
00003002  B63C 0001               3574              CMP.B       #one,D3             ; compare D3 or Register to 1
00003006  6700 0042               3575              BEQ         displayA1           ; if true, branch to displayA1
0000300A  B63C 0002               3576              CMP.B       #two,D3             ; compare D3 or Register to 2
0000300E  6700 004A               3577              BEQ         displayA2           ; if true, branch to displayA2
00003012  B63C 0003               3578              CMP.B       #three,D3           ; compare D3 or Register to 3
00003016  6700 0052               3579              BEQ         displayA3           ; if true, branch to displayA3
0000301A  B63C 0004               3580              CMP.B       #four,D3            ; compare D3 or Register to 4
0000301E  6700 005A               3581              BEQ         displayA4           ; if true, branch to displayA4
00003022  B63C 0005               3582              CMP.B       #five,D3            ; compare D3 or Register to 5
00003026  6700 0062               3583              BEQ         displayA5           ; if true, branch to displayA5
0000302A  B63C 0006               3584              CMP.B       #six,D3             ; compare D3 or Register to 6
0000302E  6700 006A               3585              BEQ         displayA6           ; if true, branch to displayA6
00003032  B63C 0007               3586              CMP.B       #seven,D3           ; compare D3 or Register to 7
00003036  6700 0072               3587              BEQ         displayA7           ; if true, branch to displayA7
0000303A                          3588              
0000303A  43F9 00003D80           3589  displayA0   LEA         dispA0, A1          ; Display A0
00003040  103C 000E               3590              MOVE.B      #14, D0             ; command for trap call to display message
00003044  4E4F                    3591              TRAP        #15                 ; trap call
00003046  6000 0532               3592              BRA         endSUB              ; go to the end of the subroutine
0000304A                          3593              
0000304A  43F9 00003D83           3594  displayA1   LEA         dispA1, A1          ; Display A1
00003050  103C 000E               3595              MOVE.B      #14, D0             ; command for trap call to display message
00003054  4E4F                    3596              TRAP        #15                 ; trap call
00003056  6000 0522               3597              BRA         endSUB              ; go to the end of the subroutine
0000305A                          3598  
0000305A  43F9 00003D86           3599  displayA2   LEA         dispA2, A1          ; Display A2
00003060  103C 000E               3600              MOVE.B      #14, D0             ; command for trap call to display message
00003064  4E4F                    3601              TRAP        #15                 ; trap call
00003066  6000 0512               3602              BRA         endSUB              ; go to the end of the subroutine
0000306A                          3603  
0000306A  43F9 00003D89           3604  displayA3   LEA         dispA3, A1          ; Display A3
00003070  103C 000E               3605              MOVE.B      #14, D0             ; command for trap call to display message
00003074  4E4F                    3606              TRAP        #15                 ; trap call
00003076  6000 0502               3607              BRA         endSUB              ; go to the end of the subroutine
0000307A                          3608  
0000307A  43F9 00003D8C           3609  displayA4   LEA         dispA4, A1          ; Display A4
00003080  103C 000E               3610              MOVE.B      #14, D0             ; command for trap call to display message
00003084  4E4F                    3611              TRAP        #15                 ; trap call
00003086  6000 04F2               3612              BRA         endSUB              ; go to the end of the subroutine
0000308A                          3613  
0000308A  43F9 00003D8F           3614  displayA5   LEA         dispA5, A1          ; Display A5
00003090  103C 000E               3615              MOVE.B      #14, D0             ; command for trap call to display message
00003094  4E4F                    3616              TRAP        #15                 ; trap call
00003096  6000 04E2               3617              BRA         endSUB              ; go to the end of the subroutine
0000309A                          3618  
0000309A  43F9 00003D92           3619  displayA6   LEA         dispA6, A1          ; Display A6
000030A0  103C 000E               3620              MOVE.B      #14, D0             ; command for trap call to display message
000030A4  4E4F                    3621              TRAP        #15                 ; trap call
000030A6  6000 04D2               3622              BRA         endSUB              ; go to the end of the subroutine
000030AA                          3623  
000030AA  43F9 00003D95           3624  displayA7   LEA         dispA7, A1          ; Display A7
000030B0  103C 000E               3625              MOVE.B      #14, D0             ; command for trap call to display message
000030B4  4E4F                    3626              TRAP        #15                 ; trap call
000030B6  6000 04C2               3627              BRA         endSUB              ; go to the end of the subroutine
000030BA                          3628  
000030BA                          3629  ***********************************************************************************************************
000030BA                          3630  * Address Register Direct
000030BA                          3631  
000030BA  43F9 00003CE6           3632  pAddrDir    LEA         opPer, A1           ; Display open parenthesis
000030C0  103C 000E               3633              MOVE.B      #14, D0             ; command for trap call to display message
000030C4  4E4F                    3634              TRAP        #15                 ; trap call
000030C6                          3635              
000030C6  B63C 0000               3636              CMP.B       #zero,D3            ; compare D3 or Register to 0
000030CA  6700 003A               3637              BEQ         displayA0A          ; if true, branch to displayA0A
000030CE  B63C 0001               3638              CMP.B       #one,D3             ; compare D3 or Register to 1
000030D2  6700 004E               3639              BEQ         displayA1A          ; if true, branch to displayA1A
000030D6  B63C 0002               3640              CMP.B       #two,D3             ; compare D3 or Register to 2
000030DA  6700 0062               3641              BEQ         displayA2A          ; if true, branch to displayA2A
000030DE  B63C 0003               3642              CMP.B       #three,D3           ; compare D3 or Register to 3
000030E2  6700 0076               3643              BEQ         displayA3A          ; if true, branch to displayA3A
000030E6  B63C 0004               3644              CMP.B       #four,D3            ; compare D3 or Register to 4
000030EA  6700 008A               3645              BEQ         displayA4A          ; if true, branch to displayA4A
000030EE  B63C 0005               3646              CMP.B       #five,D3            ; compare D3 or Register to 5
000030F2  6700 009E               3647              BEQ         displayA5A          ; if true, branch to displayA5A
000030F6  B63C 0006               3648              CMP.B       #six,D3             ; compare D3 or Register to 6
000030FA  6700 00B2               3649              BEQ         displayA6A          ; if true, branch to displayA6A
000030FE  B63C 0007               3650              CMP.B       #seven,D3           ; compare D3 or Register to 7
00003102  6700 00C6               3651              BEQ         displayA7A          ; if true, branch to displayA7A
00003106                          3652              
00003106  43F9 00003D80           3653  displayA0A  LEA         dispA0, A1          ; Display A0
0000310C  103C 000E               3654              MOVE.B      #14, D0             ; command for trap call to display message
00003110  4E4F                    3655              TRAP        #15                 ; trap call
00003112  43F9 00003CE8           3656              LEA         clPer, A1           ; Display closing parenthesis
00003118  103C 000E               3657              MOVE.B      #14, D0             ; command for trap call to display message
0000311C  4E4F                    3658              TRAP        #15                 ; trap call
0000311E  6000 045A               3659              BRA         endSUB              ; go to the end of the subroutine
00003122                          3660              
00003122  43F9 00003D83           3661  displayA1A  LEA         dispA1, A1          ; Display A1
00003128  103C 000E               3662              MOVE.B      #14, D0             ; command for trap call to display message
0000312C  4E4F                    3663              TRAP        #15                 ; trap call
0000312E  43F9 00003CE8           3664              LEA         clPer, A1           ; Display closing parenthesis
00003134  103C 000E               3665              MOVE.B      #14, D0             ; command for trap call to display message
00003138  4E4F                    3666              TRAP        #15                 ; trap call
0000313A  6000 043E               3667              BRA         endSUB              ; go to the end of the subroutine
0000313E                          3668  
0000313E  43F9 00003D86           3669  displayA2A  LEA         dispA2, A1          ; Display A2
00003144  103C 000E               3670              MOVE.B      #14, D0             ; command for trap call to display message
00003148  4E4F                    3671              TRAP        #15                 ; trap call
0000314A  43F9 00003CE8           3672              LEA         clPer, A1           ; Display closing parenthesis
00003150  103C 000E               3673              MOVE.B      #14, D0             ; command for trap call to display message
00003154  4E4F                    3674              TRAP        #15                 ; trap call
00003156  6000 0422               3675              BRA         endSUB              ; go to the end of the subroutine
0000315A                          3676  
0000315A  43F9 00003D89           3677  displayA3A  LEA         dispA3, A1          ; Display A3
00003160  103C 000E               3678              MOVE.B      #14, D0             ; command for trap call to display message
00003164  4E4F                    3679              TRAP        #15                 ; trap call
00003166  43F9 00003CE8           3680              LEA         clPer, A1           ; Display closing parenthesis
0000316C  103C 000E               3681              MOVE.B      #14, D0             ; command for trap call to display message
00003170  4E4F                    3682              TRAP        #15                 ; trap call
00003172  6000 0406               3683              BRA         endSUB              ; go to the end of the subroutine
00003176                          3684  
00003176  43F9 00003D8C           3685  displayA4A  LEA         dispA4, A1          ; Display A4
0000317C  103C 000E               3686              MOVE.B      #14, D0             ; command for trap call to display message
00003180  4E4F                    3687              TRAP        #15                 ; trap call
00003182  43F9 00003CE8           3688              LEA         clPer, A1           ; Display closing parenthesis
00003188  103C 000E               3689              MOVE.B      #14, D0             ; command for trap call to display message
0000318C  4E4F                    3690              TRAP        #15                 ; trap call
0000318E  6000 03EA               3691              BRA         endSUB              ; go to the end of the subroutine
00003192                          3692  
00003192  43F9 00003D8F           3693  displayA5A  LEA         dispA5, A1          ; Display A5
00003198  103C 000E               3694              MOVE.B      #14, D0             ; command for trap call to display message
0000319C  4E4F                    3695              TRAP        #15                 ; trap call
0000319E  43F9 00003CE8           3696              LEA         clPer, A1           ; Display closing parenthesis
000031A4  103C 000E               3697              MOVE.B      #14, D0             ; command for trap call to display message
000031A8  4E4F                    3698              TRAP        #15                 ; trap call
000031AA  6000 03CE               3699              BRA         endSUB              ; go to the end of the subroutine
000031AE                          3700  
000031AE  43F9 00003D92           3701  displayA6A  LEA         dispA6, A1          ; Display A6
000031B4  103C 000E               3702              MOVE.B      #14, D0             ; command for trap call to display message
000031B8  4E4F                    3703              TRAP        #15                 ; trap call
000031BA  43F9 00003CE8           3704              LEA         clPer, A1           ; Display closing parenthesis
000031C0  103C 000E               3705              MOVE.B      #14, D0             ; command for trap call to display message
000031C4  4E4F                    3706              TRAP        #15                 ; trap call
000031C6  6000 03B2               3707              BRA         endSUB              ; go to the end of the subroutine
000031CA                          3708  
000031CA  43F9 00003D95           3709  displayA7A  LEA         dispA7, A1          ; Display A7
000031D0  103C 000E               3710              MOVE.B      #14, D0             ; command for trap call to display message
000031D4  4E4F                    3711              TRAP        #15                 ; trap call
000031D6  43F9 00003CE8           3712              LEA         clPer, A1           ; Display closing parenthesis
000031DC  103C 000E               3713              MOVE.B      #14, D0             ; command for trap call to display message
000031E0  4E4F                    3714              TRAP        #15                 ; trap call
000031E2  6000 0396               3715              BRA         endSUB              ; go to the end of the subroutine
000031E6                          3716              
000031E6                          3717  ***********************************************************************************************************
000031E6                          3718  * Addr Post-increment
000031E6                          3719              
000031E6  43F9 00003CE6           3720  pAddrPost   LEA         opPer, A1           ; Display open parenthesis
000031EC  103C 000E               3721              MOVE.B      #14, D0             ; command for trap call to display message
000031F0  4E4F                    3722              TRAP        #15                 ; trap call
000031F2                          3723              
000031F2  B63C 0000               3724              CMP.B       #zero,D3            ; compare D3 or Register to 0
000031F6  6700 003A               3725              BEQ         displayA0P          ; if true, branch to displayA0P
000031FA  B63C 0001               3726              CMP.B       #one,D3             ; compare D3 or Register to 1
000031FE  6700 005A               3727              BEQ         displayA1P          ; if true, branch to displayA1P
00003202  B63C 0002               3728              CMP.B       #two,D3             ; compare D3 or Register to 2
00003206  6700 007A               3729              BEQ         displayA2P          ; if true, branch to displayA2P
0000320A  B63C 0003               3730              CMP.B       #three,D3           ; compare D3 or Register to 3
0000320E  6700 009A               3731              BEQ         displayA3P          ; if true, branch to displayA3P
00003212  B63C 0004               3732              CMP.B       #four,D3            ; compare D3 or Register to 4
00003216  6700 00BA               3733              BEQ         displayA4P          ; if true, branch to displayA4P
0000321A  B63C 0005               3734              CMP.B       #five,D3            ; compare D3 or Register to 5
0000321E  6700 00DA               3735              BEQ         displayA5P          ; if true, branch to displayA5P
00003222  B63C 0006               3736              CMP.B       #six,D3             ; compare D3 or Register to 6
00003226  6700 00FA               3737              BEQ         displayA6P          ; if true, branch to displayA6P
0000322A  B63C 0007               3738              CMP.B       #seven,D3           ; compare D3 or Register to 7
0000322E  6700 011A               3739              BEQ         displayA7P          ; if true, branch to displayA7P
00003232                          3740              
00003232  43F9 00003D80           3741  displayA0P  LEA         dispA0, A1          ; Display A0
00003238  103C 000E               3742              MOVE.B      #14, D0             ; command for trap call to display message
0000323C  4E4F                    3743              TRAP        #15                 ; trap call
0000323E  43F9 00003CE8           3744              LEA         clPer, A1           ; Display closing parenthesis
00003244  103C 000E               3745              MOVE.B      #14, D0             ; command for trap call to display message
00003248  4E4F                    3746              TRAP        #15                 ; trap call
0000324A  43F9 00003CEC           3747              LEA         inc, A1             ; Display +
00003250  103C 000E               3748              MOVE.B      #14, D0             ; command for trap call to display message
00003254  4E4F                    3749              TRAP        #15                 ; trap call
00003256  6000 0322               3750              BRA         endSUB              ; go to the end of the subroutine
0000325A                          3751              
0000325A  43F9 00003D83           3752  displayA1P  LEA         dispA1, A1          ; Display A1
00003260  103C 000E               3753              MOVE.B      #14, D0             ; command for trap call to display message
00003264  4E4F                    3754              TRAP        #15                 ; trap call
00003266  43F9 00003CE8           3755              LEA         clPer, A1           ; Display closing parenthesis
0000326C  103C 000E               3756              MOVE.B      #14, D0             ; command for trap call to display message
00003270  4E4F                    3757              TRAP        #15                 ; trap call
00003272  43F9 00003CEC           3758              LEA         inc, A1             ; Display +
00003278  103C 000E               3759              MOVE.B      #14, D0             ; command for trap call to display message
0000327C  4E4F                    3760              TRAP        #15                 ; trap call
0000327E  6000 02FA               3761              BRA         endSUB              ; go to the end of the subroutine
00003282                          3762  
00003282  43F9 00003D86           3763  displayA2P  LEA         dispA2, A1          ; Display A2
00003288  103C 000E               3764              MOVE.B      #14, D0             ; command for trap call to display message
0000328C  4E4F                    3765              TRAP        #15                 ; trap call
0000328E  43F9 00003CE8           3766              LEA         clPer, A1           ; Display closing parenthesis
00003294  103C 000E               3767              MOVE.B      #14, D0             ; command for trap call to display message
00003298  4E4F                    3768              TRAP        #15                 ; trap call
0000329A  43F9 00003CEC           3769              LEA         inc, A1             ; Display +
000032A0  103C 000E               3770              MOVE.B      #14, D0             ; command for trap call to display message
000032A4  4E4F                    3771              TRAP        #15                 ; trap call
000032A6  6000 02D2               3772              BRA         endSUB              ; go to the end of the subroutine
000032AA                          3773  
000032AA  43F9 00003D89           3774  displayA3P  LEA         dispA3, A1          ; Display A3
000032B0  103C 000E               3775              MOVE.B      #14, D0             ; command for trap call to display message
000032B4  4E4F                    3776              TRAP        #15                 ; trap call
000032B6  43F9 00003CE8           3777              LEA         clPer, A1           ; Display closing parenthesis
000032BC  103C 000E               3778              MOVE.B      #14, D0             ; command for trap call to display message
000032C0  4E4F                    3779              TRAP        #15                 ; trap call
000032C2  43F9 00003CEC           3780              LEA         inc, A1             ; Display +
000032C8  103C 000E               3781              MOVE.B      #14, D0             ; command for trap call to display message
000032CC  4E4F                    3782              TRAP        #15                 ; trap call
000032CE  6000 02AA               3783              BRA         endSUB              ; go to the end of the subroutine
000032D2                          3784  
000032D2  43F9 00003D8C           3785  displayA4P  LEA         dispA4, A1          ; Display A4
000032D8  103C 000E               3786              MOVE.B      #14, D0             ; command for trap call to display message
000032DC  4E4F                    3787              TRAP        #15                 ; trap call
000032DE  43F9 00003CE8           3788              LEA         clPer, A1           ; Display closing parenthesis
000032E4  103C 000E               3789              MOVE.B      #14, D0             ; command for trap call to display message
000032E8  4E4F                    3790              TRAP        #15                 ; trap call
000032EA  43F9 00003CEC           3791              LEA         inc, A1             ; Display +
000032F0  103C 000E               3792              MOVE.B      #14, D0             ; command for trap call to display message
000032F4  4E4F                    3793              TRAP        #15                 ; trap call
000032F6  6000 0282               3794              BRA         endSUB              ; go to the end of the subroutine
000032FA                          3795  
000032FA  43F9 00003D8F           3796  displayA5P  LEA         dispA5, A1          ; Display A5
00003300  103C 000E               3797              MOVE.B      #14, D0             ; command for trap call to display message
00003304  4E4F                    3798              TRAP        #15                 ; trap call
00003306  43F9 00003CE8           3799              LEA         clPer, A1           ; Display closing parenthesis
0000330C  103C 000E               3800              MOVE.B      #14, D0             ; command for trap call to display message
00003310  4E4F                    3801              TRAP        #15                 ; trap call
00003312  43F9 00003CEC           3802              LEA         inc, A1             ; Display +
00003318  103C 000E               3803              MOVE.B      #14, D0             ; command for trap call to display message
0000331C  4E4F                    3804              TRAP        #15                 ; trap call
0000331E  6000 025A               3805              BRA         endSUB              ; go to the end of the subroutine
00003322                          3806  
00003322  43F9 00003D92           3807  displayA6P  LEA         dispA6, A1          ; Display A6
00003328  103C 000E               3808              MOVE.B      #14, D0             ; command for trap call to display message
0000332C  4E4F                    3809              TRAP        #15                 ; trap call
0000332E  43F9 00003CE8           3810              LEA         clPer, A1           ; Display closing parenthesis
00003334  103C 000E               3811              MOVE.B      #14, D0             ; command for trap call to display message
00003338  4E4F                    3812              TRAP        #15                 ; trap call
0000333A  43F9 00003CEC           3813              LEA         inc, A1             ; Display +
00003340  103C 000E               3814              MOVE.B      #14, D0             ; command for trap call to display message
00003344  4E4F                    3815              TRAP        #15                 ; trap call
00003346  6000 0232               3816              BRA         endSUB              ; go to the end of the subroutine
0000334A                          3817  
0000334A  43F9 00003D95           3818  displayA7P  LEA         dispA7, A1          ; Display A7
00003350  103C 000E               3819              MOVE.B      #14, D0             ; command for trap call to display message
00003354  4E4F                    3820              TRAP        #15                 ; trap call
00003356  43F9 00003CE8           3821              LEA         clPer, A1           ; Display closing parenthesis
0000335C  103C 000E               3822              MOVE.B      #14, D0             ; command for trap call to display message
00003360  4E4F                    3823              TRAP        #15                 ; trap call
00003362  43F9 00003CEC           3824              LEA         inc, A1             ; Display +
00003368  103C 000E               3825              MOVE.B      #14, D0             ; command for trap call to display message
0000336C  4E4F                    3826              TRAP        #15                 ; trap call
0000336E  6000 020A               3827              BRA         endSUB              ; go to the end of the subroutine
00003372                          3828  
00003372                          3829  ***********************************************************************************************************
00003372                          3830  * Addr Post-decrement
00003372                          3831  
00003372                          3832  pAddrDec    
00003372  43F9 00003CEA           3833              LEA         dec, A1             ; Display -
00003378  103C 000E               3834              MOVE.B      #14, D0             ; command for trap call to display message
0000337C  4E4F                    3835              TRAP        #15                 ; trap call
0000337E                          3836              
0000337E  43F9 00003CE6           3837              LEA         opPer, A1           ; Display open parenthesis
00003384  103C 000E               3838              MOVE.B      #14, D0             ; command for trap call to display message
00003388  4E4F                    3839              TRAP        #15                 ; trap call
0000338A                          3840              
0000338A  B63C 0000               3841              CMP.B       #zero,D3            ; compare D3 or Register to 0
0000338E  6700 003A               3842              BEQ         displayA0D          ; if true, branch to displayA0D
00003392  B63C 0001               3843              CMP.B       #one,D3             ; compare D3 or Register to 1
00003396  6700 004E               3844              BEQ         displayA1D          ; if true, branch to displayA1D
0000339A  B63C 0002               3845              CMP.B       #two,D3             ; compare D3 or Register to 2
0000339E  6700 0062               3846              BEQ         displayA2D          ; if true, branch to displayA2D
000033A2  B63C 0003               3847              CMP.B       #three,D3           ; compare D3 or Register to 3
000033A6  6700 0076               3848              BEQ         displayA3D          ; if true, branch to displayA3D
000033AA  B63C 0004               3849              CMP.B       #four,D3            ; compare D3 or Register to 4
000033AE  6700 008A               3850              BEQ         displayA4D          ; if true, branch to displayA4D
000033B2  B63C 0005               3851              CMP.B       #five,D3            ; compare D3 or Register to 5
000033B6  6700 009E               3852              BEQ         displayA5D          ; if true, branch to displayA5D
000033BA  B63C 0006               3853              CMP.B       #six,D3             ; compare D3 or Register to 6
000033BE  6700 00B2               3854              BEQ         displayA6D          ; if true, branch to displayA6D
000033C2  B63C 0007               3855              CMP.B       #seven,D3           ; compare D3 or Register to 7
000033C6  6700 00C6               3856              BEQ         displayA7D          ; if true, branch to displayA7D
000033CA                          3857              
000033CA                          3858  displayA0D  
000033CA  43F9 00003D80           3859              LEA         dispA0, A1          ; Display A0
000033D0  103C 000E               3860              MOVE.B      #14, D0             ; command for trap call to display message
000033D4  4E4F                    3861              TRAP        #15                 ; trap call
000033D6  43F9 00003CE8           3862              LEA         clPer, A1           ; Display closing parenthesis
000033DC  103C 000E               3863              MOVE.B      #14, D0             ; command for trap call to display message
000033E0  4E4F                    3864              TRAP        #15                 ; trap call
000033E2  6000 0196               3865              BRA         endSUB              ; go to the end of the subroutine
000033E6                          3866              
000033E6                          3867  displayA1D  
000033E6  43F9 00003D83           3868              LEA         dispA1, A1          ; Display A1
000033EC  103C 000E               3869              MOVE.B      #14, D0             ; command for trap call to display message
000033F0  4E4F                    3870              TRAP        #15                 ; trap call
000033F2  43F9 00003CE8           3871              LEA         clPer, A1           ; Display closing parenthesis
000033F8  103C 000E               3872              MOVE.B      #14, D0             ; command for trap call to display message
000033FC  4E4F                    3873              TRAP        #15                 ; trap call
000033FE  6000 017A               3874              BRA         endSUB              ; go to the end of the subroutine
00003402                          3875  
00003402                          3876  displayA2D  
00003402  43F9 00003D86           3877              LEA         dispA2, A1          ; Display A2
00003408  103C 000E               3878              MOVE.B      #14, D0             ; command for trap call to display message
0000340C  4E4F                    3879              TRAP        #15                 ; trap call
0000340E  43F9 00003CE8           3880              LEA         clPer, A1           ; Display closing parenthesis
00003414  103C 000E               3881              MOVE.B      #14, D0             ; command for trap call to display message
00003418  4E4F                    3882              TRAP        #15                 ; trap call
0000341A  6000 015E               3883              BRA         endSUB              ; go to the end of the subroutine
0000341E                          3884  
0000341E                          3885  displayA3D  
0000341E  43F9 00003D89           3886              LEA         dispA3, A1          ; Display A3
00003424  103C 000E               3887              MOVE.B      #14, D0             ; command for trap call to display message
00003428  4E4F                    3888              TRAP        #15                 ; trap call
0000342A  43F9 00003CE8           3889              LEA         clPer, A1           ; Display closing parenthesis
00003430  103C 000E               3890              MOVE.B      #14, D0             ; command for trap call to display message
00003434  4E4F                    3891              TRAP        #15                 ; trap call
00003436  6000 0142               3892              BRA         endSUB              ; go to the end of the subroutine
0000343A                          3893  
0000343A                          3894  displayA4D  
0000343A  43F9 00003D8C           3895              LEA         dispA4, A1          ; Display A4
00003440  103C 000E               3896              MOVE.B      #14, D0             ; command for trap call to display message
00003444  4E4F                    3897              TRAP        #15                 ; trap call
00003446  43F9 00003CE8           3898              LEA         clPer, A1           ; Display closing parenthesis
0000344C  103C 000E               3899              MOVE.B      #14, D0             ; command for trap call to display message
00003450  4E4F                    3900              TRAP        #15                 ; trap call
00003452  6000 0126               3901              BRA         endSUB              ; go to the end of the subroutine
00003456                          3902  
00003456                          3903  displayA5D  
00003456  43F9 00003D8F           3904              LEA         dispA5, A1          ; Display A5
0000345C  103C 000E               3905              MOVE.B      #14, D0             ; command for trap call to display message
00003460  4E4F                    3906              TRAP        #15                 ; trap call
00003462  43F9 00003CE8           3907              LEA         clPer, A1           ; Display closing parenthesis
00003468  103C 000E               3908              MOVE.B      #14, D0             ; command for trap call to display message
0000346C  4E4F                    3909              TRAP        #15                 ; trap call
0000346E  6000 010A               3910              BRA         endSUB              ; go to the end of the subroutine
00003472                          3911  
00003472                          3912  displayA6D  
00003472  43F9 00003D92           3913              LEA         dispA6, A1          ; Display A6
00003478  103C 000E               3914              MOVE.B      #14, D0             ; command for trap call to display message
0000347C  4E4F                    3915              TRAP        #15                 ; trap call
0000347E  43F9 00003CE8           3916              LEA         clPer, A1           ; Display closing parenthesis
00003484  103C 000E               3917              MOVE.B      #14, D0             ; command for trap call to display message
00003488  4E4F                    3918              TRAP        #15                 ; trap call
0000348A  6000 00EE               3919              BRA         endSUB              ; go to the end of the subroutine
0000348E                          3920  
0000348E                          3921  displayA7D  
0000348E  43F9 00003D95           3922              LEA         dispA7, A1          ; Display A7
00003494  103C 000E               3923              MOVE.B      #14, D0             ; command for trap call to display message
00003498  4E4F                    3924              TRAP        #15                 ; trap call
0000349A  43F9 00003CE8           3925              LEA         clPer, A1           ; Display closing parenthesis
000034A0  103C 000E               3926              MOVE.B      #14, D0             ; command for trap call to display message
000034A4  4E4F                    3927              TRAP        #15                 ; trap call
000034A6  6000 00D2               3928              BRA         endSUB              ; go to the end of the subroutine
000034AA                          3929  
000034AA                          3930  ***********************************************************************************************************
000034AA                          3931  * Display Hex
000034AA                          3932  
000034AA                          3933  pHex        
000034AA  B63C 0000               3934              CMP.B       #zero, D3           ; compare D3 or Register to 0
000034AE  6700 0012               3935              BEQ         AbsShort            ; if true, branch to AbsShort
000034B2  B63C 0001               3936              CMP.B       #one, D3            ; compare D3 or Register to 1
000034B6  6700 0042               3937              BEQ         AbsLong             ; if true, branch to AbsLong
000034BA  B63C 0004               3938              CMP.B       #four, D3           ; compare D3 or Register to 4
000034BE  6700 0072               3939              BEQ         DispImm             ; if true, branch to DispImm
000034C2                          3940              
000034C2                          3941  AbsShort    
000034C2  43F9 00003CE6           3942              LEA         opPer, A1           ; Display open parenthesis
000034C8  103C 000E               3943              MOVE.B      #14, D0             ; command for trap call to display message
000034CC  4E4F                    3944              TRAP        #15                 ; trap call
000034CE                          3945              
000034CE  43F9 00003CE2           3946              LEA         dispHex, A1         ; Display $
000034D4  103C 000E               3947              MOVE.B      #14, D0             ; command for trap call to display message
000034D8  4E4F                    3948              TRAP        #15                 ; trap call
000034DA                          3949              
000034DA  4241                    3950              CLR         D1                  ; clear D1
000034DC  3218                    3951              MOVE.W      (A0)+, D1           ; move next word in memory to D1
000034DE  4240                    3952              CLR         D0                  ; clear D0
000034E0  103C 0004               3953              MOVE.B      #4, D0              ; move the number of hexes to decode
000034E4                          3954              
000034E4  4EB9 00003AA2           3955              JSR         outHex              ; jump to outHex
000034EA                          3956              
000034EA  43F9 00003CE8           3957              LEA         clPer, A1           ; Display closing parenthesis
000034F0  103C 000E               3958              MOVE.B      #14, D0             ; command for trap call to display message
000034F4  4E4F                    3959              TRAP        #15                 ; trap call
000034F6                          3960              
000034F6  6000 0082               3961              BRA         endSub              ; go to the end of the subroutine
000034FA                          3962              
000034FA                          3963  AbsLong     
000034FA  43F9 00003CE6           3964              LEA         opPer, A1           ; Display open parenthesis
00003500  103C 000E               3965              MOVE.B      #14, D0             ; command for trap call to display message
00003504  4E4F                    3966              TRAP        #15                 ; trap call
00003506                          3967              
00003506  43F9 00003CE2           3968              LEA         dispHex, A1         ; Display $
0000350C  103C 000E               3969              MOVE.B      #14, D0             ; command for trap call to display message
00003510  4E4F                    3970              TRAP        #15                 ; trap call
00003512                          3971              
00003512  4241                    3972              CLR         D1                  ; clear D1
00003514  2218                    3973              MOVE.L      (A0)+, D1           ; move next long-word in memory to D1
00003516  4240                    3974              CLR         D0                  ; clear D0
00003518  103C 0008               3975              MOVE.B      #8, D0              ; move the number of hexes to decode
0000351C                          3976              
0000351C  4EB9 00003AA2           3977              JSR         outHex              ; jump to outHex
00003522                          3978              
00003522  43F9 00003CE8           3979              LEA         clPer, A1           ; Display closing parenthesis
00003528  103C 000E               3980              MOVE.B      #14, D0             ; command for trap call to display message
0000352C  4E4F                    3981              TRAP        #15                 ; trap call
0000352E                          3982              
0000352E  6000 004A               3983              BRA         endSub              ; go to the end of the subroutine
00003532                          3984  
00003532                          3985  DispImm     
00003532  43F9 00003CE0           3986              LEA         hashTag, A1         ; Display #
00003538  103C 000E               3987              MOVE.B      #14, D0             ; command for trap call to display message
0000353C  4E4F                    3988              TRAP        #15                 ; trap call
0000353E                          3989  
0000353E  43F9 00003CE2           3990              LEA         dispHex, A1         ; Display $
00003544  103C 000E               3991              MOVE.B      #14, D0             ; command for trap call to display message
00003548  4E4F                    3992              TRAP        #15                 ; trap call
0000354A                          3993              
0000354A  BC3C 0001               3994              CMP.B       #1,D6               ; compare 1 to D6 for this determines if long immediate needs printing
0000354E  6700 0016               3995              BEQ         ImmLong             ; if true, branch to ImmLong
00003552                          3996              
00003552  4241                    3997              CLR         D1                  ; clear D1
00003554  3218                    3998              MOVE.W      (A0)+, D1           ; move next word to D1
00003556  4240                    3999              CLR         D0                  ; clear D0
00003558  103C 0004               4000              MOVE.B      #4, D0              ; move the number of hexes to decode
0000355C  4EB9 00003AA2           4001              JSR         outHex              ; jump to outHex
00003562  6000 0012               4002              BRA         LongSkip            ; branch over printing a long-word
00003566                          4003              
00003566                          4004  ImmLong     
00003566  4241                    4005              CLR         D1                  ; clear D1
00003568  2218                    4006              MOVE.L      (A0)+, D1           ; move next long-word to D1
0000356A  4240                    4007              CLR         D0                  ; clear D0
0000356C  103C 0008               4008              MOVE.B      #8, D0              ; move the number of hexes to decode
00003570  4EB9 00003AA2           4009              JSR         outHex              ; jump to outHex 
00003576                          4010  
00003576                          4011  LongSkip
00003576  6000 0002               4012              BRA         endSub              ; go to end of the subroutine
0000357A                          4013  
0000357A                          4014  invalid     
0000357A                          4015  
0000357A                          4016  endSUB        
0000357A  4CDF 7EFF               4017              MOVEM.L     (SP)+, D0-D7/A1-A6  ; pop registers off the stack
0000357E  4E75                    4018              RTS                             ; return
00003580                          4019  
00003580                          4020  ***********************************************************************************************************
00003580                          4021  *
00003580                          4022  *                       MOVEM Helper Function
00003580                          4023  *       This function is dedicated to printing out the address and data register for MOVEM. The 
00003580                          4024  *       function starts by identifying the size and then identifying the dr field. If the dr field
00003580                          4025  *       is 1, then the program goes to print before print out the address and data register for MOVEM. If dr
00003580                          4026  *       field is zero, program goes to print out the address and data register before printing out the
00003580                          4027  *       post increment or immediate data.
00003580                          4028  *
00003580                          4029  ***********************************************************************************************************
00003580                          4030  
00003580                          4031  MOVEMBRA    
00003580  48E7 FF7E               4032              MOVEM.L     D0-D7/A1-A6, -(SP)  ; Branches off depending on size bit
00003584  BA7C 0000               4033              CMP         #zero,D5            ; Checks the size to see if it word
00003588  6700 000E               4034              BEQ         MOVEMW              ; Branches if it is equal to word
0000358C  BA7C 0001               4035              CMP         #one, D5            ; Compares bits to long.
00003590  6700 0022               4036              BEQ         MOVEML              ; Branches if it is equal to long size.
00003594  6000 06D8               4037              BRA         printInvalid        ; Is invalid if it is not equal to either
00003598                          4038              
00003598                          4039  MOVEMW     
00003598  43F9 00003D7A           4040              LEA         dispWord, A1        ; Prints a W to symbolize word
0000359E  103C 000E               4041              MOVE.B      #14, D0             ; command for trap call to display message
000035A2  4E4F                    4042              TRAP        #15                 ; trap call
000035A4                          4043  
000035A4  43F9 00003CDD           4044              LEA         space, A1           ; Print a space
000035AA  103C 000E               4045              MOVE.B      #14, D0             ; command for trap call to display message
000035AE  4E4F                    4046              TRAP        #15                 ; trap call
000035B0                          4047              
000035B0  6000 001E               4048              BRA         CheckDR             ; Branch to CheckDR
000035B4                          4049  
000035B4                          4050  MOVEML   
000035B4  43F9 00003D7D           4051              LEA         dispLong, A1        ; we know that the opcode will be MOVEML, so load A1 to print message
000035BA  103C 000E               4052              MOVE.B      #14, D0             ; command for trap call to display message
000035BE  4E4F                    4053              TRAP        #15                 ; trap call
000035C0                          4054  
000035C0  43F9 00003CDD           4055              LEA         space, A1           ; Print a space
000035C6  103C 000E               4056              MOVE.B      #14, D0             ; command for trap call to display message
000035CA  4E4F                    4057              TRAP        #15                 ; trap call
000035CC                          4058           
000035CC                          4059  
000035CC  6000 0002               4060              BRA         CheckDR             ; Branch to CheckDR
000035D0                          4061  
000035D0                          4062  CheckDR     
000035D0  3218                    4063              MOVE.W      (A0)+, D1           ; Taking in next word
000035D2  BC7C 0000               4064              CMP         #zero,D6            ; Check if dr is 0, then print out data/address first
000035D6  6700 0020               4065              BEQ         printRegMem         ; branch to printRegMem
000035DA  BC7C 0001               4066              CMP         #one,D6             ; dr field is one, must print stack pointer first
000035DE  6700 0004               4067              BEQ         printStack          ; Go to print stack pointer
000035E2  6096                    4068              BRA         invalid             ; Go to invalid if equal to neither
000035E4                          4069              
000035E4                          4070  printStack 
000035E4  4EB8 2F02               4071              JSR         printEA             ; Prints out the stack pointer
000035E8                          4072              
000035E8  43F9 00003CE4           4073              LEA         comma,A1            ; Prints out comma
000035EE  103C 000E               4074              MOVE.B      #14, D0             ; command for trap call to display message
000035F2  4E4F                    4075              TRAP        #15                 ; trap call
000035F4                          4076              
000035F4                          4077              
000035F4  6000 0002               4078              BRA         printRegMem
000035F8                          4079             
000035F8                          4080  printRegMem 
000035F8  4244                    4081              CLR         D4                  ; Using D4 to store predecrement mode addresses
000035FA  1801                    4082              MOVE.B      D1,D4               ; Stores bits for D0-D7
000035FC                          4083              
000035FC  4245                    4084              CLR         D5                  ; Clear data register
000035FE  1A01                    4085              MOVE.B      D1,D5               ; Move bits containing information on filled data to D5
00003600  CA7C 0001               4086              AND         #mask1,D5           ; Use a bit mask to mask every bit except for the first bit
00003604  BA7C 0001               4087              CMP         #mask1,D5           ; Check if certain bit is 1 or 0
00003608  6700 0076               4088              BEQ         DataReg0            ; If comparison matches, then data register that is being put on stack starts her
0000360C                          4089              
0000360C  4245                    4090              CLR         D5                  ; Clear data register
0000360E  1A01                    4091              MOVE.B      D1,D5               ; Move bits containing information on filled data to D5
00003610  CA7C 0002               4092              AND         #mask2,D5           ; Use a bit mask to mask every bit except for the second bit
00003614  BA7C 0002               4093              CMP         #mask2,D5           ; Check if certain bit is 1 or 0
00003618  6700 0096               4094              BEQ         DataReg1            ; If comparison matches, then data register that is being put on stack starts here
0000361C                          4095  
0000361C  4245                    4096              CLR         D5                  ; Clear data register
0000361E  1A01                    4097              MOVE.B      D1,D5               ; Move bits containing information on filled data to D5
00003620  CA7C 0004               4098              AND         #mask3,D5           ; Use a bit mask to mask every bit except for the third bit
00003624  BA7C 0004               4099              CMP         #mask3,D5           ; Check if certain bit is 1 or 0
00003628  6700 00C6               4100              BEQ         DataReg2            ; If comparison matches, then data register that is being put on stack starts her
0000362C                          4101              
0000362C  4245                    4102              CLR         D5                  ; Clear data register
0000362E  1A01                    4103              MOVE.B      D1,D5               ; Move bits containing information on filled data to D5
00003630  CA7C 0008               4104              AND         #mask4,D5           ; Use a bit mask to mask every bit except for the fourth
00003634  BA7C 0008               4105              CMP         #mask4,D5           ; Check if certain bit is 1 or 0
00003638  6700 00F6               4106              BEQ         DataReg3            ; If comparison matches, then data register that is being put on stack starts her
0000363C                          4107              
0000363C  4245                    4108              CLR         D5                  ; Clear data register
0000363E  1A01                    4109              MOVE.B      D1,D5               ; Move bits containing information on filled address/data to D5
00003640  CA7C 0010               4110              AND         #mask5,D5           ; Use a bit mask to mask every bit except for the fifth bit
00003644  BA7C 0010               4111              CMP         #mask5,D5           ; Check if certain bit is 1 or 0
00003648  6700 0126               4112              BEQ         DataReg4            ; If comparison matches, then data register that is being put on stack starts her
0000364C                          4113  
0000364C  4245                    4114              CLR         D5                  ; Clear data register
0000364E  1A01                    4115              MOVE.B      D1,D5               ; Move bits containing information on filled address/data to D5
00003650  CA7C 0020               4116              AND         #mask6,D5           ; Use a bit mask to mask every bit except for the sixth bit
00003654  BA7C 0020               4117              CMP         #mask6,D5           ; Check if certain bit is 1 or 0
00003658  6700 0156               4118              BEQ         DataReg5            ; If comparison matches, then data register that is being put on stack starts her
0000365C                          4119  
0000365C  4245                    4120              CLR         D5                  ; Clear data register
0000365E  1A01                    4121              MOVE.B      D1,D5               ; Move bits containing information on filled address/data to D5
00003660  CA7C 0040               4122              AND         #mask7,D5           ; Use a bit mask to mask every bit except for the seventh
00003664  BA7C 0040               4123              CMP         #mask7,D5           ; Check if certain bit is 1 or 0
00003668  6700 0186               4124              BEQ         DataReg6            ; If comparison matches, then data register that is being put on stack starts her
0000366C                          4125  
0000366C  4245                    4126              CLR         D5                  ; Clear data register
0000366E  1A01                    4127              MOVE.B      D1,D5               ; Move bits containing information on filled address/data to D5
00003670  CA7C 0080               4128              AND         #mask8,D5           ; Use a bit mask to mask every bit except for the seventh
00003674  BA7C 0080               4129              CMP         #mask8,D5           ; Check if certain bit is 1 or 0
00003678  6700 01B6               4130              BEQ         DataReg7            ; If comparison matches, then only D7 is being used
0000367C                          4131              
0000367C  6000 FEFC               4132              BRA         invalid             ; If comaparisons fail then this is not MOVEM. Branch out.
00003680                          4133              
00003680                          4134  DataReg0
00003680  43F9 00003D9A           4135              LEA         dispD0, A1          ; Output string D0
00003686  103C 000E               4136              MOVE.B      #14, D0             ; command for trap call to display message
0000368A  4E4F                    4137              TRAP        #15                 ; trap call
0000368C                          4138              
0000368C  4245                    4139              CLR         D5                  ; Clear data register
0000368E  1A01                    4140              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003690  CA7C 0002               4141              AND         #mask2,D5           ; Uses mask to check for valid after current bit
00003694  BA7C 0002               4142              CMP         #mask2,D5           ; Check if there are anymore data registers used
00003698  6700 0006               4143              BEQ         Reg0Cont            ; Continues to check for last register used if so
0000369C  6000 01A2               4144              BRA         printMem            ; Else it will continue on to print the address/memory
000036A0                          4145              
000036A0                          4146  Reg0Cont        
000036A0  43F9 00003CEA           4147              LEA         dec, A1             ; Output -
000036A6  103C 000E               4148              MOVE.B      #14, D0             ; command for trap call to display message
000036AA  4E4F                    4149              TRAP        #15                 ; trap call        
000036AC  6000 0002               4150              BRA         DataReg1            ; Found starting register move on to find ending register
000036B0                          4151  
000036B0                          4152  DataReg1
000036B0  4245                    4153              CLR         D5                  ; Clear data register
000036B2  1A01                    4154              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000036B4  CA7C 0005               4155              AND         #maskA,D5           ; Uses mask to check for valid bits before and after current bit
000036B8  BA7C 0005               4156              CMP         #maskA,D5           ; Check if there are bits before and after current masked bit
000036BC  6700 0032               4157              BEQ         DataReg2            ; Branch to skip printing until the end register is found
000036C0                          4158              
000036C0  43F9 00003D9D           4159              LEA         dispD1, A1          ; Output string D0
000036C6  103C 000E               4160              MOVE.B      #14, D0             ; command for trap call to display message
000036CA  4E4F                    4161              TRAP        #15                 ; trap call
000036CC                          4162              
000036CC  4245                    4163              CLR         D5                  ; Clear data register
000036CE  1A01                    4164              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000036D0  CA7C 0004               4165              AND         #mask3,D5           ; Bitmasking to check if next bit is used or not
000036D4  BA7C 0004               4166              CMP         #mask3,D5           ; Checking if next bit is use
000036D8  6700 0006               4167              BEQ         Reg1Cont            ; Continues to check for last register used if so
000036DC  6000 0162               4168              BRA         printMem            ; Else it will continue on to print the address/memory
000036E0                          4169              
000036E0                          4170  Reg1Cont        
000036E0  43F9 00003CEA           4171              LEA         dec, A1             ; Output -
000036E6  103C 000E               4172              MOVE.B      #14, D0             ; command for trap call to display message
000036EA  4E4F                    4173              TRAP        #15                 ; trap call        
000036EC  6000 0002               4174              BRA         DataReg2            ; Found starting register move on to find ending registe
000036F0                          4175  
000036F0                          4176  DataReg2
000036F0  4245                    4177              CLR         D5                  ; Clear data register
000036F2  1A01                    4178              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000036F4  CA7C 000A               4179              AND         #maskB,D5           ; Uses mask to check for valid bits before and after current bit
000036F8  BA7C 000A               4180              CMP         #maskB,D5           ; Check if there are bits before and after current masked bit
000036FC  6700 0032               4181              BEQ         DataReg3            ; If there are bits before and after, skip to next register to find ending
00003700                          4182              
00003700                          4183              
00003700  43F9 00003DA0           4184              LEA         dispD2, A1          ; Output D2
00003706  103C 000E               4185              MOVE.B      #14, D0             ; command for trap call to display message
0000370A  4E4F                    4186              TRAP        #15                 ; trap call
0000370C                          4187              
0000370C  4245                    4188              CLR         D5                  ; Clear data register
0000370E  1A01                    4189              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003710  CA7C 0008               4190              AND         #mask4,D5           ; Bitmasking to check if next bit is used or not
00003714  BA7C 0008               4191              CMP         #mask4,D5           ; Checking if next bit is used
00003718  6700 0006               4192              BEQ         Reg2Cont            ; Continues to check for last register used if so
0000371C  6000 0122               4193              BRA         printMem            ; Else it will continue on to print the address/memory
00003720                          4194              
00003720                          4195  Reg2Cont        
00003720  43F9 00003CEA           4196              LEA         dec, A1             ; Output -
00003726  103C 000E               4197              MOVE.B      #14, D0             ; command for trap call to display message
0000372A  4E4F                    4198              TRAP        #15                 ; trap call        
0000372C  6000 0002               4199              BRA         DataReg3            ; Found starting register move on to find ending registe
00003730                          4200  
00003730                          4201  DataReg3
00003730  4245                    4202              CLR         D5                  ; Clear data register
00003732  1A01                    4203              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003734  CA7C 0014               4204              AND         #maskC,D5           ; Uses mask to check for valid bits before and after current bit
00003738  BA7C 0014               4205              CMP         #maskC,D5           ; Check if there are bits before and after current masked bit
0000373C  6700 0032               4206              BEQ         DataReg4            ; If there are bits before and after, skip to next register to find ending
00003740                          4207      
00003740                          4208              
00003740  43F9 00003DA3           4209              LEA         dispD3, A1          ; Output string D0
00003746  103C 000E               4210              MOVE.B      #14, D0             ; command for trap call to display message
0000374A  4E4F                    4211              TRAP        #15                 ; trap call
0000374C                          4212              
0000374C  4245                    4213              CLR         D5                  ; Clear data register
0000374E  1A01                    4214              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003750  CA7C 0010               4215              AND         #mask5,D5           ; Bitmasking to check if next bit is used or not
00003754  BA7C 0010               4216              CMP         #mask5,D5
00003758  6700 0006               4217              BEQ         Reg3Cont            ; Continues to check for last register used if so
0000375C  6000 00E2               4218              BRA         printMem            ; Else it will continue on to print the address/memory
00003760                          4219              
00003760                          4220  Reg3Cont        
00003760  43F9 00003CEA           4221              LEA         dec, A1             ; Output -
00003766  103C 000E               4222              MOVE.B      #14, D0             ; command for trap call to display message
0000376A  4E4F                    4223              TRAP        #15                 ; trap call        
0000376C  6000 0002               4224              BRA         DataReg4            ; Found starting register move on to find ending registe
00003770                          4225  
00003770                          4226  DataReg4
00003770  4245                    4227              CLR         D5                  ; Clear data register
00003772  1A01                    4228              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003774  CA7C 0028               4229              AND         #maskD,D5           ; Uses mask to check for valid bits before and after current bit
00003778  BA7C 0028               4230              CMP         #maskD,D5           ; Check if there are bits before and after current masked bit
0000377C  6700 0032               4231              BEQ         DataReg5            ; If there are bits before and after, skip to next register to find ending
00003780                          4232              
00003780  43F9 00003DA6           4233              LEA         dispD4, A1          ; Output string D0
00003786  103C 000E               4234              MOVE.B      #14, D0             ; command for trap call to display message
0000378A  4E4F                    4235              TRAP        #15                 ; trap call
0000378C                          4236              
0000378C  4245                    4237              CLR         D5                  ; Clear data register
0000378E  1A01                    4238              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003790  CA7C 0020               4239              AND         #mask6,D5           ; Bitmasking to check if next bit is used or not
00003794  BA7C 0020               4240              CMP         #mask6,D5           ; Checking if next bit is use
00003798  6700 0006               4241              BEQ         Reg4Cont            ; Continues to check for last register used if so
0000379C  6000 00A2               4242              BRA         printMem            ; Else it will continue on to print the address/memory
000037A0                          4243              
000037A0                          4244  Reg4Cont        
000037A0  43F9 00003CEA           4245              LEA         dec, A1             ; Output -
000037A6  103C 000E               4246              MOVE.B      #14, D0             ; command for trap call to display message
000037AA  4E4F                    4247              TRAP        #15                 ; trap call        
000037AC  6000 0002               4248              BRA         DataReg5            ; Found starting register move on to find ending registe
000037B0                          4249  
000037B0                          4250  DataReg5
000037B0  4245                    4251              CLR         D5                  ; Clear data register
000037B2  1A01                    4252              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000037B4  CA7C 0050               4253              AND         #maskE,D5           ; Uses mask to check for valid bits before and after current bit
000037B8  BA7C 0050               4254              CMP         #maskE,D5           ; Check if there are bits before and after current masked bit
000037BC  6700 0032               4255              BEQ         DataReg6            ; If there are bits before and after, skip to next register to find ending
000037C0                          4256              
000037C0  43F9 00003DA9           4257              LEA         dispD5, A1          ; Output string D0
000037C6  103C 000E               4258              MOVE.B      #14, D0             ; command for trap call to display message
000037CA  4E4F                    4259              TRAP        #15                 ; trap call
000037CC                          4260              
000037CC  4245                    4261              CLR         D5                  ; Clear data register
000037CE  1A01                    4262              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000037D0  CA7C 0040               4263              AND         #mask7,D5           ; Bitmasking to check if next bit is used or not
000037D4  BA7C 0040               4264              CMP         #mask7,D5           ; Checking if next bit is use
000037D8  6700 0006               4265              BEQ         Reg5Cont            ; Continues to check for last register used if so
000037DC  6000 0062               4266              BRA         printMem            ; Else it will continue on to print the address/memory
000037E0                          4267              
000037E0                          4268  Reg5Cont        
000037E0  43F9 00003CEA           4269              LEA         dec, A1             ; Output -
000037E6  103C 000E               4270              MOVE.B      #14, D0             ; command for trap call to display message
000037EA  4E4F                    4271              TRAP        #15                 ; trap call        
000037EC  6000 0042               4272              BRA         DataReg7            ; Found starting register move on to find ending registe
000037F0                          4273  
000037F0                          4274  DataReg6
000037F0  4245                    4275              CLR         D5                  ; Clear data register
000037F2  1A01                    4276              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000037F4  CA7C 00A0               4277              AND         #maskF,D5           ; Uses mask to check for valid bits before and after current bit
000037F8  BA7C 00A0               4278              CMP         #maskF,D5           ; Check if there are bits before and after current masked bit
000037FC  6700 0032               4279              BEQ         DataReg7            ; If there are bits before and after, skip to next register to find ending
00003800                          4280  
00003800  43F9 00003DAC           4281              LEA         dispD6, A1          ; Output string D0
00003806  103C 000E               4282              MOVE.B      #14, D0             ; command for trap call to display message
0000380A  4E4F                    4283              TRAP        #15                 ; trap call
0000380C                          4284              
0000380C  4245                    4285              CLR         D5                  ; Clear data register
0000380E  1A01                    4286              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003810  CA7C 0080               4287              AND         #mask8,D5           ; Bitmasking to check if next bit is used or not
00003814  BA7C 0080               4288              CMP         #mask8,D5           ; Checking if next bit is use
00003818  6700 0006               4289              BEQ         Reg6Cont            ; Continues to check for last register used if so
0000381C  6000 0022               4290              BRA         printMem            ; Else it will continue on to print the address/memory
00003820                          4291              
00003820                          4292  Reg6Cont        
00003820  43F9 00003CEA           4293              LEA         dec, A1             ; Output -
00003826  103C 000E               4294              MOVE.B      #14, D0             ; command for trap call to display message
0000382A  4E4F                    4295              TRAP        #15                 ; trap call        
0000382C  6000 0002               4296              BRA         DataReg7            ; Found starting register move on to find ending registe
00003830                          4297  
00003830                          4298  DataReg7    
00003830  43F9 00003DAF           4299              LEA         dispD7, A1          ; Output -
00003836  103C 000E               4300              MOVE.B      #14, D0             ; command for trap call to display message
0000383A  4E4F                    4301              TRAP        #15                 ; trap call        
0000383C  6000 0002               4302              BRA         printMem            ; Last check, branch to print out the address register     
00003840                          4303              
00003840                          4304  printMem                                    ; Made this function in order to reuse if DR is 1
00003840  6000 0002               4305              BRA         printMemNow         ; Branch out to printMemNow
00003844                          4306              
00003844                          4307  printMemNow                           
00003844  43F9 00003D70           4308              LEA         slash, A1           ; Display slash
0000384A  103C 000E               4309              MOVE.B      #14, D0             ; command for trap call to display message
0000384E  4E4F                    4310              TRAP        #15                 ; trap call
00003850                          4311           
00003850  4244                    4312              CLR         D4                  ; Using D4 to store predecrement mode addresses
00003852  3801                    4313              MOVE.W      D1,D4               ; Stores bits for D0-D7
00003854  E044                    4314              ASR         #eight,D4           ; Rotate to the right, to create space for next byte
00003856                          4315              
00003856  4245                    4316              CLR         D5                  ; Clear space
00003858  1A04                    4317              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
0000385A  CA7C 0001               4318              AND         #mask1,D5           ; Use a bit mask to mask every bit except for the first bit
0000385E  BA7C 0001               4319              CMP         #mask1,D5           ; Check if certain bit is 1 or 0
00003862  6700 0072               4320              BEQ         AddrReg0            ; If comparison matches, then address register that is being put on stack starts here
00003866                          4321              
00003866  4245                    4322              CLR         D5                  ; Clear data register 
00003868  1A04                    4323              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
0000386A  CA7C 0002               4324              AND         #mask2,D5           ; Use a bit mask to mask every bit except for the second bit
0000386E  BA7C 0002               4325              CMP         #mask2,D5           ; Check if certain bit is 1 or 0
00003872  6700 0092               4326              BEQ         AddrReg1            ; If comparison matches, then address register that is being put on stack starts here
00003876                          4327  
00003876  4245                    4328              CLR         D5                  ; Clear data register
00003878  1A04                    4329              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
0000387A  CA7C 0004               4330              AND         #mask3,D5           ; Use a bit mask to mask every bit except for the third
0000387E  BA7C 0004               4331              CMP         #mask3,D5           ; Check if certain bit is 1 or 0
00003882  6700 00C2               4332              BEQ         AddrReg2            ; If comparison matches, then address register that is being put on stack starts here         
00003886                          4333              
00003886  4245                    4334              CLR         D5                  ; Clear data register
00003888  1A04                    4335              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
0000388A  CA7C 0008               4336              AND         #mask4,D5           ; Use a bit mask to mask every bit except for the fourth bit
0000388E  BA7C 0008               4337              CMP         #mask4,D5           ; Check if certain bit is 1 or 0
00003892  6700 00F2               4338              BEQ         AddrReg3            ; If comparison matches, then address register that is being put on stack starts here     
00003896                          4339                  
00003896  4245                    4340              CLR         D5                  ; Clear data register
00003898  1A04                    4341              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
0000389A  CA7C 0010               4342              AND         #mask5,D5           ; Use a bit mask to mask every bit except for the fifth bit
0000389E  BA7C 0010               4343              CMP         #mask5,D5           ; Check if certain bit is 1 or 0
000038A2  6700 0122               4344              BEQ         AddrReg4            ; If comparison matches, then address register that is being put on stack starts here
000038A6                          4345  
000038A6  4245                    4346              CLR         D5                  ; Clear data register
000038A8  1A04                    4347              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
000038AA  CA7C 0020               4348              AND         #mask6,D5           ; Use a bit mask to mask every bit except for the sixth bit
000038AE  BA7C 0020               4349              CMP         #mask6,D5           ; Check if certain bit is 1 or 0
000038B2  6700 0152               4350              BEQ         AddrReg5            ; If comparison matches, then address register that is being put on stack starts here
000038B6                          4351  
000038B6  4245                    4352              CLR         D5                  ; Clear data register
000038B8  1A04                    4353              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
000038BA  CA7C 0040               4354              AND         #mask7,D5           ; Use a bit mask to mask every bit except for the seventh bit
000038BE  BA7C 0040               4355              CMP         #mask7,D5           ; Check if certain bit is 1 or 0
000038C2  6700 0182               4356              BEQ         AddrReg6            ; If comparison matches, then address register that is being put on stack starts here
000038C6                          4357  
000038C6  4245                    4358              CLR         D5                  ; Clear data register
000038C8  1A04                    4359              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
000038CA  CA7C 0080               4360              AND         #mask8,D5           ; Use a bit mask to mask every bit except for the last bit
000038CE  BA7C 0080               4361              CMP         #mask8,D5           ; Check if certain bit is 1 or 0
000038D2  6700 01B2               4362              BEQ         AddrReg7            ; If comparison matches, then address register that is being put on stack starts here
000038D6                          4363              
000038D6                          4364  AddrReg0
000038D6                          4365  
000038D6  43F9 00003D80           4366              LEA         dispA0, A1          ; Output string D0
000038DC  103C 000E               4367              MOVE.B      #14, D0             ; command for trap call to display message
000038E0  4E4F                    4368              TRAP        #15                 ; trap call
000038E2                          4369              
000038E2  4245                    4370              CLR         D5                  ; Clear data register
000038E4  1A01                    4371              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000038E6  CA7C 0002               4372              AND         #mask2,D5           ; Bitmasking to check if next bit is used or not
000038EA  BA7C 0002               4373              CMP         #mask2,D5           ; Checking if next bit is use
000038EE  6700 0006               4374              BEQ         Addr0Cont           ; Continues to check for last register used if so
000038F2  6000 01A2               4375              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
000038F6                          4376              
000038F6                          4377  Addr0Cont        
000038F6  43F9 00003CEA           4378              LEA         dec, A1             ; Output -
000038FC  103C 000E               4379              MOVE.B      #14, D0             ; command for trap call to display message
00003900  4E4F                    4380              TRAP        #15                 ; trap call        
00003902  6000 0002               4381              BRA         AddrReg1            ; Branch to second address
00003906                          4382  
00003906                          4383  AddrReg1
00003906  4245                    4384              CLR         D5                  ; Clear data register
00003908  1A04                    4385              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
0000390A  CA7C 0005               4386              AND         #maskA,D5           ; Uses mask to check for valid bits before and after current bit
0000390E  BA7C 0005               4387              CMP         #maskA,D5           ; Check if there are bits before and after current masked bit
00003912  6700 0032               4388              BEQ         AddrReg2            ; Skip print and move to next address to check if it the last address used
00003916                          4389              
00003916  43F9 00003D83           4390              LEA         dispA1, A1          ; Output string D0
0000391C  103C 000E               4391              MOVE.B      #14, D0             ; command for trap call to display message
00003920  4E4F                    4392              TRAP        #15                 ; trap call
00003922                          4393              
00003922  4245                    4394              CLR         D5                  ; Clear data register
00003924  1A04                    4395              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003926  CA7C 0004               4396              AND         #mask3,D5           ; Bitmasking to check if next bit is used or not
0000392A  BA7C 0004               4397              CMP         #mask3,D5           ; Checking if next bit is use
0000392E  6700 0006               4398              BEQ         Addr1Cont           ; Continues to check for last register used if so
00003932  6000 0162               4399              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
00003936                          4400              
00003936                          4401  Addr1Cont        
00003936  43F9 00003CEA           4402              LEA         dec, A1             ; Output -
0000393C  103C 000E               4403              MOVE.B      #14, D0             ; command for trap call to display message
00003940  4E4F                    4404              TRAP        #15                 ; trap call        
00003942  6000 0002               4405              BRA         AddrReg2            ; Skip print and move to next address to check if it the last address used    
00003946                          4406  
00003946                          4407  AddrReg2
00003946  4245                    4408              CLR         D5                  ; Clear data register
00003948  1A04                    4409              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
0000394A  CA7C 000A               4410              AND         #maskB,D5           ; Uses mask to check for valid bits before and after current bit
0000394E  BA7C 000A               4411              CMP         #maskB,D5           ; Check if there are bits before and after current masked bit
00003952  6700 0032               4412              BEQ         AddrReg3            ; If there are bits before and after, skip to next register to find ending
00003956                          4413  
00003956                          4414              
00003956  43F9 00003D86           4415              LEA         dispA2, A1          ; Output string D0
0000395C  103C 000E               4416              MOVE.B      #14, D0             ; command for trap call to display message
00003960  4E4F                    4417              TRAP        #15                 ; trap call
00003962                          4418              
00003962  4245                    4419              CLR         D5                  ; Clear data register
00003964  1A04                    4420              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003966  CA7C 0008               4421              AND         #mask4,D5           ; Bitmasking to check if next bit is used or not
0000396A  BA7C 0008               4422              CMP         #mask4,D5           ; Checking if next bit is use
0000396E  6700 0006               4423              BEQ         Addr2Cont           ; Continues to check for last register used if so
00003972  6000 0122               4424              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
00003976                          4425              
00003976                          4426  Addr2Cont        
00003976  43F9 00003CEA           4427              LEA         dec, A1             ; Output -
0000397C  103C 000E               4428              MOVE.B      #14, D0             ; command for trap call to display message
00003980  4E4F                    4429              TRAP        #15                 ; trap call        
00003982  6000 0002               4430              BRA         AddrReg3            ; Skip print and move to next address to check if it the last address used
00003986                          4431  
00003986                          4432  AddrReg3
00003986  4245                    4433              CLR         D5                  ; Clear data register
00003988  1A04                    4434              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
0000398A  CA7C 0014               4435              AND         #maskC,D5           ; Uses mask to check for valid bits before and after current bit
0000398E  BA7C 0014               4436              CMP         #maskC,D5           ; Check if there are bits before and after current masked bit
00003992  6700 0032               4437              BEQ         AddrReg4            ; If there are bits before and after, skip to next register to find ending
00003996                          4438              
00003996  43F9 00003D89           4439              LEA         dispA3, A1          ; Output string D0
0000399C  103C 000E               4440              MOVE.B      #14, D0             ; command for trap call to display message
000039A0  4E4F                    4441              TRAP        #15                 ; trap call
000039A2                          4442              
000039A2  4245                    4443              CLR         D5                  ; Clear data register
000039A4  1A04                    4444              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
000039A6  CA7C 0010               4445              AND         #mask5,D5           ; Bitmasking to check if next bit is used or not  
000039AA  BA7C 0010               4446              CMP         #mask5,D5           ; Checking if next bit is use
000039AE  6700 0006               4447              BEQ         Addr3Cont           ; Continues to check for last register used if so
000039B2  6000 00E2               4448              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
000039B6                          4449              
000039B6                          4450  Addr3Cont        
000039B6  43F9 00003CEA           4451              LEA         dec, A1             ; Output -
000039BC  103C 000E               4452              MOVE.B      #14, D0             ; command for trap call to display message
000039C0  4E4F                    4453              TRAP        #15                 ; trap call        
000039C2  6000 0002               4454              BRA         AddrReg4
000039C6                          4455  
000039C6                          4456  AddrReg4
000039C6  4245                    4457              CLR         D5                  ; Clear data register
000039C8  1A04                    4458              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
000039CA  CA7C 0028               4459              AND         #maskD,D5           ; Uses mask to check for valid bits before and after current bit
000039CE  BA7C 0028               4460              CMP         #maskD,D5           ; Check if there are bits before and after current masked bit
000039D2  6700 0032               4461              BEQ         AddrReg5            ; If there are bits before and after, skip to next register to find ending
000039D6                          4462              
000039D6  43F9 00003D8C           4463              LEA         dispA4, A1          ; Output string D0
000039DC  103C 000E               4464              MOVE.B      #14, D0             ; command for trap call to display message
000039E0  4E4F                    4465              TRAP        #15                 ; trap call
000039E2                          4466              
000039E2  4245                    4467              CLR         D5                  ; Clear data register
000039E4  1A04                    4468              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
000039E6  CA7C 0020               4469              AND         #mask6,D5           ; Bitmasking to check if next bit is used or not 
000039EA  BA7C 0020               4470              CMP         #mask6,D5           ; Checking if next bit is use
000039EE  6700 0006               4471              BEQ         Addr4Cont           ; Continues to check for last register used if so
000039F2  6000 00A2               4472              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
000039F6                          4473              
000039F6                          4474  Addr4Cont        
000039F6  43F9 00003CEA           4475              LEA         dec, A1             ; Output -
000039FC  103C 000E               4476              MOVE.B      #14, D0             ; command for trap call to display message
00003A00  4E4F                    4477              TRAP        #15                 ; trap call        
00003A02  6000 0002               4478              BRA         AddrReg5
00003A06                          4479  AddrReg5
00003A06  4245                    4480              CLR         D5                  ; Clear data register
00003A08  1A04                    4481              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003A0A  CA7C 0050               4482              AND         #maskE,D5           ; Uses mask to check for valid bits before and after current bit
00003A0E  BA7C 0050               4483              CMP         #maskE,D5           ; Check if there are bits before and after current masked bit
00003A12  6700 0032               4484              BEQ         AddrReg6            ; If there are bits before and after, skip to next register to find ending
00003A16                          4485              
00003A16  43F9 00003D8F           4486              LEA         dispA5, A1          ; Output string D0
00003A1C  103C 000E               4487              MOVE.B      #14, D0             ; command for trap call to display message
00003A20  4E4F                    4488              TRAP        #15                 ; trap call
00003A22                          4489              
00003A22  4245                    4490              CLR         D5                  ; Clear data register
00003A24  1A04                    4491              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003A26  CA7C 0040               4492              AND         #mask7,D5           ; Bitmasking to check if next bit is used or not
00003A2A  BA7C 0040               4493              CMP         #mask7,D5           ; Checking if next bit is use
00003A2E  6700 0006               4494              BEQ         Addr5Cont           ; Continues to check for last register used if so
00003A32  6000 0062               4495              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
00003A36                          4496              
00003A36                          4497  Addr5Cont        
00003A36  43F9 00003CEA           4498              LEA         dec, A1             ; Output -
00003A3C  103C 000E               4499              MOVE.B      #14, D0             ; command for trap call to display message
00003A40  4E4F                    4500              TRAP        #15                 ; trap call        
00003A42  6000 0042               4501              BRA         AddrReg7
00003A46                          4502  
00003A46                          4503  AddrReg6
00003A46  4245                    4504              CLR         D5                  ; Clear data register
00003A48  1A04                    4505              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003A4A  CA7C 00A0               4506              AND         #maskF,D5           ; Uses mask to check for valid bits before and after current bit
00003A4E  BA7C 00A0               4507              CMP         #maskF,D5           ; Check if there are bits before and after current masked bit
00003A52  6700 0032               4508              BEQ         AddrReg7            ; If there are bits before and after, skip to next register to find ending
00003A56                          4509  
00003A56  43F9 00003D92           4510              LEA         dispA6, A1          ; Output string D0
00003A5C  103C 000E               4511              MOVE.B      #14, D0             ; command for trap call to display message
00003A60  4E4F                    4512              TRAP        #15                 ; trap call
00003A62                          4513              
00003A62  4245                    4514              CLR         D5                  ; Clear data register
00003A64  1A04                    4515              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003A66  CA7C 0080               4516              AND         #mask8,D5           ; Bitmasking to check if next bit is used or not
00003A6A  BA7C 0080               4517              CMP         #mask8,D5           ; Checking if next bit is use
00003A6E  6700 0006               4518              BEQ         Addr6Cont           ; Continues to check for last register used if so
00003A72  6000 0022               4519              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
00003A76                          4520              
00003A76                          4521  Addr6Cont        
00003A76  43F9 00003CEA           4522              LEA         dec, A1             ; Output -
00003A7C  103C 000E               4523              MOVE.B      #14, D0             ; command for trap call to display message
00003A80  4E4F                    4524              TRAP        #15                 ; trap call        
00003A82  6000 0002               4525              BRA         AddrReg7            ; Skip print and move to next address to check if it the last address used
00003A86                          4526  
00003A86                          4527  AddrReg7    
00003A86  43F9 00003D95           4528              LEA         dispA7, A1          ; Output -
00003A8C  103C 000E               4529              MOVE.B      #14, D0             ; command for trap call to display message
00003A90  4E4F                    4530              TRAP        #15                 ; trap call        
00003A92  6000 0002               4531              BRA         endMOVE             ; Skip print and move to next address to check if it the last address used
00003A96                          4532          
00003A96                          4533  endMOVE
00003A96  4CDF 7EFF               4534              MOVEM.L  (SP)+, D0-D7/A1-A6     ; Pops all data and address register off the stack
00003A9A  4E75                    4535              RTS
00003A9C                          4536  endMove1                                    ; Used if MOVEM has DR is 1
00003A9C  4CDF 7EFF               4537              MOVEM.L  (SP)+, D0-D7/A1-A6
00003AA0  4E75                    4538              RTS
00003AA2                          4539  ***********************************************************************************************************
00003AA2                          4540  *
00003AA2                          4541  *                       Hex Decode
00003AA2                          4542  *
00003AA2                          4543  *this subroutine displays hex code stored in D1. It displays based on the number of 
00003AA2                          4544  *It displays based on the number of hex to display which is stored in D0. If it is a
00003AA2                          4545  *long or word to display, it will figure out the ascii character and add $37 if it
00003AA2                          4546  *is a letter, and $30 if its a number. It will then load the character into D1 and 
00003AA2                          4547  *display it via trap task 6 and loop however many times is needed, 4 or 8. If a word
00003AA2                          4548  *needs to be displayed, it will roll the bits over so that, the hex are shifted by a word.
00003AA2                          4549  *
00003AA2                          4550  ***********************************************************************************************************
00003AA2                          4551  
00003AA2                          4552  outHex      
00003AA2  48E7 FF7E               4553              MOVEM.L     D0-D7/A1-A6, -(SP)  ; callee saved data
00003AA6  4243                    4554              CLR         D3                  ; clear D3  
00003AA8  4244                    4555              CLR         D4                  ; clear D2
00003AAA  1800                    4556              MOVE.B      D0, D4              ; copy number of hexes to decode from D0 to D4
00003AAC  2601                    4557              MOVE.L      D1, D3              ; copy data to be converted to display from D1 to D3 
00003AAE  B03C 0004               4558              CMP.B       #4, D0              ; compare 4 to D0 for number of hexes to decode
00003AB2  6700 0006               4559              BEQ         moveOver            ; if true, branch to moveOver
00003AB6  6000 0006               4560              BRA         dispLOOP            ; otherwise branch to dispLOOP
00003ABA                          4561              
00003ABA                          4562  moveOver    
00003ABA  E19B                    4563              ROL.L       #8,D3               ; roll over bits in D3 by 8
00003ABC  E19B                    4564              ROL.L       #8,D3               ; repeat again to get word at the end of D3
00003ABE                          4565              
00003ABE                          4566  dispLOOP    
00003ABE  B83C 0000               4567              CMP.B       #0, D4              ; compare 0 to counter or D4
00003AC2  6700 0042               4568              BEQ         endDispSub          ; it true, branch to endDispSub
00003AC6  E99B                    4569              ROL.L       #4, D3              ; roll 4 bits to get Hex
00003AC8  4245                    4570              CLR         D5                  ; clear D5
00003ACA  1A03                    4571              MOVE.B      D3, D5              ; move the byte from D3 to D5
00003ACC  CABC 0000000F           4572              AND.L       #$0F, D5            ; and D5 by F to get just one nibble
00003AD2  BA3C 000A               4573              CMP.B       #10, D5             ; compare 10 by D5
00003AD6  6D00 0006               4574              BLT         DLnine              ; if less than, branch to print numbers
00003ADA  6000 0016               4575              BRA         DLetters            ; otherwise branch to print letters
00003ADE                          4576              
00003ADE                          4577  DLnine      
00003ADE  0645 0030               4578              ADD         #$30, D5            ; add 30 to D5 to get ascii character
00003AE2  4241                    4579              CLR         D1                  ; clear D1
00003AE4  1205                    4580              MOVE.B      D5, D1              ; copy D5 to D1
00003AE6  4240                    4581              CLR         D0                  ; clear D0
00003AE8  103C 0006               4582              MOVE.B      #6, D0              ; move trap task 6 to D0 to print single character
00003AEC  4E4F                    4583              TRAP        #15                 ; trap call
00003AEE  5344                    4584              SUB         #1, D4              ; decrement counter
00003AF0  60CC                    4585              BRA         dispLOOP            ; branch back to dispLOOP
00003AF2                          4586   
00003AF2                          4587  DLetters    
00003AF2  0645 0037               4588              ADD         #$37, D5            ; add 37 to D5 to get ascii character
00003AF6  4241                    4589              CLR         D1                  ; clear D1
00003AF8  1205                    4590              MOVE.B      D5, D1              ; copy D5 to D1
00003AFA  4240                    4591              CLR         D0                  ; clear D0
00003AFC  103C 0006               4592              MOVE.B      #6, D0              ; move trap task 6 to D0 to print single character
00003B00  4E4F                    4593              TRAP        #15                 ; trap call
00003B02  5344                    4594              SUB         #1, D4              ; decrement counter
00003B04  60B8                    4595              BRA         dispLOOP            ; branch back to dispLOOP       
00003B06                          4596  
00003B06                          4597  endDispSub  
00003B06  4CDF 7EFF               4598              MOVEM.L     (SP)+, D0-D7/A1-A6  ; pop registers from stack
00003B0A  4E75                    4599              RTS                             ; return
00003B0C                          4600  
00003B0C                          4601              
00003B0C                          4602  ***********************************************************************************************************
00003B0C                          4603  *
00003B0C                          4604  *                       IO Subroutine
00003B0C                          4605  *
00003B0C                          4606  *
00003B0C                          4607  *   the following subroutine gets the string address from the user
00003B0C                          4608  *   and converts it to Hex for a starting/ending address. it is done 
00003B0C                          4609  *   by checking each byte at address A1, and converting it from ascii to 
00003B0C                          4610  *   hex number. If the user enters an invalid character string, the
00003B0C                          4611  *   program will have a simhalt.
00003B0C                          4612  *
00003B0C                          4613  ***********************************************************************************************************
00003B0C                          4614  
00003B0C                          4615  Address     
00003B0C  48E7 1F3E               4616              MOVEM.L     D3-D7/A2-A6, -(SP)  ; callee saved data
00003B10                          4617  
00003B10                          4618  Retry       
00003B10  4242                    4619              CLR         D2                  ; clear D2
00003B12  4243                    4620              CLR         D3                  ; clear D3
00003B14  B23C 0004               4621              CMP.B       #4, D1              ; compare 4 to D1 or number of ascii inputs to decode
00003B18  6700 000E               4622              BEQ         subLOOP             ; if true, branch to subLOOP
00003B1C  B23C 0008               4623              CMP.B       #8, D1              ; compare 8 to D1 or number of ascii inputs to decode
00003B20  6700 0006               4624              BEQ         subLOOP             ; if true, branch to subLOOP
00003B24  6000 012A               4625              BRA         ADDinvalid          ; otherwise invalid
00003B28                          4626          
00003B28                          4627  subLOOP     
00003B28  E85C                    4628              ROR         #4, D4              ; rotate D4 by 4 bits
00003B2A  1404                    4629              MOVE.B      D4, D2              ; move byte from D4 to D2
00003B2C  4244                    4630              CLR         D4                  ; clear D4
00003B2E  4245                    4631              CLR         D5                  ; clear D5
00003B30  B601                    4632              CMP.B       D1, D3              ; compare counter D3 to total count D1
00003B32  6700 0134               4633              BEQ         endLOOP             ; if equal branch to endLOOP
00003B36  5443                    4634              ADD.W       #2, D3              ; add 2 to D3
00003B38  E19A                    4635              ROL.L       #8, D2              ; rotate D2 by 8 bits
00003B3A                          4636          
00003B3A                          4637  bytLOOP     
00003B3A  E95C                    4638              ROL         #4, D4              ; rotate D4 by 4 bits 
00003B3C                          4639          
00003B3C  0C11 0030               4640              CMP.B       #$30, (A1)          ; compare hex value 30 to A1's location
00003B40  6700 007E               4641              BEQ         hZero               ; if true, branch to hZero
00003B44  0C11 0031               4642              CMP.B       #$31, (A1)          ; compare hex value 31 to A1's location
00003B48  6700 007E               4643              BEQ         hOne                ; if true, branch to hOne
00003B4C  0C11 0032               4644              CMP.B       #$32, (A1)          ; compare hex value 32 to A1's location
00003B50  6700 007E               4645              BEQ         hTwo                ; if true, branch to hTwo
00003B54  0C11 0033               4646              CMP.B       #$33, (A1)          ; compare hex value 33 to A1's location
00003B58  6700 007E               4647              BEQ         hThree              ; if true, branch to hThree
00003B5C  0C11 0034               4648              CMP.B       #$34, (A1)          ; compare hex value 34 to A1's location
00003B60  6700 007E               4649              BEQ         hFour               ; if true, branch to hFour
00003B64  0C11 0035               4650              CMP.B       #$35, (A1)          ; compare hex value 35 to A1's location
00003B68  6700 007E               4651              BEQ         hFive               ; if true, branch to hFive
00003B6C  0C11 0036               4652              CMP.B       #$36, (A1)          ; compare hex value 36 to A1's location
00003B70  6700 007E               4653              BEQ         hSix                ; if true, branch to hSix
00003B74  0C11 0037               4654              CMP.B       #$37, (A1)          ; compare hex value 37 to A1's location
00003B78  6700 007E               4655              BEQ         hSeven              ; if true, branch to hSeven
00003B7C  0C11 0038               4656              CMP.B       #$38, (A1)          ; compare hex value 38 to A1's location
00003B80  6700 007E               4657              BEQ         hEight              ; if true, branch to hEight
00003B84  0C11 0039               4658              CMP.B       #$39, (A1)          ; compare hex value 39 to A1's location
00003B88  6700 007E               4659              BEQ         hNine               ; if true, branch to hNine
00003B8C  0C11 0041               4660              CMP.B       #$41, (A1)          ; compare hex value 41 to A1's location
00003B90  6700 007E               4661              BEQ         hA                  ; if true, branch to hA
00003B94  0C11 0042               4662              CMP.B       #$42, (A1)          ; compare hex value 42 to A1's location
00003B98  6700 007E               4663              BEQ         hB                  ; if true, branch to hB
00003B9C  0C11 0043               4664              CMP.B       #$43, (A1)          ; compare hex value 43 to A1's location
00003BA0  6700 007E               4665              BEQ         hC                  ; if true, branch to hC
00003BA4  0C11 0044               4666              CMP.B       #$44, (A1)          ; compare hex value 44 to A1's location
00003BA8  6700 007E               4667              BEQ         hD                  ; if true, branch to hD
00003BAC  0C11 0045               4668              CMP.B       #$45, (A1)          ; compare hex value 45 to A1's location
00003BB0  6700 007E               4669              BEQ         hE                  ; if true, branch to hE
00003BB4  0C11 0046               4670              CMP.B       #$46, (A1)          ; compare hex value 46 to A1's location
00003BB8  6700 007E               4671              BEQ         hF                  ; if true, branch to hF
00003BBC  6000 0092               4672              BRA         ADDinvalid          ; otherwise invalid
00003BC0                          4673              
00003BC0                          4674  hZero       
00003BC0  183C 0000               4675              MOVE.B      #$00, D4            ; move byte 00 to D4
00003BC4  6000 007A               4676              BRA         nextH               ; branch to next hex
00003BC8                          4677              
00003BC8                          4678  hOne        
00003BC8  183C 0010               4679              MOVE.B      #$10, D4            ; move byte 10 to D4
00003BCC  6000 0072               4680              BRA         nextH               ; branch to next hex
00003BD0                          4681  hTwo        
00003BD0  183C 0020               4682              MOVE.B      #$20, D4            ; move byte 20 to D4
00003BD4  6000 006A               4683              BRA         nextH               ; branch to next hex
00003BD8                          4684              
00003BD8                          4685  hThree      
00003BD8  183C 0030               4686              MOVE.B      #$30, D4            ; move byte 30 to D4
00003BDC  6000 0062               4687              BRA         nextH               ; branch to next hex
00003BE0                          4688              
00003BE0  183C 0040               4689  hFour       MOVE.B      #$40, D4            ; move byte 40 to D4
00003BE4  6000 005A               4690              BRA         nextH               ; branch to next hex
00003BE8                          4691              
00003BE8                          4692  hFive       
00003BE8  183C 0050               4693              MOVE.B      #$50, D4            ; move byte 50 to D4
00003BEC  6000 0052               4694              BRA         nextH               ; branch to next hex
00003BF0                          4695              
00003BF0                          4696  hSix        
00003BF0  183C 0060               4697              MOVE.B      #$60, D4            ; move byte 60 to D4
00003BF4  6000 004A               4698              BRA         nextH               ; branch to next hex
00003BF8                          4699              
00003BF8                          4700  hSeven      
00003BF8  183C 0070               4701              MOVE.B      #$70, D4            ; move byte 70 to D4
00003BFC  6000 0042               4702              BRA         nextH               ; branch to next hex
00003C00                          4703              
00003C00                          4704  hEight      
00003C00  183C 0080               4705              MOVE.B      #$80, D4            ; move byte 80 to D4
00003C04  6000 003A               4706              BRA         nextH               ; branch to next hex
00003C08                          4707              
00003C08                          4708  hNine       
00003C08  183C 0090               4709              MOVE.B      #$90, D4            ; move byte 90 to D4
00003C0C  6000 0032               4710              BRA         nextH               ; branch to next hex
00003C10                          4711          
00003C10                          4712  hA          
00003C10  183C 00A0               4713              MOVE.B      #$A0, D4            ; move byte A0 to D4
00003C14  6000 002A               4714              BRA         nextH               ; branch to next hex
00003C18                          4715              
00003C18                          4716  hB          
00003C18  183C 00B0               4717              MOVE.B      #$B0, D4            ; move byte B0 to D4
00003C1C  6000 0022               4718              BRA         nextH               ; branch to next hex
00003C20                          4719              
00003C20                          4720  hC          
00003C20  183C 00C0               4721              MOVE.B      #$C0, D4            ; move byte C0 to D4
00003C24  6000 001A               4722              BRA         nextH               ; branch to next hex
00003C28                          4723              
00003C28                          4724  hD          
00003C28  183C 00D0               4725              MOVE.B      #$D0, D4            ; move byte D0 to D4
00003C2C  6000 0012               4726              BRA         nextH               ; branch to next hex
00003C30                          4727              
00003C30                          4728  hE          
00003C30  183C 00E0               4729              MOVE.B      #$E0, D4            ; move byte E0 to D4
00003C34  6000 000A               4730              BRA         nextH               ; branch to next hex
00003C38                          4731              
00003C38                          4732  hF          
00003C38  183C 00F0               4733              MOVE.B      #$F0, D4            ; move byte F0 to D4
00003C3C  6000 0002               4734              BRA         nextH               ; branch to next hex
00003C40                          4735  
00003C40                          4736  nextH       
00003C40  1019                    4737              MOVE.B      (A1)+, D0           ; move A1's location by a byte
00003C42  5245                    4738              ADD         #1, D5              ; add 1 to D5
00003C44  BA3C 0002               4739              CMP.B       #2, D5              ; compare 2 to D5
00003C48  6700 FEDE               4740              BEQ         subLOOP             ; if true, branch back to subLOOP
00003C4C  6000 FEEC               4741              BRA         bytLOOP             ; otherwise branch to bytLOOP
00003C50                          4742          
00003C50                          4743  ADDinvalid  
00003C50  43F9 00003CBA           4744              LEA         errorMessage, A1    ; load error message to A1
00003C56  103C 000E               4745              MOVE.B      #14, D0             ; move trap task 14 to display message
00003C5A  4E4F                    4746              TRAP        #15                 ; trap call
00003C5C                          4747      
00003C5C  4241                    4748              CLR         D1                  ; clear D1
00003C5E  103C 0002               4749              MOVE.B      #2, D0              ; trap task to get input
00003C62  4E4F                    4750              TRAP        #15                 ; trap call
00003C64                          4751  
00003C64  6000 FEAA               4752              BRA         Retry               ; branch to retry
00003C68                          4753     
00003C68                          4754  endLOOP     
00003C68  4CDF 7CF8               4755              MOVEM.L     (SP)+, D3-D7/A2-A6  ; pop data from stack
00003C6C  4E75                    4756              RTS                             ; return
00003C6E                          4757  ***********************************************************************************************************
00003C6E                          4758  
00003C6E                          4759  printInvalid
00003C6E  1218                    4760              MOVE.B      (A0)+,D1            ; in case of invalid, increment A0 by byte 
00003C70  6000 D3DA               4761              BRA         LOOP                ; branch back to loop
00003C74                          4762  
00003C74                          4763  endPROG    
00003C74                          4764  
00003C74  FFFF FFFF               4765      SIMHALT                                 ; halt simulator
00003C78                          4766  
00003C78                          4767  ***********************************************************************************************************
00003C78                          4768  *
00003C78                          4769  *                       IO Strings
00003C78                          4770  *           
00003C78                          4771  *       This section holds all of the various strings to output to the console.
00003C78                          4772  *
00003C78                          4773  ***********************************************************************************************************
00003C78                          4774  
00003C78= 45 6E 74 65 72 20 ...   4775  startingMessage DC.B    'Enter Starting Address (in hex): ', 0
00003C9A= 45 6E 74 65 72 20 ...   4776  endingMessage   DC.B    'Enter Ending Address (in hex): ', 0
00003CBA= 49 6E 63 6F 72 72 ...   4777  errorMessage    DC.B    'Incorrect Address, try again: ', 0
00003CD9                          4778  
00003CD9= 20 0D 0A 00             4779  newLine         DC.B    ' ', CR, LF, 0
00003CDD= 20 20 00                4780  space           DC.B    '  ', 0
00003CE0                          4781  
00003CE0= 23 00                   4782  hashTag         DC.B    '#', 0
00003CE2= 24 00                   4783  dispHex         DC.B    '$', 0
00003CE4= 2C 00                   4784  comma           DC.B    ',', 0
00003CE6                          4785  
00003CE6= 28 00                   4786  opPer           DC.B    '(', 0
00003CE8= 29 00                   4787  clPer           DC.B    ')', 0
00003CEA= 2D 00                   4788  dec             DC.B    '-', 0
00003CEC= 2B 00                   4789  inc             DC.B    '+', 0
00003CEE                          4790  
00003CEE= 4F 52 49 00             4791  ORImatch        DC.B    'ORI', 0
00003CF2= 43 4D 50 49 00          4792  CMPImatch       DC.B    'CMPI', 0
00003CF7= 42 43 4C 52 00          4793  BCLRmatch       DC.B    'BCLR', 0
00003CFC= 4D 4F 56 45 00          4794  MOVEmatch       DC.B    'MOVE', 0
00003D01= 4D 4F 56 45 41 00       4795  MOVEAmatch      DC.B    'MOVEA', 0
00003D07= 4E 45 47 00             4796  NEGmatch        DC.B    'NEG', 0
00003D0B= 52 54 53 00             4797  RTSmatch        DC.B    'RTS', 0
00003D0F= 4A 53 52 00             4798  JSRmatch        DC.B    'JSR', 0
00003D13= 4D 4F 56 45 4D 00       4799  MOVEMmatch      DC.B    'MOVEM', 0
00003D19= 4C 45 41 00             4800  LEAmatch        DC.B    'LEA', 0
00003D1D= 53 55 42 51 00          4801  SUBQmatch       DC.B    'SUBQ', 0
00003D22= 42 52 41 00             4802  BRAmatch        DC.B    'BRA', 0
00003D26= 42 43 53 00             4803  BCSmatch        DC.B    'BCS', 0
00003D2A= 42 56 43 00             4804  BVCmatch        DC.B    'BVC', 0
00003D2E= 42 47 45 00             4805  BGEmatch        DC.B    'BGE', 0
00003D32= 42 4C 54 00             4806  BLTmatch        DC.B    'BLT', 0
00003D36= 44 49 56 53 00          4807  DIVSmatch       DC.B    'DIVS', 0
00003D3B= 4F 52 00                4808  ORmatch         DC.B    'OR', 0
00003D3E= 53 55 42 00             4809  SUBmatch        DC.B    'SUB', 0
00003D42= 45 4F 52 00             4810  EORmatch        DC.B    'EOR', 0
00003D46= 43 4D 50 00             4811  CMPmatch        DC.B    'CMP', 0
00003D4A= 4D 55 4C 53 00          4812  MULSmatch       DC.B    'MULS', 0
00003D4F= 41 44 44 00             4813  ADDmatch        DC.B    'ADD', 0
00003D53= 41 44 44 41 00          4814  ADDAmatch       DC.B    'ADDA', 0
00003D58= 4C 53 52 00             4815  LSRmatch        DC.B    'LSR', 0
00003D5C= 4C 53 4C 00             4816  LSLmatch        DC.B    'LSL', 0
00003D60= 41 53 52 00             4817  ASRmatch        DC.B    'ASR', 0
00003D64= 41 53 4C 00             4818  ASLmatch        DC.B    'ASL', 0
00003D68= 52 4F 52 00             4819  RORmatch        DC.B    'ROR', 0
00003D6C= 52 4F 4C 00             4820  ROLmatch        DC.B    'ROL', 0
00003D70                          4821  
00003D70= 2F 00                   4822  slash           DC.B    '/', 0
00003D72= 28 53 50 29 00          4823  stack           DC.B    '(SP)', 0
00003D77                          4824   
00003D77= 2E 42 00                4825  dispByte        DC.B    '.B', 0
00003D7A= 2E 57 00                4826  dispWord        DC.B    '.W', 0
00003D7D= 2E 4C 00                4827  dispLong        DC.B    '.L', 0
00003D80                          4828  
00003D80= 41 30 00                4829  dispA0          DC.B    'A0', 0
00003D83= 41 31 00                4830  dispA1          DC.B    'A1', 0
00003D86= 41 32 00                4831  dispA2          DC.B    'A2', 0
00003D89= 41 33 00                4832  dispA3          DC.B    'A3', 0
00003D8C= 41 34 00                4833  dispA4          DC.B    'A4', 0
00003D8F= 41 35 00                4834  dispA5          DC.B    'A5', 0
00003D92= 41 36 00                4835  dispA6          DC.B    'A6', 0
00003D95= 41 37 00                4836  dispA7          DC.B    'A7', 0
00003D98                          4837  
00003D98= 44 00                   4838  dispD           DC.B    'D',0
00003D9A= 44 30 00                4839  dispD0          DC.B    'D0', 0
00003D9D= 44 31 00                4840  dispD1          DC.B    'D1', 0
00003DA0= 44 32 00                4841  dispD2          DC.B    'D2', 0
00003DA3= 44 33 00                4842  dispD3          DC.B    'D3', 0
00003DA6= 44 34 00                4843  dispD4          DC.B    'D4', 0
00003DA9= 44 35 00                4844  dispD5          DC.B    'D5', 0
00003DAC= 44 36 00                4845  dispD6          DC.B    'D6', 0
00003DAF= 44 37 00                4846  dispD7          DC.B    'D7', 0 
00003DB2                          4847   
00003DB2                          4848             END    START                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             34FA
ABSSHORT            34C2
ADDAMATCH           3D53
ADDINVALID          3C50
ADDMATCH            3D4F
ADDR0CONT           38F6
ADDR1CONT           3936
ADDR2CONT           3976
ADDR3CONT           39B6
ADDR4CONT           39F6
ADDR5CONT           3A36
ADDR6CONT           3A76
ADDRESS             3B0C
ADDRREG0            38D6
ADDRREG1            3906
ADDRREG2            3946
ADDRREG3            3986
ADDRREG4            39C6
ADDRREG5            3A06
ADDRREG6            3A46
ADDRREG7            3A86
ASLMATCH            3D64
ASRMATCH            3D60
BCLRMATCH           3CF7
BCSMATCH            3D26
BGEMATCH            3D2E
BLTMATCH            3D32
BRAEIGHT            1156
BRAELEVEN           1174
BRAFIVE             111E
BRAFOUR             1102
BRAFOURTEEN         11E4
BRAMATCH            3D22
BRANINE             1170
BRAONE              10F6
BRASIX              1122
BRATHIRTEEN         1192
BRATHREE            10FE
BRATWELVE           118E
BRATWO              10FA
BRAZERO             10C6
BVCMATCH            3D2A
BYTLOOP             3B3A
CHECKDR             35D0
CLPER               3CE8
CMPIMATCH           3CF2
CMPMATCH            3D46
COMMA               3CE4
CR                  D
DATAREG0            3680
DATAREG1            36B0
DATAREG2            36F0
DATAREG3            3730
DATAREG4            3770
DATAREG5            37B0
DATAREG6            37F0
DATAREG7            3830
DEC                 3CEA
DISPA0              3D80
DISPA1              3D83
DISPA2              3D86
DISPA3              3D89
DISPA4              3D8C
DISPA5              3D8F
DISPA6              3D92
DISPA7              3D95
DISPBYTE            3D77
DISPD               3D98
DISPD0              3D9A
DISPD1              3D9D
DISPD2              3DA0
DISPD3              3DA3
DISPD4              3DA6
DISPD5              3DA9
DISPD6              3DAC
DISPD7              3DAF
DISPHEX             3CE2
DISPIMM             3532
DISPLAYA0           303A
DISPLAYA0A          3106
DISPLAYA0D          33CA
DISPLAYA0P          3232
DISPLAYA1           304A
DISPLAYA1A          3122
DISPLAYA1D          33E6
DISPLAYA1P          325A
DISPLAYA2           305A
DISPLAYA2A          313E
DISPLAYA2D          3402
DISPLAYA2P          3282
DISPLAYA3           306A
DISPLAYA3A          315A
DISPLAYA3D          341E
DISPLAYA3P          32AA
DISPLAYA4           307A
DISPLAYA4A          3176
DISPLAYA4D          343A
DISPLAYA4P          32D2
DISPLAYA5           308A
DISPLAYA5A          3192
DISPLAYA5D          3456
DISPLAYA5P          32FA
DISPLAYA6           309A
DISPLAYA6A          31AE
DISPLAYA6D          3472
DISPLAYA6P          3322
DISPLAYA7           30AA
DISPLAYA7A          31CA
DISPLAYA7D          348E
DISPLAYA7P          334A
DISPLAYD0           2F7A
DISPLAYD1           2F8A
DISPLAYD2           2F9A
DISPLAYD3           2FAA
DISPLAYD4           2FBA
DISPLAYD5           2FCA
DISPLAYD6           2FDA
DISPLAYD7           2FEA
DISPLAYEIGHT        2EF2
DISPLONG            3D7D
DISPLOOP            3ABE
DISPWORD            3D7A
DIVSMATCH           3D36
DLETTERS            3AF2
DLNINE              3ADE
EIGHT               8
ELEVEN              B
ENDDISPSUB          3B06
ENDINGMESSAGE       3C9A
ENDLOOP             3C68
ENDMOVE             3A96
ENDMOVE1            3A9C
ENDPROG             3C74
ENDSUB              357A
ENDSUBROUTINE       2EFC
EORMATCH            3D42
ERRORMESSAGE        3CBA
FIRSTNIB            F0
FIVE                5
FOUR                4
FOURTEEN            E
HA                  3C10
HASHTAG             3CE0
HB                  3C18
HC                  3C20
HD                  3C28
HE                  3C30
HEIGHT              3C00
HF                  3C38
HFIVE               3BE8
HFOUR               3BE0
HNINE               3C08
HONE                3BC8
HSEVEN              3BF8
HSIX                3BF0
HTHREE              3BD8
HTWO                3BD0
HZERO               3BC0
IMMLONG             3566
INC                 3CEC
INVALID             357A
JSRMATCH            3D0F
LEAMATCH            3D19
LF                  A
LONGSKIP            3576
LOOP                104C
LSLMATCH            3D5C
LSRMATCH            3D58
MASK0               0
MASK1               1
MASK2               2
MASK3               4
MASK4               8
MASK5               10
MASK6               20
MASK7               40
MASK8               80
MASKA               5
MASKB               A
MASKC               14
MASKD               28
MASKE               50
MASKF               A0
MEMSB               268C
MEMSHIFTIMM         2ED8
MEMSHIFTS           11FE
MEMSL               2BA0
MEMSW               2916
MOVEAMATCH          3D01
MOVEMATCH           3CFC
MOVEMBRA            3580
MOVEML              35B4
MOVEMMATCH          3D13
MOVEMW              3598
MOVEOVER            3ABA
MULSMATCH           3D4A
NEGMATCH            3D07
NEWLINE             3CD9
NEXTH               3C40
NINE                9
ONE                 1
OPADDAL             2454
OPADDAW             23E4
OPADDB              2298
OPADDL              2370
OPADDW              2304
OPASBI              26CA
OPASBR              272C
OPASL               24C4
OPASLBI             270A
OPASLBR             276C
OPASLI              2BDE
OPASLLI             2C1E
OPASLLR             2C80
OPASLR              2C40
OPASLWI             2994
OPASLWR             29F6
OPASR               2510
OPASRBI             26E8
OPASRBR             274A
OPASRLI             2BFC
OPASRLR             2C5E
OPASRWI             2972
OPASRWR             29D4
OPASWI              2954
OPASWR              29B6
OPBCLR              1542
OPBCS               20DC
OPBGE               214C
OPBLT               2184
OPBRA               20A4
OPBVC               2114
OPCMP               1E0C
OPCMPB              1E3E
OPCMPI              13B8
OPCMPIB             13DA
OPCMPIL             14D0
OPCMPIW             144C
OPCMPL              1EF2
OPCMPW              1E98
OPDIVS              1C64
OPDYNBCLR           15A6
OPEOR               1CBE
OPEORB              1CEC
OPEORL              1DAC
OPEORW              1D4C
OPJSR               1992
OPLEA               1A96
OPLSBI              278E
OPLSBR              27F0
OPLSL               255C
OPLSLBI             27CE
OPLSLBR             2830
OPLSLI              2CA2
OPLSLLI             2CE2
OPLSLLR             2D44
OPLSLR              2D04
OPLSLWI             2A58
OPLSLWR             2ABA
OPLSR               25A8
OPLSRBI             27AC
OPLSRBR             280E
OPLSRLI             2CC0
OPLSRLR             2D22
OPLSRWI             2A36
OPLSRWR             2A98
OPLSWI              2A18
OPLSWR              2A7A
OPMOVEAL            172C
OPMOVEAW            1822
OPMOVEB             1614
OPMOVEL             1698
OPMOVEM             1A0C
OPMOVEMLEA          19F0
OPMOVEW             1794
OPMULS              2234
OPNEG               188A
OPNEGB              18B8
OPNEGL              18F8
OPNEGW              1938
OPOR                1B16
OPORB               1B56
OPORI               1258
OPORIB              1286
OPORIL              1352
OPORIW              12EC
OPORL               1C0A
OPORW               1BB0
OPPER               3CE6
OPROBI              2852
OPROBR              28B4
OPROL               25F4
OPROLBI             2892
OPROLBR             28F4
OPROLI              2D66
OPROLLI             2DA6
OPROLLR             2E08
OPROLR              2DC8
OPROLWI             2B1C
OPROLWR             2B7E
OPROR               2640
OPRORBI             2870
OPRORBR             28D2
OPRORLI             2D84
OPRORLR             2DE6
OPRORWI             2AFA
OPRORWR             2B5C
OPROWI              2ADC
OPROWR              2B3E
OPRTS               19D4
OPRTSJSR            1978
OPSUB               1F4C
OPSUBB              1F96
OPSUBL              204A
OPSUBQ              21BC
OPSUBQB             21EC
OPSUBQL             2218
OPSUBQW             2202
OPSUBW              1FF0
ORIMATCH            3CEE
ORMATCH             3D3B
OUTHEX              3AA2
PADDRDEC            3372
PADDRDIR            30BA
PADDRPOST           31E6
PADDRREG            2FFA
PDATAREG            2F3A
PHEX                34AA
PRINTEA             2F02
PRINTINVALID        3C6E
PRINTMEM            3840
PRINTMEMNOW         3844
PRINTREGMEM         35F8
PRINTSTACK          35E4
PRNTIMM             2E2A
PRNTREG             2E86
REG0CONT            36A0
REG1CONT            36E0
REG2CONT            3720
REG3CONT            3760
REG4CONT            37A0
REG5CONT            37E0
REG6CONT            3820
REGSHIFTS           123C
RETRY               3B10
RETRYEADD           1022
RETRYSADD           1000
ROLMATCH            3D6C
RORMATCH            3D68
RTSMATCH            3D0B
SECNIB              F
SEVEN               7
SIX                 6
SKIPPRINTEA         1A86
SLASH               3D70
SPACE               3CDD
STACK               3D72
START               1000
STARTINGMESSAGE     3C78
SUBLOOP             3B28
SUBMATCH            3D3E
SUBQMATCH           3D1D
THIRTEEN            D
THREE               3
TWELVE              C
TWO                 2
ZERO                0
