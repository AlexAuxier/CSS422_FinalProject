00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/12/2014 3:57:03 AM

00000000                             1                                     
00000000                             2      ****       ****  *******     ****    ***      ***
00000000                             3      ****       **** *******    ********  ***     ***
00000000                             4      *****     ***** ***       ***    *** ***    ***
00000000                             5      ******   ****** ***       ***    *** ***   ***
00000000                             6      ******* ******* ***        ********  ***  ***
00000000                             7      *************** *******     ******   ********
00000000                             8      ****  ***  **** ********   ********  ***  ***
00000000                             9      ****   *   **** ***   *** ***    *** ***   ***
00000000                            10      ****       **** ***   *** ***    *** ***    ***
00000000                            11      ****       **** ***   ***  ********  ***     ***
00000000                            12      ****       ****  *******     ****    ***      ***
00000000                            13      
00000000                            14              *********          ********** ****       ****
00000000                            15              ***********      *********    ****       ****
00000000                            16              ***    *****   *********      *****     *****
00000000                            17              ***      **** ********        ******   ******
00000000                            18              ***       *** ************    ******* *******
00000000                            19              ***       *** *************** ***************
00000000                            20              ***       ***    ************ ****  ***  ****
00000000                            21              ***      ***         ******** ****   *   ****
00000000                            22              ***    *****       ********   ****       ****
00000000                            23              ***********      *********    ****       ****
00000000                            24              *********     **********      ****       ****
00000000                            25          
00000000                            26  *-----------------------------------------------------------
00000000                            27  * Title      :  Motorola 68k Instruction Dissassembler (DSM)
00000000                            28  * Written by :  Abdul Hakim, David Trinh, Alexander Auxier
00000000                            29  * Date       :  2014-12-11
00000000                            30  * Description:  Stuff happens
00000000                            31  *-----------------------------------------------------------
00000000  =0000000D                 32  CR          EQU     $0D     
00000000  =0000000A                 33  LF          EQU     $0A
00000000                            34       
00000000  =00000000                 35  zero        EQU     $00                     ; defined hex value 0
00000000  =00000001                 36  one         EQU     $01                     ; defined hex value 1 
00000000  =00000002                 37  two         EQU     $02                     ; defined hex value 2
00000000  =00000003                 38  three       EQU     $03                     ; defined hex value 3
00000000  =00000004                 39  four        EQU     $04                     ; defined hex value 4
00000000  =00000005                 40  five        EQU     $05                     ; defined hex value 5
00000000  =00000006                 41  six         EQU     $06                     ; defined hex value 6
00000000  =00000007                 42  seven       EQU     $07                     ; defined hex value 7
00000000  =00000008                 43  eight       EQU     $08                     ; defined hex value 8
00000000  =00000009                 44  nine        EQU     $09                     ; defined hex value 9
00000000  =0000000B                 45  eleven      EQU     $0B                     ; defined hex value 11
00000000  =0000000C                 46  twelve      EQU     $0C                     ; defined hex value 12
00000000  =0000000D                 47  thirteen    EQU     $0D                     ; defined hex value 13
00000000  =0000000E                 48  fourteen    EQU     $0E                     ; defined hex value 14
00000000                            49  
00000000  =00000000                 50  mask0       EQU     %00000000
00000000  =00000001                 51  mask1       EQU     %00000001
00000000  =00000002                 52  mask2       EQU     %00000010
00000000  =00000004                 53  mask3       EQU     %00000100
00000000  =00000008                 54  mask4       EQU     %00001000
00000000  =00000010                 55  mask5       EQU     %00010000
00000000  =00000020                 56  mask6       EQU     %00100000
00000000  =00000040                 57  mask7       EQU     %01000000
00000000  =00000080                 58  mask8       EQU     %10000000
00000000                            59  
00000000  =00000005                 60  maskA       EQU     %00000101
00000000  =0000000A                 61  maskB       EQU     %00001010
00000000  =00000014                 62  maskC       EQU     %00010100
00000000  =00000028                 63  maskD       EQU     %00101000
00000000  =00000050                 64  maskE       EQU     %01010000
00000000  =000000A0                 65  maskF       EQU     %10100000
00000000                            66  
00000000  =000000F0                 67  firstNib    EQU     $F0
00000000  =0000000F                 68  secNib      EQU     $0F
00000000                            69               
00001000                            70              ORG    $1000
00001000                            71  START: 
00001000                            72  ***********************************************************************************************************
00001000                            73  *
00001000                            74  *                   Dissassembler Start
00001000                            75  *
00001000                            76  ***********************************************************************************************************
00001000                            77              ; Dissassemble Start, obtain addr range
00001000  43F9 00003C6E             78              LEA         startingMessage, A1
00001006  103C 000E                 79              MOVE.B      #14, D0
0000100A  4E4F                      80              TRAP        #15    
0000100C                            81          
0000100C  103C 0002                 82              MOVE.B      #2, D0
00001010  4E4F                      83              TRAP        #15
00001012                            84      
00001012  4EB9 00003B04             85              JSR         Address
00001018  2042                      86              MOVEA.L     D2, A0
0000101A                            87          
0000101A  43F9 00003C90             88              LEA         endingMessage, A1
00001020  103C 000E                 89              MOVE.B      #14, D0
00001024  4E4F                      90              TRAP        #15    
00001026                            91      
00001026  103C 0002                 92              MOVE.B      #2, D0
0000102A  4E4F                      93              TRAP        #15
0000102C                            94      
0000102C  4EB9 00003B04             95              JSR         Address
00001032  2442                      96              MOVEA.L     D2, A2
00001034                            97          
00001034  43F9 00003CCF             98              LEA         newline, A1
0000103A  103C 000E                 99              MOVE.B      #14, D0
0000103E  4E4F                     100              TRAP        #15 
00001040                           101            
00001040                           102  ***********************************************************************************************************
00001040                           103  *
00001040                           104  *                   Control Loop
00001040                           105  *
00001040                           106  *       This loop cycles and branches our code by the first nibble of OPCODE binary
00001040                           107  *
00001040                           108  ***********************************************************************************************************
00001040                           109            
00001040  4241                     110  LOOP        CLR         D1                  ; clear out D1
00001042  4242                     111              CLR         D2                  ; clear out D2
00001044  B1CA                     112              CMPA.L      A2, A0              ; compare starting and ending addresses
00001046  6E00 2C22                113              BGT         endProg             ; if A0 > A1, we've finished, end program
0000104A  1218                     114              MOVE.B      (A0)+, D1           ; load byte to D1 and increment A0 to next byte
0000104C  1401                     115              MOVE.B      D1, D2              ; copy byte to D2 for manipulation
0000104E  E882                     116              ASR.L       #four, D2           ; get first nibble in D2
00001050                           117          
00001050  B43C 0000                118              CMP.B       #zero, D2           ; compare with 0
00001054  6700 0064                119              BEQ         braZero             ; branch out to zero method
00001058  B43C 0001                120              CMP.B       #one, D2            ; compare with 1
0000105C  6700 008C                121              BEQ         braOne              ; branch out to one method
00001060  B43C 0002                122              CMP.B       #two, D2            ; compare with 2    
00001064  6700 0088                123              BEQ         braTwo              ; branch out to two method
00001068  B43C 0003                124              CMP.B       #three, D2          ; compare with 3
0000106C  6700 0084                125              BEQ         braThree            ; branch out to three method
00001070  B43C 0004                126              CMP.B       #four, D2           ; compare with 4
00001074  6700 0080                127              BEQ         braFour             ; branch out to four method
00001078  B43C 0005                128              CMP.B       #five, D2           ; compare with 5
0000107C  6700 0094                129              BEQ         braFive             ; branch out to five method
00001080  B43C 0006                130              CMP.B       #six, D2            ; compare with 6
00001084  6700 0090                131              BEQ         braSix              ; branch out to six method
00001088  B43C 0008                132              CMP.B       #eight, D2          ; compare with 8
0000108C  6700 00BC                133              BEQ         braEight            ; branch out to eight method
00001090  B43C 0009                134              CMP.B       #nine, D2           ; compare with 9
00001094  6700 00CE                135              BEQ         braNine             ; branch out to nine method
00001098  B43C 000B                136              CMP.B       #eleven, D2         ; compare with 11
0000109C  6700 00CA                137              BEQ         braEleven           ; branch out to eleven method
000010A0  B43C 000C                138              CMP.B       #twelve, D2         ; compare with 12
000010A4  6700 00DC                139              BEQ         braTwelve           ; branch out to twelve method
000010A8  B43C 000D                140              CMP.B       #thirteen, D2       ; compare with 13
000010AC  6700 00D8                141              BEQ         braThirteen         ; branch out to thirteen method
000010B0  B43C 000E                142              CMP.B       #fourteen, D2       ; compare with 14
000010B4  6700 0122                143              BEQ         braFourteen         ; branch out to fourteen method
000010B8  6086                     144              BRA         loop
000010BA                           145  
000010BA                           146  ***********************************************************************************************************
000010BA                           147  *
000010BA                           148  *                   Nibble Branch Section
000010BA                           149  *
000010BA                           150  *       This section decides which nibble goes to the corresponding opcode
000010BA                           151  *
000010BA                           152  *********************************************************************************************************** 
000010BA                           153          
000010BA                           154  braZero     
000010BA  4242                     155              CLR         D2                  ; first nibble is 0, 3 opcodes are possible 
000010BC  1401                     156              MOVE.B      D1, D2              ; clear out D2 and copy D1 back in
000010BE  C43C 000F                157              AND.B       #secNib, D2         ; set first nibble to 0
000010C2                           158  
000010C2  B43C 0000                159              CMP.B       #zero, D2           ; compare second nibble to 0
000010C6  6700 0184                160              BEQ         opORI               ; branch to ORI method
000010CA  B43C 000C                161              CMP.B       #twelve, D2         ; compare second nibble to 12
000010CE  6700 02DC                162              BEQ         opCMPI              ; branch to CMPI method
000010D2  B43C 0008                163              CMP.B       #eight,D2           ; Test for static BCLR
000010D6  6700 045E                164              BEQ         opBCLR
000010DA  C47C 0001                165              AND         #one,D2             ; Sets all bits to 0 except for first bit if it is 1
000010DE  B43C 0001                166              CMP.B       #one,D2             ; if it is one then there is a chance it is dynamic BCLR
000010E2  6700 04B6                167              BEQ         opDynBCLR
000010E6  6000 2B7C                168              BRA         printInvalid
000010EA                           169          
000010EA                           170  braOne      
000010EA  6000 051C                171              BRA         opMOVEB             ; we know that there is only one opcode that is MOVE.B
000010EE                           172  
000010EE                           173  braTwo      
000010EE  6000 059C                174              BRA         opMOVEL             ; there are two opCodes available, MOVE.L, or MOVEA.L
000010F2                           175  
000010F2                           176  braThree                                    ; there are two opCodes available, MOVE.W, or MOVEA.W
000010F2  6000 0694                177              BRA         opMOVEW
000010F6                           178  
000010F6  4242                     179  braFour     CLR         D2                  ; first nibble is 4, 5 opcodes are possible 
000010F8  1401                     180              MOVE.B      D1, D2              ; clear out D2 and copy D1 back in
000010FA  C43C 000F                181              AND.B       #secNib, D2         ; set first nibble to 0
000010FE                           182   
000010FE  B43C 0004                183              CMP.B       #four, D2           ; compare second nibble to 4
00001102  6700 077A                184              BEQ         opNEG               ; branch to NEG method
00001106  B43C 000E                185              CMP.B       #fourteen, D2       ; compare second nibble to E
0000110A  6700 0860                186              BEQ         opRTSJSR            ; branch to JSR or RTS method
0000110E  6000 08D4                187              BRA         opMOVEMLEA          ; otherwise, branch to MOVEM or LEA method
00001112                           188  
00001112                           189  braFive     
00001112  6000 109C                190              BRA         opSUBQ              ; we know that there is only one opcode that is SUBQ
00001116                           191  
00001116                           192  braSix      
00001116  4242                     193              CLR         D2                  ; first nibble is 6, 5 opcodes are possible 
00001118  1401                     194              MOVE.B      D1, D2              ; clear out D2 and copy D1 back in
0000111A  C43C 000F                195              AND.B       #$0F, D2             ; set first nibble to 0
0000111E                           196   
0000111E  B43C 0000                197              CMP.B       #zero, D2           ; compare second nibble to 0
00001122  6700 0F74                198              BEQ         opBRA               ; branch to BRA method
00001126  B43C 0005                199              CMP.B       #five, D2           ; compare second nibble to 5
0000112A  6700 0FA4                200              BEQ         opBCS               ; branch to BCS method
0000112E  B43C 0008                201              CMP.B       #eight, D2          ; compare second nibble to 8
00001132  6700 0FD4                202              BEQ         opBVC               ; branch to BCS method
00001136  B43C 000C                203              CMP.B       #twelve, D2         ; compare second nibble to 12
0000113A  6700 1004                204              BEQ         opBGE               ; branch to BGE method
0000113E  B43C 000D                205              CMP.B       #thirteen,D2        ; compare second nibble to 13
00001142  6700 1034                206              BEQ         opBLT               ; branch to BLT method
00001146  6000 2B1C                207              BRA         printInvalid        ; found an un-supported opcode
0000114A                           208  
0000114A                           209  braEight                                    ; there are two opCodes available DIVS, or OR
0000114A  4242                     210              CLR         D2                  ; clear D2 for use
0000114C  E141                     211              ASL         #8,D1               ; Shift by eight 
0000114E  1218                     212              MOVE.B      (A0)+,D1            ; Move the instruction byte into D1
00001150  3401                     213              MOVE.W      D1,D2               ; Load D2 with the word from D1
00001152  EC42                     214              ASR         #six,D2             ; Shift by 6 to find second nibble
00001154  C47C 0007                215              AND         #$07,D2             ; AND by 7 to remove unwanted bits
00001158  B43C 0007                216              CMP.B       #seven,D2           ; Compare second nibble to 7
0000115C  6700 0AFA                217              BEQ         opDIVS              ; If bits 8 - 6 are equal to 7, we have DIVS
00001160  6000 09A8                218              BRA         opOR                ; else opcode is OR
00001164                           219  
00001164                           220  braNine     
00001164  6000 0DDA                221              BRA         opSUB               ; we know that there is only one opcode that is SUB
00001168                           222  
00001168                           223  braEleven                                   ; there are two opCodes available EOR, or CMP
00001168  4242                     224              CLR         D2                  ; clear D2 for use
0000116A  E141                     225              ASL         #8,D1               ; Shift by eight for
0000116C  1218                     226              MOVE.B      (A0)+,D1            ; Re-load the instruction byte into D1
0000116E  3401                     227              MOVE.W      D1,D2               ; Move the word into D2 for the comparison
00001170  EC42                     228              ASR         #six,D2             ; Shift by 6 to find second nibble
00001172  C47C 0007                229              AND         #$07,D2             ; AND by 7 to remove unwanted bits
00001176  B43C 0003                230              CMP.B       #three,D2           ; Compare second nibble to 3
0000117A  6D00 0C84                231              BLT         opCMP               ; If opmode bits are less than 3, we have CMP
0000117E  6E00 0B32                232              BGT         opEOR               ; Else its EOR
00001182                           233  
00001182                           234  braTwelve   
00001182  6000 10A4                235              BRA         opMULS              ; we know that there is only one opcode that is MULS    
00001186                           236    
00001186                           237  braThirteen 
00001186  E141                     238              ASL         #eight, D1          ; we need the whole word to compare between add and adda, so move over the current byte 
00001188  1218                     239              MOVE.B      (A0)+, D1           ; load the remaining byte to D1
0000118A                           240              
0000118A  4242                     241              CLR         D2                  ; clear D2
0000118C  3401                     242              MOVE.W      D1, D2              ; copy opcode to D2
0000118E  EC42                     243              ASR         #six, D2            ; shift the bits right to get size and type
00001190  C47C 0007                244              AND         #seven,D2           ; clear out all but first 3 bits
00001194                           245              
00001194  B43C 0000                246              CMP.B       #zero,D2            ; compare 0 to D2
00001198  6700 10F2                247              BEQ         opADDB              ; we know its ADDB
0000119C  B43C 0001                248              CMP.B       #one, D2            ; compare 1 to D2
000011A0  6700 1156                249              BEQ         opADDW              ; we know its ADDW
000011A4  B43C 0002                250              CMP.B       #two, D2            ; compare 2 to D2
000011A8  6700 11BA                251              BEQ         opADDL              ; we know its ADDL
000011AC  B43C 0003                252              CMP.B       #three, D2          ; compare 3 to D2
000011B0  6700 1226                253              BEQ         opADDAW             ; we know its ADDAW
000011B4  B43C 0004                254              CMP.B       #four, D2           ; compare 4 to D2
000011B8  6700 10D2                255              BEQ         opADDB              ; we know its ADDB
000011BC  B43C 0005                256              CMP.B       #five, D2           ; compare 5 to D2
000011C0  6700 1136                257              BEQ         opADDW              ; we know its ADDW
000011C4  B43C 0006                258              CMP.B       #six, D2            ; compare 6 to D2
000011C8  6700 119A                259              BEQ         opADDL              ; we know its ADDL
000011CC  B43C 0007                260              CMP.B       #seven, D2          ; compare 7 to D2
000011D0  6700 1276                261              BEQ         opADDAL             ; we know its ADDAL
000011D4  6000 2A8E                262              BRA         printInvalid        ; invalid opcode
000011D8                           263               
000011D8                           264  braFourteen 
000011D8  E141                     265              ASL.W       #eight,D1           ; we need the whole word to compare between add and adda, so move over the current byte
000011DA  1218                     266              MOVE.B      (A0)+, D1           ; load the remaining byte to D1
000011DC                           267              
000011DC  4242                     268              CLR         D2                  ; clear D2
000011DE  3401                     269              MOVE.W      D1, D2              ; copy opcode to D2
000011E0  EC42                     270              ASR         #six, D2            ; shift the bits right to get size
000011E2  C47C 0003                271              AND         #03,D2
000011E6                           272          
000011E6  B43C 0003                273              CMP.B       #three, D2          ; if the size is three, we are shifting memory
000011EA  6700 0006                274              BEQ         memShifts           ; go to memory shift
000011EE  6000 0040                275              BRA         regShifts           ; else go to register shift
000011F2                           276  
000011F2                           277  memShifts   
000011F2  4242                     278              CLR         D2             
000011F4  3401                     279              MOVE.W      D1, D2              ; clear out D2 and copy D1 back in
000011F6  E082                     280              ASR.L       #eight,D2           ; move to get first byte back
000011F8  C47C 000F                281              AND         #secNib, D2         ; set first nibble to 0
000011FC                           282   
000011FC  B43C 0000                283              CMP.B       #zero, D2           ; compare second nibble to 0
00001200  6700 1302                284              BEQ         opASR               ; branch to ASR method
00001204  B43C 0001                285              CMP.B       #one, D2            ; compare second nibble to 1
00001208  6700 12AE                286              BEQ         opASL               ; branch to ASL method
0000120C  B43C 0002                287              CMP.B       #two, D2            ; compare second nibble to 2
00001210  6700 138A                288              BEQ         opLSR               ; branch to LSR method
00001214  B43C 0003                289              CMP.B       #three, D2          ; compare second nibble to 3
00001218  6700 1336                290              BEQ         opLSL               ; branch to LSL method
0000121C  B43C 0006                291              CMP.B       #six, D2            ; compare second nibble to 6
00001220  6700 1412                292              BEQ         opROR               ; branch to ROR method
00001224  B43C 0007                293              CMP.B       #seven, D2          ; compare second nibble to 7
00001228  6700 13BE                294              BEQ         opROL               ; branch to ROL method
0000122C  6000 2A36                295              BRA         printInvalid        ; otherwise, invalid
00001230                           296              
00001230                           297  regShifts   
00001230  B43C 0000                298              CMP.B       #zero, D2           ; if size is 0, we are shifting a byte
00001234  6700 144A                299              BEQ         memSB               ; branch to register shift byte
00001238  B43C 0001                300              CMP.B       #one, D2            ; if size is 1, we are shifting a word
0000123C  6700 16CC                301              BEQ         memSW               ; branch to register shift word
00001240  B43C 0002                302              CMP.B       #two, D2            ; if size is 1, we are shifting a long
00001244  6700 194E                303              BEQ         memSL               ; branch to register shift long
00001248  6000 2A1A                304              BRA         printInvalid        ; otherwise, invalid
0000124C                           305              
0000124C                           306  ***********************************************************************************************************
0000124C                           307  *
0000124C                           308  *                   ORI OPCODE
0000124C                           309  *       ORI starts out with size branching. Will compare sizes and branch to appropriate size.
0000124C                           310  *       Once size is found, code will print out ORI and continue to find mode and register and print it out
0000124C                           311  *
0000124C                           312  ***********************************************************************************************************
0000124C                           313  
0000124C                           314  opORI       
0000124C  43F9 00003CE4            315              LEA         ORImatch, A1        ; we know that the opcode will be ORI, so load A1 to print message
00001252  103C 000E                316              MOVE.B      #14, D0             ; command for trap call to display message
00001256  4E4F                     317              TRAP        #15                 ; trap call
00001258                           318          
00001258  1218                     319              MOVE.B      (A0)+, D1
0000125A  1401                     320              MOVE.B      D1,D2               ; copy data over
0000125C  EC42                     321              ASR         #6,D2               ; shifts 6 bits over to read just the size        
0000125E  B43C 0000                322              CMP.B       #zero,D2            ; Size is 0, must be byte
00001262  6700 0016                323              BEQ         opORIB              ; Branch to ORIB to print and deal with the byte
00001266  B43C 0001                324              CMP.B       #one,D2             ; Compare size to one
0000126A  6700 0074                325              BEQ         opORIW              ; If size is one, then ORI is dealing with a word.
0000126E  B43C 0002                326              CMP.B       #two,D2             ; Compare size to two
00001272  6700 00D2                327              BEQ         opORIL              ; If size is two then move onto deal with long in opORIL
00001276                           328          
00001276  6000 29EC                329              BRA         printInvalid        ; None matches, invalid code. Branch off.
0000127A                           330          
0000127A                           331  opORIB      
0000127A  43F9 00003D6D            332              LEA         dispByte, A1        ; Display byte
00001280  103C 000E                333              MOVE.B      #14, D0             ; command for trap call to display message
00001284  4E4F                     334              TRAP        #15                 ; trap call
00001286                           335          
00001286  43F9 00003CD3            336              LEA         space, A1           ; Display space
0000128C  103C 000E                337              MOVE.B      #14, D0             ; command for trap call to display message
00001290  4E4F                     338              TRAP        #15                 ; trap call
00001292                           339          
00001292  4244                     340              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
00001294  1801                     341              MOVE.B      D1,D4               ; Move byte over to D4 to use
00001296  E644                     342              ASR         #three,D4           ; Moves out insignifcant bits to find mode
00001298  C87C 0007                343              AND         #seven,D4           ; Clear other bits besides mode
0000129C  4245                     344              CLR         D5                  ; Use D5 as temporary register for destination regsiter
0000129E  1A01                     345              MOVE.B      D1,D5               ; Move data over to isolate mode
000012A0  CA7C 0007                346              AND         #seven,D5           ; Isolate the mode
000012A4                           347          
000012A4  4243                     348              CLR         D3                  ; Clear D3 to move register into it
000012A6  4242                     349              CLR         D2                  ; Clear D2 to move mode into it
000012A8  163C 0004                350              MOVE.B      #four,D3            ; Set values to be used in printEA
000012AC  143C 0007                351              MOVE.B      #seven,D2           ; Set values to be used in printEA
000012B0                           352      
000012B0  4EB9 00002EF6            353              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000012B6                           354          
000012B6  43F9 00003CDA            355              LEA         comma, A1           ; Display space
000012BC  103C 000E                356              MOVE.B      #14, D0             ; command for trap call to display message
000012C0  4E4F                     357              TRAP        #15                 ; trap call
000012C2                           358          
000012C2  4242                     359              CLR         D2                  ; Clear out D2 to move destination mode in
000012C4  4243                     360              CLR         D3                  ; Clear out D3 to move destintion register in
000012C6  1404                     361              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
000012C8  1605                     362              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA
000012CA                           363          
000012CA  4EB9 00002EF6            364              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000012D0                           365          
000012D0  43F9 00003CCF            366              LEA         newLine, A1           ; Display space
000012D6  103C 000E                367              MOVE.B      #14, D0             ; command for trap call to display message
000012DA  4E4F                     368              TRAP        #15                 ; trap call
000012DC                           369          
000012DC  6000 FD62                370              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000012E0                           371          
000012E0                           372  opORIW      
000012E0  43F9 00003D70            373              LEA         dispWord, A1        ; Display byte
000012E6  103C 000E                374              MOVE.B      #14, D0             ; command for trap call to display message
000012EA  4E4F                     375              TRAP        #15                 ; trap call
000012EC                           376          
000012EC  43F9 00003CD3            377              LEA         space, A1           ; Display space
000012F2  103C 000E                378              MOVE.B      #14, D0             ; command for trap call to display message
000012F6  4E4F                     379              TRAP        #15                 ; trap call
000012F8                           380          
000012F8  4244                     381              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
000012FA  1801                     382              MOVE.B      D1,D4               ; Move byte over to D4 to use
000012FC  E644                     383              ASR         #three,D4           ; Moves out insignifcant bits to find mode
000012FE  C87C 0007                384              AND         #seven,D4           ; Clear other bits besides mode
00001302  4245                     385              CLR         D5                  ; Use D5 as temporary register for destination regsiter
00001304  1A01                     386              MOVE.B      D1,D5               ; Move data over to isolate mode
00001306  CA7C 0007                387              AND         #seven,D5           ; Isolate the mode
0000130A                           388          
0000130A  4243                     389              CLR         D3                  ; Clear D3 to move register into it
0000130C  4242                     390              CLR         D2                  ; Clear D2 to move mode into it
0000130E  163C 0004                391              MOVE.B      #four,D3            ; Set values to be used in printEA
00001312  143C 0007                392              MOVE.B      #seven,D2           ; Set values to be used in printEA
00001316                           393          
00001316  4EB9 00002EF6            394              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000131C                           395          
0000131C  43F9 00003CDA            396              LEA         comma, A1           ; Display space
00001322  103C 000E                397              MOVE.B      #14, D0             ; command for trap call to display message
00001326  4E4F                     398              TRAP        #15                 ; trap call
00001328                           399          
00001328  4242                     400              CLR         D2                  ; Clear out D2 to move destination mode in
0000132A  4243                     401              CLR         D3                  ; Clear out D3 to move destintion register in
0000132C  1404                     402              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
0000132E  1605                     403              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA
00001330                           404                  
00001330  4EB9 00002EF6            405              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001336                           406          
00001336  43F9 00003CCF            407              LEA         newLine, A1           ; Display space
0000133C  103C 000E                408              MOVE.B      #14, D0             ; command for trap call to display message
00001340  4E4F                     409              TRAP        #15                 ; trap call
00001342                           410          
00001342  6000 FCFC                411              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001346                           412       
00001346                           413  opORIL      
00001346  43F9 00003D73            414              LEA         dispLong, A1        ; Display byte
0000134C  103C 000E                415              MOVE.B      #14, D0             ; command for trap call to display message
00001350  4E4F                     416              TRAP        #15                 ; trap call
00001352                           417          
00001352  43F9 00003CD3            418              LEA         space, A1           ; Display space
00001358  103C 000E                419              MOVE.B      #14, D0             ; command for trap call to display message
0000135C  4E4F                     420              TRAP        #15                 ; trap call
0000135E                           421          
0000135E  4244                     422              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
00001360  1801                     423              MOVE.B      D1,D4               ; Move byte over to D4 to use
00001362  E644                     424              ASR         #three,D4           ; Moves out insignifcant bits to find mode
00001364  C87C 0007                425              AND         #seven,D4           ; Clear other bits besides mode
00001368  4245                     426              CLR         D5                  ; Use D5 as temporary register for destination regsiter
0000136A  1A01                     427              MOVE.B      D1,D5               ; Move data over to isolate mode
0000136C  CA7C 0007                428              AND         #seven,D5           ; Isolate the mode
00001370                           429          
00001370  4243                     430              CLR         D3                  ; Clear D3 to move register into it
00001372  4242                     431              CLR         D2                  ; Clear D2 to move mode into it
00001374  163C 0004                432              MOVE.B      #four,D3            ; Set values to be used in printEA
00001378  143C 0007                433              MOVE.B      #seven,D2           ; Set values to be used in printEA
0000137C                           434          
0000137C  4EB9 00002EF6            435              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001382                           436          
00001382  4242                     437              CLR         D2                  ; Clear out D2 to move destination mode in
00001384  4243                     438              CLR         D3                  ; Clear out D3 to move destintion register in
00001386  1404                     439              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
00001388  1605                     440              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA
0000138A                           441          
0000138A  43F9 00003CDA            442              LEA         comma, A1           ; Display space
00001390  103C 000E                443              MOVE.B      #14, D0             ; command for trap call to display message
00001394  4E4F                     444              TRAP        #15                 ; trap call
00001396                           445          
00001396  4EB9 00002EF6            446              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000139C                           447          
0000139C  43F9 00003CCF            448              LEA         newLine, A1           ; Display space
000013A2  103C 000E                449              MOVE.B      #14, D0             ; command for trap call to display message
000013A6  4E4F                     450              TRAP        #15                 ; trap call
000013A8                           451          
000013A8  6000 FC96                452              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000013AC                           453          
000013AC                           454  ***********************************************************************************************************
000013AC                           455  *
000013AC                           456  *                   CMPI OPCODE
000013AC                           457  *       This section is dedicated to the compare (CMPI) instruction. Its determined in the control loop
000013AC                           458  *       that the first nibble is 0 for CMPI, and the second nibble is 12.
000013AC                           459  *       The type of CMPI, or the opmode, is used to determined what we output to our console next.
000013AC                           460  *       From that point, we load the correct size/opmode, and then route to the EA subroutine to output
000013AC                           461  *       EA related register information.
000013AC                           462  *       The process for finding the operand register info (EA info) is similar for all opmodes.
000013AC                           463  *
000013AC                           464  ***********************************************************************************************************
000013AC                           465          
000013AC                           466  opCMPI           
000013AC  1218                     467              MOVE.B      (A0)+, D1
000013AE  1401                     468              MOVE.B      D1,D2               ; copy data over
000013B0  EC42                     469              ASR         #6,D2               ; shifts 6 bits over to read just the size        
000013B2  B43C 0000                470              CMP.B       #zero,D2            ; Check if size is 0 which is byte
000013B6  6700 0016                471              BEQ         opCMPIB             ; Moves to CMPIB if it is 0
000013BA  B43C 0001                472              CMP.B       #one,D2             ; Check if size is 0 which is word
000013BE  6700 0080                473              BEQ         opCMPIW             ; Branch to CMPIW
000013C2  B43C 0002                474              CMP.B       #two,D2             ; Check if size is 2 which is long
000013C6  6700 00FC                475              BEQ         opCMPIL             ; Branch to CMPIL
000013CA  6000 21A2                476              BRA         invalid             ; Size is invalid, therefore code is invalid.
000013CE                           477  
000013CE                           478  opCMPIB 
000013CE  43F9 00003CE8            479              LEA         CMPImatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
000013D4  103C 000E                480              MOVE.B      #14, D0             ; command for trap call to display message
000013D8  4E4F                     481              TRAP        #15                 ; trap call
000013DA                           482          
000013DA  43F9 00003D6D            483              LEA         dispByte, A1        ; Display byte
000013E0  103C 000E                484              MOVE.B      #14, D0             ; command for trap call to display message
000013E4  4E4F                     485              TRAP        #15                 ; trap call
000013E6                           486          
000013E6  43F9 00003CD3            487              LEA         space, A1           ; Display space
000013EC  103C 000E                488              MOVE.B      #14, D0             ; command for trap call to display message
000013F0  4E4F                     489              TRAP        #15                 ; trap call
000013F2                           490          
000013F2  4244                     491              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
000013F4  1801                     492              MOVE.B      D1,D4               ; Move byte over to D4 to use
000013F6  E644                     493              ASR         #three,D4           ; Moves out insignifcant bits to find mode
000013F8  C87C 0007                494              AND         #seven,D4           ; Clear other bits besides mode
000013FC  4245                     495              CLR         D5                  ; Use D5 as temporary register for destination regsiter
000013FE  1A01                     496              MOVE.B      D1,D5               ; Move data over to isolate mode
00001400  CA7C 0007                497              AND         #seven,D5           ; Isolate the mode
00001404                           498          
00001404  4243                     499              CLR         D3                  ; Clear D3 to move register into it
00001406  4242                     500              CLR         D2                  ; Clear D2 to move mode into it
00001408  163C 0004                501              MOVE.B      #four,D3            ; Set values to be used in printEA
0000140C  143C 0007                502              MOVE.B      #seven,D2           ; Set values to be used in printEA  
00001410                           503          
00001410  4EB9 00002EF6            504              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001416                           505              
00001416  43F9 00003CDA            506              LEA         comma, A1           ; Display space
0000141C  103C 000E                507              MOVE.B      #14, D0             ; command for trap call to display message
00001420  4E4F                     508              TRAP        #15                 ; trap call
00001422                           509          
00001422  4242                     510              CLR         D2                  ; Clear out D2 to move destination mode in
00001424  4243                     511              CLR         D3                  ; Clear out D3 to move destintion register in
00001426  1404                     512              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
00001428  1605                     513              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA    
0000142A                           514          
0000142A  4EB9 00002EF6            515              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001430                           516          
00001430  43F9 00003CCF            517              LEA         newLine, A1         ; Display space
00001436  103C 000E                518              MOVE.B      #14, D0             ; command for trap call to display message
0000143A  4E4F                     519              TRAP        #15                 ; trap call
0000143C                           520  
0000143C  6000 FC02                521              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001440                           522  
00001440                           523  opCMPIW 
00001440  43F9 00003CE8            524              LEA         CMPImatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
00001446  103C 000E                525              MOVE.B      #14, D0             ; command for trap call to display message
0000144A  4E4F                     526              TRAP        #15                 ; trap call
0000144C                           527          
0000144C  43F9 00003D70            528              LEA         dispWord, A1        ; Display byte
00001452  103C 000E                529              MOVE.B      #14, D0             ; command for trap call to display message
00001456  4E4F                     530              TRAP        #15                 ; trap call
00001458                           531          
00001458  43F9 00003CD3            532              LEA         space, A1           ; Display space
0000145E  103C 000E                533              MOVE.B      #14, D0             ; command for trap call to display message
00001462  4E4F                     534              TRAP        #15                 ; trap call
00001464                           535          
00001464  4244                     536              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
00001466  1801                     537              MOVE.B      D1,D4               ; Move byte over to D4 to use
00001468  E644                     538              ASR         #three,D4           ; Moves out insignifcant bits to find mode
0000146A  C87C 0007                539              AND         #seven,D4           ; Clear other bits besides mode
0000146E  4245                     540              CLR         D5                  ; Use D5 as temporary register for destination regsiter
00001470  1A01                     541              MOVE.B      D1,D5               ; Move data over to isolate mode
00001472  CA7C 0007                542              AND         #seven,D5           ; Isolate the mode
00001476                           543          
00001476  4243                     544              CLR         D3                  ; Clear D3 to move register into it
00001478  4242                     545              CLR         D2                  ; Clear D2 to move mode into it
0000147A  163C 0004                546              MOVE.B      #four,D3            ; Set values to be used in printEA
0000147E  143C 0007                547              MOVE.B      #seven,D2           ; Set values to be used in printEA      
00001482                           548          
00001482  4EB9 00002EF6            549              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001488                           550          
00001488  43F9 00003CD6            551              LEA         hashTag, A1         ; Display space
0000148E  103C 000E                552              MOVE.B      #14, D0             ; command for trap call to display message
00001492  4E4F                     553              TRAP        #15                 ; trap call
00001494                           554          
00001494  103C 0003                555              MOVE.B      #3, D0              ; Move 3 into D0 to output
00001498  4E4F                     556              TRAP        #15                 ; Use TRAP #15 to output the immediate data
0000149A                           557          
0000149A  43F9 00003CDA            558              LEA         comma, A1           ; Display space
000014A0  103C 000E                559              MOVE.B      #14, D0             ; command for trap call to display message
000014A4  4E4F                     560              TRAP        #15                 ; trap call
000014A6                           561  
000014A6  4242                     562              CLR         D2                  ; Clear out D2 to move destination mode in
000014A8  4243                     563              CLR         D3                  ; Clear out D3 to move destintion register in
000014AA  1404                     564              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
000014AC  1605                     565              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA    
000014AE                           566          
000014AE  4EB9 00002EF6            567              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000014B4                           568          
000014B4  43F9 00003CCF            569              LEA         newLine, A1           ; Display space
000014BA  103C 000E                570              MOVE.B      #14, D0             ; command for trap call to display message
000014BE  4E4F                     571              TRAP        #15                 ; trap call
000014C0  6000 FB7E                572              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000014C4                           573  
000014C4                           574  opCMPIL 
000014C4  43F9 00003CE8            575              LEA         CMPImatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
000014CA  103C 000E                576              MOVE.B      #14, D0             ; command for trap call to display message
000014CE  4E4F                     577              TRAP        #15                 ; trap call
000014D0                           578          
000014D0  43F9 00003D73            579              LEA         dispLong, A1        ; Display byte
000014D6  103C 000E                580              MOVE.B      #14, D0             ; command for trap call to display message
000014DA  4E4F                     581              TRAP        #15                 ; trap call
000014DC                           582          
000014DC  43F9 00003CD3            583              LEA         space, A1           ; Display space
000014E2  103C 000E                584              MOVE.B      #14, D0             ; command for trap call to display message
000014E6  4E4F                     585              TRAP        #15                 ; trap call
000014E8                           586              
000014E8  4244                     587              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
000014EA  1801                     588              MOVE.B      D1,D4               ; Move byte over to D4 to use
000014EC  E644                     589              ASR         #three,D4           ; Moves out insignifcant bits to find mode
000014EE  C87C 0007                590              AND         #seven,D4           ; Clear other bits besides mode
000014F2  4245                     591              CLR         D5                  ; Use D5 as temporary register for destination regsiter
000014F4  1A01                     592              MOVE.B      D1,D5               ; Move data over to isolate mode
000014F6  CA7C 0007                593              AND         #seven,D5           ; Isolate the mode
000014FA                           594          
000014FA  4243                     595              CLR         D3                  ; Clear D3 to move register into it
000014FC  4242                     596              CLR         D2                  ; Clear D2 to move mode into it
000014FE  163C 0004                597              MOVE.B      #four,D3            ; Set values to be used in printEA
00001502  143C 0007                598              MOVE.B      #seven,D2           ; Set values to be used in printEA  
00001506                           599          
00001506  4EB9 00002EF6            600              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000150C                           601          
0000150C  43F9 00003CDA            602              LEA         comma, A1           ; Display space
00001512  103C 000E                603              MOVE.B      #14, D0             ; command for trap call to display message
00001516  4E4F                     604              TRAP        #15                 ; trap call
00001518                           605          
00001518  4242                     606              CLR         D2                  ; Clear out D2 to move destination mode in
0000151A  4243                     607              CLR         D3                  ; Clear out D3 to move destintion register in
0000151C  1404                     608              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
0000151E  1605                     609              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA                
00001520                           610          
00001520  4EB9 00002EF6            611              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001526                           612          
00001526  43F9 00003CCF            613              LEA         newLine, A1         ; Display space
0000152C  103C 000E                614              MOVE.B      #14, D0             ; command for trap call to display message
00001530  4E4F                     615              TRAP        #15                 ; trap call
00001532                           616          
00001532  6000 FB0C                617              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001536                           618          
00001536                           619  ***********************************************************************************************************
00001536                           620  *
00001536                           621  *                   BCLR OPCODE
00001536                           622  *       This section is dedicated to the compare BCLR instruction. The first nibble is 0 and the second
00001536                           623  *       nibble is 2. Once both checks are passed then code goes to print BCLR and its EA.
00001536                           624  *       
00001536                           625  ***********************************************************************************************************
00001536                           626  
00001536                           627  opBCLR      
00001536  43F9 00003CED            628              LEA         BCLRmatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
0000153C  103C 000E                629              MOVE.B      #14, D0             ; command for trap call to display message
00001540  4E4F                     630              TRAP        #15                 ; trap call
00001542                           631  
00001542  43F9 00003CD3            632              LEA         space, A1           ; Display space
00001548  103C 000E                633              MOVE.B      #14, D0             ; command for trap call to display message
0000154C  4E4F                     634              TRAP        #15                 ; trap call
0000154E                           635                  
0000154E  4242                     636              CLR         D2                  ; Clear data register
00001550  1218                     637              MOVE.B      (A0)+, D1           ; Move byte over to D1 to be used
00001552  1401                     638              MOVE.B      D1,D2               ; copy data over
00001554  E642                     639              ASR         #three,D2           ; Shift to the right to remove register
00001556  C47C 0007                640              AND         #seven,D2           ; Sets other bits to 0 and leave Mode the same
0000155A                           641                  
0000155A  4243                     642              CLR         D3                  ; Clear D3 so we can move D1 in
0000155C  1601                     643              MOVE.B      D1,D3               ; Move othr byte in
0000155E  C67C 0007                644              AND         #seven,D3           ; Set everything besides register to 0
00001562                           645                 
00001562  4241                     646              CLR         D1                  ; Clear out data register
00001564  3218                     647              MOVE.W      (A0)+, D1           ; Take in next nibble that contains data
00001566                           648                 
00001566                           649                  
00001566  43F9 00003CD6            650              LEA         hashTag, A1         ; Display space
0000156C  103C 000E                651              MOVE.B      #14, D0             ; command for trap call to display message
00001570  4E4F                     652              TRAP        #15                 ; trap call
00001572                           653          
00001572  103C 0003                654              MOVE.B      #3, D0
00001576  4E4F                     655              TRAP        #15
00001578                           656          
00001578  43F9 00003CDA            657              LEA         comma, A1           ; Display space
0000157E  103C 000E                658              MOVE.B      #14, D0             ; command for trap call to display message
00001582  4E4F                     659              TRAP        #15                 ; trap call
00001584                           660                  
00001584  4EB9 00002EF6            661              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000158A                           662          
0000158A  43F9 00003CCF            663              LEA         newLine, A1           ; Display space
00001590  103C 000E                664              MOVE.B      #14, D0             ; command for trap call to display message
00001594  4E4F                     665              TRAP        #15                 ; trap call
00001596                           666                  
00001596  6000 FAA8                667              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits   
0000159A                           668          
0000159A                           669  opDynBCLR       
0000159A  4241                     670              CLR         D1
0000159C  1218                     671              MOVE.B      (A0)+,D1            ; Copy second byte in
0000159E  1601                     672              MOVE.B      D1,D3               ; Will use D4 to store in the source register
000015A0  E243                     673              ASR         #one,D3             ; Shift register over to the end
000015A2  C67C 0007                674              AND         #seven,D3           ; Change all bits except for the register to 0. Source Register is now in D4
000015A6                           675                  
000015A6  1401                     676              MOVE.B      D1,D2
000015A8  EC42                     677              ASR         #six,D2             ; Removing mode and register to check BCLR bits
000015AA  B47C 0002                678              CMP         #two,D2             ; Checking the static bits to make sure it is BCLR
000015AE  6600 26B4                679              BNE         printInvalid        ; If not equal, than this is not BCLR or any other mode we're dealing with
000015B2                           680  
000015B2                           681                  
000015B2  43F9 00003CED            682              LEA         BCLRmatch, A1       ; we now know that the opcode will be BCLR, so load A1 to print message
000015B8  103C 000E                683              MOVE.B      #14, D0             ; command for trap call to display message
000015BC  4E4F                     684              TRAP        #15                 ; trap call  
000015BE                           685                  
000015BE  43F9 00003CD3            686              LEA         space, A1           ; Display space
000015C4  103C 000E                687              MOVE.B      #14, D0             ; command for trap call to display message
000015C8  4E4F                     688              TRAP        #15                 ; trap call
000015CA                           689                  
000015CA  143C 0000                690              MOVE.B      #zero,D2            ; Move 0 into D2 to print out data register in printEA   
000015CE  4EB9 00002EF6            691              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000015D4                           692                  
000015D4  43F9 00003CDA            693              LEA         comma, A1           ; Display space
000015DA  103C 000E                694              MOVE.B      #14, D0             ; command for trap call to display message
000015DE  4E4F                     695              TRAP        #15                 ; trap call
000015E0                           696                
000015E0  4242                     697              CLR         D2
000015E2  1401                     698              MOVE.B      D1,D2               ; Using D2 to store EA mode
000015E4  E642                     699              ASR         #three,D2           ; Remove/shift the register out
000015E6  C47C 0007                700              AND         #seven,D2           ; Change all bits except for the mode bits to 0
000015EA                           701                  
000015EA  4243                     702              CLR         D3                  ; Clearing D3 to avoid mashing data
000015EC  1601                     703              MOVE.B      D1,D3               ; Moving byte into D3. Using D3 to store EA register
000015EE  C67C 0007                704              AND         #seven,D3           ; Change all bits except for register bits to 0
000015F2                           705              
000015F2  4EB9 00002EF6            706              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000015F8                           707          
000015F8  43F9 00003CCF            708              LEA         newLine, A1         ; Display space
000015FE  103C 000E                709              MOVE.B      #14, D0             ; command for trap call to display message
00001602  4E4F                     710              TRAP        #15                 ; trap call            
00001604                           711  
00001604                           712  
00001604  6000 FA3A                713              BRA         LOOP                ; go back to the loop   
00001608                           714                  
00001608                           715  ***********************************************************************************************************
00001608                           716  *
00001608                           717  *                   MOVE OPCODE
00001608                           718  *                   MOVEA OPCODE
00001608                           719  *       This section of code is dedication to MOVE and MOVEA opcode instructions. MOVEA is determined by
00001608                           720  *       its static bits at 8, 7, and 6. Once those static bits are confirmed, the code branches off to 
00001608                           721  *       MOVEA, else it continues into MOVE.
00001608                           722  *
00001608                           723  ***********************************************************************************************************
00001608                           724   
00001608                           725  opMOVEB 
00001608  43F9 00003CF2            726              LEA         MOVEmatch, A1       ; we know that the opcode will be MOVE.B, so load A1 to print message
0000160E  103C 000E                727              MOVE.B      #14, D0             ; command for trap call to display message
00001612  4E4F                     728              TRAP        #15                 ; trap call
00001614  43F9 00003D6D            729              LEA         dispByte, A1        ; display byte
0000161A  103C 000E                730              MOVE.B      #14, D0             ; command for trap call to display message
0000161E  4E4F                     731              TRAP        #15                 ; trap call
00001620  43F9 00003CD3            732              LEA         space, A1           ; create spaces
00001626  103C 000E                733              MOVE.B      #14, D0             ; command for trap call to display message
0000162A  4E4F                     734              TRAP        #15                 ; trap call
0000162C                           735          
0000162C                           736          
0000162C  4245                     737              CLR         D5                  ; Clear D5
0000162E  1A01                     738              MOVE.B      D1,D5               ; Copying byte over to D5. Will use D5 to store destination Register
00001630  E245                     739              ASR         #one,D5             ; shifted mode out. Register is now stored into D5
00001632  CA7C 0007                740              AND         #seven,D5
00001636                           741          
00001636  4244                     742              CLR         D4                  ; Clear out D4
00001638  1801                     743              MOVE.B      D1,D4               ; Copy byte over to store destination mode
0000163A  C87C 0001                744              AND         #one,D4             ; Set all the other bits to 0, leave the bit for the destination mode alone.
0000163E                           745          
0000163E  4241                     746              CLR          D1                 ; Clear data register
00001640  4242                     747              CLR          D2                 ; Clear data register
00001642  1218                     748              MOVE.B      (A0)+,D1            ; Copy byte into D1
00001644  1401                     749              MOVE.B      D1,D2
00001646  EC42                     750              ASR         #6,D2               ; Shifts source mode and register out to get destination mode
00001648  D842                     751              ADD         D2,D4               ; Adds the remaining bits to D4
0000164A                           752          
0000164A  4242                     753              CLR         D2                  ; Clear data register
0000164C  1401                     754              MOVE.B      D1,D2               ; Copy new byte over to D2
0000164E  E642                     755              ASR         #three,D2           ; Shift source register out
00001650  C47C 0007                756              AND         #seven,D2           ; Set everything to 0 except for the mode
00001654                           757          
00001654  4243                     758              CLR         D3                  ; Clear Data register 3
00001656  1601                     759              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
00001658  C67C 0007                760              AND         #seven,D3           ; Sets up everything to 0 except for the register bits
0000165C                           761          
0000165C  4EB9 00002EF6            762              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001662                           763          
00001662  43F9 00003CDA            764              LEA         comma, A1           ; Display space
00001668  103C 000E                765              MOVE.B      #14, D0             ; command for trap call to display message
0000166C  4E4F                     766              TRAP        #15                 ; trap call
0000166E                           767          
0000166E  4242                     768              CLR         D2                  ; Clear data register
00001670  4243                     769              CLR         D3                  ; Clear data register
00001672  1404                     770              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
00001674  1605                     771              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
00001676                           772          
00001676  4EB9 00002EF6            773              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000167C                           774          
0000167C  43F9 00003CCF            775              LEA         newLine, A1         ; Display space
00001682  103C 000E                776              MOVE.B      #14, D0             ; command for trap call to display message
00001686  4E4F                     777              TRAP        #15                 ; trap call            
00001688                           778  
00001688  6000 F9B6                779              BRA         LOOP                ; go back to the loop
0000168C                           780          
0000168C                           781  opMOVEL     
0000168C  4245                     782              CLR         D5                  ; Clear D5
0000168E  1A01                     783              MOVE.B      D1,D5               ; Copying byte over to D5. Will use D5 to store destination Register
00001690  E245                     784              ASR         #one,D5             ; shifted mode out. Register is now stored into D5
00001692  CA7C 0007                785              AND         #seven,D5
00001696                           786          
00001696  4244                     787              CLR         D4                  ; Clear out D4
00001698  1801                     788              MOVE.B      D1,D4               ; Copy byte over to store destination mode
0000169A  C87C 0001                789              AND         #one,D4             ; Set all the other bits to 0, leave the bit for the destination mode alone.
0000169E                           790          
0000169E  4241                     791              CLR          D1                 ; Clear data register
000016A0  4242                     792              CLR          D2                 ; Clear data register
000016A2  1218                     793              MOVE.B      (A0)+,D1            ; Copy byte into D1
000016A4  1401                     794              MOVE.B      D1,D2
000016A6  EC42                     795              ASR         #6,D2               ; Shifts source mode and register out to get destination mode
000016A8  D842                     796              ADD         D2,D4               ; Adds the remaining bits to D4
000016AA                           797          
000016AA  B87C 0001                798              CMP         #one,D4             ; Check if it is MOVEA
000016AE  6700 0070                799              BEQ         opMOVEAL            ; If it is, branch off
000016B2                           800              
000016B2  43F9 00003CF2            801              LEA         MOVEmatch, A1       ; we know that the opcode will be MOVE.L OR MOVEA.L, so load A1 to print message
000016B8  103C 000E                802              MOVE.B      #14, D0             ; command for trap call to display message
000016BC  4E4F                     803              TRAP        #15                 ; trap call  
000016BE                           804              
000016BE  43F9 00003D73            805              LEA         dispLong,A1         ; Prints out L to display a long
000016C4  103C 000E                806              MOVE.B      #14, D0             ; command for trap call to display message
000016C8  4E4F                     807              TRAP        #15                 ; trap call
000016CA                           808              
000016CA  43F9 00003CD3            809              LEA         space, A1           ; create spaces
000016D0  103C 000E                810              MOVE.B      #14, D0             ; command for trap call to display message
000016D4  4E4F                     811              TRAP        #15                 ; trap call
000016D6                           812          
000016D6  4242                     813              CLR         D2                  ; Clear data register
000016D8  1401                     814              MOVE.B      D1,D2               ; Copy new byte over to D2
000016DA  E642                     815              ASR         #three,D2           ; Shift source register out
000016DC  C47C 0007                816              AND         #seven,D2           ; Set everything to 0 except for the mode
000016E0                           817          
000016E0  4243                     818              CLR         D3                  ; Clear Data register 3
000016E2  1601                     819              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
000016E4  C67C 0007                820              AND         #seven,D3           ; Sets up everything to 0 except for the register bits      
000016E8                           821              
000016E8  4246                     822              CLR         D6                  ; Clear data register
000016EA  1C3C 0001                823              MOVE.B      #1,D6               ; Moves 1 into D6 to be used in printEA to display long
000016EE  4EB9 00002EF6            824              JSR         printEA             ; Prints out EA
000016F4  4246                     825              CLR         D6
000016F6                           826              
000016F6  43F9 00003CDA            827              LEA         comma, A1           ; Display comma
000016FC  103C 000E                828              MOVE.B      #14, D0             ; command for trap call to display message
00001700  4E4F                     829              TRAP        #15                 ; trap call
00001702                           830          
00001702  4242                     831              CLR         D2                  ; Clear data register            
00001704  4243                     832              CLR         D3                  ; Clear data register
00001706  1404                     833              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
00001708  1605                     834              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
0000170A                           835          
0000170A  4EB9 00002EF6            836              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001710                           837  
00001710  43F9 00003CCF            838              LEA         newLine, A1         ; Display space
00001716  103C 000E                839              MOVE.B      #14, D0             ; command for trap call to display message
0000171A  4E4F                     840              TRAP        #15                 ; trap call            
0000171C                           841  
0000171C  6000 F922                842              BRA         LOOP                ; go back to the loop
00001720                           843              
00001720                           844  opMOVEAL
00001720  43F9 00003CF7            845              LEA         MOVEAmatch,A1       ; MOVEA has been determined. Print out MOVEA
00001726  103C 000E                846              MOVE.B      #14, D0             ; command for trap call to display message
0000172A  4E4F                     847              TRAP        #15                 ; trap call
0000172C                           848              
0000172C  43F9 00003D73            849              LEA         dispLong,A1         ; Prints out L
00001732  103C 000E                850              MOVE.B      #14, D0             ; command for trap call to display message
00001736  4E4F                     851              TRAP        #15                 ; trap call
00001738                           852              
00001738                           853  
00001738  43F9 00003CD3            854              LEA         space, A1           ; create spaces
0000173E  103C 000E                855              MOVE.B      #14, D0             ; command for trap call to display message
00001742  4E4F                     856              TRAP        #15                 ; trap call
00001744                           857              
00001744  4242                     858              CLR         D2                  ; Clear data register
00001746  1401                     859              MOVE.B      D1,D2               ; Copy new byte over to D2
00001748  E642                     860              ASR         #three,D2           ; Shift source register out
0000174A  C47C 0007                861              AND         #seven,D2           ; Set everything to 0 except for the mode
0000174E                           862          
0000174E  4243                     863              CLR         D3                  ; Clear Data register 3
00001750  1601                     864              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
00001752  C67C 0007                865              AND         #seven,D3           ; Sets up everything to 0 except for the register bits    
00001756                           866              
00001756  4241                     867              CLR         D1                  ; Clear D1
00001758                           868              
00001758  4EB9 00002EF6            869              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000175E                           870              
0000175E  43F9 00003CDA            871              LEA         comma, A1           ; Display comma
00001764  103C 000E                872              MOVE.B      #14, D0             ; command for trap call to display message
00001768  4E4F                     873              TRAP        #15                 ; trap call
0000176A                           874  
0000176A  4242                     875              CLR         D2                  ; Clear data register
0000176C  4243                     876              CLR         D3                  ; Clear data register
0000176E  1404                     877              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
00001770  1605                     878              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
00001772                           879          
00001772  4EB9 00002EF6            880              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001778                           881          
00001778  43F9 00003CCF            882              LEA         newLine, A1         ; Display space
0000177E  103C 000E                883              MOVE.B      #14, D0             ; command for trap call to display message
00001782  4E4F                     884              TRAP        #15                 ; trap call            
00001784                           885  
00001784  6000 F8BA                886              BRA         LOOP                ; go back to the loop
00001788                           887  
00001788                           888  opMOVEW
00001788  4245                     889              CLR         D5                  ; Clear D5
0000178A  1A01                     890              MOVE.B      D1,D5               ; Copying byte over to D5. Will use D5 to store destination Register
0000178C  E245                     891              ASR         #one,D5             ; shifted mode out. Register is now stored into D5
0000178E  CA7C 0007                892              AND         #seven,D5
00001792                           893          
00001792  4244                     894              CLR         D4                  ; Clear out D4
00001794  1801                     895              MOVE.B      D1,D4               ; Copy byte over to store destination mode
00001796  C87C 0001                896              AND         #one,D4             ; Set all the other bits to 0, leave the bit for the destination mode alone.
0000179A                           897          
0000179A  4241                     898              CLR          D1                 ; Clear data register
0000179C  4242                     899              CLR          D2                 ; Clear data register
0000179E  1218                     900              MOVE.B      (A0)+,D1            ; Copy byte into D1
000017A0  1401                     901              MOVE.B      D1,D2
000017A2  EC42                     902              ASR         #6,D2               ; Shifts source mode and register out to get destination mode
000017A4  D842                     903              ADD         D2,D4               ; Adds the remaining bits to D4
000017A6                           904          
000017A6  B87C 0001                905              CMP         #one,D4             ; Check if it is MOVEA
000017AA  6700 006A                906              BEQ         opMOVEAW            ; If it is, branch off
000017AE                           907              
000017AE  43F9 00003CF2            908              LEA         MOVEmatch, A1       ; we know that the opcode will be MOVE.L OR MOVEA.L, so load A1 to print message
000017B4  103C 000E                909              MOVE.B      #14, D0             ; command for trap call to display message
000017B8  4E4F                     910              TRAP        #15                 ; trap call  
000017BA                           911              
000017BA  43F9 00003D70            912              LEA         dispWord,A1         ; Prints out a W after the opcode
000017C0  103C 000E                913              MOVE.B      #14, D0             ; command for trap call to display message
000017C4  4E4F                     914              TRAP        #15                 ; trap call
000017C6                           915              
000017C6  43F9 00003CD3            916              LEA         space, A1           ; create spaces
000017CC  103C 000E                917              MOVE.B      #14, D0             ; command for trap call to display message
000017D0  4E4F                     918              TRAP        #15                 ; trap call
000017D2                           919          
000017D2  4242                     920              CLR         D2
000017D4  1401                     921              MOVE.B      D1,D2               ; Copy new byte over to D2
000017D6  E642                     922              ASR         #three,D2           ; Shift source register out
000017D8  C47C 0007                923              AND         #seven,D2           ; Set everything to 0 except for the mode
000017DC                           924          
000017DC  4243                     925              CLR         D3                  ; Clear Data register 3
000017DE  1601                     926              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
000017E0  C67C 0007                927              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
000017E4                           928              
000017E4  4241                     929              CLR         D1                  ; Clear D1
000017E6                           930              
000017E6  4EB9 00002EF6            931              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000017EC                           932              
000017EC  43F9 00003CDA            933              LEA         comma, A1           ; Display comma
000017F2  103C 000E                934              MOVE.B      #14, D0             ; command for trap call to display message
000017F6  4E4F                     935              TRAP        #15                 ; trap call
000017F8                           936          
000017F8  4242                     937              CLR         D2                  ; Clear data register 
000017FA  4243                     938              CLR         D3                  ; Clear data register
000017FC  1404                     939              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
000017FE  1605                     940              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
00001800  4EB9 00002EF6            941              JSR         printEA
00001806                           942          
00001806  43F9 00003CCF            943              LEA         newLine, A1         ; Display space
0000180C  103C 000E                944              MOVE.B      #14, D0             ; command for trap call to display message
00001810  4E4F                     945              TRAP        #15                 ; trap call            
00001812                           946  
00001812  6000 F82C                947              BRA         LOOP                ; go back to the loop
00001816                           948              
00001816                           949  opMOVEAW  
00001816  43F9 00003CF7            950              LEA         MOVEAmatch,A1       ; Prints out MOVEA
0000181C  103C 000E                951              MOVE.B      #14, D0             ; command for trap call to display message
00001820  4E4F                     952              TRAP        #15                 ; trap call
00001822                           953                  
00001822  43F9 00003D70            954              LEA         dispWord,A1         ; Prints out W
00001828  103C 000E                955              MOVE.B      #14, D0             ; command for trap call to display message
0000182C  4E4F                     956              TRAP        #15                 ; trap call
0000182E                           957              
0000182E  43F9 00003CD3            958              LEA         space, A1           ; create spaces
00001834  103C 000E                959              MOVE.B      #14, D0             ; command for trap call to display message
00001838  4E4F                     960              TRAP        #15                 ; trap call
0000183A                           961              
0000183A  4242                     962              CLR         D2                  ; Clear data register
0000183C  1401                     963              MOVE.B      D1,D2               ; Copy new byte over to D2
0000183E  E642                     964              ASR         #three,D2           ; Shift source register out
00001840  C47C 0007                965              AND         #seven,D2           ; Set everything to 0 except for the mode
00001844                           966          
00001844  4243                     967              CLR         D3                  ; Clear Data register 3
00001846  1601                     968              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
00001848  C67C 0007                969              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
0000184C                           970              
0000184C  4241                     971              CLR         D1                  ; Clear D1      
0000184E                           972              
0000184E  4EB9 00002EF6            973              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001854                           974              
00001854  43F9 00003CDA            975              LEA         comma, A1           ; Display comma
0000185A  103C 000E                976              MOVE.B      #14, D0             ; command for trap call to display message
0000185E  4E4F                     977              TRAP        #15                 ; trap call
00001860                           978  
00001860  4242                     979              CLR         D2                  ; Clear data register
00001862  4243                     980              CLR         D3                  ; Clear data register
00001864  1404                     981              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
00001866  1605                     982              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
00001868                           983          
00001868  4EB9 00002EF6            984              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000186E                           985          
0000186E  43F9 00003CCF            986              LEA         newLine, A1         ; Display space
00001874  103C 000E                987              MOVE.B      #14, D0             ; command for trap call to display message
00001878  4E4F                     988              TRAP        #15                 ; trap call            
0000187A                           989  
0000187A  6000 F7C4                990              BRA         LOOP                ; go back to the loop
0000187E                           991  
0000187E                           992  ***********************************************************************************************************
0000187E                           993  *
0000187E                           994  *                   NEG OPCODE
0000187E                           995  *       This section is dedicated to the NEG opmode instruction. NEG is determined by the first and
0000187E                           996  *       the second nibble. The first nibble is 4 and the second nibble is equal to 0. Once that has been
0000187E                           997  *       determined. NEG is printed out.
0000187E                           998  ***********************************************************************************************************
0000187E                           999  
0000187E                          1000  opNEG   
0000187E  43F9 00003CFD           1001              LEA         NEGmatch, A1        ; we know that the opcode will be NEG, so load A1 to print message
00001884  103C 000E               1002              MOVE.B      #14, D0             ; command for trap call to display message
00001888  4E4F                    1003              TRAP        #15                 ; trap call
0000188A                          1004          
0000188A                          1005          
0000188A  1218                    1006              MOVE.B      (A0)+, D1           ; Move data into D1 for use 
0000188C  1401                    1007              MOVE.B      D1,D2               ; copy data over
0000188E  EC42                    1008              ASR         #six,D2             ; Moves six bits over to read the size
00001890                          1009              
00001890  B47C 0000               1010              CMP         #zero,D2            ; Compare size
00001894  6700 0016               1011              BEQ         opNEGB              ; Branch to NEG if size is byte
00001898  B47C 0001               1012              CMP         #one,D2             ; Compare size with one, 
0000189C  6700 008E               1013              BEQ         opNEGW              ; If equal, size is a word. Branch to NEGW
000018A0  B47C 0002               1014              CMP         #two,D2             ; Compare size with two
000018A4  6700 0046               1015              BEQ         opNEGL              ; If size is two, NEG size is long. Branch to NEGL
000018A8  6000 1CC4               1016              BRA         invalid             ; If size is neither, code is invalid. Branch to deal with invalid code.
000018AC                          1017              
000018AC                          1018  opNEGB
000018AC  43F9 00003D6D           1019              LEA         dispByte, A1        ; we know that the opcode will be NEG, so load A1 to print message
000018B2  103C 000E               1020              MOVE.B      #14, D0             ; command for trap call to display message
000018B6  4E4F                    1021              TRAP        #15                 ; trap call
000018B8                          1022          
000018B8  43F9 00003CD3           1023              LEA         space, A1           ; we know that the opcode will be NEG, so load A1 to print message
000018BE  103C 000E               1024              MOVE.B      #14, D0             ; command for trap call to display message
000018C2  4E4F                    1025              TRAP        #15                 ; trap call
000018C4                          1026          
000018C4  4242                    1027              CLR         D2                  ; Clear Data register 2
000018C6  3401                    1028              MOVE        D1,D2               ; Move byte into D2
000018C8  E642                    1029              ASR         #three,D2           ; Shift mode into place and moves mode into place
000018CA  C47C 0007               1030              AND         #seven,D2           ; Stores mode
000018CE                          1031              
000018CE  4243                    1032              CLR         D3                  ; Clear Data register 3
000018D0  1601                    1033              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
000018D2  C67C 0007               1034              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
000018D6                          1035              
000018D6  4EB9 00002EF6           1036              JSR         printEA
000018DC                          1037                  
000018DC  43F9 00003CCF           1038              LEA         newLine, A1         ; Display space
000018E2  103C 000E               1039              MOVE.B      #14, D0             ; command for trap call to display message
000018E6  4E4F                    1040              TRAP        #15                 ; trap call  
000018E8                          1041          
000018E8  6000 F756               1042              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000018EC                          1043  
000018EC                          1044  opNEGL
000018EC  43F9 00003D73           1045              LEA         dispLong, A1        ; we know that the opcode will be NEG, so load A1 to print message
000018F2  103C 000E               1046              MOVE.B      #14, D0             ; command for trap call to display message
000018F6  4E4F                    1047              TRAP        #15                 ; trap call
000018F8                          1048  
000018F8  43F9 00003CD3           1049              LEA         space, A1           ; we know that the opcode will be NEG, so load A1 to print message
000018FE  103C 000E               1050              MOVE.B      #14, D0             ; command for trap call to display message
00001902  4E4F                    1051              TRAP        #15                 ; trap call
00001904                          1052                  
00001904  4242                    1053              CLR         D2                  ; Clear Data register 2
00001906  3401                    1054              MOVE        D1,D2               ; Move byte into D2
00001908  E642                    1055              ASR         #three,D2           ; Shift mode into place and moves mode into place
0000190A  C47C 0007               1056              AND         #seven,D2           ; Stores mode
0000190E                          1057          
0000190E  4243                    1058              CLR         D3                  ; Clear Data register 3
00001910  1601                    1059              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
00001912  C67C 0007               1060              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
00001916                          1061          
00001916  4EB9 00002EF6           1062              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000191C                          1063                      
0000191C  43F9 00003CCF           1064              LEA         newLine, A1         ; Display space
00001922  103C 000E               1065              MOVE.B      #14, D0             ; command for trap call to display message
00001926  4E4F                    1066              TRAP        #15                 ; trap call  
00001928                          1067          
00001928  6000 F716               1068              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
0000192C                          1069  
0000192C                          1070  opNEGW
0000192C  43F9 00003D70           1071              LEA         dispWord, A1        ; we know that the opcode will be NEG, so load A1 to print message
00001932  103C 000E               1072              MOVE.B      #14, D0             ; command for trap call to display message
00001936  4E4F                    1073              TRAP        #15                 ; trap call
00001938                          1074          
00001938  43F9 00003CD3           1075              LEA         space, A1           ; we know that the opcode will be NEG, so load A1 to print message
0000193E  103C 000E               1076              MOVE.B      #14, D0             ; command for trap call to display message
00001942  4E4F                    1077              TRAP        #15                 ; trap call        
00001944                          1078                  
00001944  4242                    1079              CLR         D2                  ; Clear Data register 2
00001946  3401                    1080              MOVE        D1,D2               ; Move byte into D2
00001948  E642                    1081              ASR         #three,D2           ; Shift mode into place and moves mode into place
0000194A  C47C 0007               1082              AND         #seven,D2           ; Stores mode
0000194E                          1083          
0000194E  4243                    1084              CLR         D3                  ; Clear Data register 3
00001950  1601                    1085              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
00001952  C67C 0007               1086              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
00001956                          1087          
00001956  4EB9 00002EF6           1088              JSR         printEA
0000195C                          1089              
0000195C  43F9 00003CCF           1090              LEA         newLine, A1         ; Display space
00001962  103C 000E               1091              MOVE.B      #14, D0             ; command for trap call to display message
00001966  4E4F                    1092              TRAP        #15                 ; trap call  
00001968                          1093          
00001968  6000 F6D6               1094              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
0000196C                          1095              
0000196C                          1096  ***********************************************************************************************************
0000196C                          1097  *
0000196C                          1098  *                   RTS_JSR Helper Function
0000196C                          1099  *       Compare byte with static bits from JSR and RTS. If data is not equal to either, then data is
0000196C                          1100  *       considered an invalid opcode and branches off to invalid.
0000196C                          1101  *
0000196C                          1102  ***********************************************************************************************************
0000196C                          1103  
0000196C                          1104  opRTSJSR
0000196C  1218                    1105              MOVE.B      (A0)+, D1           ; Move byte into D1 and increment.
0000196E                          1106              
0000196E  1401                    1107              MOVE.B      D1,D2               ; copy data over
00001970  B47C 0075               1108              CMP         #117,D2             ; 117 is the decimal value of RTS.
00001974  6700 0052               1109              BEQ         opRTS               ; If equal, branch to RTS to print out.
00001978                          1110              
00001978  EC42                    1111              ASR         #six,D2             ; Moving bits over to check if it matches the two static bits in JSR
0000197A  B47C 0002               1112              CMP         #two,D2             ; Checking if it is JSR
0000197E  6700 0006               1113              BEQ         opJSR               ; It is equal, so branch off to opJSR
00001982                          1114  
00001982  6000 1BEA               1115              BRA         invalid             ; Branch to invalid to deal with invalid data.
00001986                          1116              
00001986                          1117  ***********************************************************************************************************
00001986                          1118  *
00001986                          1119  *                   JSR OPCODE
00001986                          1120  *       This section is dedicated to the JSR opmode instruction. JSR is determined by the 9 static bits.
00001986                          1121  *       Once the bits have matched the disassembled code, the code passes through and prints out JSR along
00001986                          1122  *       with its EA.               
00001986                          1123  *
00001986                          1124  ***********************************************************************************************************
00001986                          1125  
00001986                          1126  opJSR
00001986  43F9 00003D05           1127              LEA         JSRMatch, A1        ; we know that the opcode will be JSR, so load A1 to print message
0000198C  103C 000E               1128              MOVE.B      #14, D0             ; command for trap call to display message
00001990  4E4F                    1129              TRAP        #15                 ; trap call
00001992                          1130              
00001992  43F9 00003CD3           1131              LEA         space, A1           ; we know that the opcode will be NEG, so load A1 to print message
00001998  103C 000E               1132              MOVE.B      #14, D0             ; command for trap call to display message
0000199C  4E4F                    1133              TRAP        #15                 ; trap call
0000199E                          1134              
0000199E  4242                    1135              CLR         D2                  ; Clearing data register 
000019A0  4243                    1136              CLR         D3                  ; Clearing data register 
000019A2                          1137              
000019A2  1401                    1138              MOVE.B      D1,D2               ; Move D1 data to D2 to find the EA mode
000019A4  E642                    1139              ASR         #three,D2           ; Move mode over to the end in order to read
000019A6  C47C 0007               1140              AND         #seven,D2           ; Set every bit to 0 except for mode bits
000019AA                          1141              
000019AA  4243                    1142              CLR         D3
000019AC  1601                    1143              MOVE.B      D1,D3               ; Move bits over to D3 to find register
000019AE  C67C 0007               1144              AND         #seven,D3           ; Sets every bit to 0 except for register bits
000019B2                          1145              
000019B2  4EB9 00002EF6           1146              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000019B8                          1147              
000019B8  43F9 00003CCF           1148              LEA         newLine, A1         ; Display space
000019BE  103C 000E               1149              MOVE.B      #14, D0             ; command for trap call to display message
000019C2  4E4F                    1150              TRAP        #15                 ; trap call  
000019C4                          1151              
000019C4  6000 F67A               1152              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000019C8                          1153  
000019C8                          1154  ***********************************************************************************************************
000019C8                          1155  *
000019C8                          1156  *                   RTS OPCODE
000019C8                          1157  *       Function prints out RTS. Does not need to check in here as it is done beforehand. Branches back
000019C8                          1158  *       into loop afterwards.
000019C8                          1159  *
000019C8                          1160  ***********************************************************************************************************
000019C8                          1161  
000019C8                          1162  opRTS
000019C8  43F9 00003D01           1163              LEA         RTSMatch, A1        ; we know that the opcode will be RTS, so load A1 to print message
000019CE  103C 000E               1164              MOVE.B      #14, D0             ; command for trap call to display message
000019D2  4E4F                    1165              TRAP        #15                 ; trap call
000019D4                          1166              
000019D4  43F9 00003CCF           1167              LEA         newLine, A1         ; Display space
000019DA  103C 000E               1168              MOVE.B      #14, D0             ; command for trap call to display message
000019DE  4E4F                    1169              TRAP        #15                 ; trap call 
000019E0                          1170              
000019E0  6000 F65E               1171              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000019E4                          1172              
000019E4                          1173  ***********************************************************************************************************
000019E4                          1174  *
000019E4                          1175  *                   MOVEM_LEA OPCODE
000019E4                          1176  *       This part of the code is used to branch to either MOVEM or LEA depending on the second nibble.
000019E4                          1177  *
000019E4                          1178  ***********************************************************************************************************
000019E4                          1179  
000019E4                          1180  opMOVEMLEA
000019E4  4242                    1181              CLR         D2                  ; Clear D2
000019E6  1401                    1182              MOVE.B      D1,D2               ; Copy byte over
000019E8  C47C 000F               1183              AND         #secNib,D2          ; Check only the second nibble
000019EC  B47C 000C               1184              CMP         #twelve,D2          ; Compare the second nibble to twelve
000019F0  6700 000E               1185              BEQ         opMOVEM             ; If it is twelve, then it is MOVEM
000019F4  B47C 0008               1186              CMP         #eight,D2           ; Compare the second nibble to eight
000019F8  6700 0006               1187              BEQ         opMOVEM             ; If it is eight, then it is also MOVEM
000019FC  6000 008C               1188              BRA         opLEA               ; Otherwise branch to OPLEA and check for invalid in there
00001A00                          1189              
00001A00                          1190  ***********************************************************************************************************
00001A00                          1191  *
00001A00                          1192  *                   MOVEM OPCODE
00001A00                          1193  *       MOVEM has 7 static bits. Before anything is done, static bits are checked and the dr field is stored
00001A00                          1194  *       into D6 to be used later on for specific branching. After the static bits have confirmed this is
00001A00                          1195  *       indeed MOVEM that is being disassembled, the code will print out MOVEM and goes into the subroutine
00001A00                          1196  *       to print out the data and address registers.
00001A00                          1197  *
00001A00                          1198  ***********************************************************************************************************
00001A00                          1199  
00001A00                          1200  opMOVEM            
00001A00  4246                    1201              CLR         D6                  ; Clearing D4 to store dr field
00001A02  1C01                    1202              MOVE.B      D1,D6               ; Moving byte to find dr field
00001A04  E446                    1203              ASR         #two,D6             ; Moving dr field to readable spot
00001A06  CC7C 0001               1204              AND         #one,D6             ; seting everything except dr to 0
00001A0A                          1205  
00001A0A  4241                    1206              CLR         D1  
00001A0C  1218                    1207              MOVE.B      (A0)+, D1           ; Taking in next byte
00001A0E                          1208              
00001A0E  4245                    1209              CLR         D5
00001A10  1A01                    1210              MOVE.B      D1,D5               ; Using D6 to check if this is indeed MOVEM
00001A12  EE45                    1211              ASR         #seven,D5
00001A14  CA7C 0001               1212              AND         #one,D5
00001A18  BA7C 0001               1213              CMP         #one,D5             ; This bit should be one if this is MOVEM
00001A1C  6600 1B50               1214              BNE         invalid             ; If this is not 1 then this is not moveM
00001A20  4245                    1215              CLR         D5
00001A22                          1216              
00001A22  43F9 00003D09           1217              LEA         MOVEMMatch, A1       ; we know that the opcode will be MOVEM, so load A1 to print message
00001A28  103C 000E               1218              MOVE.B      #14, D0             ; command for trap call to display message
00001A2C  4E4F                    1219              TRAP        #15                 ; trap call
00001A2E                          1220              
00001A2E  4245                    1221              CLR         D5                  ; Clearing D5 to store size
00001A30  1A01                    1222              MOVE.B      D1,D5               ; Moving byte that contains bit for size
00001A32  EC45                    1223              ASR         #six,D5             ; Moving size bit to the very right to read
00001A34  CA7C 0001               1224              AND         #one,D5             ; Isolating the one bit for size
00001A38                          1225              
00001A38  4242                    1226              CLR         D2                  ; Clear Data register 2
00001A3A  3401                    1227              MOVE        D1,D2               ; Move byte into D2
00001A3C  E642                    1228              ASR         #three,D2           ; Shift mode into place and moves mode into place
00001A3E  C47C 0007               1229              AND         #seven,D2           ; Stores mode
00001A42                          1230              
00001A42  4243                    1231              CLR         D3                  ; Storing EA register into D3
00001A44  1601                    1232              MOVE.B      D1,D3               ; Move bits over to D3 to find register
00001A46  C67C 0007               1233              AND         #seven,D3           ; Sets every bit to 0 except for register bits
00001A4A                          1234              
00001A4A  4EB9 00003578           1235              JSR         MOVEMBRA            ; Jumps to subroutine that prints out the data and address registers
00001A50                          1236              
00001A50  B47C 0003               1237              CMP         #three,D2           ; Checks if this is post increment
00001A54  6700 0024               1238              BEQ         skipPrintEA         ; If it is, skipping printing EA again, because it is printed already in JSR
00001A58                          1239              
00001A58  43F9 00003CDA           1240              LEA         comma, A1           ; Display comma
00001A5E  103C 000E               1241              MOVE.B      #14, D0             ; command for trap call to display message
00001A62  4E4F                    1242              TRAP        #15                 ; trap call
00001A64                          1243              
00001A64  4EB9 00002EF6           1244              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001A6A                          1245              
00001A6A  43F9 00003CCF           1246              LEA         newline, A1         ; we know that the opcode will be MOVEM, so load A1 to print message
00001A70  103C 000E               1247              MOVE.B      #14, D0             ; command for trap call to display message
00001A74  4E4F                    1248              TRAP        #15                 ; trap call            
00001A76                          1249  
00001A76  6000 F5C8               1250              BRA         loop                ; Branch back to outer most loop that finds the first four bits
00001A7A                          1251  
00001A7A                          1252  skipPrintEA 
00001A7A  43F9 00003CCF           1253              LEA         newline, A1         ; Prints out new line or carraige return
00001A80  103C 000E               1254              MOVE.B      #14, D0             ; command for trap call to display message
00001A84  4E4F                    1255              TRAP        #15                 ; trap call            
00001A86                          1256  
00001A86  6000 F5B8               1257              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001A8A                          1258              
00001A8A                          1259  ***********************************************************************************************************
00001A8A                          1260  *
00001A8A                          1261  *               LEA OPCODE
00001A8A                          1262  *
00001A8A                          1263  *       This section is dedicated to the LEA opcode. This is determined that the first nibble is 4 nibbles as
00001A8A                          1264  *       well as the three static nibbles on 8,7, and 6. Once both have been checked, the code prints out
00001A8A                          1265  *       LEA and goes on to print its effective address.
00001A8A                          1266  *
00001A8A                          1267  ***********************************************************************************************************
00001A8A                          1268  
00001A8A                          1269  opLEA
00001A8A  4244                    1270              CLR         D4                  ; Clearing space for source register
00001A8C  1801                    1271              MOVE.B      D1,D4               ; Moving byte to isolate register
00001A8E  E244                    1272              ASR         #one,D4
00001A90  C87C 0007               1273              AND         #seven,D4           ; Isolated register
00001A94                          1274  
00001A94  4245                    1275              CLR         D5                  ; Clearing D5 to check if bits match LEA static bits
00001A96  1A01                    1276              MOVE.B      D1,D5               ; Stores destination register in temporary data register for later use
00001A98  CA7C 0001               1277              AND         #one,D5             ; Setting all other bits to one except for mode register
00001A9C  E545                    1278              ASL         #two,D5             ; Shifts the two register bits over to correct spot
00001A9E                          1279              
00001A9E  1218                    1280              MOVE.B      (A0)+, D1           ; Taking in next byte
00001AA0                          1281              
00001AA0  1C01                    1282              MOVE.B      D1,D6               
00001AA2  EC46                    1283              ASR         #six,D6             ; Shifts 6 bits over to move register
00001AA4  DA46                    1284              ADD         D6,D5               ; Add the remaining bits to the register
00001AA6  4246                    1285              CLR         D6                  ; Clear out the temporary register
00001AA8                          1286  
00001AA8  BA7C 0007               1287              CMP         #seven,D5           ; Checks the seven static bits to see if it is LEA
00001AAC  6600 1AC0               1288              BNE         invalid             ; If it is not equal then this is not LEA
00001AB0                          1289              
00001AB0  43F9 00003D0F           1290              LEA         LEAmatch, A1        ; we know that the opcode will be LEA, so load A1 to print message
00001AB6  103C 000E               1291              MOVE.B      #14, D0             ; command for trap call to display message
00001ABA  4E4F                    1292              TRAP        #15                 ; trap call            
00001ABC                          1293  
00001ABC  43F9 00003CD3           1294              LEA         space, A1           ; we know that the opcode will be MOVEM, so load A1 to print message
00001AC2  103C 000E               1295              MOVE.B      #14, D0             ; command for trap call to display message
00001AC6  4E4F                    1296              TRAP        #15                 ; trap call            
00001AC8                          1297              
00001AC8  4242                    1298              CLR         D2                  ; Clear Data register 2
00001ACA  3401                    1299              MOVE        D1,D2               ; Move byte into D2
00001ACC  E642                    1300              ASR         #three,D2           ; Shift mode into place and moves mode into place
00001ACE  C47C 0007               1301              AND         #seven,D2           ; Stores mode
00001AD2                          1302              
00001AD2  4243                    1303              CLR         D3
00001AD4  1601                    1304              MOVE.B      D1,D3               ; Move bits over to D3 to find register
00001AD6  C67C 0007               1305              AND         #seven,D3           ; Sets every bit to 0 except for register bits
00001ADA                          1306              
00001ADA  4EB9 00002EF6           1307              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001AE0                          1308              
00001AE0  43F9 00003CDA           1309              LEA         comma, A1           ; we know that the opcode will be MOVEM, so load A1 to print message
00001AE6  103C 000E               1310              MOVE.B      #14, D0             ; command for trap call to display message
00001AEA  4E4F                    1311              TRAP        #15                 ; trap call            
00001AEC                          1312              
00001AEC                          1313              
00001AEC  4243                    1314              CLR         D3                  ; Clears D3 to move effective address into it
00001AEE  1604                    1315              MOVE.B      D4,D3               ; Moves data with EA register
00001AF0  143C 0001               1316              MOVE.B      #one,D2             ; Puts 1 into D2 to print an An within printEA
00001AF4                          1317              
00001AF4  4EB9 00002EF6           1318              JSR         printEA             ; Prints out source address
00001AFA                          1319              
00001AFA  43F9 00003CCF           1320              LEA         newline, A1         ; Prints new line
00001B00  103C 000E               1321              MOVE.B      #14, D0             ; command for trap call to display message
00001B04  4E4F                    1322              TRAP        #15                 ; trap call
00001B06                          1323  
00001B06  6000 F538               1324              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits                 
00001B0A                          1325  
00001B0A                          1326  ***********************************************************************************************************
00001B0A                          1327  *
00001B0A                          1328  *                   OR OPCODE
00001B0A                          1329  *
00001B0A                          1330  *       This section is dedicated to the OR opcode. This is determined that the first nibble is 8, and the
00001B0A                          1331  *       second nibble is not 7 (or we would have DIVS), we must have OR.
00001B0A                          1332  *       OR is varied by the operand direction. We have and EA to Dn, and DN to EA operation.
00001B0A                          1333  *       These operand directions determine our opmode, which we use to disassemble.
00001B0A                          1334  *
00001B0A                          1335  ***********************************************************************************************************
00001B0A                          1336              
00001B0A                          1337  opOR                                        ; Assumed we found OR, begin disassemble
00001B0A  43F9 00003D31           1338              LEA         ORmatch,A1          ; Output OR to the IO console
00001B10  103C 000E               1339              MOVE.B      #14,D0              ; Use trap 14
00001B14  4E4F                    1340              TRAP        #15                 ; Halt for IO
00001B16                          1341              
00001B16  E141                    1342              ASL         #eight,D1           ; Shift D1 by eight to find opmode
00001B18  1401                    1343              MOVE.B      D1,D2               ; Load D2 with the resulting byte
00001B1A                          1344              
00001B1A                          1345              ; These are for EA to Dn direction
00001B1A  B43C 0000               1346              CMP.B       #zero,D2            ; Check for a byte
00001B1E  6700 002A               1347              BEQ         opORB               ; Byte in opmode
00001B22  B43C 0001               1348              CMP.B       #one,D2             ; Check for a word
00001B26  6700 007C               1349              BEQ         opORW               ; Word in opmode
00001B2A  B43C 0002               1350              CMP.B       #two,D2             ; Check for a long
00001B2E  6700 00CE               1351              BEQ         opORL               ; Long in opmode
00001B32                          1352              
00001B32                          1353              ; These are for Dn to EA direction
00001B32  B43C 0004               1354              CMP.B       #four,D2            ; Check for a byte
00001B36  6700 0012               1355              BEQ         opORB               ; Byte in opmode
00001B3A  B43C 0005               1356              CMP.B       #five,D2            ; Check for a word
00001B3E  6700 0064               1357              BEQ         opORW               ; Word in opmode
00001B42  B43C 0006               1358              CMP.B       #six,D2             ; Check for a long
00001B46  6700 00B6               1359              BEQ         opORL               ; Long in opmode
00001B4A                          1360              
00001B4A                          1361  opORB                                       ; Byte determined, find operands from here
00001B4A  43F9 00003D6D           1362              LEA         dispByte,A1         ; Display our byte info
00001B50  103C 000E               1363              MOVE.B      #14,D0              ; Trap #14 for our IO
00001B54  4E4F                    1364              TRAP        #15                 ; Halt for IO
00001B56                          1365              
00001B56  43F9 00003CD3           1366              LEA         space, A1           ; Display space
00001B5C  103C 000E               1367              MOVE.B      #14, D0             ; command for trap call to display message
00001B60  4E4F                    1368              TRAP        #15                 ; trap call
00001B62                          1369              
00001B62                          1370  
00001B62  1401                    1371              MOVE.B      D1,D2               ; Load D2 again with the byte in D1
00001B64  E642                    1372              ASR         #3,D2               ; Shift by 3 for finding 1 operand
00001B66  C47C 0007               1373              AND         #$07,D2             ; AND by 7 to remove extras
00001B6A  1601                    1374              MOVE.B      D1,D3               ; Load D3 with more necessary EA info
00001B6C  C67C 0007               1375              AND         #$07,D3             ; AND by 7 to remove extra bits
00001B70  4EB9 00002EF6           1376              JSR         printEA             ; Determines the "left" operand register
00001B76                          1377              
00001B76  43F9 00003CDA           1378              LEA         comma, A1           ; Display space
00001B7C  103C 000E               1379              MOVE.B      #14, D0             ; command for trap call to display message
00001B80  4E4F                    1380              TRAP        #15                 ; trap call
00001B82                          1381              
00001B82  4242                    1382              CLR         D2                  ; Clear D2 for use
00001B84  3601                    1383              MOVE.W      D1,D3               ; Move our word into D3 for EA use
00001B86  E043                    1384              ASR         #eight,D3           ; Shift by 8 to isolate EA info
00001B88  E243                    1385              ASR         #one,D3             ; We need additional shift, so total shifts is by 9
00001B8A  C67C 0007               1386              AND         #$07,D3             ; AND to remove extra data
00001B8E  4EB9 00002EF6           1387              JSR         printEA             ; Redirect to EA subroutine to find EA operand info
00001B94                          1388              
00001B94  43F9 00003CCF           1389              LEA         newLine,A1          ; Prime a new line for the next instruction
00001B9A  103C 000E               1390              MOVE.B      #14,D0              ; Send it to the console
00001B9E  4E4F                    1391              TRAP        #15                 ; IO halt here
00001BA0                          1392              
00001BA0  6000 F49E               1393              BRA         LOOP                ; Return to control loop to find additional instructions
00001BA4                          1394              
00001BA4                          1395              
00001BA4                          1396  opORW                                       ; Word opmode has been found
00001BA4  43F9 00003D70           1397              LEA         dispWord,A1         ; Display our word info
00001BAA  103C 000E               1398              MOVE.B      #14,D0              ; Trap #14 for our IO
00001BAE  4E4F                    1399              TRAP        #15                 ; Halt for IO
00001BB0                          1400              
00001BB0  43F9 00003CD3           1401              LEA         space, A1           ; Display space
00001BB6  103C 000E               1402              MOVE.B      #14, D0             ; command for trap call to display message
00001BBA  4E4F                    1403              TRAP        #15                 ; trap call
00001BBC                          1404              
00001BBC                          1405  
00001BBC  1401                    1406              MOVE.B      D1,D2               ; Load D2 again with the byte in D1
00001BBE  E642                    1407              ASR         #3,D2               ; Shift by 3 for finding 1 operand
00001BC0  C47C 0007               1408              AND         #$07,D2             ; AND by 7 to remove extras
00001BC4  1601                    1409              MOVE.B      D1,D3               ; Load D3 with more necessary EA info
00001BC6  C67C 0007               1410              AND         #$07,D3             ; AND by 7 to remove extra bits
00001BCA  4EB9 00002EF6           1411              JSR         printEA             ; Determines the "left" operand register
00001BD0                          1412              
00001BD0  43F9 00003CDA           1413              LEA         comma, A1           ; Display space
00001BD6  103C 000E               1414              MOVE.B      #14, D0             ; command for trap call to display message
00001BDA  4E4F                    1415              TRAP        #15                 ; trap call
00001BDC                          1416              
00001BDC  4242                    1417              CLR         D2                  ; Clear D2 for use
00001BDE  3601                    1418              MOVE.W      D1,D3               ; Move our word into D3 for EA use
00001BE0  E043                    1419              ASR         #eight,D3           ; Shift by 8 to isolate EA info
00001BE2  E243                    1420              ASR         #one,D3             ; We need additional shift, so total shifts is by 9
00001BE4  C67C 0007               1421              AND         #$07,D3             ; AND to remove extra data
00001BE8  4EB9 00002EF6           1422              JSR         printEA             ; Redirect to EA subroutine to find EA operand info
00001BEE                          1423              
00001BEE  43F9 00003CCF           1424              LEA         newLine,A1          ; Prime a new line for the next instruction
00001BF4  103C 000E               1425              MOVE.B      #14,D0              ; Send it to the console
00001BF8  4E4F                    1426              TRAP        #15                 ; IO halt here
00001BFA                          1427              
00001BFA  6000 F444               1428              BRA         LOOP                ; Return to control loop to find additional instructions
00001BFE                          1429              
00001BFE                          1430  opORL                                       ; Long value has been found for OR
00001BFE  43F9 00003D73           1431              LEA         dispLong,A1         ; Display our long info
00001C04  103C 000E               1432              MOVE.B      #14,D0              ; Trap #14 for our IO
00001C08  4E4F                    1433              TRAP        #15                 ; Halt for IO
00001C0A                          1434              
00001C0A  43F9 00003CD3           1435              LEA         space, A1           ; Display space
00001C10  103C 000E               1436              MOVE.B      #14, D0             ; command for trap call to display message
00001C14  4E4F                    1437              TRAP        #15                 ; trap call
00001C16                          1438              
00001C16                          1439  
00001C16  1401                    1440              MOVE.B      D1,D2               ; Load D2 again with the byte in D1
00001C18  E642                    1441              ASR         #3,D2               ; Shift by 3 for finding 1 operand
00001C1A  C47C 0007               1442              AND         #$07,D2             ; AND by 7 to remove extras
00001C1E  1601                    1443              MOVE.B      D1,D3               ; Load D3 with more necessary EA info
00001C20  C67C 0007               1444              AND         #$07,D3             ; AND by 7 to remove extra bits
00001C24  4EB9 00002EF6           1445              JSR         printEA             ; Determines the "left" operand register
00001C2A                          1446              
00001C2A  43F9 00003CDA           1447              LEA         comma, A1           ; Display space
00001C30  103C 000E               1448              MOVE.B      #14, D0             ; command for trap call to display message
00001C34  4E4F                    1449              TRAP        #15                 ; trap call
00001C36                          1450              
00001C36  4242                    1451              CLR         D2                  ; Clear D2 for use
00001C38  3601                    1452              MOVE.W      D1,D3               ; Move our word into D3 for EA use
00001C3A  E043                    1453              ASR         #eight,D3           ; Shift by 8 to isolate EA info
00001C3C  E243                    1454              ASR         #one,D3             ; We need additional shift, so total shifts is by 9
00001C3E  C67C 0007               1455              AND         #$07,D3             ; AND to remove extra data
00001C42  4EB9 00002EF6           1456              JSR         printEA             ; Redirect to EA subroutine to find EA operand info
00001C48                          1457              
00001C48  43F9 00003CCF           1458              LEA         newLine,A1          ; Prime a new line for the next instruction
00001C4E  103C 000E               1459              MOVE.B      #14,D0              ; Send it to the console
00001C52  4E4F                    1460              TRAP        #15                 ; IO halt here
00001C54                          1461              
00001C54  6000 F3EA               1462              BRA         LOOP                ; Return to control loop to find additional instructions
00001C58                          1463              
00001C58                          1464  ***********************************************************************************************************
00001C58                          1465  *
00001C58                          1466  *                   DIVS OPCODE
00001C58                          1467  *
00001C58                          1468  *       This section is dedicate to the DIVS instruction, which is determined by a 8 in the first nibble
00001C58                          1469  *       and a 7 in the second nibble of the instruction.
00001C58                          1470  *       DIVSL is not supported, so the following code only accounts for the case of DIVS, which is short
00001C58                          1471  *       instead of a long
00001C58                          1472  *
00001C58                          1473  ***********************************************************************************************************
00001C58                          1474  
00001C58                          1475  opDIVS                                      ; Second nibble determined that the instruction was DIVS
00001C58  43F9 00003D2C           1476              LEA         DIVSmatch,A1        ; Load DIVS into A1 for output console
00001C5E  103C 000E               1477              MOVE.B      #14,D0              ; Get trap task #14 for IO
00001C62  4E4F                    1478              TRAP        #15                 ; Trap call to halt
00001C64                          1479              
00001C64  43F9 00003CD3           1480              LEA         space, A1           ; Display space
00001C6A  103C 000E               1481              MOVE.B      #14, D0             ; command for trap call to display message
00001C6E  4E4F                    1482              TRAP        #15                 ; trap to halt
00001C70                          1483              
00001C70  1401                    1484              MOVE.B      D1,D2               ; Move our byte from D1 to D2 to manipulate
00001C72  E642                    1485              ASR         #3,D2               ; Shift by 3 to find register
00001C74  C47C 0007               1486              AND         #$07,D2             ; AND by 7 to clear unnecessary bits
00001C78  1601                    1487              MOVE.B      D1,D3               ; Load the byte into D3 for EA comparison
00001C7A  C67C 0007               1488              AND         #$07,D3             ; AND by 7 to clear unnecessary bits
00001C7E  4EB9 00002EF6           1489              JSR         printEA             ; Call our EA subroutine to obtain EA bits from instruction
00001C84                          1490              
00001C84  43F9 00003CDA           1491              LEA         comma, A1           ; Display space
00001C8A  103C 000E               1492              MOVE.B      #14, D0             ; command for trap call to display message
00001C8E  4E4F                    1493              TRAP        #15                 ; trap to halt call
00001C90                          1494              
00001C90  4242                    1495              CLR         D2                  ; Clear old data from D2 to avoid errors
00001C92  3601                    1496              MOVE.W      D1,D3               ; Move word into D3 for EA subroutine
00001C94  E043                    1497              ASR         #eight,D3           ; Shift by 8 to find to find the remaining EA components
00001C96  E243                    1498              ASR         #one,D3             ; Additional shift by 1 to get proper bits
00001C98  C67C 0007               1499              AND         #$07,D3             ; AND to clear unwanted bits
00001C9C  4EB9 00002EF6           1500              JSR         printEA             ; Obtain other operand info
00001CA2                          1501              
00001CA2  43F9 00003CCF           1502              LEA         newLine,A1          ; Prepare new line for next instruction
00001CA8  103C 000E               1503              MOVE.B      #14,D0              ; Utilize trap task 14
00001CAC  4E4F                    1504              TRAP        #15                 ; Halt for IO
00001CAE                          1505              
00001CAE  6000 F390               1506              BRA         LOOP                ; Return to control loop
00001CB2                          1507              
00001CB2                          1508  **********************************************************************************************************
00001CB2                          1509  *
00001CB2                          1510  *                   EOR OPCODE
00001CB2                          1511  *
00001CB2                          1512  *       This sectioon is dedicated to the EOR opcode. We determine this with an 11 in the first nibble, and
00001CB2                          1513  *       a value higher than 3 in the second nibble.
00001CB2                          1514  *       The opmode fields is used to differ this instruction from CMP.
00001CB2                          1515  *       Dissassembly acquires opmode field info, which is similar to size, and to different EA related
00001CB2                          1516  *       operands.
00001CB2                          1517  *
00001CB2                          1518  ***********************************************************************************************************
00001CB2                          1519  
00001CB2                          1520  opEOR                                       ; We found EOR, begin disassembly
00001CB2  43F9 00003D38           1521              LEA         EORmatch,A1         ; Load A1 with our EOR output
00001CB8  103C 000E               1522              MOVE.B      #14,D0              ; Prime trap task #14
00001CBC  4E4F                    1523              TRAP        #15                 ; Halt for IO
00001CBE                          1524              
00001CBE  4242                    1525              CLR         D2                  ; Clear D2 for use again
00001CC0                          1526              
00001CC0  1401                    1527              MOVE.B      D1,D2               ; Move byte used in D1 to D2 for opmode check
00001CC2  EE42                    1528              ASR         #seven,D2           ; Move bits 7 places over to find opmode
00001CC4  C47C 0007               1529              AND         #$07,D2             ; AND by 7 to clear extra bits
00001CC8  B43C 0005               1530              CMP.B       #five,D2            ; Check for a byte in opmode
00001CCC  6D00 0012               1531              BLT         opEORB              ; Byte in opmode
00001CD0  B43C 0005               1532              CMP.B       #five,D2            ; Check for a word in opmode
00001CD4  6700 006A               1533              BEQ         opEORW              ; Word in opmode
00001CD8  B43C 0005               1534              CMP.B       #five,D2            ; Check for a long in opmode
00001CDC  6E00 00C2               1535              BGT         opEORL              ; Long in opmode
00001CE0                          1536              
00001CE0                          1537  opEORB                                      ; Determine instruction is a byte operation
00001CE0  43F9 00003D6D           1538              LEA         dispByte,A1         ; Send out the byte info for the instruction
00001CE6  103C 000E               1539              MOVE.B      #14,D0              ; Utilize trap task 14
00001CEA  4E4F                    1540              TRAP        #15                 ; Halt for IO
00001CEC                          1541              
00001CEC  43F9 00003CD3           1542              LEA         space, A1           ; Display space
00001CF2  103C 000E               1543              MOVE.B      #14, D0             ; command for trap call to display message
00001CF6  4E4F                    1544              TRAP        #15                 ; trap call to halt
00001CF8                          1545              
00001CF8  4242                    1546              CLR         D2                  ; Clear D2 again for use
00001CFA  4243                    1547              CLR         D3                  ; Remove anything from D3
00001CFC  3601                    1548              MOVE.W      D1,D3               ; Move word to D3 to find an operand
00001CFE  E043                    1549              ASR         #eight,D3           ; Shift by eight to ensure correct portion of instruction
00001D00  E243                    1550              ASR         #one,D3             ; Needs to be shifted by an additional 1
00001D02  C67C 0007               1551              AND         #$07,D3             ; Clear extra bits 
00001D06  4EB9 00002EF6           1552              JSR         printEA             ; Use EA subroutine to print operand
00001D0C                          1553              
00001D0C  43F9 00003CDA           1554              LEA         comma, A1           ; Display space
00001D12  103C 000E               1555              MOVE.B      #14, D0             ; command for trap call to display message
00001D16  4E4F                    1556              TRAP        #15                 ; trap call
00001D18                          1557              
00001D18  4242                    1558              CLR         D2                  ; Clear D2 again
00001D1A  4243                    1559              CLR         D3                  ; Clear D3 again
00001D1C  1401                    1560              MOVE.B      D1,D2               ; Move the byte value in D1 to D2 for EA use
00001D1E  E642                    1561              ASR         #three,D2           ; Shift by 3 to find EA info
00001D20  C47C 0007               1562              AND         #seven,D2           ; AND by 7 to remove extra bits
00001D24  1601                    1563              MOVE.B      D1,D3               ; Move byte value from D1 into D3
00001D26  C67C 0007               1564              AND         #$07,D3             ; AND by 7 for EA subroutine
00001D2A  4EB9 00002EF6           1565              JSR         printEA             ; Determines remained operand EA info to print
00001D30                          1566              
00001D30  43F9 00003CCF           1567              LEA         newLine,A1          ; Print new line for next instruction
00001D36  103C 000E               1568              MOVE.B      #14,D0              ; Use trap 14 to output to console
00001D3A  4E4F                    1569              TRAP        #15                 ; Halt for IO
00001D3C                          1570              
00001D3C  6000 F302               1571              BRA         LOOP                ; Return to control loop
00001D40                          1572               
00001D40                          1573  opEORW                                      ; Word opmode has been determined
00001D40  43F9 00003D70           1574              LEA         dispWord,A1         ; Send out the word info for the instruction
00001D46  103C 000E               1575              MOVE.B      #14,D0              ; Utilize trap task 14
00001D4A  4E4F                    1576              TRAP        #15                 ; Halt for IO
00001D4C                          1577              
00001D4C  43F9 00003CD3           1578              LEA         space, A1           ; Display space
00001D52  103C 000E               1579              MOVE.B      #14, D0             ; command for trap call to display message
00001D56  4E4F                    1580              TRAP        #15                 ; trap call to halt
00001D58                          1581              
00001D58  4242                    1582              CLR         D2                  ; Clear D2 again for use
00001D5A  4243                    1583              CLR         D3                  ; Remove anything from D3
00001D5C  3601                    1584              MOVE.W      D1,D3               ; Move word to D3 to find an operand
00001D5E  E043                    1585              ASR         #eight,D3           ; Shift by eight to ensure correct portion of instruction
00001D60  E243                    1586              ASR         #one,D3             ; Needs to be shifted by an additional 1
00001D62  C67C 0007               1587              AND         #$07,D3             ; Clear extra bits 
00001D66  4EB9 00002EF6           1588              JSR         printEA             ; Use EA subroutine to print operand
00001D6C                          1589              
00001D6C  43F9 00003CDA           1590              LEA         comma, A1           ; Display space
00001D72  103C 000E               1591              MOVE.B      #14, D0             ; command for trap call to display message
00001D76  4E4F                    1592              TRAP        #15                 ; trap call
00001D78                          1593              
00001D78  4242                    1594              CLR         D2                  ; Clear D2 again
00001D7A  4243                    1595              CLR         D3                  ; Clear D3 again
00001D7C  1401                    1596              MOVE.B      D1,D2               ; Move the byte value in D1 to D2 for EA use
00001D7E  E642                    1597              ASR         #three,D2           ; Shift by 3 to find EA info
00001D80  C47C 0007               1598              AND         #seven,D2           ; AND by 7 to remove extra bits
00001D84  1601                    1599              MOVE.B      D1,D3               ; Move byte value from D1 into D3
00001D86  C67C 0007               1600              AND         #$07,D3             ; AND by 7 for EA subroutine
00001D8A  4EB9 00002EF6           1601              JSR         printEA             ; Determines remained operand EA info to print
00001D90                          1602              
00001D90  43F9 00003CCF           1603              LEA         newLine,A1          ; Print new line for next instruction
00001D96  103C 000E               1604              MOVE.B      #14,D0              ; Use trap 14 to output to console
00001D9A  4E4F                    1605              TRAP        #15                 ; Halt for IO
00001D9C                          1606              
00001D9C  6000 F2A2               1607              BRA         LOOP                ; Return to control loop
00001DA0                          1608              
00001DA0                          1609  opEORL                                      ; Long has been determined
00001DA0  43F9 00003D73           1610              LEA         dispLong,A1         ; Send out the long word info for the instruction
00001DA6  103C 000E               1611              MOVE.B      #14,D0              ; Utilize trap task 14
00001DAA  4E4F                    1612              TRAP        #15                 ; Halt for IO
00001DAC                          1613              
00001DAC  43F9 00003CD3           1614              LEA         space, A1           ; Display space
00001DB2  103C 000E               1615              MOVE.B      #14, D0             ; command for trap call to display message
00001DB6  4E4F                    1616              TRAP        #15                 ; trap call to halt
00001DB8                          1617              
00001DB8  4242                    1618              CLR         D2                  ; Clear D2 again for use
00001DBA  4243                    1619              CLR         D3                  ; Remove anything from D3
00001DBC  3601                    1620              MOVE.W      D1,D3               ; Move word to D3 to find an operand
00001DBE  E043                    1621              ASR         #eight,D3           ; Shift by eight to ensure correct portion of instruction
00001DC0  E243                    1622              ASR         #one,D3             ; Needs to be shifted by an additional 1
00001DC2  C67C 0007               1623              AND         #$07,D3             ; Clear extra bits 
00001DC6  4EB9 00002EF6           1624              JSR         printEA             ; Use EA subroutine to print operand
00001DCC                          1625              
00001DCC  43F9 00003CDA           1626              LEA         comma, A1           ; Display space
00001DD2  103C 000E               1627              MOVE.B      #14, D0             ; command for trap call to display message
00001DD6  4E4F                    1628              TRAP        #15                 ; trap call
00001DD8                          1629              
00001DD8  4242                    1630              CLR         D2                  ; Clear D2 again
00001DDA  4243                    1631              CLR         D3                  ; Clear D3 again
00001DDC  1401                    1632              MOVE.B      D1,D2               ; Move the byte value in D1 to D2 for EA use
00001DDE  E642                    1633              ASR         #three,D2           ; Shift by 3 to find EA info
00001DE0  C47C 0007               1634              AND         #seven,D2           ; AND by 7 to remove extra bits
00001DE4  1601                    1635              MOVE.B      D1,D3               ; Move byte value from D1 into D3
00001DE6  C67C 0007               1636              AND         #$07,D3             ; AND by 7 for EA subroutine
00001DEA  4EB9 00002EF6           1637              JSR         printEA             ; Determines remained operand EA info to print
00001DF0                          1638              
00001DF0  43F9 00003CCF           1639              LEA         newLine,A1          ; Print new line for next instruction
00001DF6  103C 000E               1640              MOVE.B      #14,D0              ; Use trap 14 to output to console
00001DFA  4E4F                    1641              TRAP        #15                 ; Halt for IO
00001DFC                          1642              
00001DFC  6000 F242               1643              BRA         LOOP                ; Return to the control loop
00001E00                          1644  
00001E00                          1645  ***********************************************************************************************************
00001E00                          1646  *
00001E00                          1647  *                   CMP OPCODE
00001E00                          1648  *
00001E00                          1649  *       This section is dedicated to the compare (CMP) instruction. Its determined in the control loop
00001E00                          1650  *       that the first nibble is 11 for CMP, and the second nibble is 3.
00001E00                          1651  *       The type of CMP, or the opmode, is used to determined what we output to our console next.
00001E00                          1652  *       From that point, we load the correct size/opmode, and then route to the EA subroutine to output
00001E00                          1653  *       EA related register information.
00001E00                          1654  *       The process for finding the operand register info (EA info) is similar for all opmodes.
00001E00                          1655  *
00001E00                          1656  ***********************************************************************************************************
00001E00                          1657  
00001E00                          1658  opCMP       
00001E00  43F9 00003D3C           1659              LEA         CMPmatch,A1         ; We determined that the opcode is CMP, output to console
00001E06  103C 000E               1660              MOVE.B      #14,D0              ; Getting trap task #14 ready
00001E0A  4E4F                    1661              TRAP        #15                 ; Trap 15 call for IO
00001E0C                          1662              
00001E0C  4242                    1663              CLR         D2                  ; D2 should be cleared for use later
00001E0E                          1664              
00001E0E  1401                    1665              MOVE.B      D1,D2               ; Get the next byte to manipulate
00001E10  EC42                    1666              ASR         #six,D2             ; Move bits 7 places over to find opmode
00001E12  C47C 0007               1667              AND         #$07,D2             ; AND by 7 allows us to compare properly on which opmode we need
00001E16  B43C 0000               1668              CMP.B       #zero,D2            ; Compare to zero to see if we have a byte
00001E1A  6700 0016               1669              BEQ         opCMPB              ; Byte in opmode
00001E1E  B43C 0001               1670              CMP.B       #one,D2             ; Compare to one to see if we have a word
00001E22  6700 0068               1671              BEQ         opCMPW              ; Word in opmode
00001E26  B43C 0002               1672              CMP.B       #two,D2             ; Compare to two to see if we have a long
00001E2A  6700 00BA               1673              BEQ         opCMPL              ; Long in opmode
00001E2E                          1674              
00001E2E  6000 1E34               1675              BRA         printInvalid        ; Incorrect input
00001E32                          1676  
00001E32                          1677  opCMPB                                      ; Known we have CMP.B, find and output operands
00001E32  43F9 00003D6D           1678              LEA         dispByte,A1         ; Output the byte component of the instruction
00001E38  103C 000E               1679              MOVE.B      #14,D0              ; Trap task #14 for console out
00001E3C  4E4F                    1680              TRAP        #15                 ; Halt for console out
00001E3E                          1681              
00001E3E  43F9 00003CD3           1682              LEA         space, A1           ; Display space for operands
00001E44  103C 000E               1683              MOVE.B      #14, D0             ; command for trap call to display message
00001E48  4E4F                    1684              TRAP        #15                 ; Console out/halt
00001E4A                          1685              
00001E4A  1401                    1686              MOVE.B      D1,D2               ; Move the byte for manipulation to D2
00001E4C  E642                    1687              ASR         #3,D2               ; Shift right by 3 to find left operand register
00001E4E  C47C 0007               1688              AND         #$07,D2             ; AND for comparison later
00001E52  1601                    1689              MOVE.B      D1,D3               ; Move the byte to D3 for use in our EA subroutine
00001E54  C67C 0007               1690              AND         #$07,D3             ; AND for comparison in subroutine
00001E58  4EB9 00002EF6           1691              JSR         printEA             ; Use our EA subroutine to determine the left operand register
00001E5E                          1692              
00001E5E  43F9 00003CDA           1693              LEA         comma, A1           ; Display space
00001E64  103C 000E               1694              MOVE.B      #14, D0             ; command for trap call to display message
00001E68  4E4F                    1695              TRAP        #15                 ; trap call
00001E6A                          1696              
00001E6A  4242                    1697              CLR         D2                  ; D2 needs to be cleared for use later
00001E6C  3601                    1698              MOVE.W      D1,D3               ; Move the entire word in D3 for shifting
00001E6E  E043                    1699              ASR         #eight,D3           ; Shift right by 8 to get EA bits from instruction
00001E70  E243                    1700              ASR         #one,D3             ; Shift right once more to move the bits all the way
00001E72  C67C 0007               1701              AND         #$07,D3             ; AND by 7 to clear unnecessary bits
00001E76  4EB9 00002EF6           1702              JSR         printEA             ; EA subroutine call to get remaining operand sent to the console
00001E7C                          1703              
00001E7C  43F9 00003CCF           1704              LEA         newLine,A1          ; Prime A1 with our new line to output
00001E82  103C 000E               1705              MOVE.B      #14,D0              ; Prime new line for next instruction
00001E86  4E4F                    1706              TRAP        #15                 ; Halt for IO
00001E88                          1707              
00001E88  6000 F1B6               1708              BRA         LOOP                ; Return to control loop for next disassembly
00001E8C                          1709              
00001E8C                          1710  opCMPW                                      ; Known we have CMP.W, find and output operands
00001E8C  43F9 00003D70           1711              LEA         dispWord,A1         ; Output the byte component of the instruction
00001E92  103C 000E               1712              MOVE.B      #14,D0              ; Trap task #14 for console out
00001E96  4E4F                    1713              TRAP        #15                 ; Halt for console out
00001E98                          1714              
00001E98  43F9 00003CD3           1715              LEA         space, A1           ; Display space for operands
00001E9E  103C 000E               1716              MOVE.B      #14, D0             ; command for trap call to display message
00001EA2  4E4F                    1717              TRAP        #15                 ; Console out/halt
00001EA4                          1718              
00001EA4  1401                    1719              MOVE.B      D1,D2               ; Move the byte for manipulation to D2
00001EA6  E642                    1720              ASR         #3,D2               ; Shift right by 3 to find left operand register
00001EA8  C47C 0007               1721              AND         #$07,D2             ; AND for comparison later
00001EAC  1601                    1722              MOVE.B      D1,D3               ; Move the byte to D3 for use in our EA subroutine
00001EAE  C67C 0007               1723              AND         #$07,D3             ; AND for comparison in subroutine
00001EB2  4EB9 00002EF6           1724              JSR         printEA             ; Use our EA subroutine to determine the left operand register
00001EB8                          1725              
00001EB8  43F9 00003CDA           1726              LEA         comma, A1           ; Display space
00001EBE  103C 000E               1727              MOVE.B      #14, D0             ; command for trap call to display message
00001EC2  4E4F                    1728              TRAP        #15                 ; trap call
00001EC4                          1729              
00001EC4  4242                    1730              CLR         D2                  ; D2 needs to be cleared for use later
00001EC6  3601                    1731              MOVE.W      D1,D3               ; Move the entire word in D3 for shifting
00001EC8  E043                    1732              ASR         #eight,D3           ; Shift right by 8 to get EA bits from instruction
00001ECA  E243                    1733              ASR         #one,D3             ; Shift right once more to move the bits all the way
00001ECC  C67C 0007               1734              AND         #$07,D3             ; AND by 7 to clear unnecessary bits
00001ED0  4EB9 00002EF6           1735              JSR         printEA             ; EA subroutine call to get remaining operand sent to the console
00001ED6                          1736              
00001ED6  43F9 00003CCF           1737              LEA         newLine,A1          ; Prime A1 with our new line to output
00001EDC  103C 000E               1738              MOVE.B      #14,D0              ; Prime new line for next instruction
00001EE0  4E4F                    1739              TRAP        #15                 ; Halt for IO
00001EE2                          1740              
00001EE2  6000 F15C               1741              BRA         LOOP                ; Return to control loop for next disassembly
00001EE6                          1742  
00001EE6                          1743  opCMPL                                      ; Known we have CMP.L, find and output operands
00001EE6  43F9 00003D73           1744              LEA         dispLong,A1         ; Output the byte component of the instruction
00001EEC  103C 000E               1745              MOVE.B      #14,D0              ; Trap task #14 for console out
00001EF0  4E4F                    1746              TRAP        #15                 ; Halt for console out
00001EF2                          1747              
00001EF2  43F9 00003CD3           1748              LEA         space, A1           ; Display space for operands
00001EF8  103C 000E               1749              MOVE.B      #14, D0             ; command for trap call to display message
00001EFC  4E4F                    1750              TRAP        #15                 ; Console out/halt
00001EFE                          1751              
00001EFE  1401                    1752              MOVE.B      D1,D2               ; Move the byte for manipulation to D2
00001F00  E642                    1753              ASR         #3,D2               ; Shift right by 3 to find left operand register
00001F02  C47C 0007               1754              AND         #$07,D2             ; AND for comparison later
00001F06  1601                    1755              MOVE.B      D1,D3               ; Move the byte to D3 for use in our EA subroutine
00001F08  C67C 0007               1756              AND         #$07,D3             ; AND for comparison in subroutine
00001F0C  4EB9 00002EF6           1757              JSR         printEA             ; Use our EA subroutine to determine the left operand register
00001F12                          1758              
00001F12  43F9 00003CDA           1759              LEA         comma, A1           ; Display space
00001F18  103C 000E               1760              MOVE.B      #14, D0             ; command for trap call to display message
00001F1C  4E4F                    1761              TRAP        #15                 ; trap call
00001F1E                          1762              
00001F1E  4242                    1763              CLR         D2                  ; D2 needs to be cleared for use later
00001F20  3601                    1764              MOVE.W      D1,D3               ; Move the entire word in D3 for shifting
00001F22  E043                    1765              ASR         #eight,D3           ; Shift right by 8 to get EA bits from instruction
00001F24  E243                    1766              ASR         #one,D3             ; Shift right once more to move the bits all the way
00001F26  C67C 0007               1767              AND         #$07,D3             ; AND by 7 to clear unnecessary bits
00001F2A  4EB9 00002EF6           1768              JSR         printEA             ; EA subroutine call to get remaining operand sent to the console
00001F30                          1769              
00001F30  43F9 00003CCF           1770              LEA         newLine,A1          ; Prime A1 with our new line to output
00001F36  103C 000E               1771              MOVE.B      #14,D0              ; Prime new line for next instruction
00001F3A  4E4F                    1772              TRAP        #15                 ; Halt for IO
00001F3C                          1773              
00001F3C  6000 F102               1774              BRA         LOOP                ; Return to control loop for next disassembly
00001F40                          1775  
00001F40                          1776  ***********************************************************************************************************
00001F40                          1777  *
00001F40                          1778  *                   SUB OPCODE
00001F40                          1779  *
00001F40                          1780  *       This section is dedicated to disassembling the SUB opcode. We assume that the first nibble being 9
00001F40                          1781  *       leads us to the SUB opcode.
00001F40                          1782  *       SUB is differed by a operand direction, that being Dn - EA or EA - Dn.
00001F40                          1783  *       These directions are deteremined as an opmode, and doubles up for each byte, long, and word mode.
00001F40                          1784  *
00001F40                          1785  ***********************************************************************************************************
00001F40                          1786  
00001F40                          1787  opSUB                                       ; We assume we found SUB, begin SUB disassemble
00001F40  43F9 00003D34           1788              LEA         SUBmatch, A1        ; Load A1 to print SUB found message
00001F46  103C 000E               1789              MOVE.B      #14, D0             ; command for trap call to display message
00001F4A  4E4F                    1790              TRAP        #15                 ; trap call to halt
00001F4C                          1791          
00001F4C                          1792          
00001F4C  E141                    1793              ASL         #eight,D1           ; Shift D1 to by 8 to find opmode
00001F4E  1218                    1794              MOVE.B      (A0)+,D1            ; Reload instruction
00001F50  4242                    1795              CLR         D2                  ; Ensure D2 is clear
00001F52                          1796              
00001F52  3401                    1797              MOVE.W      D1,D2               ; Load our word into D2 to manipulate
00001F54  EC42                    1798              ASR         #six,D2             ; Move bits 7 places over to find opmode
00001F56  C47C 0007               1799              AND         #seven,D2           ; AND by 7 to remove extra bits
00001F5A                          1800              
00001F5A                          1801              ; These are for Dn - EA
00001F5A  B43C 0000               1802              CMP.B       #zero,D2            ; Check for byte
00001F5E  6700 002A               1803              BEQ         opSUBB              ; Byte in opmode
00001F62  B43C 0001               1804              CMP.B       #one,D2             ; Check for word
00001F66  6700 007C               1805              BEQ         opSUBW              ; Word in opmode
00001F6A  B43C 0002               1806              CMP.B       #two,D2             ; Check for long
00001F6E  6700 00CE               1807              BEQ         opSUBL              ; Long in opmode
00001F72                          1808              
00001F72                          1809              ; These are for EA - Dn
00001F72  B43C 0004               1810              CMP.B       #four,D2            ; Check for byte
00001F76  6700 0012               1811              BEQ         opSUBB              ; Byte in opmode
00001F7A  B43C 0005               1812              CMP.B       #five,D2            ; Check for word
00001F7E  6700 0064               1813              BEQ         opSUBW              ; Word in opmode
00001F82  B43C 0006               1814              CMP.B       #six,D2             ; Check for long
00001F86  6700 00B6               1815              BEQ         opSUBL              ; Long in opmode
00001F8A                          1816              
00001F8A                          1817  opSUBB                                      ; Byte has been found, find operands
00001F8A  43F9 00003D6D           1818              LEA         dispByte,A1         ; Output the byte info to the console
00001F90  103C 000E               1819              MOVE.B      #14,D0              ; Use trap task 14 for IO
00001F94  4E4F                    1820              TRAP        #15                 ; Halt for IO
00001F96                          1821              
00001F96  43F9 00003CD3           1822              LEA         space, A1           ; Display space
00001F9C  103C 000E               1823              MOVE.B      #14, D0             ; command for trap call to display message
00001FA0  4E4F                    1824              TRAP        #15                 ; trap call         
00001FA2                          1825              
00001FA2  1401                    1826              MOVE.B      D1,D2               ; Load D2 with our D1 byte
00001FA4  E642                    1827              ASR         #3,D2               ; Shift by 3 to find an operand
00001FA6  C47C 0007               1828              AND         #$07,D2             ; AND by 7 to remove extra bits
00001FAA  3601                    1829              MOVE.W      D1,D3               ; Load D3 with our word in D1
00001FAC  C67C 0007               1830              AND         #$07,D3             ; AND by 7 to remove extra bits
00001FB0  4EB9 00002EF6           1831              JSR         printEA             ; Use EA subroutine to find an operand
00001FB6                          1832              
00001FB6  43F9 00003CDA           1833              LEA         comma, A1           ; Display space
00001FBC  103C 000E               1834              MOVE.B      #14, D0             ; command for trap call to display message
00001FC0  4E4F                    1835              TRAP        #15                 ; trap call
00001FC2                          1836              
00001FC2  4242                    1837              CLR         D2                  ; Empty D2 for use again
00001FC4  3601                    1838              MOVE.W      D1,D3               ; Load the word again into D3
00001FC6  E043                    1839              ASR         #eight,D3           ; Shift by 8 to find other operand
00001FC8  E243                    1840              ASR         #one,D3             ; Requires an additional shift
00001FCA  C67C 0007               1841              AND         #$07,D3             ; AND by 7 to remove extra bits
00001FCE  4EB9 00002EF6           1842              JSR         printEA             ; EA subroutine finds our remaining operand
00001FD4                          1843              
00001FD4  43F9 00003CCF           1844              LEA         newLine,A1          ; Ready console with newline
00001FDA  103C 000E               1845              MOVE.B      #14,D0              ; Trap 14 for output
00001FDE  4E4F                    1846              TRAP        #15                 ; Halt for IO
00001FE0                          1847              
00001FE0  6000 F05E               1848              BRA         LOOP                ; Return to control loop
00001FE4                          1849              
00001FE4                          1850  opSUBW                                      ; Word has been found, find operands
00001FE4  43F9 00003D70           1851              LEA         dispWord,A1         ; Output the word info to the console
00001FEA  103C 000E               1852              MOVE.B      #14,D0              ; Use trap task 14 for IO
00001FEE  4E4F                    1853              TRAP        #15                 ; Halt for IO
00001FF0                          1854              
00001FF0  43F9 00003CD3           1855              LEA         space, A1           ; Display space
00001FF6  103C 000E               1856              MOVE.B      #14, D0             ; command for trap call to display message
00001FFA  4E4F                    1857              TRAP        #15                 ; trap call         
00001FFC                          1858              
00001FFC  1401                    1859              MOVE.B      D1,D2               ; Load D2 with our D1 byte
00001FFE  E642                    1860              ASR         #3,D2               ; Shift by 3 to find an operand
00002000  C47C 0007               1861              AND         #$07,D2             ; AND by 7 to remove extra bits
00002004  3601                    1862              MOVE.W      D1,D3               ; Load D3 with our word in D1
00002006  C67C 0007               1863              AND         #$07,D3             ; AND by 7 to remove extra bits
0000200A  4EB9 00002EF6           1864              JSR         printEA             ; Use EA subroutine to find an operand
00002010                          1865              
00002010  43F9 00003CDA           1866              LEA         comma, A1           ; Display space
00002016  103C 000E               1867              MOVE.B      #14, D0             ; command for trap call to display message
0000201A  4E4F                    1868              TRAP        #15                 ; trap call
0000201C                          1869              
0000201C  4242                    1870              CLR         D2                  ; Empty D2 for use again
0000201E  3601                    1871              MOVE.W      D1,D3               ; Load the word again into D3
00002020  E043                    1872              ASR         #eight,D3           ; Shift by 8 to find other operand
00002022  E243                    1873              ASR         #one,D3             ; Requires an additional shift
00002024  C67C 0007               1874              AND         #$07,D3             ; AND by 7 to remove extra bits
00002028  4EB9 00002EF6           1875              JSR         printEA             ; EA subroutine finds our remaining operand
0000202E                          1876              
0000202E  43F9 00003CCF           1877              LEA         newLine,A1          ; Ready console with newline
00002034  103C 000E               1878              MOVE.B      #14,D0              ; Trap 14 for output
00002038  4E4F                    1879              TRAP        #15                 ; Halt for IO
0000203A                          1880              
0000203A  6000 F004               1881              BRA         LOOP                ; Return to control loop
0000203E                          1882              
0000203E                          1883  opSUBL                                      ; Long has been found, find operands
0000203E  43F9 00003D73           1884              LEA         dispLong,A1         ; Output the long info to the console
00002044  103C 000E               1885              MOVE.B      #14,D0              ; Use trap task 14 for IO
00002048  4E4F                    1886              TRAP        #15                 ; Halt for IO
0000204A                          1887              
0000204A  43F9 00003CD3           1888              LEA         space, A1           ; Display space
00002050  103C 000E               1889              MOVE.B      #14, D0             ; command for trap call to display message
00002054  4E4F                    1890              TRAP        #15                 ; trap call         
00002056                          1891              
00002056  1401                    1892              MOVE.B      D1,D2               ; Load D2 with our D1 byte
00002058  E642                    1893              ASR         #3,D2               ; Shift by 3 to find an operand
0000205A  C47C 0007               1894              AND         #$07,D2             ; AND by 7 to remove extra bits
0000205E  3601                    1895              MOVE.W      D1,D3               ; Load D3 with our word in D1
00002060  C67C 0007               1896              AND         #$07,D3             ; AND by 7 to remove extra bits
00002064  4EB9 00002EF6           1897              JSR         printEA             ; Use EA subroutine to find an operand
0000206A                          1898              
0000206A  43F9 00003CDA           1899              LEA         comma, A1           ; Display space
00002070  103C 000E               1900              MOVE.B      #14, D0             ; command for trap call to display message
00002074  4E4F                    1901              TRAP        #15                 ; trap call
00002076                          1902              
00002076  4242                    1903              CLR         D2                  ; Empty D2 for use again
00002078  3601                    1904              MOVE.W      D1,D3               ; Load the word again into D3
0000207A  E043                    1905              ASR         #eight,D3           ; Shift by 8 to find other operand
0000207C  E243                    1906              ASR         #one,D3             ; Requires an additional shift
0000207E  C67C 0007               1907              AND         #$07,D3             ; AND by 7 to remove extra bits
00002082  4EB9 00002EF6           1908              JSR         printEA             ; EA subroutine finds our remaining operand
00002088                          1909              
00002088  43F9 00003CCF           1910              LEA         newLine,A1          ; Ready console with newline
0000208E  103C 000E               1911              MOVE.B      #14,D0              ; Trap 14 for output
00002092  4E4F                    1912              TRAP        #15                 ; Halt for IO
00002094                          1913              
00002094  6000 EFAA               1914              BRA         LOOP                ; Return to control loop
00002098                          1915              
00002098                          1916  ***********************************************************************************************************
00002098                          1917  *
00002098                          1918  *                   BRA OPCODE
00002098                          1919  *       
00002098                          1920  *       This section is dedicated to the BRA opcode, which is determined by having six in the first
00002098                          1921  *       nibble of the instruction, and zero in the second nibble.
00002098                          1922  *
00002098                          1923  ***********************************************************************************************************
00002098                          1924              
00002098                          1925  opBRA       
00002098  43F9 00003D18           1926              LEA         BRAmatch, A1        ; we know that the opcode will be BRA, so load A1 to print message
0000209E  103C 000E               1927              MOVE.B      #14, D0             ; Prime trap task #14 for output
000020A2  4E4F                    1928              TRAP        #15                 ; trap call to output BRA
000020A4                          1929          
000020A4  4242                    1930              CLR         D2                  ; Data register to needs to be cleared for use again
000020A6  4243                    1931              CLR         D3                  ; Data register to needs to be cleared for use again
000020A8                          1932  
000020A8  43F9 00003CD3           1933              LEA         space,A1            ; output a space for the IO console
000020AE  103C 000E               1934              MOVE.B      #14,D0              ; Prime trap task #14 for the output
000020B2  4E4F                    1935              TRAP        #15                 ; Call trap #15 with number 14 for our IO
000020B4                          1936          
000020B4  143C 0007               1937              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
000020B8  1218                    1938              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
000020BA  4EB9 00002EF6           1939              JSR         printEA             ; this method handles the displacement hex values
000020C0                          1940          
000020C0  43F9 00003CCF           1941              LEA         newLine, A1         ; create new line for the IO console
000020C6  103C 000E               1942              MOVE.B      #14, D0             ; command for trap call to display message
000020CA  4E4F                    1943              TRAP        #15                 ; trap call ready console for next instruction
000020CC                          1944  
000020CC  6000 EF72               1945              BRA         LOOP                ; return back to our control loop to find next instruction
000020D0                          1946          
000020D0                          1947  ***********************************************************************************************************
000020D0                          1948  *
000020D0                          1949  *                   Bcc OPCODES
000020D0                          1950  *
000020D0                          1951  *       This section is dedicated to the conditional branching opcode. There are varying second nibble
000020D0                          1952  *       values, documented below, with the correspond cc code.
000020D0                          1953  *       BCC is similar to BRA, so we handle it in the same manner.
000020D0                          1954  *
000020D0                          1955  *       Supported cc condition codes:
000020D0                          1956  *           >Carry Clear        = CS        second nibble == 5
000020D0                          1957  *           >Overflow Set       = VC        second nibble == 8
000020D0                          1958  *           >Greater or EqualGE = GE        second nibble == 12
000020D0                          1959  *           >Less Than          = LT        second nibble == 13
000020D0                          1960  *
000020D0                          1961  ***********************************************************************************************************
000020D0                          1962  * CS Conition Code
000020D0                          1963  
000020D0                          1964  opBCS       
000020D0  43F9 00003D1C           1965              LEA         BCSmatch, A1        ; we know that the opcode will be BCS, so load A1 to print message
000020D6  103C 000E               1966              MOVE.B      #14, D0             ; command for trap call to display message
000020DA  4E4F                    1967              TRAP        #15                 ; trap call
000020DC                          1968          
000020DC  4242                    1969              CLR         D2                  ; Data register to needs to be cleared for use again
000020DE  4243                    1970              CLR         D3                  ; Data register to needs to be cleared for use again
000020E0                          1971  
000020E0  43F9 00003CD3           1972              LEA         space,A1            ; output a space for the IO console
000020E6  103C 000E               1973              MOVE.B      #14,D0              ; Prime trap task #14 for the output
000020EA  4E4F                    1974              TRAP        #15                 ; Call trap #15 with number 14 for our IO
000020EC                          1975          
000020EC  143C 0007               1976              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
000020F0  1218                    1977              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
000020F2  4EB9 00002EF6           1978              JSR         printEA             ; this method handles the displacement hex values
000020F8                          1979          
000020F8  43F9 00003CCF           1980              LEA         newLine, A1         ; create new line for the IO console
000020FE  103C 000E               1981              MOVE.B      #14, D0             ; command for trap call to display message
00002102  4E4F                    1982              TRAP        #15                 ; trap call ready console for next instruction
00002104                          1983              
00002104  6000 EF3A               1984              BRA         LOOP                ; return to the control loop for next instruction
00002108                          1985  
00002108                          1986  ***********************************************************************************************************
00002108                          1987  * VC Condition Code
00002108                          1988  
00002108                          1989  opBVC       
00002108  43F9 00003D20           1990              LEA         BVCmatch, A1        ; we know that the opcode will be BVC, so load A1 to print message
0000210E  103C 000E               1991              MOVE.B      #14, D0             ; command for trap call to display message
00002112  4E4F                    1992              TRAP        #15                 ; trap call
00002114                          1993          
00002114  4242                    1994              CLR         D2                  ; Data register to needs to be cleared for use again
00002116  4243                    1995              CLR         D3                  ; Data register to needs to be cleared for use again
00002118                          1996  
00002118  43F9 00003CD3           1997              LEA         space,A1            ; output a space for the IO console
0000211E  103C 000E               1998              MOVE.B      #14,D0              ; Prime trap task #14 for the output
00002122  4E4F                    1999              TRAP        #15                 ; Call trap #15 with number 14 for our IO
00002124                          2000          
00002124  143C 0007               2001              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
00002128  1218                    2002              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
0000212A  4EB9 00002EF6           2003              JSR         printEA             ; this method handles the displacement hex values
00002130                          2004          
00002130  43F9 00003CCF           2005              LEA         newLine, A1         ; create new line for the IO console
00002136  103C 000E               2006              MOVE.B      #14, D0             ; command for trap call to display message
0000213A  4E4F                    2007              TRAP        #15                 ; trap call ready console for next instruction
0000213C                          2008              
0000213C  6000 EF02               2009              BRA         LOOP                ; return to the control loop for next instruction
00002140                          2010  
00002140                          2011  ***********************************************************************************************************
00002140                          2012  * GE Conidtion Code     
00002140                          2013          
00002140                          2014  opBGE       
00002140  43F9 00003D24           2015              LEA         BGEmatch, A1        ; we know that the opcode will be BGE, so load A1 to print message
00002146  103C 000E               2016              MOVE.B      #14, D0             ; command for trap call to display message
0000214A  4E4F                    2017              TRAP        #15                 ; trap call
0000214C                          2018          
0000214C  4242                    2019              CLR         D2                  ; Data register to needs to be cleared for use again
0000214E  4243                    2020              CLR         D3                  ; Data register to needs to be cleared for use again
00002150                          2021  
00002150  43F9 00003CD3           2022              LEA         space,A1            ; output a space for the IO console
00002156  103C 000E               2023              MOVE.B      #14,D0              ; Prime trap task #14 for the output
0000215A  4E4F                    2024              TRAP        #15                 ; Call trap #15 with number 14 for our IO
0000215C                          2025          
0000215C  143C 0007               2026              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
00002160  1218                    2027              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
00002162  4EB9 00002EF6           2028              JSR         printEA             ; this method handles the displacement hex values
00002168                          2029          
00002168  43F9 00003CCF           2030              LEA         newLine, A1         ; create new line for the IO console
0000216E  103C 000E               2031              MOVE.B      #14, D0             ; command for trap call to display message
00002172  4E4F                    2032              TRAP        #15                 ; trap call ready console for next instruction
00002174                          2033              
00002174  6000 EECA               2034              BRA         LOOP                ; return to the control loop for next instruction
00002178                          2035  
00002178                          2036  ***********************************************************************************************************
00002178                          2037  * LT Conditions Code        
00002178                          2038          
00002178                          2039  opBLT   
00002178  43F9 00003D28           2040              LEA         BLTmatch, A1        ; we know that the opcode will be BLT, so load A1 to print message
0000217E  103C 000E               2041              MOVE.B      #14, D0             ; command for trap call to display message
00002182  4E4F                    2042              TRAP        #15                 ; trap call
00002184                          2043          
00002184  4242                    2044              CLR         D2                  ; Data register to needs to be cleared for use again
00002186  4243                    2045              CLR         D3                  ; Data register to needs to be cleared for use again
00002188                          2046  
00002188  43F9 00003CD3           2047              LEA         space,A1            ; output a space for the IO console
0000218E  103C 000E               2048              MOVE.B      #14,D0              ; Prime trap task #14 for the output
00002192  4E4F                    2049              TRAP        #15                 ; Call trap #15 with number 14 for our IO
00002194                          2050          
00002194  143C 0007               2051              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
00002198  1218                    2052              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
0000219A  4EB9 00002EF6           2053              JSR         printEA             ; this method handles the displacement hex values
000021A0                          2054          
000021A0  43F9 00003CCF           2055              LEA         newLine, A1         ; create new line for the IO console
000021A6  103C 000E               2056              MOVE.B      #14, D0             ; command for trap call to display message
000021AA  4E4F                    2057              TRAP        #15                 ; trap call ready console for next instruction
000021AC                          2058              
000021AC  6000 EE92               2059              BRA         LOOP                ; return to the control loop for next instruction
000021B0                          2060          
000021B0                          2061  ***********************************************************************************************************
000021B0                          2062  *
000021B0                          2063  *               SUBQ OPCODE
000021B0                          2064  *
000021B0                          2065  *       This section is for disassembling the SUBQ instruction, which is determined by a 5 in the first
000021B0                          2066  *       nibble.
000021B0                          2067  *       We assume there is only 1 opcode with 5 in the first nibble.
000021B0                          2068  *       SUBQ utilizes immediate data, so we use an alternate subroutine for operand output.
000021B0                          2069  *       The size field is used to branch to the subvariants of SUBQ, which we determine before hitting the
000021B0                          2070  *       final subroutines.
000021B0                          2071  *
000021B0                          2072  ***********************************************************************************************************
000021B0                          2073  
000021B0                          2074  opSUBQ                                      ; Assumed that we found SUBQ, begin disassemble
000021B0  43F9 00003D13           2075              LEA         SUBQmatch, A1       ; Send out SUBQ message
000021B6  103C 000E               2076              MOVE.B      #14, D0             ; command for trap call to display message
000021BA  4E4F                    2077              TRAP        #15                 ; trap call to halt
000021BC                          2078              
000021BC  E141                    2079              ASL         #eight,D1           ; Shift by 8 to find size bits
000021BE  1218                    2080              MOVE.B      (A0)+,D1            ; Reload D1
000021C0  1401                    2081              MOVE.B      D1,D2               ; Move data in D2 to alter later
000021C2  EE42                    2082              ASR         #seven,D2           ; Move bits 7 places over to find size
000021C4  C47C 0007               2083              AND         #$07,D2             ; AND by 7 to remove uneeded bits
000021C8                          2084              
000021C8                          2085              ; Find size bits
000021C8  B43C 0000               2086              CMP.B       #zero,D2            ; Check for a byte
000021CC  6700 0012               2087              BEQ         opSUBQB             ; Byte in size
000021D0  B43C 0001               2088              CMP.B       #one,D2             ; Check for a word
000021D4  6700 0020               2089              BEQ         opSUBQW             ; Word in size
000021D8  B43C 0002               2090              CMP.B       #two,D2             ; Check for a long
000021DC  6700 002E               2091              BEQ         opSUBQL             ; Long in size
000021E0                          2092              
000021E0                          2093  opSUBQB                                     ; Found a byte in size, prepare for JSR
000021E0  43F9 00003D6D           2094              LEA         dispByte,A1         ; Display the byte in the console
000021E6  103C 000E               2095              MOVE.B      #14,D0              ; Trap task 14 for IO
000021EA  4E4F                    2096              TRAP        #15                 ; Halt for IO
000021EC                          2097            
000021EC  4EB9 00002E1E           2098              JSR         PrntImm             ; Call immediate data subroutine to handle SUBQ operands
000021F2                          2099              
000021F2  6000 EE4C               2100              BRA         LOOP                ; Return to control loop
000021F6                          2101              
000021F6                          2102  opSUBQW                                     ; Found a word in size, prepare for JSR
000021F6  43F9 00003D70           2103              LEA         dispWord,A1         ; Display the word in the console
000021FC  103C 000E               2104              MOVE.B      #14,D0              ; Trap task 14 for IO
00002200  4E4F                    2105              TRAP        #15                 ; Halt for IO
00002202                          2106            
00002202  4EB9 00002E1E           2107              JSR         PrntImm             ; Call immediate data subroutine to handle SUBQ operands
00002208                          2108              
00002208  6000 EE36               2109              BRA         LOOP                ; Return to control loop
0000220C                          2110              
0000220C                          2111  opSUBQL                                     ; Found a long in size, prepare for JSR
0000220C  43F9 00003D73           2112              LEA         dispLong,A1         ; Display the long in the console
00002212  103C 000E               2113              MOVE.B      #14,D0              ; Trap task 14 for IO
00002216  4E4F                    2114              TRAP        #15                 ; Halt for IO
00002218                          2115            
00002218  4246                    2116              CLR         D6                  ; In the long size case, we need to ensure D6 is clear for the JSR call
0000221A  1C3C 0001               2117              MOVE.B      #1,D6               ; Needed to ensure proper immediate data is output to the console
0000221E                          2118            
0000221E  4EB9 00002E1E           2119              JSR         PrntImm             ; Call immediate data subroutine to handle SUBQ operands
00002224                          2120              
00002224  6000 EE1A               2121              BRA         LOOP                ; Return to control loop
00002228                          2122          
00002228                          2123  ***********************************************************************************************************
00002228                          2124  *
00002228                          2125  *                   MULS OPCODE
00002228                          2126  *
00002228                          2127  ***********************************************************************************************************
00002228                          2128  
00002228                          2129  opMULS  
00002228  43F9 00003D40           2130              LEA         MULSmatch, A1       ; we know that the opcode will be MULS, so load A1 to print message
0000222E  103C 000E               2131              MOVE.B      #14, D0             ; command for trap call to display message
00002232  4E4F                    2132              TRAP        #15                 ; trap call
00002234  43F9 00003CD3           2133              LEA         space, A1           ; create spaces
0000223A  103C 000E               2134              MOVE.B      #14, D0             ; command for trap call to display message
0000223E  4E4F                    2135              TRAP        #15                 ; trap call
00002240                          2136          
00002240  E141                    2137              ASL         #eight, D1          ; move D1 over by a byte
00002242  1218                    2138              MOVE.B      (A0)+, D1           ; copy the next byte into D1
00002244                          2139          
00002244  4242                    2140              CLR         D2                  ; clear D2
00002246  4243                    2141              CLR         D3                  ; clear D3
00002248  1401                    2142              MOVE.B      D1, D2              ; copy the byte from D1 to D2
0000224A  E642                    2143              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
0000224C  C47C 0007               2144              AND         #seven, D2          ; and D2 to get only first 3 bits
00002250  1601                    2145              MOVE.B      D1, D3              ; copy D1 byte to D3
00002252  C67C 0007               2146              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
00002256                          2147          
00002256  4EB9 00002EF6           2148              JSR         printEA             ; jump to printEA
0000225C                          2149          
0000225C  43F9 00003CDA           2150              LEA         comma, A1           ; create comma
00002262  103C 000E               2151              MOVE.B      #14, D0             ; command for trap call to display message
00002266  4E4F                    2152              TRAP        #15                 ; trap call
00002268                          2153  
00002268  4242                    2154              CLR         D2                  ; clear D2 since we know mode should be data register
0000226A  4243                    2155              CLR         D3                  ; clear D3
0000226C  3601                    2156              MOVE.W      D1, D3              ; Move D1 word to D3
0000226E  E043                    2157              ASR         #eight, D3          ; shift D3 by 8 bits
00002270  E243                    2158              ASR         #one, D3            ; shift D3 by 1 bit
00002272  C67C 0007               2159              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
00002276                          2160  
00002276  4EB9 00002EF6           2161              JSR         printEA             ; jump to printEA
0000227C                          2162          
0000227C  43F9 00003CCF           2163              LEA         newLine, A1         ; create new line
00002282  103C 000E               2164              MOVE.B      #14, D0             ; command for trap call to display message
00002286  4E4F                    2165              TRAP        #15                 ; trap call
00002288                          2166          
00002288  6000 EDB6               2167              BRA         LOOP                ; branch back to LOOP
0000228C                          2168  
0000228C                          2169  ***********************************************************************************************************
0000228C                          2170  *
0000228C                          2171  *                   ADD OPCODE
0000228C                          2172  *
0000228C                          2173  ***********************************************************************************************************   
0000228C                          2174  
0000228C                          2175  opADDB  
0000228C  43F9 00003D45           2176              LEA         ADDmatch, A1        ; we know that the opcode will be ADD, so load A1 to print message
00002292  103C 000E               2177              MOVE.B      #14, D0             ; command for trap call to display message
00002296  4E4F                    2178              TRAP        #15                 ; trap call
00002298                          2179          
00002298  43F9 00003D6D           2180              LEA         dispByte, A1        ; display byte
0000229E  103C 000E               2181              MOVE.B      #14, D0             ; command for trap call to display message
000022A2  4E4F                    2182              TRAP        #15                 ; trap call
000022A4  43F9 00003CD3           2183              LEA         space, A1           ; create spaces
000022AA  103C 000E               2184              MOVE.B      #14, D0             ; command for trap call to display message
000022AE  4E4F                    2185              TRAP        #15                 ; trap call
000022B0                          2186          
000022B0  4242                    2187              CLR         D2                  ; clear D2
000022B2  4243                    2188              CLR         D3                  ; clear D3
000022B4  1401                    2189              MOVE.B      D1, D2              ; copy the byte from D1 to D2
000022B6  E642                    2190              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
000022B8  C47C 0007               2191              AND         #seven, D2          ; and D2 to get only first 3 bits
000022BC  1601                    2192              MOVE.B      D1, D3              ; copy D1 byte to D3
000022BE  C67C 0007               2193              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
000022C2                          2194          
000022C2  4EB9 00002EF6           2195              JSR         printEA             ; jump to printEA
000022C8                          2196          
000022C8  43F9 00003CDA           2197              LEA         comma, A1           ; create comma
000022CE  103C 000E               2198              MOVE.B      #14, D0             ; command for trap call to display message
000022D2  4E4F                    2199              TRAP        #15                 ; trap call
000022D4                          2200  
000022D4  4242                    2201              CLR         D2                  ; clear D2 since we know mode should be data register
000022D6  4243                    2202              CLR         D3                  ; clear D3
000022D8  3601                    2203              MOVE.W      D1, D3              ; Move D1 word to D3
000022DA  E043                    2204              ASR         #eight, D3          ; shift D3 by 8 bits
000022DC  E243                    2205              ASR         #one, D3            ; shift D3 by 1 bit
000022DE  C67C 0007               2206              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
000022E2                          2207  
000022E2  4EB9 00002EF6           2208              JSR         printEA             ; jump to printEA
000022E8                          2209          
000022E8  43F9 00003CCF           2210              LEA         newLine, A1         ; create new line
000022EE  103C 000E               2211              MOVE.B      #14, D0             ; command for trap call to display message
000022F2  4E4F                    2212              TRAP        #15                 ; trap call
000022F4                          2213          
000022F4  6000 ED4A               2214              BRA         LOOP                ; branch back to LOOP
000022F8                          2215          
000022F8                          2216  opADDW  
000022F8  43F9 00003D45           2217              LEA         ADDmatch, A1        ; we know that the opcode will be ADD, so load A1 to print message
000022FE  103C 000E               2218              MOVE.B      #14, D0             ; command for trap call to display message
00002302  4E4F                    2219              TRAP        #15                 ; trap call
00002304                          2220  
00002304  43F9 00003D70           2221              LEA         dispWord, A1        ; display word
0000230A  103C 000E               2222              MOVE.B      #14, D0             ; command for trap call to display message
0000230E  4E4F                    2223              TRAP        #15                 ; trap call
00002310  43F9 00003CD3           2224              LEA         space, A1           ; create spaces
00002316  103C 000E               2225              MOVE.B      #14, D0             ; command for trap call to display message
0000231A  4E4F                    2226              TRAP        #15                 ; trap call
0000231C                          2227          
0000231C  4242                    2228              CLR         D2                  ; clear D2
0000231E  4243                    2229              CLR         D3                  ; clear D3
00002320  1401                    2230              MOVE.B      D1, D2              ; copy the byte from D1 to D2
00002322  E642                    2231              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
00002324  C47C 0007               2232              AND         #seven, D2          ; and D2 to get only first 3 bits
00002328  1601                    2233              MOVE.B      D1, D3              ; copy D1 byte to D3
0000232A  C67C 0007               2234              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
0000232E                          2235          
0000232E  4EB9 00002EF6           2236              JSR         printEA             ; jump to printEA
00002334                          2237          
00002334  43F9 00003CDA           2238              LEA         comma, A1           ; create comma
0000233A  103C 000E               2239              MOVE.B      #14, D0             ; command for trap call to display message
0000233E  4E4F                    2240              TRAP        #15                 ; trap call
00002340                          2241  
00002340  4242                    2242              CLR         D2                  ; clear D2 since we know mode should be data register
00002342  4243                    2243              CLR         D3                  ; clear D3
00002344  3601                    2244              MOVE.W      D1, D3              ; Move D1 word to D3
00002346  E043                    2245              ASR         #eight, D3          ; shift D3 by 8 bits
00002348  E243                    2246              ASR         #one, D3            ; shift D3 by 1 bit
0000234A  C67C 0007               2247              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
0000234E                          2248  
0000234E  4EB9 00002EF6           2249              JSR         printEA             ; jump to printEA
00002354                          2250          
00002354  43F9 00003CCF           2251              LEA         newLine, A1         ; create new line
0000235A  103C 000E               2252              MOVE.B      #14, D0             ; command for trap call to display message
0000235E  4E4F                    2253              TRAP        #15                 ; trap call
00002360                          2254          
00002360  6000 ECDE               2255              BRA         LOOP                ; branch back to LOOP
00002364                          2256          
00002364                          2257  opADDL  
00002364  43F9 00003D45           2258              LEA         ADDmatch, A1        ; we know that the opcode will be ADD, so load A1 to print message
0000236A  103C 000E               2259              MOVE.B      #14, D0             ; command for trap call to display message
0000236E  4E4F                    2260              TRAP        #15                 ; trap call
00002370                          2261          
00002370  43F9 00003D73           2262              LEA         dispLong, A1        ; display long
00002376  103C 000E               2263              MOVE.B      #14, D0             ; command for trap call to display message
0000237A  4E4F                    2264              TRAP        #15                 ; trap call
0000237C  43F9 00003CD3           2265              LEA         space, A1           ; create spaces
00002382  103C 000E               2266              MOVE.B      #14, D0             ; command for trap call to display message
00002386  4E4F                    2267              TRAP        #15                 ; trap call
00002388                          2268          
00002388  4242                    2269              CLR         D2                  ; clear D2
0000238A  4243                    2270              CLR         D3                  ; clear D3
0000238C  1401                    2271              MOVE.B      D1, D2              ; copy the byte from D1 to D2
0000238E  E642                    2272              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
00002390  C47C 0007               2273              AND         #seven, D2          ; and D2 to get only first 3 bits
00002394  1601                    2274              MOVE.B      D1, D3              ; copy D1 byte to D3
00002396  C67C 0007               2275              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
0000239A                          2276          
0000239A  4246                    2277              CLR         D6                  ; Clear D6
0000239C  1C3C 0001               2278              MOVE.B      #1, D6              ; move 1 to D6 in case source is printing immediate
000023A0                          2279          
000023A0  4EB9 00002EF6           2280              JSR         printEA             ; jump to printEA
000023A6  4246                    2281              CLR         D6                  ; clear D6
000023A8                          2282          
000023A8  43F9 00003CDA           2283              LEA         comma, A1           ; create comma
000023AE  103C 000E               2284              MOVE.B      #14, D0             ; command for trap call to display message
000023B2  4E4F                    2285              TRAP        #15                 ; trap call
000023B4                          2286  
000023B4  4242                    2287              CLR         D2                  ; clear D2 since we know mode should be data register
000023B6  4243                    2288              CLR         D3                  ; clear D3
000023B8  3601                    2289              MOVE.W      D1, D3              ; Move D1 word to D3
000023BA  E043                    2290              ASR         #eight, D3          ; shift D3 by 8 bits
000023BC  E243                    2291              ASR         #one, D3            ; shift D3 by 1 bit
000023BE  C67C 0007               2292              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
000023C2                          2293  
000023C2  4EB9 00002EF6           2294              JSR         printEA             ; jump to printEA
000023C8                          2295          
000023C8  43F9 00003CCF           2296              LEA         newLine, A1         ; create new line
000023CE  103C 000E               2297              MOVE.B      #14, D0             ; command for trap call to display message
000023D2  4E4F                    2298              TRAP        #15                 ; trap call
000023D4                          2299          
000023D4  6000 EC6A               2300              BRA         LOOP                ; branch back to LOOP
000023D8                          2301  
000023D8                          2302  ***********************************************************************************************************
000023D8                          2303  *
000023D8                          2304  *                   ADDA OPCODE
000023D8                          2305  *
000023D8                          2306  *********************************************************************************************************** 
000023D8                          2307  
000023D8                          2308  opADDAW 
000023D8  43F9 00003D49           2309              LEA         ADDAmatch, A1       ; we know that the opcode will be ADDA, so load A1 to print message
000023DE  103C 000E               2310              MOVE.B      #14, D0             ; command for trap call to display message
000023E2  4E4F                    2311              TRAP        #15                 ; trap call
000023E4                          2312          
000023E4  43F9 00003D70           2313              LEA         dispWord, A1        ; display word
000023EA  103C 000E               2314              MOVE.B      #14, D0             ; command for trap call to display message
000023EE  4E4F                    2315              TRAP        #15                 ; trap call
000023F0  43F9 00003CD3           2316              LEA         space, A1           ; create spaces
000023F6  103C 000E               2317              MOVE.B      #14, D0             ; command for trap call to display message
000023FA  4E4F                    2318              TRAP        #15                 ; trap call
000023FC                          2319          
000023FC  4242                    2320              CLR         D2                  ; clear D2
000023FE  4243                    2321              CLR         D3                  ; clear D3
00002400  1401                    2322              MOVE.B      D1, D2              ; copy the byte from D1 to D2
00002402  E642                    2323              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
00002404  C47C 0007               2324              AND         #seven, D2          ; and D2 to get only first 3 bits
00002408  1601                    2325              MOVE.B      D1, D3              ; copy D1 byte to D3
0000240A  C67C 0007               2326              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
0000240E                          2327          
0000240E  4EB9 00002EF6           2328              JSR         printEA             ; jump to printEA 
00002414                          2329          
00002414  43F9 00003CDA           2330              LEA         comma, A1           ; create comma
0000241A  103C 000E               2331              MOVE.B      #14, D0             ; command for trap call to display message
0000241E  4E4F                    2332              TRAP        #15                 ; trap call
00002420                          2333  
00002420  4242                    2334              CLR         D2                  ; clear D2 since we know mode should be data register
00002422  4243                    2335              CLR         D3                  ; clear D3
00002424  143C 0001               2336              MOVE.B      #one, D2            ; move 1 to D2 since mode should be address
00002428  3601                    2337              MOVE.W      D1, D3              ; Move D1 word to D3
0000242A  E043                    2338              ASR         #eight, D3          ; shift D3 by 8 bits
0000242C  E243                    2339              ASR         #one, D3            ; shift D3 by 1 bit
0000242E  C67C 0007               2340              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
00002432                          2341  
00002432  4EB9 00002EF6           2342              JSR         printEA             ; jump to printEA
00002438                          2343          
00002438  43F9 00003CCF           2344              LEA         newLine, A1         ; create new line
0000243E  103C 000E               2345              MOVE.B      #14, D0             ; command for trap call to display message
00002442  4E4F                    2346              TRAP        #15                 ; trap call
00002444                          2347          
00002444  6000 EBFA               2348              BRA         LOOP                ; branch back to LOOP
00002448                          2349  
00002448                          2350  opADDAL 
00002448  43F9 00003D49           2351              LEA         ADDAmatch, A1       ; we know that the opcode will be ADDA, so load A1 to print message
0000244E  103C 000E               2352              MOVE.B      #14, D0             ; command for trap call to display message
00002452  4E4F                    2353              TRAP        #15                 ; trap call
00002454                          2354  
00002454  43F9 00003D73           2355              LEA         dispLong, A1        ; display long
0000245A  103C 000E               2356              MOVE.B      #14, D0             ; command for trap call to display message
0000245E  4E4F                    2357              TRAP        #15                 ; trap call
00002460  43F9 00003CD3           2358              LEA         space, A1           ; create spaces
00002466  103C 000E               2359              MOVE.B      #14, D0             ; command for trap call to display message
0000246A  4E4F                    2360              TRAP        #15                 ; trap call
0000246C                          2361          
0000246C  4242                    2362              CLR         D2                  ; clear D2
0000246E  4243                    2363              CLR         D3                  ; clear D3
00002470  1401                    2364              MOVE.B      D1, D2              ; copy the byte from D1 to D2
00002472  E642                    2365              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
00002474  C47C 0007               2366              AND         #seven, D2          ; and D2 to get only first 3 bits
00002478  1601                    2367              MOVE.B      D1, D3              ; copy D1 byte to D3
0000247A  C67C 0007               2368              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
0000247E                          2369          
0000247E  4EB9 00002EF6           2370              JSR         printEA             ; jump to printEA 
00002484                          2371          
00002484  43F9 00003CDA           2372              LEA         comma, A1           ; create comma
0000248A  103C 000E               2373              MOVE.B      #14, D0             ; command for trap call to display message
0000248E  4E4F                    2374              TRAP        #15                 ; trap call
00002490                          2375  
00002490  4242                    2376              CLR         D2                  ; clear D2 since we know mode should be data register
00002492  4243                    2377              CLR         D3                  ; clear D3
00002494  143C 0001               2378              MOVE.B      #one, D2            ; move 1 to D2 since mode should be address
00002498  3601                    2379              MOVE.W      D1, D3              ; Move D1 word to D3
0000249A  E043                    2380              ASR         #eight, D3          ; shift D3 by 8 bits
0000249C  E243                    2381              ASR         #one, D3            ; shift D3 by 1 bit
0000249E  C67C 0007               2382              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
000024A2                          2383  
000024A2  4EB9 00002EF6           2384              JSR         printEA             ; jump to printEA
000024A8                          2385          
000024A8  43F9 00003CCF           2386              LEA         newLine, A1         ; create new line
000024AE  103C 000E               2387              MOVE.B      #14, D0             ; command for trap call to display message
000024B2  4E4F                    2388              TRAP        #15                 ; trap call
000024B4                          2389          
000024B4  6000 EB8A               2390              BRA         LOOP                ; branch back to LOOP
000024B8                          2391          
000024B8                          2392  ***********************************************************************************************************
000024B8                          2393  *
000024B8                          2394  *                       Shifting OPCODES
000024B8                          2395  *
000024B8                          2396  ***********************************************************************************************************
000024B8                          2397  
000024B8                          2398  opASL       
000024B8  43F9 00003D5A           2399              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
000024BE  103C 000E               2400              MOVE.B      #14, D0             ; command for trap call to display message
000024C2  4E4F                    2401              TRAP        #15                 ; trap call
000024C4                          2402          
000024C4  43F9 00003D70           2403              LEA         dispWord, A1        ; display word
000024CA  103C 000E               2404              MOVE.B      #14, D0             ; command for trap call to display message
000024CE  4E4F                    2405              TRAP        #15                 ; trap call
000024D0                          2406          
000024D0  43F9 00003CD3           2407              LEA         space, A1           ; display space 
000024D6  103C 000E               2408              MOVE.B      #14, D0             ; command for trap call to display message
000024DA  4E4F                    2409              TRAP        #15                 ; trap call
000024DC                          2410          
000024DC  4242                    2411              CLR         D2                  ; clear D2
000024DE  4243                    2412              CLR         D3                  ; clear D3
000024E0  1401                    2413              MOVE.B      D1,D2               ; move byte from D1 to D2
000024E2  1601                    2414              MOVE.B      D1,D3               ; move byte from D1 to D3
000024E4                          2415          
000024E4  E602                    2416              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
000024E6  C47C 0007               2417              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
000024EA  C67C 0007               2418              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
000024EE                          2419          
000024EE  4EB9 00002EF6           2420              JSR         printEA             ; jump to printEA
000024F4                          2421          
000024F4  43F9 00003CCF           2422              LEA         newLine, A1         ; Display newLine
000024FA  103C 000E               2423              MOVE.B      #14, D0             ; command for trap call to display message
000024FE  4E4F                    2424              TRAP        #15                 ; trap call
00002500                          2425          
00002500  6000 EB3E               2426              BRA         LOOP                ; branch back to LOOP
00002504                          2427  
00002504                          2428  opASR   
00002504  43F9 00003D56           2429              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
0000250A  103C 000E               2430              MOVE.B      #14, D0             ; command for trap call to display message
0000250E  4E4F                    2431              TRAP        #15                 ; trap call
00002510                          2432          
00002510  43F9 00003D70           2433              LEA         dispWord, A1        ; display word
00002516  103C 000E               2434              MOVE.B      #14, D0             ; command for trap call to display message
0000251A  4E4F                    2435              TRAP        #15                 ; trap call
0000251C                          2436          
0000251C  43F9 00003CD3           2437              LEA         space, A1           ; display space 
00002522  103C 000E               2438              MOVE.B      #14, D0             ; command for trap call to display message
00002526  4E4F                    2439              TRAP        #15                 ; trap call
00002528                          2440          
00002528  4242                    2441              CLR         D2                  ; clear D2
0000252A  4243                    2442              CLR         D3                  ; clear D3
0000252C  1401                    2443              MOVE.B      D1,D2               ; move byte from D1 to D2
0000252E  1601                    2444              MOVE.B      D1,D3               ; move byte from D1 to D3
00002530                          2445          
00002530  E602                    2446              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
00002532  C47C 0007               2447              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
00002536  C67C 0007               2448              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
0000253A                          2449          
0000253A  4EB9 00002EF6           2450              JSR         printEA             ; jump to printEA
00002540                          2451          
00002540  43F9 00003CCF           2452              LEA         newLine, A1         ; Display newLine
00002546  103C 000E               2453              MOVE.B      #14, D0             ; command for trap call to display message
0000254A  4E4F                    2454              TRAP        #15                 ; trap call
0000254C                          2455          
0000254C  6000 EAF2               2456              BRA         LOOP                ; branch back to LOOP
00002550                          2457  
00002550                          2458  opLSL       
00002550  43F9 00003D52           2459              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002556  103C 000E               2460              MOVE.B      #14, D0             ; command for trap call to display message
0000255A  4E4F                    2461              TRAP        #15                 ; trap call
0000255C                          2462              
0000255C  43F9 00003D70           2463              LEA         dispWord, A1        ; display word
00002562  103C 000E               2464              MOVE.B      #14, D0             ; command for trap call to display message
00002566  4E4F                    2465              TRAP        #15                 ; trap call
00002568                          2466          
00002568  43F9 00003CD3           2467              LEA         space, A1           ; display space 
0000256E  103C 000E               2468              MOVE.B      #14, D0             ; command for trap call to display message
00002572  4E4F                    2469              TRAP        #15                 ; trap call
00002574                          2470          
00002574  4242                    2471              CLR         D2                  ; clear D2
00002576  4243                    2472              CLR         D3                  ; clear D3
00002578  1401                    2473              MOVE.B      D1,D2               ; move byte from D1 to D2
0000257A  1601                    2474              MOVE.B      D1,D3               ; move byte from D1 to D3
0000257C                          2475          
0000257C  E602                    2476              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
0000257E  C47C 0007               2477              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
00002582  C67C 0007               2478              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
00002586                          2479          
00002586  4EB9 00002EF6           2480              JSR         printEA             ; jump to printEA
0000258C                          2481          
0000258C  43F9 00003CCF           2482              LEA         newLine, A1         ; Display newLine
00002592  103C 000E               2483              MOVE.B      #14, D0             ; command for trap call to display message
00002596  4E4F                    2484              TRAP        #15                 ; trap call
00002598                          2485          
00002598  6000 EAA6               2486              BRA         LOOP                ; branch back to LOOP
0000259C                          2487  
0000259C                          2488  opLSR   
0000259C  43F9 00003D4E           2489              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
000025A2  103C 000E               2490              MOVE.B      #14, D0             ; command for trap call to display message
000025A6  4E4F                    2491              TRAP        #15                 ; trap call
000025A8                          2492          
000025A8  43F9 00003D70           2493              LEA         dispWord, A1        ; display word
000025AE  103C 000E               2494              MOVE.B      #14, D0             ; command for trap call to display message
000025B2  4E4F                    2495              TRAP        #15                 ; trap call
000025B4                          2496          
000025B4  43F9 00003CD3           2497              LEA         space, A1           ; display space 
000025BA  103C 000E               2498              MOVE.B      #14, D0             ; command for trap call to display message
000025BE  4E4F                    2499              TRAP        #15                 ; trap call
000025C0                          2500          
000025C0  4242                    2501              CLR         D2                  ; clear D2
000025C2  4243                    2502              CLR         D3                  ; clear D3
000025C4  1401                    2503              MOVE.B      D1,D2               ; move byte from D1 to D2
000025C6  1601                    2504              MOVE.B      D1,D3               ; move byte from D1 to D3
000025C8                          2505          
000025C8  E602                    2506              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
000025CA  C47C 0007               2507              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
000025CE  C67C 0007               2508              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
000025D2                          2509          
000025D2  4EB9 00002EF6           2510              JSR         printEA             ; jump to printEA
000025D8                          2511          
000025D8  43F9 00003CCF           2512              LEA         newLine, A1         ; Display newLine
000025DE  103C 000E               2513              MOVE.B      #14, D0             ; command for trap call to display message
000025E2  4E4F                    2514              TRAP        #15                 ; trap call
000025E4                          2515          
000025E4  6000 EA5A               2516              BRA         LOOP                ; branch back to LOOP
000025E8                          2517  
000025E8                          2518  opROL   
000025E8  43F9 00003D62           2519              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
000025EE  103C 000E               2520              MOVE.B      #14, D0             ; command for trap call to display message
000025F2  4E4F                    2521              TRAP        #15                 ; trap call
000025F4                          2522          
000025F4  43F9 00003D70           2523              LEA         dispWord, A1        ; display word
000025FA  103C 000E               2524              MOVE.B      #14, D0             ; command for trap call to display message
000025FE  4E4F                    2525              TRAP        #15                 ; trap call
00002600                          2526          
00002600  43F9 00003CD3           2527              LEA         space, A1           ; display space 
00002606  103C 000E               2528              MOVE.B      #14, D0             ; command for trap call to display message
0000260A  4E4F                    2529              TRAP        #15                 ; trap call
0000260C                          2530          
0000260C  4242                    2531              CLR         D2                  ; clear D2
0000260E  4243                    2532              CLR         D3                  ; clear D3
00002610  1401                    2533              MOVE.B      D1,D2               ; move byte from D1 to D2
00002612  1601                    2534              MOVE.B      D1,D3               ; move byte from D1 to D3
00002614                          2535          
00002614  E602                    2536              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
00002616  C47C 0007               2537              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
0000261A  C67C 0007               2538              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
0000261E                          2539          
0000261E  4EB9 00002EF6           2540              JSR         printEA             ; jump to printEA
00002624                          2541          
00002624  43F9 00003CCF           2542              LEA         newLine, A1         ; Display newLine
0000262A  103C 000E               2543              MOVE.B      #14, D0             ; command for trap call to display message
0000262E  4E4F                    2544              TRAP        #15                 ; trap call
00002630                          2545          
00002630  6000 EA0E               2546              BRA         LOOP                ; branch back to LOOP
00002634                          2547  
00002634                          2548  opROR   
00002634  43F9 00003D5E           2549              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
0000263A  103C 000E               2550              MOVE.B      #14, D0             ; command for trap call to display message
0000263E  4E4F                    2551              TRAP        #15                 ; trap call
00002640                          2552          
00002640  43F9 00003D70           2553              LEA         dispWord, A1        ; display word
00002646  103C 000E               2554              MOVE.B      #14, D0             ; command for trap call to display message
0000264A  4E4F                    2555              TRAP        #15                 ; trap call
0000264C                          2556          
0000264C  43F9 00003CD3           2557              LEA         space, A1           ; display space 
00002652  103C 000E               2558              MOVE.B      #14, D0             ; command for trap call to display message
00002656  4E4F                    2559              TRAP        #15                 ; trap call
00002658                          2560          
00002658  4242                    2561              CLR         D2                  ; clear D2
0000265A  4243                    2562              CLR         D3                  ; clear D3
0000265C  1401                    2563              MOVE.B      D1,D2               ; move byte from D1 to D2
0000265E  1601                    2564              MOVE.B      D1,D3               ; move byte from D1 to D3
00002660                          2565          
00002660  E602                    2566              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
00002662  C47C 0007               2567              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
00002666  C67C 0007               2568              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
0000266A                          2569          
0000266A  4EB9 00002EF6           2570              JSR         printEA             ; jump to printEA
00002670                          2571          
00002670  43F9 00003CCF           2572              LEA         newLine, A1         ; Display newLine
00002676  103C 000E               2573              MOVE.B      #14, D0             ; command for trap call to display message
0000267A  4E4F                    2574              TRAP        #15                 ; trap call
0000267C                          2575          
0000267C  6000 E9C2               2576              BRA         LOOP                ; branch back to LOOP
00002680                          2577          
00002680                          2578  memSB       
00002680  4242                    2579              CLR         D2                  ; clear D2
00002682  1401                    2580              MOVE.B      D1,D2               ; move D1 to D2
00002684  E642                    2581              ASR         #three, D2          ; shift D2 by 3 bits to get i/r
00002686                          2582              
00002686  C47C 0007               2583              AND         #$07, D2            ; and D2 by 3 bits 
0000268A                          2584          
0000268A  B43C 0000               2585              CMP.B       #zero, D2           ; compare 0 to D2
0000268E  6700 002E               2586              BEQ         opASBI              ; if true, branch to ASBI for immediate
00002692  B43C 0004               2587              CMP.B       #four, D2           ; compare 4 to D2 
00002696  6700 0088               2588              BEQ         opASBR              ; if true, branch to ASBR for register
0000269A  B43C 0001               2589              CMP.B       #one, D2            ; compare 1 to D2
0000269E  6700 00E2               2590              BEQ         opLSBI              ; if true, branch to LSBI for immediate
000026A2  B43C 0005               2591              CMP.B       #five, D2           ; compare 5 to D2
000026A6  6700 013C               2592              BEQ         opLSBR              ; if true, branch to LSBR for register
000026AA  B43C 0003               2593              CMP.B       #three, D2          ; compare 3 to D2
000026AE  6700 0196               2594              BEQ         opROBI              ; if true, branch to ROBI for immediate
000026B2  B43C 0007               2595              CMP.B       #seven, D2          ; compare 7 to D2
000026B6  6700 01F0               2596              BEQ         opROBR              ; if true, branch to ROBR for register
000026BA  6000 15A8               2597              BRA         printInvalid        ; otherwise invalid
000026BE                          2598          
000026BE                          2599  opASBI  
000026BE  4242                    2600              CLR         D2                  ; clear D2
000026C0  3401                    2601              MOVE.W      D1, D2              ; move word from D1 to D2
000026C2  E042                    2602              ASR         #eight, D2          ; shift D2 over by 8 bits 
000026C4  C47C 0001               2603              AND         #$01, D2            ; and D2 by 1 bit to get direction
000026C8                          2604      
000026C8  B43C 0000               2605              CMP.B       #zero, D2           ; compare 0 to D2
000026CC  6700 000E               2606              BEQ         opASRBI             ; if true, branch to ASRBI for right
000026D0  B43C 0001               2607              CMP.B       #one, D2            ; compare 1 to D2
000026D4  6700 0028               2608              BEQ         opASLBI             ; if true, branch to ASLBI for left
000026D8  6000 158A               2609              BRA         printInvalid        ; otherwise invalid
000026DC                          2610          
000026DC                          2611  opASRBI 
000026DC  43F9 00003D56           2612              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000026E2  103C 000E               2613              MOVE.B      #14, D0             ; command for trap call to display message
000026E6  4E4F                    2614              TRAP        #15                 ; trap call
000026E8                          2615  
000026E8  43F9 00003D6D           2616              LEA         dispByte, A1        ; display byte
000026EE  103C 000E               2617              MOVE.B      #14, D0             ; command for trap call to display message
000026F2  4E4F                    2618              TRAP        #15                 ; trap call
000026F4                          2619          
000026F4  4EB9 00002E1E           2620              JSR         PrntImm             ; jump to PrntImm
000026FA                          2621          
000026FA  6000 E944               2622              BRA         LOOP                ; branch back to LOOP
000026FE                          2623  
000026FE                          2624  opASLBI 
000026FE  43F9 00003D5A           2625              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
00002704  103C 000E               2626              MOVE.B      #14, D0             ; command for trap call to display message
00002708  4E4F                    2627              TRAP        #15                 ; trap call
0000270A                          2628  
0000270A  43F9 00003D6D           2629              LEA         dispByte, A1        ; display byte
00002710  103C 000E               2630              MOVE.B      #14, D0             ; command for trap call to display message
00002714  4E4F                    2631              TRAP        #15                 ; trap call
00002716                          2632          
00002716  4EB9 00002E1E           2633              JSR         PrntImm             ; jump to PrntImm
0000271C                          2634          
0000271C  6000 E922               2635              BRA         LOOP                ; branch back to LOOP
00002720                          2636  
00002720                          2637  opASBR  
00002720  4242                    2638              CLR         D2                  ; clear D2
00002722  3401                    2639              MOVE.W      D1, D2              ; move word from D1 to D2
00002724  E042                    2640              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002726  C47C 0001               2641              AND         #$01, D2            ; and D2 by 1 bit to get direction
0000272A                          2642      
0000272A  B43C 0000               2643              CMP.B       #zero, D2           ; compare 0 to D2 
0000272E  6700 000E               2644              BEQ         opASRBR             ; if true, branch to ASRBR for right
00002732  B43C 0001               2645              CMP.B       #one, D2            ; compare 1 to D2
00002736  6700 0028               2646              BEQ         opASLBR             ; if true, branch to ASLBR for left
0000273A  6000 1528               2647              BRA         printInvalid        ; otherwise invalid
0000273E                          2648          
0000273E                          2649  opASRBR 
0000273E  43F9 00003D56           2650              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002744  103C 000E               2651              MOVE.B      #14, D0             ; command for trap call to display message
00002748  4E4F                    2652              TRAP        #15                 ; trap call
0000274A                          2653  
0000274A  43F9 00003D6D           2654              LEA         dispByte, A1        ; display byte
00002750  103C 000E               2655              MOVE.B      #14, D0             ; command for trap call to display message
00002754  4E4F                    2656              TRAP        #15                 ; trap call
00002756                          2657          
00002756  4EB9 00002E7A           2658              JSR         PrntReg             ; jump to PrntReg
0000275C                          2659          
0000275C  6000 E8E2               2660              BRA         LOOP                ; branch back to LOOP
00002760                          2661  
00002760                          2662  opASLBR 
00002760  43F9 00003D5A           2663              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
00002766  103C 000E               2664              MOVE.B      #14, D0             ; command for trap call to display message
0000276A  4E4F                    2665              TRAP        #15                 ; trap call
0000276C                          2666  
0000276C  43F9 00003D6D           2667              LEA         dispByte, A1        ; display byte
00002772  103C 000E               2668              MOVE.B      #14, D0             ; command for trap call to display message
00002776  4E4F                    2669              TRAP        #15                 ; trap call
00002778                          2670          
00002778  4EB9 00002E7A           2671              JSR         PrntReg             ; jump to PrntReg
0000277E                          2672          
0000277E  6000 E8C0               2673              BRA         LOOP                ; branch back to LOOP
00002782                          2674  
00002782                          2675  opLSBI      
00002782  4242                    2676              CLR         D2                  ; clear D2
00002784  3401                    2677              MOVE.W      D1, D2              ; move word from D1 to D2
00002786  E042                    2678              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002788  C47C 0001               2679              AND         #$01, D2            ; and D2 by 1 bit to get direction
0000278C                          2680      
0000278C  B43C 0000               2681              CMP.B       #zero, D2           ; compare 0 to D2 
00002790  6700 000E               2682              BEQ         opLSRBI             ; if true, branch to LSRBI for right
00002794  B43C 0001               2683              CMP.B       #one, D2            ; compare 1 to D2
00002798  6700 0028               2684              BEQ         opLSLBI             ; if true, branch to LSLBI for left
0000279C  6000 14C6               2685              BRA         printInvalid        ; otherwise invalid
000027A0                          2686          
000027A0                          2687  opLSRBI 
000027A0  43F9 00003D4E           2688              LEA         LSRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000027A6  103C 000E               2689              MOVE.B      #14, D0             ; command for trap call to display message
000027AA  4E4F                    2690              TRAP        #15                 ; trap call
000027AC                          2691  
000027AC  43F9 00003D6D           2692              LEA         dispByte, A1        ; display byte
000027B2  103C 000E               2693              MOVE.B      #14, D0             ; command for trap call to display message
000027B6  4E4F                    2694              TRAP        #15                 ; trap call
000027B8                          2695          
000027B8  4EB9 00002E1E           2696              JSR         PrntImm             ; jump to PrntImm
000027BE                          2697          
000027BE  6000 E880               2698              BRA         LOOP                ; branch back to LOOP
000027C2                          2699              
000027C2                          2700  opLSLBI     
000027C2  43F9 00003D52           2701              LEA         LSLmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000027C8  103C 000E               2702              MOVE.B      #14, D0             ; command for trap call to display message
000027CC  4E4F                    2703              TRAP        #15                 ; trap call
000027CE                          2704  
000027CE  43F9 00003D6D           2705              LEA         dispByte, A1        ; display byte
000027D4  103C 000E               2706              MOVE.B      #14, D0             ; command for trap call to display message
000027D8  4E4F                    2707              TRAP        #15                 ; trap call
000027DA                          2708          
000027DA  4EB9 00002E1E           2709              JSR         PrntImm             ; jump to PrntImm
000027E0                          2710          
000027E0  6000 E85E               2711              BRA         LOOP                ; branch back to LOOP
000027E4                          2712  
000027E4                          2713  opLSBR  
000027E4  4242                    2714              CLR         D2                  ; clear D2
000027E6  3401                    2715              MOVE.W      D1, D2              ; move word from D1 to D2
000027E8  E042                    2716              ASR         #eight, D2          ; shift D2 over by 8 bits 
000027EA  C47C 0001               2717              AND         #$01, D2            ; and D2 by 1 bit to get direction
000027EE                          2718      
000027EE  B43C 0000               2719              CMP.B       #zero, D2           ; compare 0 to D2 
000027F2  6700 000E               2720              BEQ         opLSRBR             ; if true, branch to LSRBR for right
000027F6  B43C 0001               2721              CMP.B       #one, D2            ; compare 1 to D2
000027FA  6700 0028               2722              BEQ         opLSLBR             ; if true, branch to LSLBR for left
000027FE  6000 1464               2723              BRA         printInvalid        ; otherwise invalid
00002802                          2724          
00002802                          2725  opLSRBR 
00002802  43F9 00003D4E           2726              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002808  103C 000E               2727              MOVE.B      #14, D0             ; command for trap call to display message
0000280C  4E4F                    2728              TRAP        #15                 ; trap call
0000280E                          2729  
0000280E  43F9 00003D6D           2730              LEA         dispByte, A1        ; display byte
00002814  103C 000E               2731              MOVE.B      #14, D0             ; command for trap call to display message
00002818  4E4F                    2732              TRAP        #15                 ; trap call
0000281A                          2733          
0000281A  4EB9 00002E7A           2734              JSR         PrntReg             ; jump to PrntReg
00002820                          2735          
00002820  6000 E81E               2736              BRA         LOOP                ; branch back to LOOP
00002824                          2737          
00002824                          2738  opLSLBR     
00002824  43F9 00003D52           2739              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
0000282A  103C 000E               2740              MOVE.B      #14, D0             ; command for trap call to display message
0000282E  4E4F                    2741              TRAP        #15                 ; trap call
00002830                          2742  
00002830  43F9 00003D6D           2743              LEA         dispByte, A1        ; display byte
00002836  103C 000E               2744              MOVE.B      #14, D0             ; command for trap call to display message
0000283A  4E4F                    2745              TRAP        #15                 ; trap call
0000283C                          2746          
0000283C  4EB9 00002E7A           2747              JSR         PrntReg             ; jump to PrntReg
00002842                          2748          
00002842  6000 E7FC               2749              BRA         LOOP                ; branch back to LOOP
00002846                          2750              
00002846                          2751  opROBI  
00002846  4242                    2752              CLR         D2                  ; clear D2
00002848  3401                    2753              MOVE.W      D1, D2              ; move word from D1 to D2
0000284A  E042                    2754              ASR         #eight, D2          ; shift D2 over by 8 bits 
0000284C  C47C 0001               2755              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002850                          2756      
00002850  B43C 0000               2757              CMP.B       #zero, D2           ; compare 0 to D2
00002854  6700 000E               2758              BEQ         opRORBI             ; if true, branch to RORBI for right
00002858  B43C 0001               2759              CMP.B       #one, D2            ; compare 1 to D2
0000285C  6700 0028               2760              BEQ         opROLBI             ; if true, branch to ROLBI for left
00002860  6000 1402               2761              BRA         printInvalid        ; otherwise invalid
00002864                          2762          
00002864                          2763  opRORBI 
00002864  43F9 00003D5E           2764              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
0000286A  103C 000E               2765              MOVE.B      #14, D0             ; command for trap call to display message
0000286E  4E4F                    2766              TRAP        #15                 ; trap call
00002870                          2767  
00002870  43F9 00003D6D           2768              LEA         dispByte, A1        ; display byte
00002876  103C 000E               2769              MOVE.B      #14, D0             ; command for trap call to display message
0000287A  4E4F                    2770              TRAP        #15                 ; trap call
0000287C                          2771          
0000287C  4EB9 00002E1E           2772              JSR         PrntImm             ; jump to PrntImm
00002882                          2773          
00002882  6000 E7BC               2774              BRA         LOOP                ; branch back to LOOP
00002886                          2775  
00002886                          2776  opROLBI 
00002886  43F9 00003D62           2777              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
0000288C  103C 000E               2778              MOVE.B      #14, D0             ; command for trap call to display message
00002890  4E4F                    2779              TRAP        #15                 ; trap call
00002892                          2780  
00002892  43F9 00003D6D           2781              LEA         dispByte, A1        ; display byte
00002898  103C 000E               2782              MOVE.B      #14, D0             ; command for trap call to display message
0000289C  4E4F                    2783              TRAP        #15                 ; trap call
0000289E                          2784          
0000289E  4EB9 00002E1E           2785              JSR         PrntImm             ; jump to PrntImm
000028A4                          2786          
000028A4  6000 E79A               2787              BRA         LOOP                ; branch back to LOOP
000028A8                          2788  
000028A8                          2789  opROBR  
000028A8  4242                    2790              CLR         D2                  ; clear D2
000028AA  3401                    2791              MOVE.W      D1, D2              ; move word from D1 to D2
000028AC  E042                    2792              ASR         #eight, D2          ; shift D2 over by 8 bits 
000028AE  C47C 0001               2793              AND         #$01, D2            ; and D2 by 1 bit to get direction
000028B2                          2794      
000028B2  B43C 0000               2795              CMP.B       #zero, D2           ; compare 0 to D2 
000028B6  6700 000E               2796              BEQ         opRORBR             ; if true, branch to RORBR for right
000028BA  B43C 0001               2797              CMP.B       #one, D2            ; compare 1 to D2
000028BE  6700 0028               2798              BEQ         opROLBR             ; if true, branch to ROLBR for left
000028C2  6000 13A0               2799              BRA         printInvalid        ; otherwise invalid    
000028C6                          2800          
000028C6                          2801  opRORBR 
000028C6  43F9 00003D5E           2802              LEA         RORmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000028CC  103C 000E               2803              MOVE.B      #14, D0             ; command for trap call to display message
000028D0  4E4F                    2804              TRAP        #15                 ; trap call
000028D2                          2805  
000028D2  43F9 00003D6D           2806              LEA         dispByte, A1        ; display byte
000028D8  103C 000E               2807              MOVE.B      #14, D0             ; command for trap call to display message
000028DC  4E4F                    2808              TRAP        #15                 ; trap call
000028DE                          2809          
000028DE  4EB9 00002E7A           2810              JSR         PrntReg             ; jump to PrntReg
000028E4                          2811          
000028E4  6000 E75A               2812              BRA         LOOP                ; branch back to LOOP
000028E8                          2813  
000028E8                          2814  opROLBR 
000028E8  43F9 00003D62           2815              LEA         ROLmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000028EE  103C 000E               2816              MOVE.B      #14, D0             ; command for trap call to display message
000028F2  4E4F                    2817              TRAP        #15                 ; trap call
000028F4                          2818  
000028F4  43F9 00003D6D           2819              LEA         dispByte, A1        ; display byte
000028FA  103C 000E               2820              MOVE.B      #14, D0             ; command for trap call to display message
000028FE  4E4F                    2821              TRAP        #15                 ; trap call
00002900                          2822          
00002900  4EB9 00002E7A           2823              JSR         PrntReg             ; jump to PrntReg
00002906                          2824          
00002906  6000 E738               2825              BRA         LOOP                ; branch back to LOOP       
0000290A                          2826  
0000290A                          2827  memSW   
0000290A  4242                    2828              CLR         D2                  ; clear D2
0000290C  1401                    2829              MOVE.B      D1,D2               ; move D1 to D2
0000290E  E642                    2830              ASR         #three, D2          ; shift D2 by 3 bits to get i/r
00002910                          2831              
00002910  C47C 0007               2832              AND         #$07, D2            ; and D2 by 3 bits 
00002914                          2833          
00002914  B43C 0000               2834              CMP.B       #zero, D2           ; compare 0 to D2
00002918  6700 002E               2835              BEQ         opASWI              ; if true, branch to ASWI for immediate
0000291C  B43C 0004               2836              CMP.B       #four, D2           ; compare 4 to D2 
00002920  6700 0088               2837              BEQ         opASWR              ; if true, branch to ASWR for register
00002924  B43C 0001               2838              CMP.B       #one, D2            ; compare 1 to D2
00002928  6700 00E2               2839              BEQ         opLSWI              ; if true, branch to LSWI for immediate
0000292C  B43C 0005               2840              CMP.B       #five, D2           ; compare 5 to D2
00002930  6700 013C               2841              BEQ         opLSWR              ; if true, branch to LSWR for register
00002934  B43C 0003               2842              CMP.B       #three, D2          ; compare 3 to D2
00002938  6700 0196               2843              BEQ         opROWI              ; if true, branch to ROWI for immediate
0000293C  B43C 0007               2844              CMP.B       #seven, D2          ; compare 7 to D2
00002940  6700 01F0               2845              BEQ         opROWR              ; if true, branch to ROWR for register
00002944  6000 131E               2846              BRA         printInvalid        ; otherwise invalid
00002948                          2847          
00002948                          2848  opASWI  
00002948  4242                    2849              CLR         D2                  ; clear D2
0000294A  3401                    2850              MOVE.W      D1, D2              ; move word from D1 to D2
0000294C  E042                    2851              ASR         #eight, D2          ; shift D2 over by 8 bits 
0000294E  C47C 0001               2852              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002952                          2853      
00002952  B43C 0000               2854              CMP.B       #zero, D2           ; compare 0 to D2
00002956  6700 000E               2855              BEQ         opASRWI             ; if true, branch to ASRWI for right
0000295A  B43C 0001               2856              CMP.B       #one, D2            ; compare 1 to D2
0000295E  6700 0028               2857              BEQ         opASLWI             ; if true, branch to ASLWI for left
00002962  6000 1300               2858              BRA         printInvalid        ; otherwise invalid
00002966                          2859          
00002966                          2860  opASRWI 
00002966  43F9 00003D56           2861              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
0000296C  103C 000E               2862              MOVE.B      #14, D0             ; command for trap call to display message
00002970  4E4F                    2863              TRAP        #15                 ; trap call
00002972                          2864  
00002972  43F9 00003D70           2865              LEA         dispWord, A1        ; display word
00002978  103C 000E               2866              MOVE.B      #14, D0             ; command for trap call to display message
0000297C  4E4F                    2867              TRAP        #15                 ; trap call
0000297E                          2868          
0000297E  4EB9 00002E1E           2869              JSR         PrntImm             ; jump to PrntImm
00002984                          2870          
00002984  6000 E6BA               2871              BRA         LOOP                ; branch back to LOOP
00002988                          2872  
00002988                          2873  opASLWI 
00002988  43F9 00003D5A           2874              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
0000298E  103C 000E               2875              MOVE.B      #14, D0             ; command for trap call to display message
00002992  4E4F                    2876              TRAP        #15                 ; trap call
00002994                          2877  
00002994  43F9 00003D70           2878              LEA         dispWord, A1        ; display word
0000299A  103C 000E               2879              MOVE.B      #14, D0             ; command for trap call to display message
0000299E  4E4F                    2880              TRAP        #15                 ; trap call
000029A0                          2881          
000029A0  4EB9 00002E1E           2882              JSR         PrntImm             ; jump to PrntImm
000029A6                          2883          
000029A6  6000 E698               2884              BRA         LOOP                ; branch back to LOOP
000029AA                          2885  
000029AA                          2886  opASWR  
000029AA  4242                    2887              CLR         D2                  ; clear D2
000029AC  3401                    2888              MOVE.W      D1, D2              ; move word from D1 to D2
000029AE  E042                    2889              ASR         #eight, D2          ; shift D2 over by 8 bits 
000029B0  C47C 0001               2890              AND         #$01, D2            ; and D2 by 1 bit to get direction
000029B4                          2891      
000029B4  B43C 0000               2892              CMP.B       #zero, D2           ; compare 0 to D2 
000029B8  6700 000E               2893              BEQ         opASRWR             ; if true, branch to ASRWR for right
000029BC  B43C 0001               2894              CMP.B       #one, D2            ; compare 1 to D2
000029C0  6700 0028               2895              BEQ         opASLWR             ; if true, branch to ASLWR for left
000029C4  6000 129E               2896              BRA         printInvalid        ; otherwise invalid
000029C8                          2897          
000029C8                          2898  opASRWR     
000029C8  43F9 00003D56           2899              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000029CE  103C 000E               2900              MOVE.B      #14, D0             ; command for trap call to display message
000029D2  4E4F                    2901              TRAP        #15                 ; trap call
000029D4                          2902  
000029D4  43F9 00003D70           2903              LEA         dispWord, A1        ; display word
000029DA  103C 000E               2904              MOVE.B      #14, D0             ; command for trap call to display message
000029DE  4E4F                    2905              TRAP        #15                 ; trap call
000029E0                          2906          
000029E0  4EB9 00002E7A           2907              JSR         PrntReg             ; jump to PrntReg
000029E6                          2908          
000029E6  6000 E658               2909              BRA         LOOP                ; branch back to LOOP
000029EA                          2910  
000029EA                          2911  opASLWR     
000029EA  43F9 00003D5A           2912              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
000029F0  103C 000E               2913              MOVE.B      #14, D0             ; command for trap call to display message
000029F4  4E4F                    2914              TRAP        #15                 ; trap call
000029F6                          2915  
000029F6  43F9 00003D70           2916              LEA         dispWord, A1        ; display word
000029FC  103C 000E               2917              MOVE.B      #14, D0             ; command for trap call to display message
00002A00  4E4F                    2918              TRAP        #15                 ; trap call
00002A02                          2919          
00002A02  4EB9 00002E7A           2920              JSR         PrntReg             ; jump to PrntReg
00002A08                          2921          
00002A08  6000 E636               2922              BRA         LOOP                ; branch back to LOOP
00002A0C                          2923  
00002A0C                          2924  opLSWI      
00002A0C  4242                    2925              CLR         D2                  ; clear D2
00002A0E  3401                    2926              MOVE.W      D1, D2              ; move word from D1 to D2
00002A10  E042                    2927              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002A12  C47C 0001               2928              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002A16                          2929      
00002A16  B43C 0000               2930              CMP.B       #zero, D2           ; compare 0 to D2 
00002A1A  6700 000E               2931              BEQ         opLSRWI             ; if true, branch to LSRWI for right
00002A1E  B43C 0001               2932              CMP.B       #one, D2            ; compare 1 to D2
00002A22  6700 0028               2933              BEQ         opLSLWI             ; if true, branch to LSLWI for left
00002A26  6000 123C               2934              BRA         printInvalid        ; otherwise invalid 
00002A2A                          2935          
00002A2A                          2936  opLSRWI 
00002A2A  43F9 00003D4E           2937              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002A30  103C 000E               2938              MOVE.B      #14, D0             ; command for trap call to display message
00002A34  4E4F                    2939              TRAP        #15                 ; trap call
00002A36                          2940      
00002A36  43F9 00003D70           2941              LEA         dispWord, A1        ; display word
00002A3C  103C 000E               2942              MOVE.B      #14, D0             ; command for trap call to display message
00002A40  4E4F                    2943              TRAP        #15                 ; trap call
00002A42                          2944          
00002A42  4EB9 00002E1E           2945              JSR         PrntImm             ; jump to PrntImm
00002A48                          2946          
00002A48  6000 E5F6               2947              BRA         LOOP                ; branch back to LOOP
00002A4C                          2948              
00002A4C                          2949  opLSLWI 
00002A4C  43F9 00003D52           2950              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002A52  103C 000E               2951              MOVE.B      #14, D0             ; command for trap call to display message
00002A56  4E4F                    2952              TRAP        #15                 ; trap call
00002A58                          2953  
00002A58  43F9 00003D70           2954              LEA         dispWord, A1        ; display word
00002A5E  103C 000E               2955              MOVE.B      #14, D0             ; command for trap call to display message
00002A62  4E4F                    2956              TRAP        #15                 ; trap call
00002A64                          2957          
00002A64  4EB9 00002E1E           2958              JSR         PrntImm             ; jump to PrntImm
00002A6A                          2959          
00002A6A  6000 E5D4               2960              BRA         LOOP                ; branch back to LOOP
00002A6E                          2961              
00002A6E                          2962  opLSWR  
00002A6E  4242                    2963              CLR         D2                  ; clear D2
00002A70  3401                    2964              MOVE.W      D1, D2              ; move word from D1 to D2
00002A72  E042                    2965              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002A74  C47C 0001               2966              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002A78                          2967      
00002A78  B43C 0000               2968              CMP.B       #zero, D2           ; compare 0 to D2 
00002A7C  6700 000E               2969              BEQ         opLSRWR             ; if true, branch to LSRWR for right
00002A80  B43C 0001               2970              CMP.B       #one, D2            ; compare 1 to D2
00002A84  6700 0028               2971              BEQ         opLSLWR             ; if true, branch to LSLWR for left
00002A88  6000 11DA               2972              BRA         printInvalid        ; otherwise invalid
00002A8C                          2973          
00002A8C                          2974  opLSRWR 
00002A8C  43F9 00003D4E           2975              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002A92  103C 000E               2976              MOVE.B      #14, D0             ; command for trap call to display message
00002A96  4E4F                    2977              TRAP        #15                 ; trap call
00002A98                          2978  
00002A98  43F9 00003D70           2979              LEA         dispWord, A1        ; display word
00002A9E  103C 000E               2980              MOVE.B      #14, D0             ; command for trap call to display message
00002AA2  4E4F                    2981              TRAP        #15                 ; trap call
00002AA4                          2982          
00002AA4  4EB9 00002E7A           2983              JSR         PrntReg             ; jump to PrntReg
00002AAA                          2984          
00002AAA  6000 E594               2985              BRA         LOOP                ; branch back to LOOP
00002AAE                          2986          
00002AAE                          2987  opLSLWR 
00002AAE  43F9 00003D52           2988              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002AB4  103C 000E               2989              MOVE.B      #14, D0             ; command for trap call to display message
00002AB8  4E4F                    2990              TRAP        #15                 ; trap call
00002ABA                          2991  
00002ABA  43F9 00003D70           2992              LEA         dispWord, A1        ; display word
00002AC0  103C 000E               2993              MOVE.B      #14, D0             ; command for trap call to display message
00002AC4  4E4F                    2994              TRAP        #15                 ; trap call
00002AC6                          2995          
00002AC6  4EB9 00002E7A           2996              JSR         PrntReg             ; jump to PrntReg
00002ACC                          2997          
00002ACC  6000 E572               2998              BRA         LOOP                ; branch back to LOOP
00002AD0                          2999  
00002AD0                          3000  opROWI  
00002AD0  4242                    3001              CLR         D2                  ; clear D2
00002AD2  3401                    3002              MOVE.W      D1, D2              ; move word from D1 to D2
00002AD4  E042                    3003              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002AD6  C47C 0001               3004              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002ADA                          3005      
00002ADA  B43C 0000               3006              CMP.B       #zero, D2           ; compare 0 to D2
00002ADE  6700 000E               3007              BEQ         opRORWI             ; if true, branch to RORWI for right
00002AE2  B43C 0001               3008              CMP.B       #one, D2            ; compare 1 to D2
00002AE6  6700 0028               3009              BEQ         opROLWI             ; if true, branch to ROLWI for left
00002AEA  6000 1178               3010              BRA         printInvalid        ; otherwise invalid
00002AEE                          3011          
00002AEE                          3012  opRORWI 
00002AEE  43F9 00003D5E           3013              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002AF4  103C 000E               3014              MOVE.B      #14, D0             ; command for trap call to display message
00002AF8  4E4F                    3015              TRAP        #15                 ; trap call
00002AFA                          3016  
00002AFA  43F9 00003D70           3017              LEA         dispWord, A1        ; display word
00002B00  103C 000E               3018              MOVE.B      #14, D0             ; command for trap call to display message
00002B04  4E4F                    3019              TRAP        #15                 ; trap call
00002B06                          3020          
00002B06  4EB9 00002E1E           3021              JSR         PrntImm             ; jump to PrntImm
00002B0C                          3022          
00002B0C  6000 E532               3023              BRA         LOOP                ; branch back to LOOP
00002B10                          3024  
00002B10                          3025  opROLWI     
00002B10  43F9 00003D62           3026              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002B16                          3027          
00002B16  103C 000E               3028              MOVE.B      #14, D0             ; command for trap call to display message
00002B1A  4E4F                    3029              TRAP        #15                 ; trap call
00002B1C                          3030  
00002B1C  43F9 00003D70           3031              LEA         dispWord, A1        ; display word
00002B22  103C 000E               3032              MOVE.B      #14, D0             ; command for trap call to display message
00002B26  4E4F                    3033              TRAP        #15                 ; trap call
00002B28                          3034          
00002B28  4EB9 00002E1E           3035              JSR         PrntImm             ; jump to PrntImm
00002B2E                          3036          
00002B2E  6000 E510               3037              BRA         LOOP                ; branch back to LOOP
00002B32                          3038  
00002B32                          3039  opROWR      
00002B32  4242                    3040              CLR         D2                  ; clear D2
00002B34  3401                    3041              MOVE.W      D1, D2              ; move word from D1 to D2
00002B36  E042                    3042              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002B38  C47C 0001               3043              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002B3C                          3044      
00002B3C  B43C 0000               3045              CMP.B       #zero, D2           ; compare 0 to D2 
00002B40  6700 000E               3046              BEQ         opRORWR             ; if true, branch to RORWR for right
00002B44  B43C 0001               3047              CMP.B       #one, D2            ; compare 1 to D2
00002B48  6700 0028               3048              BEQ         opROLWR             ; if true, branch to ROLWR for left
00002B4C  6000 1116               3049              BRA         printInvalid        ; otherwise invalid     
00002B50                          3050          
00002B50                          3051  opRORWR 
00002B50  43F9 00003D5E           3052              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002B56  103C 000E               3053              MOVE.B      #14, D0             ; command for trap call to display message
00002B5A  4E4F                    3054              TRAP        #15                 ; trap call
00002B5C                          3055      
00002B5C  43F9 00003D70           3056              LEA         dispWord, A1        ; display word
00002B62  103C 000E               3057              MOVE.B      #14, D0             ; command for trap call to display message
00002B66  4E4F                    3058              TRAP        #15                 ; trap call
00002B68                          3059          
00002B68  4EB9 00002E7A           3060              JSR         PrntReg             ; jump to PrntReg
00002B6E                          3061          
00002B6E  6000 E4D0               3062              BRA         LOOP                ; branch back to LOOP
00002B72                          3063  
00002B72                          3064  opROLWR 
00002B72  43F9 00003D62           3065              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002B78  103C 000E               3066              MOVE.B      #14, D0             ; command for trap call to display message
00002B7C  4E4F                    3067              TRAP        #15                 ; trap call
00002B7E                          3068  
00002B7E  43F9 00003D70           3069              LEA         dispWord, A1        ; display word
00002B84  103C 000E               3070              MOVE.B      #14, D0             ; command for trap call to display message
00002B88  4E4F                    3071              TRAP        #15                 ; trap call
00002B8A                          3072          
00002B8A  4EB9 00002E7A           3073              JSR         PrntReg             ; jump to PrntReg
00002B90                          3074          
00002B90  6000 E4AE               3075              BRA         LOOP                ; branch back to LOOP
00002B94                          3076  
00002B94                          3077  memSL   
00002B94  4242                    3078              CLR         D2                  ; clear D2
00002B96  1401                    3079              MOVE.B      D1,D2               ; move D1 to D2
00002B98  E642                    3080              ASR         #three, D2          ; shift D2 by 3 bits to get i/r
00002B9A                          3081              
00002B9A  C47C 0007               3082              AND         #$07, D2            ; and D2 by 3 bits 
00002B9E                          3083          
00002B9E  B43C 0000               3084              CMP.B       #zero, D2           ; compare 0 to D2
00002BA2  6700 002E               3085              BEQ         opASLI              ; if true, branch to ASLI for immediate
00002BA6  B43C 0004               3086              CMP.B       #four, D2           ; compare 4 to D2 
00002BAA  6700 0088               3087              BEQ         opASLR              ; if true, branch to ASLR for register
00002BAE  B43C 0001               3088              CMP.B       #one, D2            ; compare 1 to D2
00002BB2  6700 00E2               3089              BEQ         opLSLI              ; if true, branch to LSLI for immediate
00002BB6  B43C 0005               3090              CMP.B       #five, D2           ; compare 5 to D2
00002BBA  6700 013C               3091              BEQ         opLSLR              ; if true, branch to LSLR for register
00002BBE  B43C 0003               3092              CMP.B       #three, D2          ; compare 3 to D2
00002BC2  6700 0196               3093              BEQ         opROLI              ; if true, branch to ROLI for immediate
00002BC6  B43C 0007               3094              CMP.B       #seven, D2          ; compare 7 to D2
00002BCA  6700 01F0               3095              BEQ         opROLR              ; if true, branch to ROLR for register
00002BCE  6000 1094               3096              BRA         printInvalid        ; otherwise invalid
00002BD2                          3097          
00002BD2                          3098  opASLI  
00002BD2  4242                    3099              CLR         D2                  ; clear D2
00002BD4  3401                    3100              MOVE.W      D1, D2              ; move word from D1 to D2
00002BD6  E042                    3101              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002BD8  C47C 0001               3102              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002BDC                          3103      
00002BDC  B43C 0000               3104              CMP.B       #zero, D2           ; compare 0 to D2
00002BE0  6700 000E               3105              BEQ         opASRLI             ; if true, branch to ASRLI for right
00002BE4  B43C 0001               3106              CMP.B       #one, D2            ; compare 1 to D2
00002BE8  6700 0028               3107              BEQ         opASLLI             ; if true, branch to ASLLI for left
00002BEC  6000 1076               3108              BRA         printInvalid        ; otherwise invalid
00002BF0                          3109          
00002BF0                          3110  opASRLI 
00002BF0  43F9 00003D56           3111              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002BF6  103C 000E               3112              MOVE.B      #14, D0             ; command for trap call to display message
00002BFA  4E4F                    3113              TRAP        #15                 ; trap call
00002BFC                          3114  
00002BFC  43F9 00003D73           3115              LEA         dispLong, A1        ; display long
00002C02  103C 000E               3116              MOVE.B      #14, D0             ; command for trap call to display message
00002C06  4E4F                    3117              TRAP        #15                 ; trap call
00002C08                          3118          
00002C08  4EB9 00002E1E           3119              JSR         PrntImm             ; jump to PrntImm
00002C0E                          3120          
00002C0E  6000 E430               3121              BRA         LOOP                ; branch back to LOOP
00002C12                          3122  
00002C12                          3123  opASLLI 
00002C12  43F9 00003D5A           3124              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
00002C18  103C 000E               3125              MOVE.B      #14, D0             ; command for trap call to display message
00002C1C  4E4F                    3126              TRAP        #15                 ; trap call
00002C1E                          3127  
00002C1E  43F9 00003D73           3128              LEA         dispLong, A1        ; display long
00002C24  103C 000E               3129              MOVE.B      #14, D0             ; command for trap call to display message
00002C28  4E4F                    3130              TRAP        #15                 ; trap call
00002C2A                          3131          
00002C2A  4EB9 00002E1E           3132              JSR         PrntImm             ; jump to PrntImm
00002C30                          3133          
00002C30  6000 E40E               3134              BRA         LOOP                ; branch back to LOOP
00002C34                          3135  
00002C34                          3136  opASLR  
00002C34  4242                    3137              CLR         D2                  ; clear D2
00002C36  3401                    3138              MOVE.W      D1, D2              ; move word from D1 to D2
00002C38  E042                    3139              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002C3A  C47C 0001               3140              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002C3E                          3141      
00002C3E  B43C 0000               3142              CMP.B       #zero, D2           ; compare 0 to D2 
00002C42  6700 000E               3143              BEQ         opASRLR             ; if true, branch to ASRLR for right
00002C46  B43C 0001               3144              CMP.B       #one, D2            ; compare 1 to D2
00002C4A  6700 0028               3145              BEQ         opASLLR             ; if true, branch to ASLLR for left
00002C4E  6000 1014               3146              BRA         printInvalid        ; otherwise invalid 
00002C52                          3147          
00002C52                          3148  opASRLR 
00002C52  43F9 00003D56           3149              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002C58  103C 000E               3150              MOVE.B      #14, D0             ; command for trap call to display message
00002C5C  4E4F                    3151              TRAP        #15                 ; trap call
00002C5E                          3152  
00002C5E  43F9 00003D73           3153              LEA         dispLong, A1        ; display long
00002C64  103C 000E               3154              MOVE.B      #14, D0             ; command for trap call to display message
00002C68  4E4F                    3155              TRAP        #15                 ; trap call
00002C6A                          3156          
00002C6A  4EB9 00002E7A           3157              JSR         PrntReg             ; jump to PrntReg
00002C70                          3158          
00002C70  6000 E3CE               3159              BRA         LOOP                ; branch back to LOOP
00002C74                          3160  
00002C74                          3161  opASLLR 
00002C74  43F9 00003D5A           3162              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
00002C7A  103C 000E               3163              MOVE.B      #14, D0             ; command for trap call to display message
00002C7E  4E4F                    3164              TRAP        #15                 ; trap call
00002C80                          3165  
00002C80  43F9 00003D73           3166              LEA         dispLong, A1        ; display long
00002C86  103C 000E               3167              MOVE.B      #14, D0             ; command for trap call to display message
00002C8A  4E4F                    3168              TRAP        #15                 ; trap call
00002C8C                          3169          
00002C8C  4EB9 00002E7A           3170              JSR         PrntReg             ; jump to PrntReg
00002C92                          3171          
00002C92  6000 E3AC               3172              BRA         LOOP                ; branch back to LOOP
00002C96                          3173  
00002C96                          3174  opLSLI  
00002C96  4242                    3175              CLR         D2                  ; clear D2
00002C98  3401                    3176              MOVE.W      D1, D2              ; move word from D1 to D2
00002C9A  E042                    3177              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002C9C  C47C 0001               3178              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002CA0                          3179      
00002CA0  B43C 0000               3180              CMP.B       #zero, D2           ; compare 0 to D2 
00002CA4  6700 000E               3181              BEQ         opLSRLI             ; if true, branch to LSRLI for right
00002CA8  B43C 0001               3182              CMP.B       #one, D2            ; compare 1 to D2
00002CAC  6700 0028               3183              BEQ         opLSLLI             ; if true, branch to LSLLI for left
00002CB0  6000 0FB2               3184              BRA         printInvalid        ; otherwise invalid  
00002CB4                          3185          
00002CB4                          3186  opLSRLI 
00002CB4  43F9 00003D4E           3187              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002CBA  103C 000E               3188              MOVE.B      #14, D0             ; command for trap call to display message
00002CBE  4E4F                    3189              TRAP        #15                 ; trap call
00002CC0                          3190  
00002CC0  43F9 00003D73           3191              LEA         dispLong, A1        ; display long
00002CC6  103C 000E               3192              MOVE.B      #14, D0             ; command for trap call to display message
00002CCA  4E4F                    3193              TRAP        #15                 ; trap call
00002CCC                          3194          
00002CCC  4EB9 00002E1E           3195              JSR         PrntImm             ; jump to PrntImm
00002CD2                          3196          
00002CD2  6000 E36C               3197              BRA         LOOP                ; branch back to LOOP
00002CD6                          3198  
00002CD6                          3199  
00002CD6                          3200  opLSLLI 
00002CD6  43F9 00003D52           3201              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002CDC  103C 000E               3202              MOVE.B      #14, D0             ; command for trap call to display message
00002CE0  4E4F                    3203              TRAP        #15                 ; trap call
00002CE2                          3204  
00002CE2  43F9 00003D73           3205              LEA         dispLong, A1        ; display long
00002CE8  103C 000E               3206              MOVE.B      #14, D0             ; command for trap call to display message
00002CEC  4E4F                    3207              TRAP        #15                 ; trap call
00002CEE                          3208          
00002CEE  4EB9 00002E1E           3209              JSR         PrntImm             ; jump to PrntImm
00002CF4                          3210          
00002CF4  6000 E34A               3211              BRA         LOOP                ; branch back to LOOP
00002CF8                          3212  
00002CF8                          3213  opLSLR  
00002CF8  4242                    3214              CLR         D2                  ; clear D2
00002CFA  3401                    3215              MOVE.W      D1, D2              ; move word from D1 to D2
00002CFC  E042                    3216              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002CFE  C47C 0001               3217              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002D02                          3218      
00002D02  B43C 0000               3219              CMP.B       #zero, D2           ; compare 0 to D2 
00002D06  6700 000E               3220              BEQ         opLSRLR             ; if true, branch to LSRLR for right
00002D0A  B43C 0001               3221              CMP.B       #one, D2            ; compare 1 to D2
00002D0E  6700 0028               3222              BEQ         opLSLLR             ; if true, branch to LSLLR for left
00002D12  6000 0F50               3223              BRA         printInvalid        ; otherwise invalid
00002D16                          3224          
00002D16                          3225  opLSRLR 
00002D16  43F9 00003D4E           3226              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002D1C  103C 000E               3227              MOVE.B      #14, D0             ; command for trap call to display message
00002D20  4E4F                    3228              TRAP        #15                 ; trap call
00002D22                          3229  
00002D22  43F9 00003D73           3230              LEA         dispLong, A1        ; display long
00002D28  103C 000E               3231              MOVE.B      #14, D0             ; command for trap call to display message
00002D2C  4E4F                    3232              TRAP        #15                 ; trap call
00002D2E                          3233          
00002D2E  4EB9 00002E7A           3234              JSR         PrntReg             ; jump to PrntReg
00002D34                          3235          
00002D34  6000 E30A               3236              BRA         LOOP                ; branch back to LOOP
00002D38                          3237          
00002D38                          3238  opLSLLR 
00002D38  43F9 00003D52           3239              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002D3E  103C 000E               3240              MOVE.B      #14, D0             ; command for trap call to display message
00002D42  4E4F                    3241              TRAP        #15                 ; trap call
00002D44                          3242  
00002D44  43F9 00003D73           3243              LEA         dispLong, A1        ; display long
00002D4A  103C 000E               3244              MOVE.B      #14, D0             ; command for trap call to display message
00002D4E  4E4F                    3245              TRAP        #15                 ; trap call
00002D50                          3246          
00002D50  4EB9 00002E7A           3247              JSR         PrntReg             ; jump to PrntReg
00002D56                          3248          
00002D56  6000 E2E8               3249              BRA         LOOP                ; branch back to LOOP
00002D5A                          3250              
00002D5A                          3251  opROLI  
00002D5A  4242                    3252              CLR         D2                  ; clear D2
00002D5C  3401                    3253              MOVE.W      D1, D2              ; move word from D1 to D2
00002D5E  E042                    3254              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002D60  C47C 0001               3255              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002D64                          3256      
00002D64  B43C 0000               3257              CMP.B       #zero, D2           ; compare 0 to D2
00002D68  6700 000E               3258              BEQ         opRORLI             ; if true, branch to RORLI for right
00002D6C  B43C 0001               3259              CMP.B       #one, D2            ; compare 1 to D2
00002D70  6700 0028               3260              BEQ         opROLLI             ; if true, branch to ROLLI for left
00002D74  6000 0EEE               3261              BRA         printInvalid        ; otherwise invalid
00002D78                          3262          
00002D78                          3263  opRORLI 
00002D78  43F9 00003D5E           3264              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002D7E  103C 000E               3265              MOVE.B      #14, D0             ; command for trap call to display message
00002D82  4E4F                    3266              TRAP        #15                 ; trap call
00002D84                          3267  
00002D84  43F9 00003D73           3268              LEA         dispLong, A1        ; display long
00002D8A  103C 000E               3269              MOVE.B      #14, D0             ; command for trap call to display message
00002D8E  4E4F                    3270              TRAP        #15                 ; trap call
00002D90                          3271          
00002D90  4EB9 00002E1E           3272              JSR         PrntImm             ; jump to PrntImm
00002D96                          3273          
00002D96  6000 E2A8               3274              BRA         LOOP                ; branch back to LOOP
00002D9A                          3275  
00002D9A                          3276  opROLLI 
00002D9A  43F9 00003D62           3277              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002DA0  103C 000E               3278              MOVE.B      #14, D0             ; command for trap call to display message
00002DA4  4E4F                    3279              TRAP        #15                 ; trap call
00002DA6                          3280  
00002DA6  43F9 00003D73           3281              LEA         dispLong, A1        ; display long
00002DAC  103C 000E               3282              MOVE.B      #14, D0             ; command for trap call to display message
00002DB0  4E4F                    3283              TRAP        #15                 ; trap call
00002DB2                          3284          
00002DB2  4EB9 00002E1E           3285              JSR         PrntImm             ; jump to PrntImm
00002DB8                          3286          
00002DB8  6000 E286               3287              BRA         LOOP                ; branch back to LOOP
00002DBC                          3288  
00002DBC                          3289  opROLR  
00002DBC  4242                    3290              CLR         D2                  ; clear D2
00002DBE  3401                    3291              MOVE.W      D1, D2              ; move word from D1 to D2
00002DC0  E042                    3292              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002DC2  C47C 0001               3293              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002DC6                          3294      
00002DC6  B43C 0000               3295              CMP.B       #zero, D2           ; compare 0 to D2 
00002DCA  6700 000E               3296              BEQ         opRORLR             ; if true, branch to RORLR for right
00002DCE  B43C 0001               3297              CMP.B       #one, D2            ; compare 1 to D2
00002DD2  6700 0028               3298              BEQ         opROLLR             ; if true, branch to ROLLR for left
00002DD6  6000 0E8C               3299              BRA         printInvalid        ; otherwise invalid     
00002DDA                          3300          
00002DDA                          3301  opRORLR 
00002DDA  43F9 00003D5E           3302              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002DE0  103C 000E               3303              MOVE.B      #14, D0             ; command for trap call to display message
00002DE4  4E4F                    3304              TRAP        #15                 ; trap call
00002DE6                          3305  
00002DE6  43F9 00003D73           3306              LEA         dispLong, A1        ; display long
00002DEC  103C 000E               3307              MOVE.B      #14, D0             ; command for trap call to display message
00002DF0  4E4F                    3308              TRAP        #15                 ; trap call
00002DF2                          3309          
00002DF2  4EB9 00002E7A           3310              JSR         PrntReg             ; jump to PrntReg
00002DF8                          3311          
00002DF8  6000 E246               3312              BRA         LOOP                ; branch back to LOOP
00002DFC                          3313  
00002DFC                          3314  opROLLR     
00002DFC  43F9 00003D62           3315              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002E02  103C 000E               3316              MOVE.B      #14, D0             ; command for trap call to display message
00002E06  4E4F                    3317              TRAP        #15                 ; trap call
00002E08                          3318      
00002E08  43F9 00003D73           3319              LEA         dispLong, A1        ; display long
00002E0E  103C 000E               3320              MOVE.B      #14, D0             ; command for trap call to display message
00002E12  4E4F                    3321              TRAP        #15                 ; trap call
00002E14                          3322          
00002E14  4EB9 00002E7A           3323              JSR         PrntReg             ; jump to PrntReg
00002E1A                          3324          
00002E1A  6000 E224               3325              BRA         LOOP                ; branch back to LOOP
00002E1E                          3326          
00002E1E                          3327  ***********************************************************************************************************
00002E1E                          3328  *                       Immediate Data Subroutine Part 1
00002E1E                          3329  *
00002E1E                          3330  * The following subroutine displays the immediate number to shift and the data register that is being shifted. 
00002E1E                          3331  * This subroutine calls two printing immediate subroutine first, the the ea print subroutine.        
00002E1E                          3332  *
00002E1E                          3333  ***********************************************************************************************************
00002E1E                          3334  
00002E1E                          3335  PrntImm 
00002E1E  48E7 FF7E               3336              MOVEM.L     D0-D7/A1-A6, -(SP)  ; callee saved registers
00002E22                          3337              
00002E22  43F9 00003CD3           3338              LEA         space, A1           ; display space
00002E28  103C 000E               3339              MOVE.B      #14, D0             ; command for trap call to display message
00002E2C  4E4F                    3340              TRAP        #15                 ; trap call
00002E2E                          3341              
00002E2E  43F9 00003CD6           3342              LEA         hashTag, A1         ; display #
00002E34  103C 000E               3343              MOVE.B      #14, D0             ; command for trap call to display message
00002E38  4E4F                    3344              TRAP        #15                 ; trap call
00002E3A                          3345              
00002E3A  4242                    3346              CLR         D2                  ; clear D2
00002E3C  3401                    3347              MOVE.W      D1, D2              ; move word from D1 to D2
00002E3E  E042                    3348              ASR         #eight, D2          ; shift D2 by 8 bits
00002E40  E242                    3349              ASR         #one, D2            ; shift D2 by one bit
00002E42  C47C 0007               3350              AND         #$07, D2            ; and D2 to get just first 3 bits
00002E46                          3351          
00002E46  4EB9 00002ECC           3352              JSR         MemShiftImm         ; jump to MemShiftImm
00002E4C                          3353          
00002E4C  43F9 00003CDA           3354              LEA         comma, A1           ; display comma
00002E52  103C 000E               3355              MOVE.B      #14, D0             ; command for trap call to display message
00002E56  4E4F                    3356              TRAP        #15                 ; trap call
00002E58                          3357          
00002E58  4242                    3358              CLR         D2                  ; clear D2 since destination mode must be data register
00002E5A  4243                    3359              CLR         D3                  ; clear D3 to get register
00002E5C  1601                    3360              MOVE.B      D1,D3               ; move byte from D1 to D3
00002E5E  C67C 0007               3361              AND         #$07, D3            ; and D3 to get first 3 bits only
00002E62                          3362          
00002E62  4EB9 00002EF6           3363              JSR         printEA             ; jump to printEA
00002E68                          3364          
00002E68  43F9 00003CCF           3365              LEA         newLine, A1         ; create new line
00002E6E  103C 000E               3366              MOVE.B      #14, D0             ; command for trap call to display message
00002E72  4E4F                    3367              TRAP        #15                 ; trap call
00002E74                          3368          
00002E74  4CDF 7EFF               3369              MOVEM.L     (SP)+, D0-D7/A1-A6  ; pop saved registers from stack
00002E78  4E75                    3370              RTS                             ; return
00002E7A                          3371              
00002E7A                          3372  ***********************************************************************************************************
00002E7A                          3373  *
00002E7A                          3374  *                       Shifting Helping Function
00002E7A                          3375  *
00002E7A                          3376  * The following subroutine determines the correct data register to display, and sets the values of D2 and 
00002E7A                          3377  *       D3 accordingly to display the data register.
00002E7A                          3378  * after setting the values, it calls another subroutine to actually display the data register.        
00002E7A                          3379  *
00002E7A                          3380  ***********************************************************************************************************
00002E7A                          3381  
00002E7A                          3382  PrntReg     
00002E7A  48E7 FF7E               3383              MOVEM.L     D0-D7/A1-A6, -(SP)  ; callee saved
00002E7E                          3384          
00002E7E  43F9 00003CD3           3385              LEA         space, A1           ; display space
00002E84  103C 000E               3386              MOVE.B      #14, D0             ; command for trap call to display message
00002E88  4E4F                    3387              TRAP        #15                 ; trap call
00002E8A                          3388          
00002E8A  4242                    3389              CLR         D2                  ; clear D2
00002E8C  4243                    3390              CLR         D3                  ; clear D3
00002E8E  3601                    3391              MOVE.W      D1, D3              ; move word from D1 to D3
00002E90  E043                    3392              ASR         #eight, D3          ; shift D3 by 8 bits
00002E92  E243                    3393              ASR         #one, D3            ; shift D3 by 1 bit
00002E94  C67C 0007               3394              AND         #$07, D3            ; and D3 to get first 3 bits only
00002E98                          3395          
00002E98  4EB9 00002EF6           3396              JSR         printEA
00002E9E                          3397          
00002E9E  43F9 00003CDA           3398              LEA         comma, A1           ; display comma
00002EA4  103C 000E               3399              MOVE.B      #14, D0             ; command for trap call to display message
00002EA8  4E4F                    3400              TRAP        #15                 ; trap call
00002EAA                          3401          
00002EAA  4242                    3402              CLR         D2                  ; clear D2
00002EAC  4243                    3403              CLR         D3                  ; clear D3
00002EAE  1601                    3404              MOVE.B      D1,D3               ; move byte from D1 to D3
00002EB0  C67C 0007               3405              AND         #$07, D3            ; and D3 to get first 3 bits only
00002EB4                          3406          
00002EB4  4EB9 00002EF6           3407              JSR         printEA             ; jump to printEA
00002EBA                          3408          
00002EBA  43F9 00003CCF           3409              LEA         newLine, A1         ; newline
00002EC0  103C 000E               3410              MOVE.B      #14, D0             ; command for trap call to display message
00002EC4  4E4F                    3411              TRAP        #15                 ; trap call
00002EC6                          3412          
00002EC6  4CDF 7EFF               3413              MOVEM.L     (SP)+, D0-D7/A1-A6  ; pop saved registers from stack
00002ECA  4E75                    3414              RTS                             ; return
00002ECC                          3415  
00002ECC                          3416  ***********************************************************************************************************
00002ECC                          3417  *
00002ECC                          3418  *                       Immediate Data Subroutine Part 2
00002ECC                          3419  *
00002ECC                          3420  * The following subroutine is used to display the number between 1-8 for the bit vount for the shift/rotate opcode
00002ECC                          3421  * It displays it by storing the appropriate number in D1 and running trap task 3.
00002ECC                          3422  *
00002ECC                          3423  ***********************************************************************************************************
00002ECC                          3424  
00002ECC                          3425  MemShiftImm     
00002ECC  48E7 FF7E               3426              MOVEM.L     D0-D7/A1-A6, -(SP)  ; caller saved data
00002ED0  4241                    3427              CLR         D1                  ; clear D1
00002ED2                          3428                 
00002ED2  1202                    3429              MOVE.B      D2, D1              ; move byte from D2 to D1
00002ED4  B23C 0000               3430              CMP.B       #zero, D1           ; compare 0 to D1
00002ED8  6700 000C               3431              BEQ         displayEight        ; if true, branch to displayEight
00002EDC                          3432                  
00002EDC  103C 0003               3433              MOVE.B      #3, D0              ; trap task command to display decimal
00002EE0  4E4F                    3434              TRAP        #15                 ; trap call
00002EE2  6000 000C               3435              BRA         endSubroutine       ; branch to endSubroutine
00002EE6                          3436                  
00002EE6                          3437  displayEight    
00002EE6  123C 0008               3438              MOVE.B      #$08, D1            ; move 8 to D1
00002EEA  103C 0003               3439              MOVE.B      #3, D0              ; trap task command to display decimal
00002EEE  4E4F                    3440              TRAP        #15                 ; trap call
00002EF0                          3441              
00002EF0                          3442  endSubroutine
00002EF0  4CDF 7EFF               3443              MOVEM.L     (SP)+, D0-D7/A1-A6  ; pop saved registers from stack
00002EF4  4E75                    3444              RTS                             ; return
00002EF6                          3445          
00002EF6                          3446  ***********************************************************************************************************
00002EF6                          3447  *
00002EF6                          3448  *                       EA Print Subroutine
00002EF6                          3449  *
00002EF6                          3450  ***********************************************************************************************************
00002EF6                          3451  
00002EF6                          3452  printEA     
00002EF6  48E7 FF7E               3453              MOVEM.L  D0-D7/A1-A6, -(SP)
00002EFA                          3454  
00002EFA  B43C 0000               3455              CMP.B       #zero, D2
00002EFE  6700 002E               3456              BEQ         pDataReg
00002F02  B43C 0001               3457              CMP.B       #one, D2
00002F06  6700 00E6               3458              BEQ         pAddrReg
00002F0A  B43C 0002               3459              CMP.B       #two, D2
00002F0E  6700 019E               3460              BEQ         pAddrDir
00002F12  B43C 0003               3461              CMP.B       #three, D2
00002F16  6700 02C2               3462              BEQ         pAddrPost
00002F1A  B43C 0004               3463              CMP.B       #four, D2
00002F1E  6700 0446               3464              BEQ         pAddrDec
00002F22  B43C 0007               3465              CMP.B       #seven, D2
00002F26  6700 0576               3466              BEQ         pHex
00002F2A  6000 0642               3467              BRA         invalid
00002F2E                          3468  
00002F2E                          3469  ***********************************************************************************************************
00002F2E                          3470  * Data Register        
00002F2E                          3471  pDataReg    
00002F2E  B63C 0000               3472              CMP.B       #zero,D3
00002F32  6700 003A               3473              BEQ         displayD0
00002F36  B63C 0001               3474              CMP.B       #one,D3
00002F3A  6700 0042               3475              BEQ         displayD1
00002F3E  B63C 0002               3476              CMP.B       #two,D3
00002F42  6700 004A               3477              BEQ         displayD2
00002F46  B63C 0003               3478              CMP.B       #three,D3
00002F4A  6700 0052               3479              BEQ         displayD3
00002F4E  B63C 0004               3480              CMP.B       #four,D3
00002F52  6700 005A               3481              BEQ         displayD4
00002F56  B63C 0005               3482              CMP.B       #five,D3
00002F5A  6700 0062               3483              BEQ         displayD5
00002F5E  B63C 0006               3484              CMP.B       #six,D3
00002F62  6700 006A               3485              BEQ         displayD6
00002F66  B63C 0007               3486              CMP.B       #seven,D3
00002F6A  6700 0072               3487              BEQ         displayD7
00002F6E                          3488              
00002F6E  43F9 00003D90           3489  displayD0   LEA         dispD0, A1          ; Display space
00002F74  103C 000E               3490              MOVE.B      #14, D0             ; command for trap call to display message
00002F78  4E4F                    3491              TRAP        #15                 ; trap call
00002F7A  6000 05F6               3492              BRA         endSUB              ; go to the end of the subroutine
00002F7E                          3493              
00002F7E  43F9 00003D93           3494  displayD1   LEA         dispD1, A1          ; Display space
00002F84  103C 000E               3495              MOVE.B      #14, D0             ; command for trap call to display message
00002F88  4E4F                    3496              TRAP        #15                 ; trap call
00002F8A  6000 05E6               3497              BRA         endSUB              ; go to the end of the subroutine
00002F8E                          3498  
00002F8E  43F9 00003D96           3499  displayD2   LEA         dispD2, A1          ; Display space
00002F94  103C 000E               3500              MOVE.B      #14, D0             ; command for trap call to display message
00002F98  4E4F                    3501              TRAP        #15                 ; trap call
00002F9A  6000 05D6               3502              BRA         endSUB              ; go to the end of the subroutine
00002F9E                          3503  
00002F9E  43F9 00003D99           3504  displayD3   LEA         dispD3, A1          ; Display space
00002FA4  103C 000E               3505              MOVE.B      #14, D0             ; command for trap call to display message
00002FA8  4E4F                    3506              TRAP        #15                 ; trap call
00002FAA  6000 05C6               3507              BRA         endSUB              ; go to the end of the subroutine
00002FAE                          3508  
00002FAE  43F9 00003D9C           3509  displayD4   LEA         dispD4, A1          ; Display space
00002FB4  103C 000E               3510              MOVE.B      #14, D0             ; command for trap call to display message
00002FB8  4E4F                    3511              TRAP        #15                 ; trap call
00002FBA  6000 05B6               3512              BRA         endSUB              ; go to the end of the subroutine
00002FBE                          3513  
00002FBE  43F9 00003D9F           3514  displayD5   LEA         dispD5, A1          ; Display space
00002FC4  103C 000E               3515              MOVE.B      #14, D0             ; command for trap call to display message
00002FC8  4E4F                    3516              TRAP        #15                 ; trap call
00002FCA  6000 05A6               3517              BRA         endSUB              ; go to the end of the subroutine
00002FCE                          3518  
00002FCE  43F9 00003DA2           3519  displayD6   LEA         dispD6, A1          ; Display space
00002FD4  103C 000E               3520              MOVE.B      #14, D0             ; command for trap call to display message
00002FD8  4E4F                    3521              TRAP        #15                 ; trap call
00002FDA  6000 0596               3522              BRA         endSUB              ; go to the end of the subroutine
00002FDE                          3523  
00002FDE  43F9 00003DA5           3524  displayD7   LEA         dispD7, A1          ; Display space
00002FE4  103C 000E               3525              MOVE.B      #14, D0             ; command for trap call to display message
00002FE8  4E4F                    3526              TRAP        #15                 ; trap call
00002FEA  6000 0586               3527              BRA         endSUB              ; go to the end of the subroutine
00002FEE                          3528              
00002FEE                          3529  ***********************************************************************************************************
00002FEE                          3530  * Address Register
00002FEE                          3531  
00002FEE  B63C 0000               3532  pAddrReg    CMP.B       #zero,D3
00002FF2  6700 003A               3533              BEQ         displayA0
00002FF6  B63C 0001               3534              CMP.B       #one,D3
00002FFA  6700 0042               3535              BEQ         displayA1
00002FFE  B63C 0002               3536              CMP.B       #two,D3
00003002  6700 004A               3537              BEQ         displayA2
00003006  B63C 0003               3538              CMP.B       #three,D3
0000300A  6700 0052               3539              BEQ         displayA3
0000300E  B63C 0004               3540              CMP.B       #four,D3
00003012  6700 005A               3541              BEQ         displayA4
00003016  B63C 0005               3542              CMP.B       #five,D3
0000301A  6700 0062               3543              BEQ         displayA5
0000301E  B63C 0006               3544              CMP.B       #six,D3
00003022  6700 006A               3545              BEQ         displayA6
00003026  B63C 0007               3546              CMP.B       #seven,D3
0000302A  6700 0072               3547              BEQ         displayA7
0000302E                          3548              
0000302E  43F9 00003D76           3549  displayA0   LEA         dispA0, A1          ; Display space
00003034  103C 000E               3550              MOVE.B      #14, D0             ; command for trap call to display message
00003038  4E4F                    3551              TRAP        #15                 ; trap call
0000303A  6000 0536               3552              BRA         endSUB              ; go to the end of the subroutine
0000303E                          3553              
0000303E  43F9 00003D79           3554  displayA1   LEA         dispA1, A1          ; Display space
00003044  103C 000E               3555              MOVE.B      #14, D0             ; command for trap call to display message
00003048  4E4F                    3556              TRAP        #15                 ; trap call
0000304A  6000 0526               3557              BRA         endSUB              ; go to the end of the subroutine
0000304E                          3558  
0000304E  43F9 00003D7C           3559  displayA2   LEA         dispA2, A1          ; Display space
00003054  103C 000E               3560              MOVE.B      #14, D0             ; command for trap call to display message
00003058  4E4F                    3561              TRAP        #15                 ; trap call
0000305A  6000 0516               3562              BRA         endSUB              ; go to the end of the subroutine
0000305E                          3563  
0000305E  43F9 00003D7F           3564  displayA3   LEA         dispA3, A1          ; Display space
00003064  103C 000E               3565              MOVE.B      #14, D0             ; command for trap call to display message
00003068  4E4F                    3566              TRAP        #15                 ; trap call
0000306A  6000 0506               3567              BRA         endSUB              ; go to the end of the subroutine
0000306E                          3568  
0000306E  43F9 00003D82           3569  displayA4   LEA         dispA4, A1          ; Display space
00003074  103C 000E               3570              MOVE.B      #14, D0             ; command for trap call to display message
00003078  4E4F                    3571              TRAP        #15                 ; trap call
0000307A  6000 04F6               3572              BRA         endSUB              ; go to the end of the subroutine
0000307E                          3573  
0000307E  43F9 00003D85           3574  displayA5   LEA         dispA5, A1          ; Display space
00003084  103C 000E               3575              MOVE.B      #14, D0             ; command for trap call to display message
00003088  4E4F                    3576              TRAP        #15                 ; trap call
0000308A  6000 04E6               3577              BRA         endSUB              ; go to the end of the subroutine
0000308E                          3578  
0000308E  43F9 00003D88           3579  displayA6   LEA         dispA6, A1          ; Display space
00003094  103C 000E               3580              MOVE.B      #14, D0             ; command for trap call to display message
00003098  4E4F                    3581              TRAP        #15                 ; trap call
0000309A  6000 04D6               3582              BRA         endSUB              ; go to the end of the subroutine
0000309E                          3583  
0000309E  43F9 00003D8B           3584  displayA7   LEA         dispA7, A1          ; Display space
000030A4  103C 000E               3585              MOVE.B      #14, D0             ; command for trap call to display message
000030A8  4E4F                    3586              TRAP        #15                 ; trap call
000030AA  6000 04C6               3587              BRA         endSUB              ; go to the end of the subroutine
000030AE                          3588  
000030AE                          3589  ***********************************************************************************************************
000030AE                          3590  * Address Register Direct
000030AE                          3591  
000030AE  43F9 00003CDC           3592  pAddrDir    LEA         opPer, A1           ; Display space
000030B4  103C 000E               3593              MOVE.B      #14, D0             ; command for trap call to display message
000030B8  4E4F                    3594              TRAP        #15                 ; trap call
000030BA                          3595              
000030BA  B63C 0000               3596              CMP.B       #zero,D3
000030BE  6700 003A               3597              BEQ         displayA0A
000030C2  B63C 0001               3598              CMP.B       #one,D3
000030C6  6700 004E               3599              BEQ         displayA1A
000030CA  B63C 0002               3600              CMP.B       #two,D3
000030CE  6700 0062               3601              BEQ         displayA2A
000030D2  B63C 0003               3602              CMP.B       #three,D3
000030D6  6700 0076               3603              BEQ         displayA3A
000030DA  B63C 0004               3604              CMP.B       #four,D3
000030DE  6700 008A               3605              BEQ         displayA4A
000030E2  B63C 0005               3606              CMP.B       #five,D3
000030E6  6700 009E               3607              BEQ         displayA5A
000030EA  B63C 0006               3608              CMP.B       #six,D3
000030EE  6700 00B2               3609              BEQ         displayA6A
000030F2  B63C 0007               3610              CMP.B       #seven,D3
000030F6  6700 00C6               3611              BEQ         displayA7A
000030FA                          3612              
000030FA  43F9 00003D76           3613  displayA0A  LEA         dispA0, A1          ; Display space
00003100  103C 000E               3614              MOVE.B      #14, D0             ; command for trap call to display message
00003104  4E4F                    3615              TRAP        #15                 ; trap call
00003106  43F9 00003CDE           3616              LEA         clPer, A1           ; Display space
0000310C  103C 000E               3617              MOVE.B      #14, D0             ; command for trap call to display message
00003110  4E4F                    3618              TRAP        #15                 ; trap call
00003112  6000 045E               3619              BRA         endSUB              ; go to the end of the subroutine
00003116                          3620              
00003116  43F9 00003D79           3621  displayA1A  LEA         dispA1, A1          ; Display space
0000311C  103C 000E               3622              MOVE.B      #14, D0             ; command for trap call to display message
00003120  4E4F                    3623              TRAP        #15                 ; trap call
00003122  43F9 00003CDE           3624              LEA         clPer, A1           ; Display space
00003128  103C 000E               3625              MOVE.B      #14, D0             ; command for trap call to display message
0000312C  4E4F                    3626              TRAP        #15                 ; trap call
0000312E  6000 0442               3627              BRA         endSUB              ; go to the end of the subroutine
00003132                          3628  
00003132  43F9 00003D7C           3629  displayA2A  LEA         dispA2, A1          ; Display space
00003138  103C 000E               3630              MOVE.B      #14, D0             ; command for trap call to display message
0000313C  4E4F                    3631              TRAP        #15                 ; trap call
0000313E  43F9 00003CDE           3632              LEA         clPer, A1           ; Display space
00003144  103C 000E               3633              MOVE.B      #14, D0             ; command for trap call to display message
00003148  4E4F                    3634              TRAP        #15                 ; trap call
0000314A  6000 0426               3635              BRA         endSUB              ; go to the end of the subroutine
0000314E                          3636  
0000314E  43F9 00003D7F           3637  displayA3A  LEA         dispA3, A1          ; Display space
00003154  103C 000E               3638              MOVE.B      #14, D0             ; command for trap call to display message
00003158  4E4F                    3639              TRAP        #15                 ; trap call
0000315A  43F9 00003CDE           3640              LEA         clPer, A1           ; Display space
00003160  103C 000E               3641              MOVE.B      #14, D0             ; command for trap call to display message
00003164  4E4F                    3642              TRAP        #15                 ; trap call
00003166  6000 040A               3643              BRA         endSUB              ; go to the end of the subroutine
0000316A                          3644  
0000316A  43F9 00003D82           3645  displayA4A  LEA         dispA4, A1          ; Display space
00003170  103C 000E               3646              MOVE.B      #14, D0             ; command for trap call to display message
00003174  4E4F                    3647              TRAP        #15                 ; trap call
00003176  43F9 00003CDE           3648              LEA         clPer, A1           ; Display space
0000317C  103C 000E               3649              MOVE.B      #14, D0             ; command for trap call to display message
00003180  4E4F                    3650              TRAP        #15                 ; trap call
00003182  6000 03EE               3651              BRA         endSUB              ; go to the end of the subroutine
00003186                          3652  
00003186  43F9 00003D85           3653  displayA5A  LEA         dispA5, A1          ; Display space
0000318C  103C 000E               3654              MOVE.B      #14, D0             ; command for trap call to display message
00003190  4E4F                    3655              TRAP        #15                 ; trap call
00003192  43F9 00003CDE           3656              LEA         clPer, A1           ; Display space
00003198  103C 000E               3657              MOVE.B      #14, D0             ; command for trap call to display message
0000319C  4E4F                    3658              TRAP        #15                 ; trap call
0000319E  6000 03D2               3659              BRA         endSUB              ; go to the end of the subroutine
000031A2                          3660  
000031A2  43F9 00003D88           3661  displayA6A  LEA         dispA6, A1          ; Display space
000031A8  103C 000E               3662              MOVE.B      #14, D0             ; command for trap call to display message
000031AC  4E4F                    3663              TRAP        #15                 ; trap call
000031AE  43F9 00003CDE           3664              LEA         clPer, A1           ; Display space
000031B4  103C 000E               3665              MOVE.B      #14, D0             ; command for trap call to display message
000031B8  4E4F                    3666              TRAP        #15                 ; trap call
000031BA  6000 03B6               3667              BRA         endSUB              ; go to the end of the subroutine
000031BE                          3668  
000031BE  43F9 00003D8B           3669  displayA7A  LEA         dispA7, A1          ; Display space
000031C4  103C 000E               3670              MOVE.B      #14, D0             ; command for trap call to display message
000031C8  4E4F                    3671              TRAP        #15                 ; trap call
000031CA  43F9 00003CDE           3672              LEA         clPer, A1           ; Display space
000031D0  103C 000E               3673              MOVE.B      #14, D0             ; command for trap call to display message
000031D4  4E4F                    3674              TRAP        #15                 ; trap call
000031D6  6000 039A               3675              BRA         endSUB              ; go to the end of the subroutine
000031DA                          3676              
000031DA                          3677  ***********************************************************************************************************
000031DA                          3678  * Addr Postincrement
000031DA                          3679              
000031DA  43F9 00003CDC           3680  pAddrPost   LEA         opPer, A1           ; Display space
000031E0  103C 000E               3681              MOVE.B      #14, D0             ; command for trap call to display message
000031E4  4E4F                    3682              TRAP        #15                 ; trap call
000031E6                          3683              
000031E6  B63C 0000               3684              CMP.B       #zero,D3
000031EA  6700 003A               3685              BEQ         displayA0P
000031EE  B63C 0001               3686              CMP.B       #one,D3
000031F2  6700 005A               3687              BEQ         displayA1P
000031F6  B63C 0002               3688              CMP.B       #two,D3
000031FA  6700 007A               3689              BEQ         displayA2P
000031FE  B63C 0003               3690              CMP.B       #three,D3
00003202  6700 009A               3691              BEQ         displayA3P
00003206  B63C 0004               3692              CMP.B       #four,D3
0000320A  6700 00BA               3693              BEQ         displayA4P
0000320E  B63C 0005               3694              CMP.B       #five,D3
00003212  6700 00DA               3695              BEQ         displayA5P
00003216  B63C 0006               3696              CMP.B       #six,D3
0000321A  6700 00FA               3697              BEQ         displayA6P
0000321E  B63C 0007               3698              CMP.B       #seven,D3
00003222  6700 011A               3699              BEQ         displayA7P
00003226                          3700              
00003226  43F9 00003D76           3701  displayA0P  LEA         dispA0, A1          ; Display space
0000322C  103C 000E               3702              MOVE.B      #14, D0             ; command for trap call to display message
00003230  4E4F                    3703              TRAP        #15                 ; trap call
00003232  43F9 00003CDE           3704              LEA         clPer, A1           ; Display space
00003238  103C 000E               3705              MOVE.B      #14, D0             ; command for trap call to display message
0000323C  4E4F                    3706              TRAP        #15                 ; trap call
0000323E  43F9 00003CE2           3707              LEA         inc, A1             ; Display space
00003244  103C 000E               3708              MOVE.B      #14, D0             ; command for trap call to display message
00003248  4E4F                    3709              TRAP        #15                 ; trap call
0000324A  6000 0326               3710              BRA         endSUB              ; go to the end of the subroutine
0000324E                          3711              
0000324E  43F9 00003D79           3712  displayA1P  LEA         dispA1, A1          ; Display space
00003254  103C 000E               3713              MOVE.B      #14, D0             ; command for trap call to display message
00003258  4E4F                    3714              TRAP        #15                 ; trap call
0000325A  43F9 00003CDE           3715              LEA         clPer, A1           ; Display space
00003260  103C 000E               3716              MOVE.B      #14, D0             ; command for trap call to display message
00003264  4E4F                    3717              TRAP        #15                 ; trap call
00003266  43F9 00003CE2           3718              LEA         inc, A1             ; Display space
0000326C  103C 000E               3719              MOVE.B      #14, D0             ; command for trap call to display message
00003270  4E4F                    3720              TRAP        #15                 ; trap call
00003272  6000 02FE               3721              BRA         endSUB              ; go to the end of the subroutine
00003276                          3722  
00003276  43F9 00003D7C           3723  displayA2P  LEA         dispA2, A1          ; Display space
0000327C  103C 000E               3724              MOVE.B      #14, D0             ; command for trap call to display message
00003280  4E4F                    3725              TRAP        #15                 ; trap call
00003282  43F9 00003CDE           3726              LEA         clPer, A1           ; Display space
00003288  103C 000E               3727              MOVE.B      #14, D0             ; command for trap call to display message
0000328C  4E4F                    3728              TRAP        #15                 ; trap call
0000328E  43F9 00003CE2           3729              LEA         inc, A1             ; Display space
00003294  103C 000E               3730              MOVE.B      #14, D0             ; command for trap call to display message
00003298  4E4F                    3731              TRAP        #15                 ; trap call
0000329A  6000 02D6               3732              BRA         endSUB              ; go to the end of the subroutine
0000329E                          3733  
0000329E  43F9 00003D7F           3734  displayA3P  LEA         dispA3, A1          ; Display space
000032A4  103C 000E               3735              MOVE.B      #14, D0             ; command for trap call to display message
000032A8  4E4F                    3736              TRAP        #15                 ; trap call
000032AA  43F9 00003CDE           3737              LEA         clPer, A1           ; Display space
000032B0  103C 000E               3738              MOVE.B      #14, D0             ; command for trap call to display message
000032B4  4E4F                    3739              TRAP        #15                 ; trap call
000032B6  43F9 00003CE2           3740              LEA         inc, A1             ; Display space
000032BC  103C 000E               3741              MOVE.B      #14, D0             ; command for trap call to display message
000032C0  4E4F                    3742              TRAP        #15                 ; trap call
000032C2  6000 02AE               3743              BRA         endSUB              ; go to the end of the subroutine
000032C6                          3744  
000032C6  43F9 00003D82           3745  displayA4P  LEA         dispA4, A1          ; Display space
000032CC  103C 000E               3746              MOVE.B      #14, D0             ; command for trap call to display message
000032D0  4E4F                    3747              TRAP        #15                 ; trap call
000032D2  43F9 00003CDE           3748              LEA         clPer, A1           ; Display space
000032D8  103C 000E               3749              MOVE.B      #14, D0             ; command for trap call to display message
000032DC  4E4F                    3750              TRAP        #15                 ; trap call
000032DE  43F9 00003CE2           3751              LEA         inc, A1             ; Display space
000032E4  103C 000E               3752              MOVE.B      #14, D0             ; command for trap call to display message
000032E8  4E4F                    3753              TRAP        #15                 ; trap call
000032EA  6000 0286               3754              BRA         endSUB              ; go to the end of the subroutine
000032EE                          3755  
000032EE  43F9 00003D85           3756  displayA5P  LEA         dispA5, A1          ; Display space
000032F4  103C 000E               3757              MOVE.B      #14, D0             ; command for trap call to display message
000032F8  4E4F                    3758              TRAP        #15                 ; trap call
000032FA  43F9 00003CDE           3759              LEA         clPer, A1           ; Display space
00003300  103C 000E               3760              MOVE.B      #14, D0             ; command for trap call to display message
00003304  4E4F                    3761              TRAP        #15                 ; trap call
00003306  43F9 00003CE2           3762              LEA         inc, A1             ; Display space
0000330C  103C 000E               3763              MOVE.B      #14, D0             ; command for trap call to display message
00003310  4E4F                    3764              TRAP        #15                 ; trap call
00003312  6000 025E               3765              BRA         endSUB              ; go to the end of the subroutine
00003316                          3766  
00003316  43F9 00003D88           3767  displayA6P  LEA         dispA6, A1          ; Display space
0000331C  103C 000E               3768              MOVE.B      #14, D0             ; command for trap call to display message
00003320  4E4F                    3769              TRAP        #15                 ; trap call
00003322  43F9 00003CDE           3770              LEA         clPer, A1           ; Display space
00003328  103C 000E               3771              MOVE.B      #14, D0             ; command for trap call to display message
0000332C  4E4F                    3772              TRAP        #15                 ; trap call
0000332E  43F9 00003CE2           3773              LEA         inc, A1             ; Display space
00003334  103C 000E               3774              MOVE.B      #14, D0             ; command for trap call to display message
00003338  4E4F                    3775              TRAP        #15                 ; trap call
0000333A  6000 0236               3776              BRA         endSUB              ; go to the end of the subroutine
0000333E                          3777  
0000333E  43F9 00003D8B           3778  displayA7P  LEA         dispA7, A1          ; Display space
00003344  103C 000E               3779              MOVE.B      #14, D0             ; command for trap call to display message
00003348  4E4F                    3780              TRAP        #15                 ; trap call
0000334A  43F9 00003CDE           3781              LEA         clPer, A1           ; Display space
00003350  103C 000E               3782              MOVE.B      #14, D0             ; command for trap call to display message
00003354  4E4F                    3783              TRAP        #15                 ; trap call
00003356  43F9 00003CE2           3784              LEA         inc, A1             ; Display space
0000335C  103C 000E               3785              MOVE.B      #14, D0             ; command for trap call to display message
00003360  4E4F                    3786              TRAP        #15                 ; trap call
00003362  6000 020E               3787              BRA         endSUB              ; go to the end of the subroutine
00003366                          3788  
00003366                          3789  ***********************************************************************************************************
00003366                          3790  * Addr Postdecrement
00003366                          3791  
00003366                          3792  pAddrDec    
00003366  43F9 00003CE0           3793              LEA         dec, A1             ; Display space
0000336C  103C 000E               3794              MOVE.B      #14, D0             ; command for trap call to display message
00003370  4E4F                    3795              TRAP        #15                 ; trap call
00003372                          3796              
00003372  43F9 00003CDC           3797              LEA         opPer, A1           ; Display space
00003378  103C 000E               3798              MOVE.B      #14, D0             ; command for trap call to display message
0000337C  4E4F                    3799              TRAP        #15                 ; trap call
0000337E                          3800              
0000337E  B63C 0000               3801              CMP.B       #zero,D3
00003382  6700 003A               3802              BEQ         displayA0D
00003386  B63C 0001               3803              CMP.B       #one,D3
0000338A  6700 004E               3804              BEQ         displayA1D
0000338E  B63C 0002               3805              CMP.B       #two,D3
00003392  6700 0062               3806              BEQ         displayA2D
00003396  B63C 0003               3807              CMP.B       #three,D3
0000339A  6700 0076               3808              BEQ         displayA3D
0000339E  B63C 0004               3809              CMP.B       #four,D3
000033A2  6700 008A               3810              BEQ         displayA4D
000033A6  B63C 0005               3811              CMP.B       #five,D3
000033AA  6700 009E               3812              BEQ         displayA5D
000033AE  B63C 0006               3813              CMP.B       #six,D3
000033B2  6700 00B2               3814              BEQ         displayA6D
000033B6  B63C 0007               3815              CMP.B       #seven,D3
000033BA  6700 00C6               3816              BEQ         displayA7D
000033BE                          3817              
000033BE                          3818  displayA0D  
000033BE  43F9 00003D76           3819              LEA         dispA0, A1          ; Display space
000033C4  103C 000E               3820              MOVE.B      #14, D0             ; command for trap call to display message
000033C8  4E4F                    3821              TRAP        #15                 ; trap call
000033CA  43F9 00003CDE           3822              LEA         clPer, A1           ; Display space
000033D0  103C 000E               3823              MOVE.B      #14, D0             ; command for trap call to display message
000033D4  4E4F                    3824              TRAP        #15                 ; trap call
000033D6  6000 019A               3825              BRA         endSUB              ; go to the end of the subroutine
000033DA                          3826              
000033DA                          3827  displayA1D  
000033DA  43F9 00003D79           3828              LEA         dispA1, A1          ; Display space
000033E0  103C 000E               3829              MOVE.B      #14, D0             ; command for trap call to display message
000033E4  4E4F                    3830              TRAP        #15                 ; trap call
000033E6  43F9 00003CDE           3831              LEA         clPer, A1           ; Display space
000033EC  103C 000E               3832              MOVE.B      #14, D0             ; command for trap call to display message
000033F0  4E4F                    3833              TRAP        #15                 ; trap call
000033F2  6000 017E               3834              BRA         endSUB              ; go to the end of the subroutine
000033F6                          3835  
000033F6                          3836  displayA2D  
000033F6  43F9 00003D7C           3837              LEA         dispA2, A1          ; Display space
000033FC  103C 000E               3838              MOVE.B      #14, D0             ; command for trap call to display message
00003400  4E4F                    3839              TRAP        #15                 ; trap call
00003402  43F9 00003CDE           3840              LEA         clPer, A1           ; Display space
00003408  103C 000E               3841              MOVE.B      #14, D0             ; command for trap call to display message
0000340C  4E4F                    3842              TRAP        #15                 ; trap call
0000340E  6000 0162               3843              BRA         endSUB              ; go to the end of the subroutine
00003412                          3844  
00003412                          3845  displayA3D  
00003412  43F9 00003D7F           3846              LEA         dispA3, A1          ; Display space
00003418  103C 000E               3847              MOVE.B      #14, D0             ; command for trap call to display message
0000341C  4E4F                    3848              TRAP        #15                 ; trap call
0000341E  43F9 00003CDE           3849              LEA         clPer, A1           ; Display space
00003424  103C 000E               3850              MOVE.B      #14, D0             ; command for trap call to display message
00003428  4E4F                    3851              TRAP        #15                 ; trap call
0000342A  6000 0146               3852              BRA         endSUB              ; go to the end of the subroutine
0000342E                          3853  
0000342E                          3854  displayA4D  
0000342E  43F9 00003D82           3855              LEA         dispA4, A1          ; Display space
00003434  103C 000E               3856              MOVE.B      #14, D0             ; command for trap call to display message
00003438  4E4F                    3857              TRAP        #15                 ; trap call
0000343A  43F9 00003CDE           3858              LEA         clPer, A1           ; Display space
00003440  103C 000E               3859              MOVE.B      #14, D0             ; command for trap call to display message
00003444  4E4F                    3860              TRAP        #15                 ; trap call
00003446  6000 012A               3861              BRA         endSUB              ; go to the end of the subroutine
0000344A                          3862  
0000344A                          3863  displayA5D  
0000344A  43F9 00003D85           3864              LEA         dispA5, A1          ; Display space
00003450  103C 000E               3865              MOVE.B      #14, D0             ; command for trap call to display message
00003454  4E4F                    3866              TRAP        #15                 ; trap call
00003456  43F9 00003CDE           3867              LEA         clPer, A1           ; Display space
0000345C  103C 000E               3868              MOVE.B      #14, D0             ; command for trap call to display message
00003460  4E4F                    3869              TRAP        #15                 ; trap call
00003462  6000 010E               3870              BRA         endSUB              ; go to the end of the subroutine
00003466                          3871  
00003466                          3872  displayA6D  
00003466  43F9 00003D88           3873              LEA         dispA6, A1          ; Display space
0000346C  103C 000E               3874              MOVE.B      #14, D0             ; command for trap call to display message
00003470  4E4F                    3875              TRAP        #15                 ; trap call
00003472  43F9 00003CDE           3876              LEA         clPer, A1           ; Display space
00003478  103C 000E               3877              MOVE.B      #14, D0             ; command for trap call to display message
0000347C  4E4F                    3878              TRAP        #15                 ; trap call
0000347E  6000 00F2               3879              BRA         endSUB              ; go to the end of the subroutine
00003482                          3880  
00003482                          3881  displayA7D  
00003482  43F9 00003D8B           3882              LEA         dispA7, A1          ; Display space
00003488  103C 000E               3883              MOVE.B      #14, D0             ; command for trap call to display message
0000348C  4E4F                    3884              TRAP        #15                 ; trap call
0000348E  43F9 00003CDE           3885              LEA         clPer, A1           ; Display space
00003494  103C 000E               3886              MOVE.B      #14, D0             ; command for trap call to display message
00003498  4E4F                    3887              TRAP        #15                 ; trap call
0000349A  6000 00D6               3888              BRA         endSUB              ; go to the end of the subroutine
0000349E                          3889  
0000349E                          3890  ***********************************************************************************************************
0000349E                          3891  * Display Hex
0000349E                          3892  
0000349E                          3893  pHex        
0000349E  B63C 0000               3894              CMP.B       #zero, D3
000034A2  6700 0012               3895              BEQ         AbsShort
000034A6  B63C 0001               3896              CMP.B       #one, D3
000034AA  6700 0042               3897              BEQ         AbsLong
000034AE  B63C 0004               3898              CMP.B       #four, D3
000034B2  6700 0072               3899              BEQ         DispImm
000034B6                          3900              
000034B6                          3901  AbsShort    
000034B6  43F9 00003CDC           3902              LEA         opPer, A1           ; Display space
000034BC  103C 000E               3903              MOVE.B      #14, D0             ; command for trap call to display message
000034C0  4E4F                    3904              TRAP        #15                 ; trap call
000034C2                          3905              
000034C2  43F9 00003CD8           3906              LEA         dispHex, A1         ; Display space
000034C8  103C 000E               3907              MOVE.B      #14, D0             ; command for trap call to display message
000034CC  4E4F                    3908              TRAP        #15                 ; trap call
000034CE                          3909              
000034CE  4241                    3910              CLR         D1
000034D0  3218                    3911              MOVE.W      (A0)+, D1
000034D2  4240                    3912              CLR         D0
000034D4  103C 0004               3913              MOVE.B      #4, D0
000034D8                          3914              
000034D8  4EB9 00003A9A           3915              JSR         outHex
000034DE                          3916              
000034DE  43F9 00003CDE           3917              LEA         clPer, A1           ; Display space
000034E4  103C 000E               3918              MOVE.B      #14, D0             ; command for trap call to display message
000034E8  4E4F                    3919              TRAP        #15                 ; trap call
000034EA                          3920              
000034EA  6000 0086               3921              BRA         endSub
000034EE                          3922              
000034EE                          3923  AbsLong     
000034EE  43F9 00003CDC           3924              LEA         opPer, A1           ; Display space
000034F4  103C 000E               3925              MOVE.B      #14, D0             ; command for trap call to display message
000034F8  4E4F                    3926              TRAP        #15                 ; trap call
000034FA                          3927              
000034FA  43F9 00003CD8           3928              LEA         dispHex, A1         ; Display space
00003500  103C 000E               3929              MOVE.B      #14, D0             ; command for trap call to display message
00003504  4E4F                    3930              TRAP        #15                 ; trap call
00003506                          3931              
00003506  4241                    3932              CLR         D1
00003508  2218                    3933              MOVE.L      (A0)+, D1
0000350A  4240                    3934              CLR         D0
0000350C  103C 0008               3935              MOVE.B      #8, D0
00003510                          3936              
00003510  4EB9 00003A9A           3937              JSR         outHex
00003516                          3938              
00003516  43F9 00003CDE           3939              LEA         clPer, A1           ; Display space
0000351C  103C 000E               3940              MOVE.B      #14, D0             ; command for trap call to display message
00003520  4E4F                    3941              TRAP        #15                 ; trap call
00003522                          3942              
00003522  6000 004E               3943              BRA         endSub
00003526                          3944  
00003526                          3945  DispImm     
00003526  43F9 00003CD6           3946              LEA         hashTag, A1         ; Display space
0000352C  103C 000E               3947              MOVE.B      #14, D0             ; command for trap call to display message
00003530  4E4F                    3948              TRAP        #15                 ; trap call
00003532                          3949  
00003532  43F9 00003CD8           3950              LEA         dispHex, A1         ; Display space
00003538  103C 000E               3951              MOVE.B      #14, D0             ; command for trap call to display message
0000353C  4E4F                    3952              TRAP        #15                 ; trap call
0000353E                          3953              
0000353E  BC3C 0001               3954              CMP.B       #1,D6
00003542  6700 0016               3955              BEQ         ImmLong
00003546                          3956              
00003546  4241                    3957              CLR         D1
00003548  3218                    3958              MOVE.W      (A0)+, D1
0000354A  4240                    3959              CLR         D0
0000354C  103C 0004               3960              MOVE.B      #4, D0
00003550  4EB9 00003A9A           3961              JSR         outHex
00003556  6000 0012               3962              BRA         LongSkip
0000355A                          3963              
0000355A                          3964  ImmLong     
0000355A  4241                    3965              CLR         D1
0000355C  2218                    3966              MOVE.L      (A0)+, D1
0000355E  4240                    3967              CLR         D0
00003560  103C 0008               3968              MOVE.B      #8, D0
00003564  4EB9 00003A9A           3969              JSR         outHex             
0000356A                          3970  
0000356A                          3971  LongSkip
0000356A  6000 0006               3972              BRA         endSub
0000356E                          3973  
0000356E                          3974  invalid
0000356E  6000 06F4               3975              BRA         printInvalid
00003572                          3976  
00003572                          3977  endSUB        
00003572  4CDF 7EFF               3978              MOVEM.L     (SP)+, D0-D7/A1-A6
00003576  4E75                    3979              RTS
00003578                          3980  
00003578                          3981  ***********************************************************************************************************
00003578                          3982  *
00003578                          3983  *                       MOVEM Helper Function
00003578                          3984  *       This function is dedicated to printing out the address and data register for MOVEM. The 
00003578                          3985  *       function starts by identifying the size and then identifying the dr field. If the dr field
00003578                          3986  *       is 1, then the program goes to print before print out the address and data register for MOVEM. If dr
00003578                          3987  *       field is zero, program goes to print out the address and data register before printing out the
00003578                          3988  *       post increment or immediate data.
00003578                          3989  *
00003578                          3990  ***********************************************************************************************************
00003578                          3991  
00003578                          3992  MOVEMBRA    
00003578  48E7 FF7E               3993              MOVEM.L     D0-D7/A1-A6, -(SP)  ; Branches off depending on size bit
0000357C  BA7C 0000               3994              CMP         #zero,D5            ; Checks the size to see if it word
00003580  6700 000E               3995              BEQ         MOVEMW              ; Branches if it is equal to word
00003584  BA7C 0001               3996              CMP         #one, D5            ; Compares bits to long.
00003588  6700 0022               3997              BEQ         MOVEML              ; Branches if it is equal to long size.
0000358C  6000 06D6               3998              BRA         printInvalid        ; Is invalid if it is not equal to either
00003590                          3999              
00003590                          4000  MOVEMW     
00003590  43F9 00003D70           4001              LEA         dispWord, A1        ; Prints a W to symbolize word
00003596  103C 000E               4002              MOVE.B      #14, D0             ; command for trap call to display message
0000359A  4E4F                    4003              TRAP        #15                 ; trap call
0000359C                          4004  
0000359C  43F9 00003CD3           4005              LEA         space, A1           ; Print a space
000035A2  103C 000E               4006              MOVE.B      #14, D0             ; command for trap call to display message
000035A6  4E4F                    4007              TRAP        #15                 ; trap call
000035A8                          4008              
000035A8  6000 001E               4009              BRA         CheckDR
000035AC                          4010  
000035AC                          4011  MOVEML   
000035AC  43F9 00003D73           4012              LEA         dispLong, A1        ; we know that the opcode will be MOVEML, so load A1 to print message
000035B2  103C 000E               4013              MOVE.B      #14, D0             ; command for trap call to display message
000035B6  4E4F                    4014              TRAP        #15                 ; trap call
000035B8                          4015  
000035B8  43F9 00003CD3           4016              LEA         space, A1           ; Print a space
000035BE  103C 000E               4017              MOVE.B      #14, D0             ; command for trap call to display message
000035C2  4E4F                    4018              TRAP        #15                 ; trap call
000035C4                          4019           
000035C4                          4020  
000035C4  6000 0002               4021              BRA         CheckDR             ; Branch to CheckDR
000035C8                          4022  
000035C8                          4023  CheckDR     
000035C8  3218                    4024              MOVE.W      (A0)+, D1           ; Taking in next word
000035CA  BC7C 0000               4025              CMP         #zero,D6            ; Check if dr is 0, then print out data/address first
000035CE  6700 0020               4026              BEQ         printRegMem         ; branch to printRegMem
000035D2  BC7C 0001               4027              CMP         #one,D6             ; dr field is one, must print stack pointer first
000035D6  6700 0004               4028              BEQ         printStack          ; Go to print stack pointer
000035DA  6092                    4029              BRA         invalid             ; Go to invalid if equal to neither
000035DC                          4030              
000035DC                          4031  printStack 
000035DC  4EB8 2EF6               4032              JSR         printEA             ; Prints out the stack pointer
000035E0                          4033              
000035E0  43F9 00003CDA           4034              LEA         comma,A1            ; Prints out comma
000035E6  103C 000E               4035              MOVE.B      #14, D0             ; command for trap call to display message
000035EA  4E4F                    4036              TRAP        #15                 ; trap call
000035EC                          4037              
000035EC                          4038              
000035EC  6000 0002               4039              BRA         printRegMem
000035F0                          4040             
000035F0                          4041  printRegMem 
000035F0  4244                    4042              CLR         D4                  ; Using D4 to store predecrement mode addresses
000035F2  1801                    4043              MOVE.B      D1,D4               ; Stores bits for D0-D7
000035F4                          4044              
000035F4  4245                    4045              CLR         D5                  ; Clear data register
000035F6  1A01                    4046              MOVE.B      D1,D5               ; Move bits containing information on filled data to D5
000035F8  CA7C 0001               4047              AND         #mask1,D5           ; Use a bit mask to mask every bit except for the first bit
000035FC  BA7C 0001               4048              CMP         #mask1,D5           ; Check if certain bit is 1 or 0
00003600  6700 0076               4049              BEQ         DataReg0            ; If comparison matches, then data register that is being put on stack starts her
00003604                          4050              
00003604  4245                    4051              CLR         D5                  ; Clear data register
00003606  1A01                    4052              MOVE.B      D1,D5               ; Move bits containing information on filled data to D5
00003608  CA7C 0002               4053              AND         #mask2,D5           ; Use a bit mask to mask every bit except for the second bit
0000360C  BA7C 0002               4054              CMP         #mask2,D5           ; Check if certain bit is 1 or 0
00003610  6700 0096               4055              BEQ         DataReg1            ; If comparison matches, then data register that is being put on stack starts here
00003614                          4056  
00003614  4245                    4057              CLR         D5                  ; Clear data register
00003616  1A01                    4058              MOVE.B      D1,D5               ; Move bits containing information on filled data to D5
00003618  CA7C 0004               4059              AND         #mask3,D5           ; Use a bit mask to mask every bit except for the third bit
0000361C  BA7C 0004               4060              CMP         #mask3,D5           ; Check if certain bit is 1 or 0
00003620  6700 00C6               4061              BEQ         DataReg2            ; If comparison matches, then data register that is being put on stack starts her
00003624                          4062              
00003624  4245                    4063              CLR         D5                  ; Clear data register
00003626  1A01                    4064              MOVE.B      D1,D5               ; Move bits containing information on filled data to D5
00003628  CA7C 0008               4065              AND         #mask4,D5           ; Use a bit mask to mask every bit except for the fourth
0000362C  BA7C 0008               4066              CMP         #mask4,D5           ; Check if certain bit is 1 or 0
00003630  6700 00F6               4067              BEQ         DataReg3            ; If comparison matches, then data register that is being put on stack starts her
00003634                          4068              
00003634  4245                    4069              CLR         D5                  ; Clear data register
00003636  1A01                    4070              MOVE.B      D1,D5               ; Move bits containing information on filled address/data to D5
00003638  CA7C 0010               4071              AND         #mask5,D5           ; Use a bit mask to mask every bit except for the fifth bit
0000363C  BA7C 0010               4072              CMP         #mask5,D5           ; Check if certain bit is 1 or 0
00003640  6700 0126               4073              BEQ         DataReg4            ; If comparison matches, then data register that is being put on stack starts her
00003644                          4074  
00003644  4245                    4075              CLR         D5                  ; Clear data register
00003646  1A01                    4076              MOVE.B      D1,D5               ; Move bits containing information on filled address/data to D5
00003648  CA7C 0020               4077              AND         #mask6,D5           ; Use a bit mask to mask every bit except for the sixth bit
0000364C  BA7C 0020               4078              CMP         #mask6,D5           ; Check if certain bit is 1 or 0
00003650  6700 0156               4079              BEQ         DataReg5            ; If comparison matches, then data register that is being put on stack starts her
00003654                          4080  
00003654  4245                    4081              CLR         D5                  ; Clear data register
00003656  1A01                    4082              MOVE.B      D1,D5               ; Move bits containing information on filled address/data to D5
00003658  CA7C 0040               4083              AND         #mask7,D5           ; Use a bit mask to mask every bit except for the seventh
0000365C  BA7C 0040               4084              CMP         #mask7,D5           ; Check if certain bit is 1 or 0
00003660  6700 0186               4085              BEQ         DataReg6            ; If comparison matches, then data register that is being put on stack starts her
00003664                          4086  
00003664  4245                    4087              CLR         D5                  ; Clear data register
00003666  1A01                    4088              MOVE.B      D1,D5               ; Move bits containing information on filled address/data to D5
00003668  CA7C 0080               4089              AND         #mask8,D5           ; Use a bit mask to mask every bit except for the seventh
0000366C  BA7C 0080               4090              CMP         #mask8,D5           ; Check if certain bit is 1 or 0
00003670  6700 01B6               4091              BEQ         DataReg7            ; If comparison matches, then only D7 is being used
00003674                          4092              
00003674  6000 FEF8               4093              BRA         invalid             ; If comaparisons fail then this is not MOVEM. Branch out.
00003678                          4094              
00003678                          4095  DataReg0
00003678  43F9 00003D90           4096              LEA         dispD0, A1          ; Output string D0
0000367E  103C 000E               4097              MOVE.B      #14, D0             ; command for trap call to display message
00003682  4E4F                    4098              TRAP        #15                 ; trap call
00003684                          4099              
00003684  4245                    4100              CLR         D5                  ; Clear data register
00003686  1A01                    4101              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003688  CA7C 0002               4102              AND         #mask2,D5           ; Uses mask to check for valid after current bit
0000368C  BA7C 0002               4103              CMP         #mask2,D5           ; Check if there are anymore data registers used
00003690  6700 0006               4104              BEQ         Reg0Cont            ; Continues to check for last register used if so
00003694  6000 01A2               4105              BRA         printMem            ; Else it will continue on to print the address/memory
00003698                          4106              
00003698                          4107  Reg0Cont        
00003698  43F9 00003CE0           4108              LEA         dec, A1             ; Output -
0000369E  103C 000E               4109              MOVE.B      #14, D0             ; command for trap call to display message
000036A2  4E4F                    4110              TRAP        #15                 ; trap call        
000036A4  6000 0002               4111              BRA         DataReg1            ; Found starting register move on to find ending register
000036A8                          4112  
000036A8                          4113  DataReg1
000036A8  4245                    4114              CLR         D5                  ; Clear data register
000036AA  1A01                    4115              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000036AC  CA7C 0005               4116              AND         #maskA,D5           ; Uses mask to check for valid bits before and after current bit
000036B0  BA7C 0005               4117              CMP         #maskA,D5           ; Check if there are bits before and after current masked bit
000036B4  6700 0032               4118              BEQ         DataReg2            ; Branch to skip printing until the end register is found
000036B8                          4119              
000036B8  43F9 00003D93           4120              LEA         dispD1, A1          ; Output string D0
000036BE  103C 000E               4121              MOVE.B      #14, D0             ; command for trap call to display message
000036C2  4E4F                    4122              TRAP        #15                 ; trap call
000036C4                          4123              
000036C4  4245                    4124              CLR         D5                  ; Clear data register
000036C6  1A01                    4125              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000036C8  CA7C 0004               4126              AND         #mask3,D5           ; Bitmasking to check if next bit is used or not
000036CC  BA7C 0004               4127              CMP         #mask3,D5           ; Checking if next bit is use
000036D0  6700 0006               4128              BEQ         Reg1Cont            ; Continues to check for last register used if so
000036D4  6000 0162               4129              BRA         printMem            ; Else it will continue on to print the address/memory
000036D8                          4130              
000036D8                          4131  Reg1Cont        
000036D8  43F9 00003CE0           4132              LEA         dec, A1             ; Output -
000036DE  103C 000E               4133              MOVE.B      #14, D0             ; command for trap call to display message
000036E2  4E4F                    4134              TRAP        #15                 ; trap call        
000036E4  6000 0002               4135              BRA         DataReg2            ; Found starting register move on to find ending registe
000036E8                          4136  
000036E8                          4137  DataReg2
000036E8  4245                    4138              CLR         D5                  ; Clear data register
000036EA  1A01                    4139              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000036EC  CA7C 000A               4140              AND         #maskB,D5           ; Uses mask to check for valid bits before and after current bit
000036F0  BA7C 000A               4141              CMP         #maskB,D5           ; Check if there are bits before and after current masked bit
000036F4  6700 0032               4142              BEQ         DataReg3            ; If there are bits before and after, skip to next register to find ending
000036F8                          4143              
000036F8                          4144              
000036F8  43F9 00003D96           4145              LEA         dispD2, A1          ; Output D2
000036FE  103C 000E               4146              MOVE.B      #14, D0             ; command for trap call to display message
00003702  4E4F                    4147              TRAP        #15                 ; trap call
00003704                          4148              
00003704  4245                    4149              CLR         D5                  ; Clear data register
00003706  1A01                    4150              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003708  CA7C 0008               4151              AND         #mask4,D5           ; Bitmasking to check if next bit is used or not
0000370C  BA7C 0008               4152              CMP         #mask4,D5           ; Checking if next bit is used
00003710  6700 0006               4153              BEQ         Reg2Cont            ; Continues to check for last register used if so
00003714  6000 0122               4154              BRA         printMem            ; Else it will continue on to print the address/memory
00003718                          4155              
00003718                          4156  Reg2Cont        
00003718  43F9 00003CE0           4157              LEA         dec, A1             ; Output -
0000371E  103C 000E               4158              MOVE.B      #14, D0             ; command for trap call to display message
00003722  4E4F                    4159              TRAP        #15                 ; trap call        
00003724  6000 0002               4160              BRA         DataReg3            ; Found starting register move on to find ending registe
00003728                          4161  
00003728                          4162  DataReg3
00003728  4245                    4163              CLR         D5                  ; Clear data register
0000372A  1A01                    4164              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
0000372C  CA7C 0014               4165              AND         #maskC,D5           ; Uses mask to check for valid bits before and after current bit
00003730  BA7C 0014               4166              CMP         #maskC,D5           ; Check if there are bits before and after current masked bit
00003734  6700 0032               4167              BEQ         DataReg4            ; If there are bits before and after, skip to next register to find ending
00003738                          4168      
00003738                          4169              
00003738  43F9 00003D99           4170              LEA         dispD3, A1          ; Output string D0
0000373E  103C 000E               4171              MOVE.B      #14, D0             ; command for trap call to display message
00003742  4E4F                    4172              TRAP        #15                 ; trap call
00003744                          4173              
00003744  4245                    4174              CLR         D5                  ; Clear data register
00003746  1A01                    4175              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003748  CA7C 0010               4176              AND         #mask5,D5           ; Bitmasking to check if next bit is used or not
0000374C  BA7C 0010               4177              CMP         #mask5,D5
00003750  6700 0006               4178              BEQ         Reg3Cont            ; Continues to check for last register used if so
00003754  6000 00E2               4179              BRA         printMem            ; Else it will continue on to print the address/memory
00003758                          4180              
00003758                          4181  Reg3Cont        
00003758  43F9 00003CE0           4182              LEA         dec, A1             ; Output -
0000375E  103C 000E               4183              MOVE.B      #14, D0             ; command for trap call to display message
00003762  4E4F                    4184              TRAP        #15                 ; trap call        
00003764  6000 0002               4185              BRA         DataReg4            ; Found starting register move on to find ending registe
00003768                          4186  
00003768                          4187  DataReg4
00003768  4245                    4188              CLR         D5                  ; Clear data register
0000376A  1A01                    4189              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
0000376C  CA7C 0028               4190              AND         #maskD,D5           ; Uses mask to check for valid bits before and after current bit
00003770  BA7C 0028               4191              CMP         #maskD,D5           ; Check if there are bits before and after current masked bit
00003774  6700 0032               4192              BEQ         DataReg5            ; If there are bits before and after, skip to next register to find ending
00003778                          4193              
00003778  43F9 00003D9C           4194              LEA         dispD4, A1          ; Output string D0
0000377E  103C 000E               4195              MOVE.B      #14, D0             ; command for trap call to display message
00003782  4E4F                    4196              TRAP        #15                 ; trap call
00003784                          4197              
00003784  4245                    4198              CLR         D5                  ; Clear data register
00003786  1A01                    4199              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003788  CA7C 0020               4200              AND         #mask6,D5           ; Bitmasking to check if next bit is used or not
0000378C  BA7C 0020               4201              CMP         #mask6,D5           ; Checking if next bit is use
00003790  6700 0006               4202              BEQ         Reg4Cont            ; Continues to check for last register used if so
00003794  6000 00A2               4203              BRA         printMem            ; Else it will continue on to print the address/memory
00003798                          4204              
00003798                          4205  Reg4Cont        
00003798  43F9 00003CE0           4206              LEA         dec, A1             ; Output -
0000379E  103C 000E               4207              MOVE.B      #14, D0             ; command for trap call to display message
000037A2  4E4F                    4208              TRAP        #15                 ; trap call        
000037A4  6000 0002               4209              BRA         DataReg5            ; Found starting register move on to find ending registe
000037A8                          4210  
000037A8                          4211  DataReg5
000037A8  4245                    4212              CLR         D5                  ; Clear data register
000037AA  1A01                    4213              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000037AC  CA7C 0050               4214              AND         #maskE,D5           ; Uses mask to check for valid bits before and after current bit
000037B0  BA7C 0050               4215              CMP         #maskE,D5           ; Check if there are bits before and after current masked bit
000037B4  6700 0032               4216              BEQ         DataReg6            ; If there are bits before and after, skip to next register to find ending
000037B8                          4217              
000037B8  43F9 00003D9F           4218              LEA         dispD5, A1          ; Output string D0
000037BE  103C 000E               4219              MOVE.B      #14, D0             ; command for trap call to display message
000037C2  4E4F                    4220              TRAP        #15                 ; trap call
000037C4                          4221              
000037C4  4245                    4222              CLR         D5                  ; Clear data register
000037C6  1A01                    4223              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000037C8  CA7C 0040               4224              AND         #mask7,D5           ; Bitmasking to check if next bit is used or not
000037CC  BA7C 0040               4225              CMP         #mask7,D5           ; Checking if next bit is use
000037D0  6700 0006               4226              BEQ         Reg5Cont            ; Continues to check for last register used if so
000037D4  6000 0062               4227              BRA         printMem            ; Else it will continue on to print the address/memory
000037D8                          4228              
000037D8                          4229  Reg5Cont        
000037D8  43F9 00003CE0           4230              LEA         dec, A1             ; Output -
000037DE  103C 000E               4231              MOVE.B      #14, D0             ; command for trap call to display message
000037E2  4E4F                    4232              TRAP        #15                 ; trap call        
000037E4  6000 0042               4233              BRA         DataReg7            ; Found starting register move on to find ending registe
000037E8                          4234  
000037E8                          4235  DataReg6
000037E8  4245                    4236              CLR         D5                  ; Clear data register
000037EA  1A01                    4237              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000037EC  CA7C 00A0               4238              AND         #maskF,D5           ; Uses mask to check for valid bits before and after current bit
000037F0  BA7C 00A0               4239              CMP         #maskF,D5           ; Check if there are bits before and after current masked bit
000037F4  6700 0032               4240              BEQ         DataReg7            ; If there are bits before and after, skip to next register to find ending
000037F8                          4241  
000037F8  43F9 00003DA2           4242              LEA         dispD6, A1          ; Output string D0
000037FE  103C 000E               4243              MOVE.B      #14, D0             ; command for trap call to display message
00003802  4E4F                    4244              TRAP        #15                 ; trap call
00003804                          4245              
00003804  4245                    4246              CLR         D5                  ; Clear data register
00003806  1A01                    4247              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003808  CA7C 0080               4248              AND         #mask8,D5           ; Bitmasking to check if next bit is used or not
0000380C  BA7C 0080               4249              CMP         #mask8,D5           ; Checking if next bit is use
00003810  6700 0006               4250              BEQ         Reg6Cont            ; Continues to check for last register used if so
00003814  6000 0022               4251              BRA         printMem            ; Else it will continue on to print the address/memory
00003818                          4252              
00003818                          4253  Reg6Cont        
00003818  43F9 00003CE0           4254              LEA         dec, A1             ; Output -
0000381E  103C 000E               4255              MOVE.B      #14, D0             ; command for trap call to display message
00003822  4E4F                    4256              TRAP        #15                 ; trap call        
00003824  6000 0002               4257              BRA         DataReg7            ; Found starting register move on to find ending registe
00003828                          4258  
00003828                          4259  DataReg7    
00003828  43F9 00003DA5           4260              LEA         dispD7, A1          ; Output -
0000382E  103C 000E               4261              MOVE.B      #14, D0             ; command for trap call to display message
00003832  4E4F                    4262              TRAP        #15                 ; trap call        
00003834  6000 0002               4263              BRA         printMem            ; Last check, branch to print out the address register     
00003838                          4264              
00003838                          4265  printMem                                    ; Made this function in order to reuse if DR is 1
00003838  6000 0002               4266              BRA         printMemNow         ; Branch out to printMemNow
0000383C                          4267              
0000383C                          4268  printMemNow                           
0000383C  43F9 00003D66           4269              LEA         slash, A1           ; Display slash
00003842  103C 000E               4270              MOVE.B      #14, D0             ; command for trap call to display message
00003846  4E4F                    4271              TRAP        #15                 ; trap call
00003848                          4272           
00003848  4244                    4273              CLR         D4                  ; Using D4 to store predecrement mode addresses
0000384A  3801                    4274              MOVE.W      D1,D4               ; Stores bits for D0-D7
0000384C  E044                    4275              ASR         #eight,D4           ; Rotate to the right, to create space for next byte
0000384E                          4276              
0000384E  4245                    4277              CLR         D5                  ; Clear space
00003850  1A04                    4278              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
00003852  CA7C 0001               4279              AND         #mask1,D5           ; Use a bit mask to mask every bit except for the first bit
00003856  BA7C 0001               4280              CMP         #mask1,D5           ; Check if certain bit is 1 or 0
0000385A  6700 0072               4281              BEQ         AddrReg0            ; If comparison matches, then address register that is being put on stack starts here
0000385E                          4282              
0000385E  4245                    4283              CLR         D5                  ; Clear data register 
00003860  1A04                    4284              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
00003862  CA7C 0002               4285              AND         #mask2,D5           ; Use a bit mask to mask every bit except for the second bit
00003866  BA7C 0002               4286              CMP         #mask2,D5           ; Check if certain bit is 1 or 0
0000386A  6700 0092               4287              BEQ         AddrReg1            ; If comparison matches, then address register that is being put on stack starts here
0000386E                          4288  
0000386E  4245                    4289              CLR         D5                  ; Clear data register
00003870  1A04                    4290              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
00003872  CA7C 0004               4291              AND         #mask3,D5           ; Use a bit mask to mask every bit except for the third
00003876  BA7C 0004               4292              CMP         #mask3,D5           ; Check if certain bit is 1 or 0
0000387A  6700 00C2               4293              BEQ         AddrReg2            ; If comparison matches, then address register that is being put on stack starts here         
0000387E                          4294              
0000387E  4245                    4295              CLR         D5                  ; Clear data register
00003880  1A04                    4296              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
00003882  CA7C 0008               4297              AND         #mask4,D5           ; Use a bit mask to mask every bit except for the fourth bit
00003886  BA7C 0008               4298              CMP         #mask4,D5           ; Check if certain bit is 1 or 0
0000388A  6700 00F2               4299              BEQ         AddrReg3            ; If comparison matches, then address register that is being put on stack starts here     
0000388E                          4300                  
0000388E  4245                    4301              CLR         D5                  ; Clear data register
00003890  1A04                    4302              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
00003892  CA7C 0010               4303              AND         #mask5,D5           ; Use a bit mask to mask every bit except for the fifth bit
00003896  BA7C 0010               4304              CMP         #mask5,D5           ; Check if certain bit is 1 or 0
0000389A  6700 0122               4305              BEQ         AddrReg4            ; If comparison matches, then address register that is being put on stack starts here
0000389E                          4306  
0000389E  4245                    4307              CLR         D5                  ; Clear data register
000038A0  1A04                    4308              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
000038A2  CA7C 0020               4309              AND         #mask6,D5           ; Use a bit mask to mask every bit except for the sixth bit
000038A6  BA7C 0020               4310              CMP         #mask6,D5           ; Check if certain bit is 1 or 0
000038AA  6700 0152               4311              BEQ         AddrReg5            ; If comparison matches, then address register that is being put on stack starts here
000038AE                          4312  
000038AE  4245                    4313              CLR         D5                  ; Clear data register
000038B0  1A04                    4314              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
000038B2  CA7C 0040               4315              AND         #mask7,D5           ; Use a bit mask to mask every bit except for the seventh bit
000038B6  BA7C 0040               4316              CMP         #mask7,D5           ; Check if certain bit is 1 or 0
000038BA  6700 0182               4317              BEQ         AddrReg6            ; If comparison matches, then address register that is being put on stack starts here
000038BE                          4318  
000038BE  4245                    4319              CLR         D5                  ; Clear data register
000038C0  1A04                    4320              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
000038C2  CA7C 0080               4321              AND         #mask8,D5           ; Use a bit mask to mask every bit except for the last bit
000038C6  BA7C 0080               4322              CMP         #mask8,D5           ; Check if certain bit is 1 or 0
000038CA  6700 01B2               4323              BEQ         AddrReg7            ; If comparison matches, then address register that is being put on stack starts here
000038CE                          4324              
000038CE                          4325  AddrReg0
000038CE                          4326  
000038CE  43F9 00003D76           4327              LEA         dispA0, A1          ; Output string D0
000038D4  103C 000E               4328              MOVE.B      #14, D0             ; command for trap call to display message
000038D8  4E4F                    4329              TRAP        #15                 ; trap call
000038DA                          4330              
000038DA  4245                    4331              CLR         D5                  ; Clear data register
000038DC  1A01                    4332              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000038DE  CA7C 0002               4333              AND         #mask2,D5           ; Bitmasking to check if next bit is used or not
000038E2  BA7C 0002               4334              CMP         #mask2,D5           ; Checking if next bit is use
000038E6  6700 0006               4335              BEQ         Addr0Cont           ; Continues to check for last register used if so
000038EA  6000 01A2               4336              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
000038EE                          4337              
000038EE                          4338  Addr0Cont        
000038EE  43F9 00003CE0           4339              LEA         dec, A1             ; Output -
000038F4  103C 000E               4340              MOVE.B      #14, D0             ; command for trap call to display message
000038F8  4E4F                    4341              TRAP        #15                 ; trap call        
000038FA  6000 0002               4342              BRA         AddrReg1            ; Branch to second address
000038FE                          4343  
000038FE                          4344  AddrReg1
000038FE  4245                    4345              CLR         D5                  ; Clear data register
00003900  1A04                    4346              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003902  CA7C 0005               4347              AND         #maskA,D5           ; Uses mask to check for valid bits before and after current bit
00003906  BA7C 0005               4348              CMP         #maskA,D5           ; Check if there are bits before and after current masked bit
0000390A  6700 0032               4349              BEQ         AddrReg2            ; Skip print and move to next address to check if it the last address used
0000390E                          4350              
0000390E  43F9 00003D79           4351              LEA         dispA1, A1          ; Output string D0
00003914  103C 000E               4352              MOVE.B      #14, D0             ; command for trap call to display message
00003918  4E4F                    4353              TRAP        #15                 ; trap call
0000391A                          4354              
0000391A  4245                    4355              CLR         D5                  ; Clear data register
0000391C  1A04                    4356              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
0000391E  CA7C 0004               4357              AND         #mask3,D5           ; Bitmasking to check if next bit is used or not
00003922  BA7C 0004               4358              CMP         #mask3,D5           ; Checking if next bit is use
00003926  6700 0006               4359              BEQ         Addr1Cont           ; Continues to check for last register used if so
0000392A  6000 0162               4360              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
0000392E                          4361              
0000392E                          4362  Addr1Cont        
0000392E  43F9 00003CE0           4363              LEA         dec, A1             ; Output -
00003934  103C 000E               4364              MOVE.B      #14, D0             ; command for trap call to display message
00003938  4E4F                    4365              TRAP        #15                 ; trap call        
0000393A  6000 0002               4366              BRA         AddrReg2            ; Skip print and move to next address to check if it the last address used    
0000393E                          4367  
0000393E                          4368  AddrReg2
0000393E  4245                    4369              CLR         D5                  ; Clear data register
00003940  1A04                    4370              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003942  CA7C 000A               4371              AND         #maskB,D5           ; Uses mask to check for valid bits before and after current bit
00003946  BA7C 000A               4372              CMP         #maskB,D5           ; Check if there are bits before and after current masked bit
0000394A  6700 0032               4373              BEQ         AddrReg3            ; If there are bits before and after, skip to next register to find ending
0000394E                          4374  
0000394E                          4375              
0000394E  43F9 00003D7C           4376              LEA         dispA2, A1          ; Output string D0
00003954  103C 000E               4377              MOVE.B      #14, D0             ; command for trap call to display message
00003958  4E4F                    4378              TRAP        #15                 ; trap call
0000395A                          4379              
0000395A  4245                    4380              CLR         D5                  ; Clear data register
0000395C  1A04                    4381              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
0000395E  CA7C 0008               4382              AND         #mask4,D5           ; Bitmasking to check if next bit is used or not
00003962  BA7C 0008               4383              CMP         #mask4,D5           ; Checking if next bit is use
00003966  6700 0006               4384              BEQ         Addr2Cont           ; Continues to check for last register used if so
0000396A  6000 0122               4385              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
0000396E                          4386              
0000396E                          4387  Addr2Cont        
0000396E  43F9 00003CE0           4388              LEA         dec, A1             ; Output -
00003974  103C 000E               4389              MOVE.B      #14, D0             ; command for trap call to display message
00003978  4E4F                    4390              TRAP        #15                 ; trap call        
0000397A  6000 0002               4391              BRA         AddrReg3            ; Skip print and move to next address to check if it the last address used
0000397E                          4392  
0000397E                          4393  AddrReg3
0000397E  4245                    4394              CLR         D5                  ; Clear data register
00003980  1A04                    4395              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003982  CA7C 0014               4396              AND         #maskC,D5           ; Uses mask to check for valid bits before and after current bit
00003986  BA7C 0014               4397              CMP         #maskC,D5           ; Check if there are bits before and after current masked bit
0000398A  6700 0032               4398              BEQ         AddrReg4            ; If there are bits before and after, skip to next register to find ending
0000398E                          4399              
0000398E  43F9 00003D7F           4400              LEA         dispA3, A1          ; Output string D0
00003994  103C 000E               4401              MOVE.B      #14, D0             ; command for trap call to display message
00003998  4E4F                    4402              TRAP        #15                 ; trap call
0000399A                          4403              
0000399A  4245                    4404              CLR         D5                  ; Clear data register
0000399C  1A04                    4405              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
0000399E  CA7C 0010               4406              AND         #mask5,D5           ; Bitmasking to check if next bit is used or not  
000039A2  BA7C 0010               4407              CMP         #mask5,D5           ; Checking if next bit is use
000039A6  6700 0006               4408              BEQ         Addr3Cont           ; Continues to check for last register used if so
000039AA  6000 00E2               4409              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
000039AE                          4410              
000039AE                          4411  Addr3Cont        
000039AE  43F9 00003CE0           4412              LEA         dec, A1             ; Output -
000039B4  103C 000E               4413              MOVE.B      #14, D0             ; command for trap call to display message
000039B8  4E4F                    4414              TRAP        #15                 ; trap call        
000039BA  6000 0002               4415              BRA         AddrReg4
000039BE                          4416  
000039BE                          4417  AddrReg4
000039BE  4245                    4418              CLR         D5                  ; Clear data register
000039C0  1A04                    4419              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
000039C2  CA7C 0028               4420              AND         #maskD,D5           ; Uses mask to check for valid bits before and after current bit
000039C6  BA7C 0028               4421              CMP         #maskD,D5           ; Check if there are bits before and after current masked bit
000039CA  6700 0032               4422              BEQ         AddrReg5            ; If there are bits before and after, skip to next register to find ending
000039CE                          4423              
000039CE  43F9 00003D82           4424              LEA         dispA4, A1          ; Output string D0
000039D4  103C 000E               4425              MOVE.B      #14, D0             ; command for trap call to display message
000039D8  4E4F                    4426              TRAP        #15                 ; trap call
000039DA                          4427              
000039DA  4245                    4428              CLR         D5                  ; Clear data register
000039DC  1A04                    4429              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
000039DE  CA7C 0020               4430              AND         #mask6,D5           ; Bitmasking to check if next bit is used or not 
000039E2  BA7C 0020               4431              CMP         #mask6,D5           ; Checking if next bit is use
000039E6  6700 0006               4432              BEQ         Addr4Cont           ; Continues to check for last register used if so
000039EA  6000 00A2               4433              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
000039EE                          4434              
000039EE                          4435  Addr4Cont        
000039EE  43F9 00003CE0           4436              LEA         dec, A1             ; Output -
000039F4  103C 000E               4437              MOVE.B      #14, D0             ; command for trap call to display message
000039F8  4E4F                    4438              TRAP        #15                 ; trap call        
000039FA  6000 0002               4439              BRA         AddrReg5
000039FE                          4440  AddrReg5
000039FE  4245                    4441              CLR         D5                  ; Clear data register
00003A00  1A04                    4442              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003A02  CA7C 0050               4443              AND         #maskE,D5           ; Uses mask to check for valid bits before and after current bit
00003A06  BA7C 0050               4444              CMP         #maskE,D5           ; Check if there are bits before and after current masked bit
00003A0A  6700 0032               4445              BEQ         AddrReg6            ; If there are bits before and after, skip to next register to find ending
00003A0E                          4446              
00003A0E  43F9 00003D85           4447              LEA         dispA5, A1          ; Output string D0
00003A14  103C 000E               4448              MOVE.B      #14, D0             ; command for trap call to display message
00003A18  4E4F                    4449              TRAP        #15                 ; trap call
00003A1A                          4450              
00003A1A  4245                    4451              CLR         D5                  ; Clear data register
00003A1C  1A04                    4452              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003A1E  CA7C 0040               4453              AND         #mask7,D5           ; Bitmasking to check if next bit is used or not
00003A22  BA7C 0040               4454              CMP         #mask7,D5           ; Checking if next bit is use
00003A26  6700 0006               4455              BEQ         Addr5Cont           ; Continues to check for last register used if so
00003A2A  6000 0062               4456              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
00003A2E                          4457              
00003A2E                          4458  Addr5Cont        
00003A2E  43F9 00003CE0           4459              LEA         dec, A1             ; Output -
00003A34  103C 000E               4460              MOVE.B      #14, D0             ; command for trap call to display message
00003A38  4E4F                    4461              TRAP        #15                 ; trap call        
00003A3A  6000 0042               4462              BRA         AddrReg7
00003A3E                          4463  
00003A3E                          4464  AddrReg6
00003A3E  4245                    4465              CLR         D5                  ; Clear data register
00003A40  1A04                    4466              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003A42  CA7C 00A0               4467              AND         #maskF,D5           ; Uses mask to check for valid bits before and after current bit
00003A46  BA7C 00A0               4468              CMP         #maskF,D5           ; Check if there are bits before and after current masked bit
00003A4A  6700 0032               4469              BEQ         AddrReg7            ; If there are bits before and after, skip to next register to find ending
00003A4E                          4470  
00003A4E  43F9 00003D88           4471              LEA         dispA6, A1          ; Output string D0
00003A54  103C 000E               4472              MOVE.B      #14, D0             ; command for trap call to display message
00003A58  4E4F                    4473              TRAP        #15                 ; trap call
00003A5A                          4474              
00003A5A  4245                    4475              CLR         D5                  ; Clear data register
00003A5C  1A04                    4476              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003A5E  CA7C 0080               4477              AND         #mask8,D5           ; Bitmasking to check if next bit is used or not
00003A62  BA7C 0080               4478              CMP         #mask8,D5           ; Checking if next bit is use
00003A66  6700 0006               4479              BEQ         Addr6Cont           ; Continues to check for last register used if so
00003A6A  6000 0022               4480              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
00003A6E                          4481              
00003A6E                          4482  Addr6Cont        
00003A6E  43F9 00003CE0           4483              LEA         dec, A1             ; Output -
00003A74  103C 000E               4484              MOVE.B      #14, D0             ; command for trap call to display message
00003A78  4E4F                    4485              TRAP        #15                 ; trap call        
00003A7A  6000 0002               4486              BRA         AddrReg7            ; Skip print and move to next address to check if it the last address used
00003A7E                          4487  
00003A7E                          4488  AddrReg7    
00003A7E  43F9 00003D8B           4489              LEA         dispA7, A1          ; Output -
00003A84  103C 000E               4490              MOVE.B      #14, D0             ; command for trap call to display message
00003A88  4E4F                    4491              TRAP        #15                 ; trap call        
00003A8A  6000 0002               4492              BRA         endMOVE             ; Skip print and move to next address to check if it the last address used
00003A8E                          4493          
00003A8E                          4494  endMOVE
00003A8E  4CDF 7EFF               4495              MOVEM.L  (SP)+, D0-D7/A1-A6     ; Pops all data and address register off the stack
00003A92  4E75                    4496              RTS
00003A94                          4497  endMove1                                    ; Used if MOVEM has DR is 1
00003A94  4CDF 7EFF               4498              MOVEM.L  (SP)+, D0-D7/A1-A6
00003A98  4E75                    4499              RTS
00003A9A                          4500  ***********************************************************************************************************
00003A9A                          4501  *
00003A9A                          4502  *                       Hex Decode
00003A9A                          4503  *
00003A9A                          4504  *this subroutine displays hex code stored in D1. It displays based on the number of 
00003A9A                          4505  *It displays based on the number of hex to display which is stored in D0. If it is a
00003A9A                          4506  *long or word to display, it will figure out the ascii character and add $37 if it
00003A9A                          4507  *is a letter, and $30 if its a number. It will then load the character into D1 and 
00003A9A                          4508  *display it via trap task 6 and loop however many times is needed, 4 or 8. If a word
00003A9A                          4509  *needs to be displayed, it will roll the bits over so that, the hex are shifted by a word.
00003A9A                          4510  *
00003A9A                          4511  ***********************************************************************************************************
00003A9A                          4512  
00003A9A                          4513  outHex      
00003A9A  48E7 FF7E               4514              MOVEM.L     D0-D7/A1-A6, -(SP)
00003A9E  4243                    4515              CLR         D3
00003AA0  4244                    4516              CLR         D4
00003AA2  1800                    4517              MOVE.B      D0, D4
00003AA4  2601                    4518              MOVE.L      D1, D3
00003AA6  B03C 0004               4519              CMP.B       #4, D0
00003AAA  6700 0006               4520              BEQ         moveOver
00003AAE  6000 0006               4521              BRA         dispLOOP
00003AB2                          4522              
00003AB2                          4523  moveOver    
00003AB2  E19B                    4524              ROL.L       #8,D3
00003AB4  E19B                    4525              ROL.L       #8,D3
00003AB6                          4526              
00003AB6                          4527  dispLOOP    
00003AB6  B83C 0000               4528              CMP.B       #0, D4
00003ABA  6700 0042               4529              BEQ         endDispSub
00003ABE  E99B                    4530              ROL.L       #4, D3
00003AC0  4245                    4531              CLR         D5
00003AC2  1A03                    4532              MOVE.B      D3, D5 
00003AC4  CABC 0000000F           4533              AND.L       #$0F, D5
00003ACA  BA3C 000A               4534              CMP.B       #10, D5
00003ACE  6D00 0006               4535              BLT         DLnine
00003AD2  6000 0016               4536              BRA         DLetters
00003AD6                          4537              
00003AD6                          4538  DLnine      
00003AD6  0645 0030               4539              ADD         #$30, D5
00003ADA  4241                    4540              CLR         D1
00003ADC  1205                    4541              MOVE.B      D5, D1
00003ADE  4240                    4542              CLR         D0
00003AE0  103C 0006               4543              MOVE.B      #6, D0
00003AE4  4E4F                    4544              TRAP        #15
00003AE6  5344                    4545              SUB         #1, D4
00003AE8  60CC                    4546              BRA         dispLOOP  
00003AEA                          4547   
00003AEA                          4548  DLetters    
00003AEA  0645 0037               4549              ADD         #$37, D5
00003AEE  4241                    4550              CLR         D1
00003AF0  1205                    4551              MOVE.B      D5, D1
00003AF2  4240                    4552              CLR         D0
00003AF4  103C 0006               4553              MOVE.B      #6, D0
00003AF8  4E4F                    4554              TRAP        #15
00003AFA  5344                    4555              SUB         #1, D4
00003AFC  60B8                    4556              BRA         dispLOOP        
00003AFE                          4557  
00003AFE                          4558  endDispSub  
00003AFE  4CDF 7EFF               4559              MOVEM.L     (SP)+, D0-D7/A1-A6
00003B02  4E75                    4560              RTS
00003B04                          4561  
00003B04                          4562              
00003B04                          4563  ***********************************************************************************************************
00003B04                          4564  *
00003B04                          4565  *                       IO Subroutine
00003B04                          4566  *
00003B04                          4567  *
00003B04                          4568  *   the following subroutine gets the string address from the user
00003B04                          4569  *   and converts it to Hex for a starting/ending address. it is done 
00003B04                          4570  *   by checking each byte at address A1, and converting it from ascii to 
00003B04                          4571  *   hex number. If the user enters an invalid character string, the
00003B04                          4572  *   program will have a simhalt.
00003B04                          4573  *
00003B04                          4574  ***********************************************************************************************************
00003B04                          4575  
00003B04                          4576  Address     
00003B04  48E7 1F3E               4577              MOVEM.L     D3-D7/A2-A6, -(SP)
00003B08                          4578  
00003B08                          4579  Retry       
00003B08  4242                    4580              CLR         D2
00003B0A  4243                    4581              CLR         D3
00003B0C  B23C 0004               4582              CMP.B       #4, D1
00003B10  6700 000E               4583              BEQ         subLOOP
00003B14  B23C 0008               4584              CMP.B       #8, D1
00003B18  6700 0006               4585              BEQ         subLOOP
00003B1C  6000 012A               4586              BRA         ADDinvalid        
00003B20                          4587          
00003B20                          4588  subLOOP     
00003B20  E85C                    4589              ROR         #4, D4
00003B22  1404                    4590              MOVE.B      D4, D2
00003B24  4244                    4591              CLR         D4
00003B26  4245                    4592              CLR         D5
00003B28  B601                    4593              CMP.B       D1, D3
00003B2A  6700 0132               4594              BEQ         endLOOP
00003B2E  5443                    4595              ADD.W       #2, D3
00003B30  E19A                    4596              ROL.L       #8, D2
00003B32                          4597          
00003B32                          4598  bytLOOP     
00003B32  E95C                    4599              ROL         #4, D4
00003B34                          4600          
00003B34  0C11 0030               4601              CMP.B       #$30, (A1)
00003B38  6700 007E               4602              BEQ         hZero 
00003B3C  0C11 0031               4603              CMP.B       #$31, (A1)
00003B40  6700 007E               4604              BEQ         hOne
00003B44  0C11 0032               4605              CMP.B       #$32, (A1)
00003B48  6700 007E               4606              BEQ         hTwo
00003B4C  0C11 0033               4607              CMP.B       #$33, (A1)
00003B50  6700 007E               4608              BEQ         hThree
00003B54  0C11 0034               4609              CMP.B       #$34, (A1)
00003B58  6700 007E               4610              BEQ         hFour
00003B5C  0C11 0035               4611              CMP.B       #$35, (A1)
00003B60  6700 007E               4612              BEQ         hFive
00003B64  0C11 0036               4613              CMP.B       #$36, (A1)
00003B68  6700 007E               4614              BEQ         hSix
00003B6C  0C11 0037               4615              CMP.B       #$37, (A1)
00003B70  6700 007E               4616              BEQ         hSeven
00003B74  0C11 0038               4617              CMP.B       #$38, (A1)
00003B78  6700 007E               4618              BEQ         hEight
00003B7C  0C11 0039               4619              CMP.B       #$39, (A1)
00003B80  6700 007E               4620              BEQ         hNine
00003B84  0C11 0041               4621              CMP.B       #$41, (A1)
00003B88  6700 007E               4622              BEQ         hA
00003B8C  0C11 0042               4623              CMP.B       #$42, (A1)
00003B90  6700 007E               4624              BEQ         hB
00003B94  0C11 0043               4625              CMP.B       #$43, (A1)
00003B98  6700 007E               4626              BEQ         hC
00003B9C  0C11 0044               4627              CMP.B       #$44, (A1)
00003BA0  6700 007E               4628              BEQ         hD
00003BA4  0C11 0045               4629              CMP.B       #$45, (A1)
00003BA8  6700 007E               4630              BEQ         hE
00003BAC  0C11 0046               4631              CMP.B       #$46, (A1)
00003BB0  6700 007E               4632              BEQ         hF 
00003BB4                          4633              
00003BB4  6000 F9B8               4634              BRA         invalid 
00003BB8                          4635              
00003BB8                          4636  hZero       
00003BB8  183C 0000               4637              MOVE.B      #$00, D4
00003BBC  6000 007A               4638              BRA         nextH
00003BC0                          4639              
00003BC0                          4640  hOne        
00003BC0  183C 0010               4641              MOVE.B      #$10, D4
00003BC4  6000 0072               4642              BRA         nextH
00003BC8                          4643  hTwo        
00003BC8  183C 0020               4644              MOVE.B      #$20, D4
00003BCC  6000 006A               4645              BRA         nextH
00003BD0                          4646              
00003BD0                          4647  hThree      
00003BD0  183C 0030               4648              MOVE.B      #$30, D4
00003BD4  6000 0062               4649              BRA         nextH
00003BD8                          4650              
00003BD8  183C 0040               4651  hFour       MOVE.B      #$40, D4
00003BDC  6000 005A               4652              BRA         nextH
00003BE0                          4653              
00003BE0                          4654  hFive       
00003BE0  183C 0050               4655              MOVE.B      #$50, D4
00003BE4  6000 0052               4656              BRA         nextH
00003BE8                          4657              
00003BE8                          4658  hSix        
00003BE8  183C 0060               4659              MOVE.B      #$60, D4
00003BEC  6000 004A               4660              BRA         nextH
00003BF0                          4661              
00003BF0                          4662  hSeven      
00003BF0  183C 0070               4663              MOVE.B      #$70, D4
00003BF4  6000 0042               4664              BRA         nextH
00003BF8                          4665              
00003BF8                          4666  hEight      
00003BF8  183C 0080               4667              MOVE.B      #$80, D4
00003BFC  6000 003A               4668              BRA         nextH
00003C00                          4669              
00003C00                          4670  hNine       
00003C00  183C 0090               4671              MOVE.B      #$90, D4
00003C04  6000 0032               4672              BRA         nextH
00003C08                          4673          
00003C08                          4674  hA          
00003C08  183C 00A0               4675              MOVE.B      #$A0, D4
00003C0C  6000 002A               4676              BRA         nextH
00003C10                          4677              
00003C10                          4678  hB          
00003C10  183C 00B0               4679              MOVE.B      #$B0, D4
00003C14  6000 0022               4680              BRA         nextH
00003C18                          4681              
00003C18                          4682  hC          
00003C18  183C 00C0               4683              MOVE.B      #$C0, D4
00003C1C  6000 001A               4684              BRA         nextH
00003C20                          4685              
00003C20                          4686  hD          
00003C20  183C 00D0               4687              MOVE.B      #$D0, D4
00003C24  6000 0012               4688              BRA         nextH
00003C28                          4689              
00003C28                          4690  hE          
00003C28  183C 00E0               4691              MOVE.B      #$E0, D4
00003C2C  6000 000A               4692              BRA         nextH
00003C30                          4693              
00003C30                          4694  hF          
00003C30  183C 00F0               4695              MOVE.B      #$F0, D4
00003C34  6000 0002               4696              BRA         nextH
00003C38                          4697  
00003C38                          4698  nextH       
00003C38  1019                    4699              MOVE.B      (A1)+, D0
00003C3A  5245                    4700              ADD         #1, D5
00003C3C  BA3C 0002               4701              CMP.B       #2, D5
00003C40  6700 FEDE               4702              BEQ         subLOOP
00003C44  6000 FEEC               4703              BRA         bytLOOP
00003C48                          4704          
00003C48                          4705  ADDinvalid  
00003C48  43F9 00003CB0           4706              LEA         errorMessage, A1
00003C4E  103C 000E               4707              MOVE.B      #14, D0
00003C52  4E4F                    4708              TRAP        #15    
00003C54                          4709      
00003C54  103C 0002               4710              MOVE.B      #2, D0
00003C58  4E4F                    4711              TRAP        #15
00003C5A                          4712  
00003C5A  6000 FEAC               4713              BRA         Retry
00003C5E                          4714     
00003C5E                          4715  endLOOP     
00003C5E  4CDF 7CF8               4716              MOVEM.L     (SP)+, D3-D7/A2-A6
00003C62  4E75                    4717              RTS
00003C64                          4718  
00003C64                          4719  printInvalid
00003C64  1218                    4720              MOVE.B      (A0)+,D1
00003C66  6000 D3D8               4721              BRA         LOOP
00003C6A                          4722  
00003C6A                          4723  endPROG    
00003C6A                          4724  
00003C6A  FFFF FFFF               4725      SIMHALT                             ; halt simulator
00003C6E                          4726  
00003C6E                          4727  ***********************************************************************************************************
00003C6E                          4728  *
00003C6E                          4729  *                       IO Strings
00003C6E                          4730  *           
00003C6E                          4731  *       This section holds all of the various strings to output to the console.
00003C6E                          4732  *
00003C6E                          4733  ***********************************************************************************************************
00003C6E                          4734  
00003C6E= 45 6E 74 65 72 20 ...   4735  startingMessage DC.B    'Enter Starting Address (in hex): ', 0
00003C90= 45 6E 74 65 72 20 ...   4736  endingMessage   DC.B    'Enter Ending Address (in hex): ', 0
00003CB0= 49 6E 63 6F 72 72 ...   4737  errorMessage    DC.B    'Incorrect Address, try again: ', 0
00003CCF                          4738  
00003CCF= 20 0D 0A 00             4739  newLine         DC.B    ' ', CR, LF, 0
00003CD3= 20 20 00                4740  space           DC.B    '  ', 0
00003CD6                          4741  
00003CD6= 23 00                   4742  hashTag         DC.B    '#', 0
00003CD8= 24 00                   4743  dispHex         DC.B    '$', 0
00003CDA= 2C 00                   4744  comma           DC.B    ',', 0
00003CDC                          4745  
00003CDC= 28 00                   4746  opPer           DC.B    '(', 0
00003CDE= 29 00                   4747  clPer           DC.B    ')', 0
00003CE0= 2D 00                   4748  dec             DC.B    '-', 0
00003CE2= 2B 00                   4749  inc             DC.B    '+', 0
00003CE4                          4750  
00003CE4= 4F 52 49 00             4751  ORImatch        DC.B    'ORI', 0
00003CE8= 43 4D 50 49 00          4752  CMPImatch       DC.B    'CMPI', 0
00003CED= 42 43 4C 52 00          4753  BCLRmatch       DC.B    'BCLR', 0
00003CF2= 4D 4F 56 45 00          4754  MOVEmatch       DC.B    'MOVE', 0
00003CF7= 4D 4F 56 45 41 00       4755  MOVEAmatch      DC.B    'MOVEA', 0
00003CFD= 4E 45 47 00             4756  NEGmatch        DC.B    'NEG', 0
00003D01= 52 54 53 00             4757  RTSmatch        DC.B    'RTS', 0
00003D05= 4A 53 52 00             4758  JSRmatch        DC.B    'JSR', 0
00003D09= 4D 4F 56 45 4D 00       4759  MOVEMmatch      DC.B    'MOVEM', 0
00003D0F= 4C 45 41 00             4760  LEAmatch        DC.B    'LEA', 0
00003D13= 53 55 42 51 00          4761  SUBQmatch       DC.B    'SUBQ', 0
00003D18= 42 52 41 00             4762  BRAmatch        DC.B    'BRA', 0
00003D1C= 42 43 53 00             4763  BCSmatch        DC.B    'BCS', 0
00003D20= 42 56 43 00             4764  BVCmatch        DC.B    'BVC', 0
00003D24= 42 47 45 00             4765  BGEmatch        DC.B    'BGE', 0
00003D28= 42 4C 54 00             4766  BLTmatch        DC.B    'BLT', 0
00003D2C= 44 49 56 53 00          4767  DIVSmatch       DC.B    'DIVS', 0
00003D31= 4F 52 00                4768  ORmatch         DC.B    'OR', 0
00003D34= 53 55 42 00             4769  SUBmatch        DC.B    'SUB', 0
00003D38= 45 4F 52 00             4770  EORmatch        DC.B    'EOR', 0
00003D3C= 43 4D 50 00             4771  CMPmatch        DC.B    'CMP', 0
00003D40= 4D 55 4C 53 00          4772  MULSmatch       DC.B    'MULS', 0
00003D45= 41 44 44 00             4773  ADDmatch        DC.B    'ADD', 0
00003D49= 41 44 44 41 00          4774  ADDAmatch       DC.B    'ADDA', 0
00003D4E= 4C 53 52 00             4775  LSRmatch        DC.B    'LSR', 0
00003D52= 4C 53 4C 00             4776  LSLmatch        DC.B    'LSL', 0
00003D56= 41 53 52 00             4777  ASRmatch        DC.B    'ASR', 0
00003D5A= 41 53 4C 00             4778  ASLmatch        DC.B    'ASL', 0
00003D5E= 52 4F 52 00             4779  RORmatch        DC.B    'ROR', 0
00003D62= 52 4F 4C 00             4780  ROLmatch        DC.B    'ROL', 0
00003D66                          4781  
00003D66= 2F 00                   4782  slash           DC.B    '/', 0
00003D68= 28 53 50 29 00          4783  stack           DC.B    '(SP)', 0
00003D6D                          4784   
00003D6D= 2E 42 00                4785  dispByte        DC.B    '.B', 0
00003D70= 2E 57 00                4786  dispWord        DC.B    '.W', 0
00003D73= 2E 4C 00                4787  dispLong        DC.B    '.L', 0
00003D76                          4788  
00003D76= 41 30 00                4789  dispA0          DC.B    'A0', 0
00003D79= 41 31 00                4790  dispA1          DC.B    'A1', 0
00003D7C= 41 32 00                4791  dispA2          DC.B    'A2', 0
00003D7F= 41 33 00                4792  dispA3          DC.B    'A3', 0
00003D82= 41 34 00                4793  dispA4          DC.B    'A4', 0
00003D85= 41 35 00                4794  dispA5          DC.B    'A5', 0
00003D88= 41 36 00                4795  dispA6          DC.B    'A6', 0
00003D8B= 41 37 00                4796  dispA7          DC.B    'A7', 0
00003D8E                          4797  
00003D8E= 44 00                   4798  dispD           DC.B    'D',0
00003D90= 44 30 00                4799  dispD0          DC.B    'D0', 0
00003D93= 44 31 00                4800  dispD1          DC.B    'D1', 0
00003D96= 44 32 00                4801  dispD2          DC.B    'D2', 0
00003D99= 44 33 00                4802  dispD3          DC.B    'D3', 0
00003D9C= 44 34 00                4803  dispD4          DC.B    'D4', 0
00003D9F= 44 35 00                4804  dispD5          DC.B    'D5', 0
00003DA2= 44 36 00                4805  dispD6          DC.B    'D6', 0
00003DA5= 44 37 00                4806  dispD7          DC.B    'D7', 0 
00003DA8                          4807   
00003DA8                          4808             END    START                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             34EE
ABSSHORT            34B6
ADDAMATCH           3D49
ADDINVALID          3C48
ADDMATCH            3D45
ADDR0CONT           38EE
ADDR1CONT           392E
ADDR2CONT           396E
ADDR3CONT           39AE
ADDR4CONT           39EE
ADDR5CONT           3A2E
ADDR6CONT           3A6E
ADDRESS             3B04
ADDRREG0            38CE
ADDRREG1            38FE
ADDRREG2            393E
ADDRREG3            397E
ADDRREG4            39BE
ADDRREG5            39FE
ADDRREG6            3A3E
ADDRREG7            3A7E
ASLMATCH            3D5A
ASRMATCH            3D56
BCLRMATCH           3CED
BCSMATCH            3D1C
BGEMATCH            3D24
BLTMATCH            3D28
BRAEIGHT            114A
BRAELEVEN           1168
BRAFIVE             1112
BRAFOUR             10F6
BRAFOURTEEN         11D8
BRAMATCH            3D18
BRANINE             1164
BRAONE              10EA
BRASIX              1116
BRATHIRTEEN         1186
BRATHREE            10F2
BRATWELVE           1182
BRATWO              10EE
BRAZERO             10BA
BVCMATCH            3D20
BYTLOOP             3B32
CHECKDR             35C8
CLPER               3CDE
CMPIMATCH           3CE8
CMPMATCH            3D3C
COMMA               3CDA
CR                  D
DATAREG0            3678
DATAREG1            36A8
DATAREG2            36E8
DATAREG3            3728
DATAREG4            3768
DATAREG5            37A8
DATAREG6            37E8
DATAREG7            3828
DEC                 3CE0
DISPA0              3D76
DISPA1              3D79
DISPA2              3D7C
DISPA3              3D7F
DISPA4              3D82
DISPA5              3D85
DISPA6              3D88
DISPA7              3D8B
DISPBYTE            3D6D
DISPD               3D8E
DISPD0              3D90
DISPD1              3D93
DISPD2              3D96
DISPD3              3D99
DISPD4              3D9C
DISPD5              3D9F
DISPD6              3DA2
DISPD7              3DA5
DISPHEX             3CD8
DISPIMM             3526
DISPLAYA0           302E
DISPLAYA0A          30FA
DISPLAYA0D          33BE
DISPLAYA0P          3226
DISPLAYA1           303E
DISPLAYA1A          3116
DISPLAYA1D          33DA
DISPLAYA1P          324E
DISPLAYA2           304E
DISPLAYA2A          3132
DISPLAYA2D          33F6
DISPLAYA2P          3276
DISPLAYA3           305E
DISPLAYA3A          314E
DISPLAYA3D          3412
DISPLAYA3P          329E
DISPLAYA4           306E
DISPLAYA4A          316A
DISPLAYA4D          342E
DISPLAYA4P          32C6
DISPLAYA5           307E
DISPLAYA5A          3186
DISPLAYA5D          344A
DISPLAYA5P          32EE
DISPLAYA6           308E
DISPLAYA6A          31A2
DISPLAYA6D          3466
DISPLAYA6P          3316
DISPLAYA7           309E
DISPLAYA7A          31BE
DISPLAYA7D          3482
DISPLAYA7P          333E
DISPLAYD0           2F6E
DISPLAYD1           2F7E
DISPLAYD2           2F8E
DISPLAYD3           2F9E
DISPLAYD4           2FAE
DISPLAYD5           2FBE
DISPLAYD6           2FCE
DISPLAYD7           2FDE
DISPLAYEIGHT        2EE6
DISPLONG            3D73
DISPLOOP            3AB6
DISPWORD            3D70
DIVSMATCH           3D2C
DLETTERS            3AEA
DLNINE              3AD6
EIGHT               8
ELEVEN              B
ENDDISPSUB          3AFE
ENDINGMESSAGE       3C90
ENDLOOP             3C5E
ENDMOVE             3A8E
ENDMOVE1            3A94
ENDPROG             3C6A
ENDSUB              3572
ENDSUBROUTINE       2EF0
EORMATCH            3D38
ERRORMESSAGE        3CB0
FIRSTNIB            F0
FIVE                5
FOUR                4
FOURTEEN            E
HA                  3C08
HASHTAG             3CD6
HB                  3C10
HC                  3C18
HD                  3C20
HE                  3C28
HEIGHT              3BF8
HF                  3C30
HFIVE               3BE0
HFOUR               3BD8
HNINE               3C00
HONE                3BC0
HSEVEN              3BF0
HSIX                3BE8
HTHREE              3BD0
HTWO                3BC8
HZERO               3BB8
IMMLONG             355A
INC                 3CE2
INVALID             356E
JSRMATCH            3D05
LEAMATCH            3D0F
LF                  A
LONGSKIP            356A
LOOP                1040
LSLMATCH            3D52
LSRMATCH            3D4E
MASK0               0
MASK1               1
MASK2               2
MASK3               4
MASK4               8
MASK5               10
MASK6               20
MASK7               40
MASK8               80
MASKA               5
MASKB               A
MASKC               14
MASKD               28
MASKE               50
MASKF               A0
MEMSB               2680
MEMSHIFTIMM         2ECC
MEMSHIFTS           11F2
MEMSL               2B94
MEMSW               290A
MOVEAMATCH          3CF7
MOVEMATCH           3CF2
MOVEMBRA            3578
MOVEML              35AC
MOVEMMATCH          3D09
MOVEMW              3590
MOVEOVER            3AB2
MULSMATCH           3D40
NEGMATCH            3CFD
NEWLINE             3CCF
NEXTH               3C38
NINE                9
ONE                 1
OPADDAL             2448
OPADDAW             23D8
OPADDB              228C
OPADDL              2364
OPADDW              22F8
OPASBI              26BE
OPASBR              2720
OPASL               24B8
OPASLBI             26FE
OPASLBR             2760
OPASLI              2BD2
OPASLLI             2C12
OPASLLR             2C74
OPASLR              2C34
OPASLWI             2988
OPASLWR             29EA
OPASR               2504
OPASRBI             26DC
OPASRBR             273E
OPASRLI             2BF0
OPASRLR             2C52
OPASRWI             2966
OPASRWR             29C8
OPASWI              2948
OPASWR              29AA
OPBCLR              1536
OPBCS               20D0
OPBGE               2140
OPBLT               2178
OPBRA               2098
OPBVC               2108
OPCMP               1E00
OPCMPB              1E32
OPCMPI              13AC
OPCMPIB             13CE
OPCMPIL             14C4
OPCMPIW             1440
OPCMPL              1EE6
OPCMPW              1E8C
OPDIVS              1C58
OPDYNBCLR           159A
OPEOR               1CB2
OPEORB              1CE0
OPEORL              1DA0
OPEORW              1D40
OPJSR               1986
OPLEA               1A8A
OPLSBI              2782
OPLSBR              27E4
OPLSL               2550
OPLSLBI             27C2
OPLSLBR             2824
OPLSLI              2C96
OPLSLLI             2CD6
OPLSLLR             2D38
OPLSLR              2CF8
OPLSLWI             2A4C
OPLSLWR             2AAE
OPLSR               259C
OPLSRBI             27A0
OPLSRBR             2802
OPLSRLI             2CB4
OPLSRLR             2D16
OPLSRWI             2A2A
OPLSRWR             2A8C
OPLSWI              2A0C
OPLSWR              2A6E
OPMOVEAL            1720
OPMOVEAW            1816
OPMOVEB             1608
OPMOVEL             168C
OPMOVEM             1A00
OPMOVEMLEA          19E4
OPMOVEW             1788
OPMULS              2228
OPNEG               187E
OPNEGB              18AC
OPNEGL              18EC
OPNEGW              192C
OPOR                1B0A
OPORB               1B4A
OPORI               124C
OPORIB              127A
OPORIL              1346
OPORIW              12E0
OPORL               1BFE
OPORW               1BA4
OPPER               3CDC
OPROBI              2846
OPROBR              28A8
OPROL               25E8
OPROLBI             2886
OPROLBR             28E8
OPROLI              2D5A
OPROLLI             2D9A
OPROLLR             2DFC
OPROLR              2DBC
OPROLWI             2B10
OPROLWR             2B72
OPROR               2634
OPRORBI             2864
OPRORBR             28C6
OPRORLI             2D78
OPRORLR             2DDA
OPRORWI             2AEE
OPRORWR             2B50
OPROWI              2AD0
OPROWR              2B32
OPRTS               19C8
OPRTSJSR            196C
OPSUB               1F40
OPSUBB              1F8A
OPSUBL              203E
OPSUBQ              21B0
OPSUBQB             21E0
OPSUBQL             220C
OPSUBQW             21F6
OPSUBW              1FE4
ORIMATCH            3CE4
ORMATCH             3D31
OUTHEX              3A9A
PADDRDEC            3366
PADDRDIR            30AE
PADDRPOST           31DA
PADDRREG            2FEE
PDATAREG            2F2E
PHEX                349E
PRINTEA             2EF6
PRINTINVALID        3C64
PRINTMEM            3838
PRINTMEMNOW         383C
PRINTREGMEM         35F0
PRINTSTACK          35DC
PRNTIMM             2E1E
PRNTREG             2E7A
REG0CONT            3698
REG1CONT            36D8
REG2CONT            3718
REG3CONT            3758
REG4CONT            3798
REG5CONT            37D8
REG6CONT            3818
REGSHIFTS           1230
RETRY               3B08
ROLMATCH            3D62
RORMATCH            3D5E
RTSMATCH            3D01
SECNIB              F
SEVEN               7
SIX                 6
SKIPPRINTEA         1A7A
SLASH               3D66
SPACE               3CD3
STACK               3D68
START               1000
STARTINGMESSAGE     3C6E
SUBLOOP             3B20
SUBMATCH            3D34
SUBQMATCH           3D13
THIRTEEN            D
THREE               3
TWELVE              C
TWO                 2
ZERO                0
