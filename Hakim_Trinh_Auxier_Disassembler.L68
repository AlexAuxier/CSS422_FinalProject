00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/12/2014 2:45:13 PM

00000000                             1                                     
00000000                             2      ****       ****  *******     ****    ***      ***
00000000                             3      ****       **** *******    ********  ***     ***
00000000                             4      *****     ***** ***       ***    *** ***    ***
00000000                             5      ******   ****** ***       ***    *** ***   ***
00000000                             6      ******* ******* ***        ********  ***  ***
00000000                             7      *************** *******     ******   ********
00000000                             8      ****  ***  **** ********   ********  ***  ***
00000000                             9      ****   *   **** ***   *** ***    *** ***   ***
00000000                            10      ****       **** ***   *** ***    *** ***    ***
00000000                            11      ****       **** ***   ***  ********  ***     ***
00000000                            12      ****       ****  *******     ****    ***      ***
00000000                            13      
00000000                            14              *********          ********** ****       ****
00000000                            15              ***********      *********    ****       ****
00000000                            16              ***    *****   *********      *****     *****
00000000                            17              ***      **** ********        ******   ******
00000000                            18              ***       *** ************    ******* *******
00000000                            19              ***       *** *************** ***************
00000000                            20              ***       ***    ************ ****  ***  ****
00000000                            21              ***      ***         ******** ****   *   ****
00000000                            22              ***    *****       ********   ****       ****
00000000                            23              ***********      *********    ****       ****
00000000                            24              *********     **********      ****       ****
00000000                            25          
00000000                            26  *-----------------------------------------------------------
00000000                            27  * Title      :  Motorola 68k Instruction Dissassembler (DSM)
00000000                            28  * Written by :  Abdul Hakim, David Trinh, Alexander Auxier
00000000                            29  * Date       :  2014-12-11
00000000                            30  * Description:  Disassemble Opcodes
00000000                            31  *-----------------------------------------------------------
00000000  =0000000D                 32  CR          EQU     $0D     
00000000  =0000000A                 33  LF          EQU     $0A
00000000                            34       
00000000  =00000000                 35  zero        EQU     $00                     ; defined hex value 0
00000000  =00000001                 36  one         EQU     $01                     ; defined hex value 1 
00000000  =00000002                 37  two         EQU     $02                     ; defined hex value 2
00000000  =00000003                 38  three       EQU     $03                     ; defined hex value 3
00000000  =00000004                 39  four        EQU     $04                     ; defined hex value 4
00000000  =00000005                 40  five        EQU     $05                     ; defined hex value 5
00000000  =00000006                 41  six         EQU     $06                     ; defined hex value 6
00000000  =00000007                 42  seven       EQU     $07                     ; defined hex value 7
00000000  =00000008                 43  eight       EQU     $08                     ; defined hex value 8
00000000  =00000009                 44  nine        EQU     $09                     ; defined hex value 9
00000000  =0000000B                 45  eleven      EQU     $0B                     ; defined hex value 11
00000000  =0000000C                 46  twelve      EQU     $0C                     ; defined hex value 12
00000000  =0000000D                 47  thirteen    EQU     $0D                     ; defined hex value 13
00000000  =0000000E                 48  fourteen    EQU     $0E                     ; defined hex value 14
00000000                            49  
00000000  =00000000                 50  mask0       EQU     %00000000
00000000  =00000001                 51  mask1       EQU     %00000001
00000000  =00000002                 52  mask2       EQU     %00000010
00000000  =00000004                 53  mask3       EQU     %00000100
00000000  =00000008                 54  mask4       EQU     %00001000
00000000  =00000010                 55  mask5       EQU     %00010000
00000000  =00000020                 56  mask6       EQU     %00100000
00000000  =00000040                 57  mask7       EQU     %01000000
00000000  =00000080                 58  mask8       EQU     %10000000
00000000                            59  
00000000  =00000005                 60  maskA       EQU     %00000101
00000000  =0000000A                 61  maskB       EQU     %00001010
00000000  =00000014                 62  maskC       EQU     %00010100
00000000  =00000028                 63  maskD       EQU     %00101000
00000000  =00000050                 64  maskE       EQU     %01010000
00000000  =000000A0                 65  maskF       EQU     %10100000
00000000                            66  
00000000  =000000F0                 67  firstNib    EQU     $F0
00000000  =0000000F                 68  secNib      EQU     $0F
00000000                            69               
00001000                            70              ORG    $1000
00001000                            71  START: 
00001000                            72  ***********************************************************************************************************
00001000                            73  *
00001000                            74  *                   Dissassembler Start
00001000                            75  *
00001000                            76  ***********************************************************************************************************
00001000                            77              ; Dissassemble Start, obtain addr range
00001000                            78              
00001000                            79  RetrySAdd   
00001000  43F9 00003C78             80              LEA         startingMessage, A1 ; load starting message to A1
00001006  103C 000E                 81              MOVE.B      #14, D0             ; trap task to display message
0000100A  4E4F                      82              TRAP        #15                 ; trap call
0000100C  103C 0002                 83              MOVE.B      #2, D0              ; trap task to read input 
00001010  4E4F                      84              TRAP        #15                 ; trap call
00001012                            85      
00001012  4EB9 00003B0C             86              JSR         Address             ; jump to Address
00001018  B4BC 00004000             87              CMP.L       #$00004000, D2      ; compare minimum starting address to D2
0000101E  6DE0                      88              BLT         RetrySAdd           ; if less than, branch back up to starting address
00001020  2042                      89              MOVEA.L     D2, A0              ; move starting address to A0
00001022                            90          
00001022                            91  RetryEAdd   
00001022  43F9 00003C9A             92              LEA         endingMessage, A1   ; load ending address message to A1
00001028  103C 000E                 93              MOVE.B      #14, D0             ; trap task to display message
0000102C  4E4F                      94              TRAP        #15                 ; trap call
0000102E                            95          
0000102E  103C 0002                 96              MOVE.B      #2, D0              ; trap task to read input 
00001032  4E4F                      97              TRAP        #15                 ; trap call
00001034                            98      
00001034  4EB9 00003B0C             99              JSR         Address             ; jump to Address
0000103A  B488                     100              CMP.L       A0, D2              ; compare starting address to D2
0000103C  6DE4                     101              BLT         RetryEAdd           ; if less than, branch back up to ending address
0000103E  2442                     102              MOVEA.L     D2, A2              ; move ending address to A2
00001040                           103          
00001040  43F9 00003CD9            104              LEA         newline, A1         ; display new line
00001046  103C 000E                105              MOVE.B      #14, D0             ; trap task to display message
0000104A  4E4F                     106              TRAP        #15                 ; trap call
0000104C                           107            
0000104C                           108  ***********************************************************************************************************
0000104C                           109  *
0000104C                           110  *                   Control Loop
0000104C                           111  *
0000104C                           112  *       This loop cycles and branches our code by the first nibble of OPCODE binary
0000104C                           113  *
0000104C                           114  ***********************************************************************************************************
0000104C                           115            
0000104C  4241                     116  LOOP        CLR         D1                  ; clear out D1
0000104E  4242                     117              CLR         D2                  ; clear out D2
00001050  B1CA                     118              CMPA.L      A2, A0              ; compare starting and ending addresses
00001052  6E00 2C20                119              BGT         endProg             ; if A0 > A1, we've finished, end program
00001056  1218                     120              MOVE.B      (A0)+, D1           ; load byte to D1 and increment A0 to next byte
00001058  1401                     121              MOVE.B      D1, D2              ; copy byte to D2 for manipulation
0000105A  E882                     122              ASR.L       #four, D2           ; get first nibble in D2
0000105C                           123          
0000105C  B43C 0000                124              CMP.B       #zero, D2           ; compare with 0
00001060  6700 0064                125              BEQ         braZero             ; branch out to zero method
00001064  B43C 0001                126              CMP.B       #one, D2            ; compare with 1
00001068  6700 008C                127              BEQ         braOne              ; branch out to one method
0000106C  B43C 0002                128              CMP.B       #two, D2            ; compare with 2    
00001070  6700 0088                129              BEQ         braTwo              ; branch out to two method
00001074  B43C 0003                130              CMP.B       #three, D2          ; compare with 3
00001078  6700 0084                131              BEQ         braThree            ; branch out to three method
0000107C  B43C 0004                132              CMP.B       #four, D2           ; compare with 4
00001080  6700 0080                133              BEQ         braFour             ; branch out to four method
00001084  B43C 0005                134              CMP.B       #five, D2           ; compare with 5
00001088  6700 0094                135              BEQ         braFive             ; branch out to five method
0000108C  B43C 0006                136              CMP.B       #six, D2            ; compare with 6
00001090  6700 0090                137              BEQ         braSix              ; branch out to six method
00001094  B43C 0008                138              CMP.B       #eight, D2          ; compare with 8
00001098  6700 00BC                139              BEQ         braEight            ; branch out to eight method
0000109C  B43C 0009                140              CMP.B       #nine, D2           ; compare with 9
000010A0  6700 00CE                141              BEQ         braNine             ; branch out to nine method
000010A4  B43C 000B                142              CMP.B       #eleven, D2         ; compare with 11
000010A8  6700 00CA                143              BEQ         braEleven           ; branch out to eleven method
000010AC  B43C 000C                144              CMP.B       #twelve, D2         ; compare with 12
000010B0  6700 00DC                145              BEQ         braTwelve           ; branch out to twelve method
000010B4  B43C 000D                146              CMP.B       #thirteen, D2       ; compare with 13
000010B8  6700 00D8                147              BEQ         braThirteen         ; branch out to thirteen method
000010BC  B43C 000E                148              CMP.B       #fourteen, D2       ; compare with 14
000010C0  6700 0122                149              BEQ         braFourteen         ; branch out to fourteen method
000010C4  6086                     150              BRA         loop
000010C6                           151  
000010C6                           152  ***********************************************************************************************************
000010C6                           153  *
000010C6                           154  *                   Nibble Branch Section
000010C6                           155  *
000010C6                           156  *       This section decides which nibble goes to the corresponding opcode
000010C6                           157  *
000010C6                           158  *********************************************************************************************************** 
000010C6                           159          
000010C6                           160  braZero     
000010C6  4242                     161              CLR         D2                  ; first nibble is 0, 3 opcodes are possible 
000010C8  1401                     162              MOVE.B      D1, D2              ; clear out D2 and copy D1 back in
000010CA  C43C 000F                163              AND.B       #secNib, D2         ; set first nibble to 0
000010CE                           164  
000010CE  B43C 0000                165              CMP.B       #zero, D2           ; compare second nibble to 0
000010D2  6700 0184                166              BEQ         opORI               ; branch to ORI method
000010D6  B43C 000C                167              CMP.B       #twelve, D2         ; compare second nibble to 12
000010DA  6700 02DC                168              BEQ         opCMPI              ; branch to CMPI method
000010DE  B43C 0008                169              CMP.B       #eight,D2           ; Test for static BCLR
000010E2  6700 045E                170              BEQ         opBCLR
000010E6  C47C 0001                171              AND         #one,D2             ; Sets all bits to 0 except for first bit if it is 1
000010EA  B43C 0001                172              CMP.B       #one,D2             ; if it is one then there is a chance it is dynamic BCLR
000010EE  6700 04B6                173              BEQ         opDynBCLR
000010F2  6000 2B7A                174              BRA         printInvalid
000010F6                           175          
000010F6                           176  braOne      
000010F6  6000 051C                177              BRA         opMOVEB             ; we know that there is only one opcode that is MOVE.B
000010FA                           178  
000010FA                           179  braTwo      
000010FA  6000 059C                180              BRA         opMOVEL             ; there are two opCodes available, MOVE.L, or MOVEA.L
000010FE                           181  
000010FE                           182  braThree                                    ; there are two opCodes available, MOVE.W, or MOVEA.W
000010FE  6000 0694                183              BRA         opMOVEW
00001102                           184  
00001102  4242                     185  braFour     CLR         D2                  ; first nibble is 4, 5 opcodes are possible 
00001104  1401                     186              MOVE.B      D1, D2              ; clear out D2 and copy D1 back in
00001106  C43C 000F                187              AND.B       #secNib, D2         ; set first nibble to 0
0000110A                           188   
0000110A  B43C 0004                189              CMP.B       #four, D2           ; compare second nibble to 4
0000110E  6700 077A                190              BEQ         opNEG               ; branch to NEG method
00001112  B43C 000E                191              CMP.B       #fourteen, D2       ; compare second nibble to E
00001116  6700 0860                192              BEQ         opRTSJSR            ; branch to JSR or RTS method
0000111A  6000 08D4                193              BRA         opMOVEMLEA          ; otherwise, branch to MOVEM or LEA method
0000111E                           194  
0000111E                           195  braFive     
0000111E  6000 109C                196              BRA         opSUBQ              ; we know that there is only one opcode that is SUBQ
00001122                           197  
00001122                           198  braSix      
00001122  4242                     199              CLR         D2                  ; first nibble is 6, 5 opcodes are possible 
00001124  1401                     200              MOVE.B      D1, D2              ; clear out D2 and copy D1 back in
00001126  C43C 000F                201              AND.B       #$0F, D2             ; set first nibble to 0
0000112A                           202   
0000112A  B43C 0000                203              CMP.B       #zero, D2           ; compare second nibble to 0
0000112E  6700 0F74                204              BEQ         opBRA               ; branch to BRA method
00001132  B43C 0005                205              CMP.B       #five, D2           ; compare second nibble to 5
00001136  6700 0FA4                206              BEQ         opBCS               ; branch to BCS method
0000113A  B43C 0008                207              CMP.B       #eight, D2          ; compare second nibble to 8
0000113E  6700 0FD4                208              BEQ         opBVC               ; branch to BCS method
00001142  B43C 000C                209              CMP.B       #twelve, D2         ; compare second nibble to 12
00001146  6700 1004                210              BEQ         opBGE               ; branch to BGE method
0000114A  B43C 000D                211              CMP.B       #thirteen,D2        ; compare second nibble to 13
0000114E  6700 1034                212              BEQ         opBLT               ; branch to BLT method
00001152  6000 2B1A                213              BRA         printInvalid        ; found an un-supported opcode
00001156                           214  
00001156                           215  braEight                                    ; there are two opCodes available DIVS, or OR
00001156  4242                     216              CLR         D2                  ; clear D2 for use
00001158  E141                     217              ASL         #8,D1               ; Shift by eight 
0000115A  1218                     218              MOVE.B      (A0)+,D1            ; Move the instruction byte into D1
0000115C  3401                     219              MOVE.W      D1,D2               ; Load D2 with the word from D1
0000115E  EC42                     220              ASR         #six,D2             ; Shift by 6 to find second nibble
00001160  C47C 0007                221              AND         #$07,D2             ; AND by 7 to remove unwanted bits
00001164  B43C 0007                222              CMP.B       #seven,D2           ; Compare second nibble to 7
00001168  6700 0AFA                223              BEQ         opDIVS              ; If bits 8 - 6 are equal to 7, we have DIVS
0000116C  6000 09A8                224              BRA         opOR                ; else opcode is OR
00001170                           225  
00001170                           226  braNine     
00001170  6000 0DDA                227              BRA         opSUB               ; we know that there is only one opcode that is SUB
00001174                           228  
00001174                           229  braEleven                                   ; there are two opCodes available EOR, or CMP
00001174  4242                     230              CLR         D2                  ; clear D2 for use
00001176  E141                     231              ASL         #8,D1               ; Shift by eight for
00001178  1218                     232              MOVE.B      (A0)+,D1            ; Re-load the instruction byte into D1
0000117A  3401                     233              MOVE.W      D1,D2               ; Move the word into D2 for the comparison
0000117C  EC42                     234              ASR         #six,D2             ; Shift by 6 to find second nibble
0000117E  C47C 0007                235              AND         #$07,D2             ; AND by 7 to remove unwanted bits
00001182  B43C 0003                236              CMP.B       #three,D2           ; Compare second nibble to 3
00001186  6D00 0C84                237              BLT         opCMP               ; If opmode bits are less than 3, we have CMP
0000118A  6E00 0B32                238              BGT         opEOR               ; Else its EOR
0000118E                           239  
0000118E                           240  braTwelve   
0000118E  6000 10A4                241              BRA         opMULS              ; we know that there is only one opcode that is MULS    
00001192                           242    
00001192                           243  braThirteen 
00001192  E141                     244              ASL         #eight, D1          ; we need the whole word to compare between add and adda, so move over the current byte 
00001194  1218                     245              MOVE.B      (A0)+, D1           ; load the remaining byte to D1
00001196                           246              
00001196  4242                     247              CLR         D2                  ; clear D2
00001198  3401                     248              MOVE.W      D1, D2              ; copy opcode to D2
0000119A  EC42                     249              ASR         #six, D2            ; shift the bits right to get size and type
0000119C  C47C 0007                250              AND         #seven,D2           ; clear out all but first 3 bits
000011A0                           251              
000011A0  B43C 0000                252              CMP.B       #zero,D2            ; compare 0 to D2
000011A4  6700 10F2                253              BEQ         opADDB              ; we know its ADDB
000011A8  B43C 0001                254              CMP.B       #one, D2            ; compare 1 to D2
000011AC  6700 1156                255              BEQ         opADDW              ; we know its ADDW
000011B0  B43C 0002                256              CMP.B       #two, D2            ; compare 2 to D2
000011B4  6700 11BA                257              BEQ         opADDL              ; we know its ADDL
000011B8  B43C 0003                258              CMP.B       #three, D2          ; compare 3 to D2
000011BC  6700 1226                259              BEQ         opADDAW             ; we know its ADDAW
000011C0  B43C 0004                260              CMP.B       #four, D2           ; compare 4 to D2
000011C4  6700 10D2                261              BEQ         opADDB              ; we know its ADDB
000011C8  B43C 0005                262              CMP.B       #five, D2           ; compare 5 to D2
000011CC  6700 1136                263              BEQ         opADDW              ; we know its ADDW
000011D0  B43C 0006                264              CMP.B       #six, D2            ; compare 6 to D2
000011D4  6700 119A                265              BEQ         opADDL              ; we know its ADDL
000011D8  B43C 0007                266              CMP.B       #seven, D2          ; compare 7 to D2
000011DC  6700 1276                267              BEQ         opADDAL             ; we know its ADDAL
000011E0  6000 2A8C                268              BRA         printInvalid        ; invalid opcode
000011E4                           269               
000011E4                           270  braFourteen 
000011E4  E141                     271              ASL.W       #eight,D1           ; we need the whole word to compare between add and adda, so move over the current byte
000011E6  1218                     272              MOVE.B      (A0)+, D1           ; load the remaining byte to D1
000011E8                           273              
000011E8  4242                     274              CLR         D2                  ; clear D2
000011EA  3401                     275              MOVE.W      D1, D2              ; copy opcode to D2
000011EC  EC42                     276              ASR         #six, D2            ; shift the bits right to get size
000011EE  C47C 0003                277              AND         #03,D2
000011F2                           278          
000011F2  B43C 0003                279              CMP.B       #three, D2          ; if the size is three, we are shifting memory
000011F6  6700 0006                280              BEQ         memShifts           ; go to memory shift
000011FA  6000 0040                281              BRA         regShifts           ; else go to register shift
000011FE                           282  
000011FE                           283  memShifts   
000011FE  4242                     284              CLR         D2             
00001200  3401                     285              MOVE.W      D1, D2              ; clear out D2 and copy D1 back in
00001202  E082                     286              ASR.L       #eight,D2           ; move to get first byte back
00001204  C47C 000F                287              AND         #secNib, D2         ; set first nibble to 0
00001208                           288   
00001208  B43C 0000                289              CMP.B       #zero, D2           ; compare second nibble to 0
0000120C  6700 1302                290              BEQ         opASR               ; branch to ASR method
00001210  B43C 0001                291              CMP.B       #one, D2            ; compare second nibble to 1
00001214  6700 12AE                292              BEQ         opASL               ; branch to ASL method
00001218  B43C 0002                293              CMP.B       #two, D2            ; compare second nibble to 2
0000121C  6700 138A                294              BEQ         opLSR               ; branch to LSR method
00001220  B43C 0003                295              CMP.B       #three, D2          ; compare second nibble to 3
00001224  6700 1336                296              BEQ         opLSL               ; branch to LSL method
00001228  B43C 0006                297              CMP.B       #six, D2            ; compare second nibble to 6
0000122C  6700 1412                298              BEQ         opROR               ; branch to ROR method
00001230  B43C 0007                299              CMP.B       #seven, D2          ; compare second nibble to 7
00001234  6700 13BE                300              BEQ         opROL               ; branch to ROL method
00001238  6000 2A34                301              BRA         printInvalid        ; otherwise, invalid
0000123C                           302              
0000123C                           303  regShifts   
0000123C  B43C 0000                304              CMP.B       #zero, D2           ; if size is 0, we are shifting a byte
00001240  6700 144A                305              BEQ         memSB               ; branch to register shift byte
00001244  B43C 0001                306              CMP.B       #one, D2            ; if size is 1, we are shifting a word
00001248  6700 16CC                307              BEQ         memSW               ; branch to register shift word
0000124C  B43C 0002                308              CMP.B       #two, D2            ; if size is 1, we are shifting a long
00001250  6700 194E                309              BEQ         memSL               ; branch to register shift long
00001254  6000 2A18                310              BRA         printInvalid        ; otherwise, invalid
00001258                           311              
00001258                           312  ***********************************************************************************************************
00001258                           313  *
00001258                           314  *                   ORI OPCODE
00001258                           315  *       ORI starts out with size branching. Will compare sizes and branch to appropriate size.
00001258                           316  *       Once size is found, code will print out ORI and continue to find mode and register and print it out
00001258                           317  *
00001258                           318  ***********************************************************************************************************
00001258                           319  
00001258                           320  opORI       
00001258  43F9 00003CEE            321              LEA         ORImatch, A1        ; we know that the opcode will be ORI, so load A1 to print message
0000125E  103C 000E                322              MOVE.B      #14, D0             ; command for trap call to display message
00001262  4E4F                     323              TRAP        #15                 ; trap call
00001264                           324          
00001264  1218                     325              MOVE.B      (A0)+, D1
00001266  1401                     326              MOVE.B      D1,D2               ; copy data over
00001268  EC42                     327              ASR         #6,D2               ; shifts 6 bits over to read just the size        
0000126A  B43C 0000                328              CMP.B       #zero,D2            ; Size is 0, must be byte
0000126E  6700 0016                329              BEQ         opORIB              ; Branch to ORIB to print and deal with the byte
00001272  B43C 0001                330              CMP.B       #one,D2             ; Compare size to one
00001276  6700 0074                331              BEQ         opORIW              ; If size is one, then ORI is dealing with a word.
0000127A  B43C 0002                332              CMP.B       #two,D2             ; Compare size to two
0000127E  6700 00D2                333              BEQ         opORIL              ; If size is two then move onto deal with long in opORIL
00001282                           334          
00001282  6000 29EA                335              BRA         printInvalid        ; None matches, invalid code. Branch off.
00001286                           336          
00001286                           337  opORIB      
00001286  43F9 00003D77            338              LEA         dispByte, A1        ; Display byte
0000128C  103C 000E                339              MOVE.B      #14, D0             ; command for trap call to display message
00001290  4E4F                     340              TRAP        #15                 ; trap call
00001292                           341          
00001292  43F9 00003CDD            342              LEA         space, A1           ; Display space
00001298  103C 000E                343              MOVE.B      #14, D0             ; command for trap call to display message
0000129C  4E4F                     344              TRAP        #15                 ; trap call
0000129E                           345          
0000129E  4244                     346              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
000012A0  1801                     347              MOVE.B      D1,D4               ; Move byte over to D4 to use
000012A2  E644                     348              ASR         #three,D4           ; Moves out insignifcant bits to find mode
000012A4  C87C 0007                349              AND         #seven,D4           ; Clear other bits besides mode
000012A8  4245                     350              CLR         D5                  ; Use D5 as temporary register for destination regsiter
000012AA  1A01                     351              MOVE.B      D1,D5               ; Move data over to isolate mode
000012AC  CA7C 0007                352              AND         #seven,D5           ; Isolate the mode
000012B0                           353          
000012B0  4243                     354              CLR         D3                  ; Clear D3 to move register into it
000012B2  4242                     355              CLR         D2                  ; Clear D2 to move mode into it
000012B4  163C 0004                356              MOVE.B      #four,D3            ; Set values to be used in printEA
000012B8  143C 0007                357              MOVE.B      #seven,D2           ; Set values to be used in printEA
000012BC                           358      
000012BC  4EB9 00002F02            359              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000012C2                           360          
000012C2  43F9 00003CE4            361              LEA         comma, A1           ; Display space
000012C8  103C 000E                362              MOVE.B      #14, D0             ; command for trap call to display message
000012CC  4E4F                     363              TRAP        #15                 ; trap call
000012CE                           364          
000012CE  4242                     365              CLR         D2                  ; Clear out D2 to move destination mode in
000012D0  4243                     366              CLR         D3                  ; Clear out D3 to move destintion register in
000012D2  1404                     367              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
000012D4  1605                     368              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA
000012D6                           369          
000012D6  4EB9 00002F02            370              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000012DC                           371          
000012DC  43F9 00003CD9            372              LEA         newLine, A1           ; Display space
000012E2  103C 000E                373              MOVE.B      #14, D0             ; command for trap call to display message
000012E6  4E4F                     374              TRAP        #15                 ; trap call
000012E8                           375          
000012E8  6000 FD62                376              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000012EC                           377          
000012EC                           378  opORIW      
000012EC  43F9 00003D7A            379              LEA         dispWord, A1        ; Display byte
000012F2  103C 000E                380              MOVE.B      #14, D0             ; command for trap call to display message
000012F6  4E4F                     381              TRAP        #15                 ; trap call
000012F8                           382          
000012F8  43F9 00003CDD            383              LEA         space, A1           ; Display space
000012FE  103C 000E                384              MOVE.B      #14, D0             ; command for trap call to display message
00001302  4E4F                     385              TRAP        #15                 ; trap call
00001304                           386          
00001304  4244                     387              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
00001306  1801                     388              MOVE.B      D1,D4               ; Move byte over to D4 to use
00001308  E644                     389              ASR         #three,D4           ; Moves out insignifcant bits to find mode
0000130A  C87C 0007                390              AND         #seven,D4           ; Clear other bits besides mode
0000130E  4245                     391              CLR         D5                  ; Use D5 as temporary register for destination regsiter
00001310  1A01                     392              MOVE.B      D1,D5               ; Move data over to isolate mode
00001312  CA7C 0007                393              AND         #seven,D5           ; Isolate the mode
00001316                           394          
00001316  4243                     395              CLR         D3                  ; Clear D3 to move register into it
00001318  4242                     396              CLR         D2                  ; Clear D2 to move mode into it
0000131A  163C 0004                397              MOVE.B      #four,D3            ; Set values to be used in printEA
0000131E  143C 0007                398              MOVE.B      #seven,D2           ; Set values to be used in printEA
00001322                           399          
00001322  4EB9 00002F02            400              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001328                           401          
00001328  43F9 00003CE4            402              LEA         comma, A1           ; Display space
0000132E  103C 000E                403              MOVE.B      #14, D0             ; command for trap call to display message
00001332  4E4F                     404              TRAP        #15                 ; trap call
00001334                           405          
00001334  4242                     406              CLR         D2                  ; Clear out D2 to move destination mode in
00001336  4243                     407              CLR         D3                  ; Clear out D3 to move destintion register in
00001338  1404                     408              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
0000133A  1605                     409              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA
0000133C                           410                  
0000133C  4EB9 00002F02            411              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001342                           412          
00001342  43F9 00003CD9            413              LEA         newLine, A1           ; Display space
00001348  103C 000E                414              MOVE.B      #14, D0             ; command for trap call to display message
0000134C  4E4F                     415              TRAP        #15                 ; trap call
0000134E                           416          
0000134E  6000 FCFC                417              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001352                           418       
00001352                           419  opORIL      
00001352  43F9 00003D7D            420              LEA         dispLong, A1        ; Display byte
00001358  103C 000E                421              MOVE.B      #14, D0             ; command for trap call to display message
0000135C  4E4F                     422              TRAP        #15                 ; trap call
0000135E                           423          
0000135E  43F9 00003CDD            424              LEA         space, A1           ; Display space
00001364  103C 000E                425              MOVE.B      #14, D0             ; command for trap call to display message
00001368  4E4F                     426              TRAP        #15                 ; trap call
0000136A                           427          
0000136A  4244                     428              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
0000136C  1801                     429              MOVE.B      D1,D4               ; Move byte over to D4 to use
0000136E  E644                     430              ASR         #three,D4           ; Moves out insignifcant bits to find mode
00001370  C87C 0007                431              AND         #seven,D4           ; Clear other bits besides mode
00001374  4245                     432              CLR         D5                  ; Use D5 as temporary register for destination regsiter
00001376  1A01                     433              MOVE.B      D1,D5               ; Move data over to isolate mode
00001378  CA7C 0007                434              AND         #seven,D5           ; Isolate the mode
0000137C                           435          
0000137C  4243                     436              CLR         D3                  ; Clear D3 to move register into it
0000137E  4242                     437              CLR         D2                  ; Clear D2 to move mode into it
00001380  163C 0004                438              MOVE.B      #four,D3            ; Set values to be used in printEA
00001384  143C 0007                439              MOVE.B      #seven,D2           ; Set values to be used in printEA
00001388                           440          
00001388  4EB9 00002F02            441              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000138E                           442          
0000138E  4242                     443              CLR         D2                  ; Clear out D2 to move destination mode in
00001390  4243                     444              CLR         D3                  ; Clear out D3 to move destintion register in
00001392  1404                     445              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
00001394  1605                     446              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA
00001396                           447          
00001396  43F9 00003CE4            448              LEA         comma, A1           ; Display space
0000139C  103C 000E                449              MOVE.B      #14, D0             ; command for trap call to display message
000013A0  4E4F                     450              TRAP        #15                 ; trap call
000013A2                           451          
000013A2  4EB9 00002F02            452              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000013A8                           453          
000013A8  43F9 00003CD9            454              LEA         newLine, A1           ; Display space
000013AE  103C 000E                455              MOVE.B      #14, D0             ; command for trap call to display message
000013B2  4E4F                     456              TRAP        #15                 ; trap call
000013B4                           457          
000013B4  6000 FC96                458              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000013B8                           459          
000013B8                           460  ***********************************************************************************************************
000013B8                           461  *
000013B8                           462  *                   CMPI OPCODE
000013B8                           463  *       This section is dedicated to the compare (CMPI) instruction. Its determined in the control loop
000013B8                           464  *       that the first nibble is 0 for CMPI, and the second nibble is 12.
000013B8                           465  *       The type of CMPI, or the opmode, is used to determined what we output to our console next.
000013B8                           466  *       From that point, we load the correct size/opmode, and then route to the EA subroutine to output
000013B8                           467  *       EA related register information.
000013B8                           468  *       The process for finding the operand register info (EA info) is similar for all opmodes.
000013B8                           469  *
000013B8                           470  ***********************************************************************************************************
000013B8                           471          
000013B8                           472  opCMPI           
000013B8  1218                     473              MOVE.B      (A0)+, D1
000013BA  1401                     474              MOVE.B      D1,D2               ; copy data over
000013BC  EC42                     475              ASR         #6,D2               ; shifts 6 bits over to read just the size        
000013BE  B43C 0000                476              CMP.B       #zero,D2            ; Check if size is 0 which is byte
000013C2  6700 0016                477              BEQ         opCMPIB             ; Moves to CMPIB if it is 0
000013C6  B43C 0001                478              CMP.B       #one,D2             ; Check if size is 0 which is word
000013CA  6700 0080                479              BEQ         opCMPIW             ; Branch to CMPIW
000013CE  B43C 0002                480              CMP.B       #two,D2             ; Check if size is 2 which is long
000013D2  6700 00FC                481              BEQ         opCMPIL             ; Branch to CMPIL
000013D6  6000 21A2                482              BRA         invalid             ; Size is invalid, therefore code is invalid.
000013DA                           483  
000013DA                           484  opCMPIB 
000013DA  43F9 00003CF2            485              LEA         CMPImatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
000013E0  103C 000E                486              MOVE.B      #14, D0             ; command for trap call to display message
000013E4  4E4F                     487              TRAP        #15                 ; trap call
000013E6                           488          
000013E6  43F9 00003D77            489              LEA         dispByte, A1        ; Display byte
000013EC  103C 000E                490              MOVE.B      #14, D0             ; command for trap call to display message
000013F0  4E4F                     491              TRAP        #15                 ; trap call
000013F2                           492          
000013F2  43F9 00003CDD            493              LEA         space, A1           ; Display space
000013F8  103C 000E                494              MOVE.B      #14, D0             ; command for trap call to display message
000013FC  4E4F                     495              TRAP        #15                 ; trap call
000013FE                           496          
000013FE  4244                     497              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
00001400  1801                     498              MOVE.B      D1,D4               ; Move byte over to D4 to use
00001402  E644                     499              ASR         #three,D4           ; Moves out insignifcant bits to find mode
00001404  C87C 0007                500              AND         #seven,D4           ; Clear other bits besides mode
00001408  4245                     501              CLR         D5                  ; Use D5 as temporary register for destination regsiter
0000140A  1A01                     502              MOVE.B      D1,D5               ; Move data over to isolate mode
0000140C  CA7C 0007                503              AND         #seven,D5           ; Isolate the mode
00001410                           504          
00001410  4243                     505              CLR         D3                  ; Clear D3 to move register into it
00001412  4242                     506              CLR         D2                  ; Clear D2 to move mode into it
00001414  163C 0004                507              MOVE.B      #four,D3            ; Set values to be used in printEA
00001418  143C 0007                508              MOVE.B      #seven,D2           ; Set values to be used in printEA  
0000141C                           509          
0000141C  4EB9 00002F02            510              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001422                           511              
00001422  43F9 00003CE4            512              LEA         comma, A1           ; Display space
00001428  103C 000E                513              MOVE.B      #14, D0             ; command for trap call to display message
0000142C  4E4F                     514              TRAP        #15                 ; trap call
0000142E                           515          
0000142E  4242                     516              CLR         D2                  ; Clear out D2 to move destination mode in
00001430  4243                     517              CLR         D3                  ; Clear out D3 to move destintion register in
00001432  1404                     518              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
00001434  1605                     519              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA    
00001436                           520          
00001436  4EB9 00002F02            521              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000143C                           522          
0000143C  43F9 00003CD9            523              LEA         newLine, A1         ; Display space
00001442  103C 000E                524              MOVE.B      #14, D0             ; command for trap call to display message
00001446  4E4F                     525              TRAP        #15                 ; trap call
00001448                           526  
00001448  6000 FC02                527              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
0000144C                           528  
0000144C                           529  opCMPIW 
0000144C  43F9 00003CF2            530              LEA         CMPImatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
00001452  103C 000E                531              MOVE.B      #14, D0             ; command for trap call to display message
00001456  4E4F                     532              TRAP        #15                 ; trap call
00001458                           533          
00001458  43F9 00003D7A            534              LEA         dispWord, A1        ; Display byte
0000145E  103C 000E                535              MOVE.B      #14, D0             ; command for trap call to display message
00001462  4E4F                     536              TRAP        #15                 ; trap call
00001464                           537          
00001464  43F9 00003CDD            538              LEA         space, A1           ; Display space
0000146A  103C 000E                539              MOVE.B      #14, D0             ; command for trap call to display message
0000146E  4E4F                     540              TRAP        #15                 ; trap call
00001470                           541          
00001470  4244                     542              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
00001472  1801                     543              MOVE.B      D1,D4               ; Move byte over to D4 to use
00001474  E644                     544              ASR         #three,D4           ; Moves out insignifcant bits to find mode
00001476  C87C 0007                545              AND         #seven,D4           ; Clear other bits besides mode
0000147A  4245                     546              CLR         D5                  ; Use D5 as temporary register for destination regsiter
0000147C  1A01                     547              MOVE.B      D1,D5               ; Move data over to isolate mode
0000147E  CA7C 0007                548              AND         #seven,D5           ; Isolate the mode
00001482                           549          
00001482  4243                     550              CLR         D3                  ; Clear D3 to move register into it
00001484  4242                     551              CLR         D2                  ; Clear D2 to move mode into it
00001486  163C 0004                552              MOVE.B      #four,D3            ; Set values to be used in printEA
0000148A  143C 0007                553              MOVE.B      #seven,D2           ; Set values to be used in printEA      
0000148E                           554          
0000148E  4EB9 00002F02            555              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001494                           556          
00001494  43F9 00003CE0            557              LEA         hashTag, A1         ; Display space
0000149A  103C 000E                558              MOVE.B      #14, D0             ; command for trap call to display message
0000149E  4E4F                     559              TRAP        #15                 ; trap call
000014A0                           560          
000014A0  103C 0003                561              MOVE.B      #3, D0              ; Move 3 into D0 to output
000014A4  4E4F                     562              TRAP        #15                 ; Use TRAP #15 to output the immediate data
000014A6                           563          
000014A6  43F9 00003CE4            564              LEA         comma, A1           ; Display space
000014AC  103C 000E                565              MOVE.B      #14, D0             ; command for trap call to display message
000014B0  4E4F                     566              TRAP        #15                 ; trap call
000014B2                           567  
000014B2  4242                     568              CLR         D2                  ; Clear out D2 to move destination mode in
000014B4  4243                     569              CLR         D3                  ; Clear out D3 to move destintion register in
000014B6  1404                     570              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
000014B8  1605                     571              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA    
000014BA                           572          
000014BA  4EB9 00002F02            573              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000014C0                           574          
000014C0  43F9 00003CD9            575              LEA         newLine, A1           ; Display space
000014C6  103C 000E                576              MOVE.B      #14, D0             ; command for trap call to display message
000014CA  4E4F                     577              TRAP        #15                 ; trap call
000014CC  6000 FB7E                578              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000014D0                           579  
000014D0                           580  opCMPIL 
000014D0  43F9 00003CF2            581              LEA         CMPImatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
000014D6  103C 000E                582              MOVE.B      #14, D0             ; command for trap call to display message
000014DA  4E4F                     583              TRAP        #15                 ; trap call
000014DC                           584          
000014DC  43F9 00003D7D            585              LEA         dispLong, A1        ; Display byte
000014E2  103C 000E                586              MOVE.B      #14, D0             ; command for trap call to display message
000014E6  4E4F                     587              TRAP        #15                 ; trap call
000014E8                           588          
000014E8  43F9 00003CDD            589              LEA         space, A1           ; Display space
000014EE  103C 000E                590              MOVE.B      #14, D0             ; command for trap call to display message
000014F2  4E4F                     591              TRAP        #15                 ; trap call
000014F4                           592              
000014F4  4244                     593              CLR         D4                  ; Clear D4 to use as temporary register for destination mode
000014F6  1801                     594              MOVE.B      D1,D4               ; Move byte over to D4 to use
000014F8  E644                     595              ASR         #three,D4           ; Moves out insignifcant bits to find mode
000014FA  C87C 0007                596              AND         #seven,D4           ; Clear other bits besides mode
000014FE  4245                     597              CLR         D5                  ; Use D5 as temporary register for destination regsiter
00001500  1A01                     598              MOVE.B      D1,D5               ; Move data over to isolate mode
00001502  CA7C 0007                599              AND         #seven,D5           ; Isolate the mode
00001506                           600          
00001506  4243                     601              CLR         D3                  ; Clear D3 to move register into it
00001508  4242                     602              CLR         D2                  ; Clear D2 to move mode into it
0000150A  163C 0004                603              MOVE.B      #four,D3            ; Set values to be used in printEA
0000150E  143C 0007                604              MOVE.B      #seven,D2           ; Set values to be used in printEA  
00001512                           605          
00001512  4EB9 00002F02            606              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001518                           607          
00001518  43F9 00003CE4            608              LEA         comma, A1           ; Display space
0000151E  103C 000E                609              MOVE.B      #14, D0             ; command for trap call to display message
00001522  4E4F                     610              TRAP        #15                 ; trap call
00001524                           611          
00001524  4242                     612              CLR         D2                  ; Clear out D2 to move destination mode in
00001526  4243                     613              CLR         D3                  ; Clear out D3 to move destintion register in
00001528  1404                     614              MOVE.B      D4,D2               ; Move destination mode into D2 to be used in print EA
0000152A  1605                     615              MOVE.B      D5,D3               ; Move destination register into D3 to be used in printEA                
0000152C                           616          
0000152C  4EB9 00002F02            617              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001532                           618          
00001532  43F9 00003CD9            619              LEA         newLine, A1         ; Display space
00001538  103C 000E                620              MOVE.B      #14, D0             ; command for trap call to display message
0000153C  4E4F                     621              TRAP        #15                 ; trap call
0000153E                           622          
0000153E  6000 FB0C                623              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001542                           624          
00001542                           625  ***********************************************************************************************************
00001542                           626  *
00001542                           627  *                   BCLR OPCODE
00001542                           628  *       This section is dedicated to the compare BCLR instruction. The first nibble is 0 and the second
00001542                           629  *       nibble is 2. Once both checks are passed then code goes to print BCLR and its EA.
00001542                           630  *       
00001542                           631  ***********************************************************************************************************
00001542                           632  
00001542                           633  opBCLR      
00001542  43F9 00003CF7            634              LEA         BCLRmatch, A1       ; we know that the opcode will be CMPI, so load A1 to print message
00001548  103C 000E                635              MOVE.B      #14, D0             ; command for trap call to display message
0000154C  4E4F                     636              TRAP        #15                 ; trap call
0000154E                           637  
0000154E  43F9 00003CDD            638              LEA         space, A1           ; Display space
00001554  103C 000E                639              MOVE.B      #14, D0             ; command for trap call to display message
00001558  4E4F                     640              TRAP        #15                 ; trap call
0000155A                           641                  
0000155A  4242                     642              CLR         D2                  ; Clear data register
0000155C  1218                     643              MOVE.B      (A0)+, D1           ; Move byte over to D1 to be used
0000155E  1401                     644              MOVE.B      D1,D2               ; copy data over
00001560  E642                     645              ASR         #three,D2           ; Shift to the right to remove register
00001562  C47C 0007                646              AND         #seven,D2           ; Sets other bits to 0 and leave Mode the same
00001566                           647                  
00001566  4243                     648              CLR         D3                  ; Clear D3 so we can move D1 in
00001568  1601                     649              MOVE.B      D1,D3               ; Move othr byte in
0000156A  C67C 0007                650              AND         #seven,D3           ; Set everything besides register to 0
0000156E                           651                 
0000156E  4241                     652              CLR         D1                  ; Clear out data register
00001570  3218                     653              MOVE.W      (A0)+, D1           ; Take in next nibble that contains data
00001572                           654                 
00001572                           655                  
00001572  43F9 00003CE0            656              LEA         hashTag, A1         ; Display space
00001578  103C 000E                657              MOVE.B      #14, D0             ; command for trap call to display message
0000157C  4E4F                     658              TRAP        #15                 ; trap call
0000157E                           659          
0000157E  103C 0003                660              MOVE.B      #3, D0
00001582  4E4F                     661              TRAP        #15
00001584                           662          
00001584  43F9 00003CE4            663              LEA         comma, A1           ; Display space
0000158A  103C 000E                664              MOVE.B      #14, D0             ; command for trap call to display message
0000158E  4E4F                     665              TRAP        #15                 ; trap call
00001590                           666                  
00001590  4EB9 00002F02            667              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001596                           668          
00001596  43F9 00003CD9            669              LEA         newLine, A1           ; Display space
0000159C  103C 000E                670              MOVE.B      #14, D0             ; command for trap call to display message
000015A0  4E4F                     671              TRAP        #15                 ; trap call
000015A2                           672                  
000015A2  6000 FAA8                673              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits   
000015A6                           674          
000015A6                           675  opDynBCLR       
000015A6  4241                     676              CLR         D1
000015A8  1218                     677              MOVE.B      (A0)+,D1            ; Copy second byte in
000015AA  1601                     678              MOVE.B      D1,D3               ; Will use D4 to store in the source register
000015AC  E243                     679              ASR         #one,D3             ; Shift register over to the end
000015AE  C67C 0007                680              AND         #seven,D3           ; Change all bits except for the register to 0. Source Register is now in D4
000015B2                           681                  
000015B2  1401                     682              MOVE.B      D1,D2
000015B4  EC42                     683              ASR         #six,D2             ; Removing mode and register to check BCLR bits
000015B6  B47C 0002                684              CMP         #two,D2             ; Checking the static bits to make sure it is BCLR
000015BA  6600 26B2                685              BNE         printInvalid        ; If not equal, than this is not BCLR or any other mode we're dealing with
000015BE                           686  
000015BE                           687                  
000015BE  43F9 00003CF7            688              LEA         BCLRmatch, A1       ; we now know that the opcode will be BCLR, so load A1 to print message
000015C4  103C 000E                689              MOVE.B      #14, D0             ; command for trap call to display message
000015C8  4E4F                     690              TRAP        #15                 ; trap call  
000015CA                           691                  
000015CA  43F9 00003CDD            692              LEA         space, A1           ; Display space
000015D0  103C 000E                693              MOVE.B      #14, D0             ; command for trap call to display message
000015D4  4E4F                     694              TRAP        #15                 ; trap call
000015D6                           695                  
000015D6  143C 0000                696              MOVE.B      #zero,D2            ; Move 0 into D2 to print out data register in printEA   
000015DA  4EB9 00002F02            697              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000015E0                           698                  
000015E0  43F9 00003CE4            699              LEA         comma, A1           ; Display space
000015E6  103C 000E                700              MOVE.B      #14, D0             ; command for trap call to display message
000015EA  4E4F                     701              TRAP        #15                 ; trap call
000015EC                           702                
000015EC  4242                     703              CLR         D2
000015EE  1401                     704              MOVE.B      D1,D2               ; Using D2 to store EA mode
000015F0  E642                     705              ASR         #three,D2           ; Remove/shift the register out
000015F2  C47C 0007                706              AND         #seven,D2           ; Change all bits except for the mode bits to 0
000015F6                           707                  
000015F6  4243                     708              CLR         D3                  ; Clearing D3 to avoid mashing data
000015F8  1601                     709              MOVE.B      D1,D3               ; Moving byte into D3. Using D3 to store EA register
000015FA  C67C 0007                710              AND         #seven,D3           ; Change all bits except for register bits to 0
000015FE                           711              
000015FE  4EB9 00002F02            712              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001604                           713          
00001604  43F9 00003CD9            714              LEA         newLine, A1         ; Display space
0000160A  103C 000E                715              MOVE.B      #14, D0             ; command for trap call to display message
0000160E  4E4F                     716              TRAP        #15                 ; trap call            
00001610                           717  
00001610                           718  
00001610  6000 FA3A                719              BRA         LOOP                ; go back to the loop   
00001614                           720                  
00001614                           721  ***********************************************************************************************************
00001614                           722  *
00001614                           723  *                   MOVE OPCODE
00001614                           724  *                   MOVEA OPCODE
00001614                           725  *       This section of code is dedication to MOVE and MOVEA opcode instructions. MOVEA is determined by
00001614                           726  *       its static bits at 8, 7, and 6. Once those static bits are confirmed, the code branches off to 
00001614                           727  *       MOVEA, else it continues into MOVE.
00001614                           728  *
00001614                           729  ***********************************************************************************************************
00001614                           730   
00001614                           731  opMOVEB 
00001614  43F9 00003CFC            732              LEA         MOVEmatch, A1       ; we know that the opcode will be MOVE.B, so load A1 to print message
0000161A  103C 000E                733              MOVE.B      #14, D0             ; command for trap call to display message
0000161E  4E4F                     734              TRAP        #15                 ; trap call
00001620  43F9 00003D77            735              LEA         dispByte, A1        ; display byte
00001626  103C 000E                736              MOVE.B      #14, D0             ; command for trap call to display message
0000162A  4E4F                     737              TRAP        #15                 ; trap call
0000162C  43F9 00003CDD            738              LEA         space, A1           ; create spaces
00001632  103C 000E                739              MOVE.B      #14, D0             ; command for trap call to display message
00001636  4E4F                     740              TRAP        #15                 ; trap call
00001638                           741          
00001638                           742          
00001638  4245                     743              CLR         D5                  ; Clear D5
0000163A  1A01                     744              MOVE.B      D1,D5               ; Copying byte over to D5. Will use D5 to store destination Register
0000163C  E245                     745              ASR         #one,D5             ; shifted mode out. Register is now stored into D5
0000163E  CA7C 0007                746              AND         #seven,D5
00001642                           747          
00001642  4244                     748              CLR         D4                  ; Clear out D4
00001644  1801                     749              MOVE.B      D1,D4               ; Copy byte over to store destination mode
00001646  C87C 0001                750              AND         #one,D4             ; Set all the other bits to 0, leave the bit for the destination mode alone.
0000164A                           751          
0000164A  4241                     752              CLR          D1                 ; Clear data register
0000164C  4242                     753              CLR          D2                 ; Clear data register
0000164E  1218                     754              MOVE.B      (A0)+,D1            ; Copy byte into D1
00001650  1401                     755              MOVE.B      D1,D2
00001652  EC42                     756              ASR         #6,D2               ; Shifts source mode and register out to get destination mode
00001654  D842                     757              ADD         D2,D4               ; Adds the remaining bits to D4
00001656                           758          
00001656  4242                     759              CLR         D2                  ; Clear data register
00001658  1401                     760              MOVE.B      D1,D2               ; Copy new byte over to D2
0000165A  E642                     761              ASR         #three,D2           ; Shift source register out
0000165C  C47C 0007                762              AND         #seven,D2           ; Set everything to 0 except for the mode
00001660                           763          
00001660  4243                     764              CLR         D3                  ; Clear Data register 3
00001662  1601                     765              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
00001664  C67C 0007                766              AND         #seven,D3           ; Sets up everything to 0 except for the register bits
00001668                           767          
00001668  4EB9 00002F02            768              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000166E                           769          
0000166E  43F9 00003CE4            770              LEA         comma, A1           ; Display space
00001674  103C 000E                771              MOVE.B      #14, D0             ; command for trap call to display message
00001678  4E4F                     772              TRAP        #15                 ; trap call
0000167A                           773          
0000167A  4242                     774              CLR         D2                  ; Clear data register
0000167C  4243                     775              CLR         D3                  ; Clear data register
0000167E  1404                     776              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
00001680  1605                     777              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
00001682                           778          
00001682  4EB9 00002F02            779              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001688                           780          
00001688  43F9 00003CD9            781              LEA         newLine, A1         ; Display space
0000168E  103C 000E                782              MOVE.B      #14, D0             ; command for trap call to display message
00001692  4E4F                     783              TRAP        #15                 ; trap call            
00001694                           784  
00001694  6000 F9B6                785              BRA         LOOP                ; go back to the loop
00001698                           786          
00001698                           787  opMOVEL     
00001698  4245                     788              CLR         D5                  ; Clear D5
0000169A  1A01                     789              MOVE.B      D1,D5               ; Copying byte over to D5. Will use D5 to store destination Register
0000169C  E245                     790              ASR         #one,D5             ; shifted mode out. Register is now stored into D5
0000169E  CA7C 0007                791              AND         #seven,D5
000016A2                           792          
000016A2  4244                     793              CLR         D4                  ; Clear out D4
000016A4  1801                     794              MOVE.B      D1,D4               ; Copy byte over to store destination mode
000016A6  C87C 0001                795              AND         #one,D4             ; Set all the other bits to 0, leave the bit for the destination mode alone.
000016AA                           796          
000016AA  4241                     797              CLR          D1                 ; Clear data register
000016AC  4242                     798              CLR          D2                 ; Clear data register
000016AE  1218                     799              MOVE.B      (A0)+,D1            ; Copy byte into D1
000016B0  1401                     800              MOVE.B      D1,D2
000016B2  EC42                     801              ASR         #6,D2               ; Shifts source mode and register out to get destination mode
000016B4  D842                     802              ADD         D2,D4               ; Adds the remaining bits to D4
000016B6                           803          
000016B6  B87C 0001                804              CMP         #one,D4             ; Check if it is MOVEA
000016BA  6700 0070                805              BEQ         opMOVEAL            ; If it is, branch off
000016BE                           806              
000016BE  43F9 00003CFC            807              LEA         MOVEmatch, A1       ; we know that the opcode will be MOVE.L OR MOVEA.L, so load A1 to print message
000016C4  103C 000E                808              MOVE.B      #14, D0             ; command for trap call to display message
000016C8  4E4F                     809              TRAP        #15                 ; trap call  
000016CA                           810              
000016CA  43F9 00003D7D            811              LEA         dispLong,A1         ; Prints out L to display a long
000016D0  103C 000E                812              MOVE.B      #14, D0             ; command for trap call to display message
000016D4  4E4F                     813              TRAP        #15                 ; trap call
000016D6                           814              
000016D6  43F9 00003CDD            815              LEA         space, A1           ; create spaces
000016DC  103C 000E                816              MOVE.B      #14, D0             ; command for trap call to display message
000016E0  4E4F                     817              TRAP        #15                 ; trap call
000016E2                           818          
000016E2  4242                     819              CLR         D2                  ; Clear data register
000016E4  1401                     820              MOVE.B      D1,D2               ; Copy new byte over to D2
000016E6  E642                     821              ASR         #three,D2           ; Shift source register out
000016E8  C47C 0007                822              AND         #seven,D2           ; Set everything to 0 except for the mode
000016EC                           823          
000016EC  4243                     824              CLR         D3                  ; Clear Data register 3
000016EE  1601                     825              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
000016F0  C67C 0007                826              AND         #seven,D3           ; Sets up everything to 0 except for the register bits      
000016F4                           827              
000016F4  4246                     828              CLR         D6                  ; Clear data register
000016F6  1C3C 0001                829              MOVE.B      #1,D6               ; Moves 1 into D6 to be used in printEA to display long
000016FA  4EB9 00002F02            830              JSR         printEA             ; Prints out EA
00001700  4246                     831              CLR         D6
00001702                           832              
00001702  43F9 00003CE4            833              LEA         comma, A1           ; Display comma
00001708  103C 000E                834              MOVE.B      #14, D0             ; command for trap call to display message
0000170C  4E4F                     835              TRAP        #15                 ; trap call
0000170E                           836          
0000170E  4242                     837              CLR         D2                  ; Clear data register            
00001710  4243                     838              CLR         D3                  ; Clear data register
00001712  1404                     839              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
00001714  1605                     840              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
00001716                           841          
00001716  4EB9 00002F02            842              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000171C                           843  
0000171C  43F9 00003CD9            844              LEA         newLine, A1         ; Display space
00001722  103C 000E                845              MOVE.B      #14, D0             ; command for trap call to display message
00001726  4E4F                     846              TRAP        #15                 ; trap call            
00001728                           847  
00001728  6000 F922                848              BRA         LOOP                ; go back to the loop
0000172C                           849              
0000172C                           850  opMOVEAL
0000172C  43F9 00003D01            851              LEA         MOVEAmatch,A1       ; MOVEA has been determined. Print out MOVEA
00001732  103C 000E                852              MOVE.B      #14, D0             ; command for trap call to display message
00001736  4E4F                     853              TRAP        #15                 ; trap call
00001738                           854              
00001738  43F9 00003D7D            855              LEA         dispLong,A1         ; Prints out L
0000173E  103C 000E                856              MOVE.B      #14, D0             ; command for trap call to display message
00001742  4E4F                     857              TRAP        #15                 ; trap call
00001744                           858              
00001744                           859  
00001744  43F9 00003CDD            860              LEA         space, A1           ; create spaces
0000174A  103C 000E                861              MOVE.B      #14, D0             ; command for trap call to display message
0000174E  4E4F                     862              TRAP        #15                 ; trap call
00001750                           863              
00001750  4242                     864              CLR         D2                  ; Clear data register
00001752  1401                     865              MOVE.B      D1,D2               ; Copy new byte over to D2
00001754  E642                     866              ASR         #three,D2           ; Shift source register out
00001756  C47C 0007                867              AND         #seven,D2           ; Set everything to 0 except for the mode
0000175A                           868          
0000175A  4243                     869              CLR         D3                  ; Clear Data register 3
0000175C  1601                     870              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
0000175E  C67C 0007                871              AND         #seven,D3           ; Sets up everything to 0 except for the register bits    
00001762                           872              
00001762  4241                     873              CLR         D1                  ; Clear D1
00001764                           874              
00001764  4EB9 00002F02            875              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000176A                           876              
0000176A  43F9 00003CE4            877              LEA         comma, A1           ; Display comma
00001770  103C 000E                878              MOVE.B      #14, D0             ; command for trap call to display message
00001774  4E4F                     879              TRAP        #15                 ; trap call
00001776                           880  
00001776  4242                     881              CLR         D2                  ; Clear data register
00001778  4243                     882              CLR         D3                  ; Clear data register
0000177A  1404                     883              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
0000177C  1605                     884              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
0000177E                           885          
0000177E  4EB9 00002F02            886              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001784                           887          
00001784  43F9 00003CD9            888              LEA         newLine, A1         ; Display space
0000178A  103C 000E                889              MOVE.B      #14, D0             ; command for trap call to display message
0000178E  4E4F                     890              TRAP        #15                 ; trap call            
00001790                           891  
00001790  6000 F8BA                892              BRA         LOOP                ; go back to the loop
00001794                           893  
00001794                           894  opMOVEW
00001794  4245                     895              CLR         D5                  ; Clear D5
00001796  1A01                     896              MOVE.B      D1,D5               ; Copying byte over to D5. Will use D5 to store destination Register
00001798  E245                     897              ASR         #one,D5             ; shifted mode out. Register is now stored into D5
0000179A  CA7C 0007                898              AND         #seven,D5
0000179E                           899          
0000179E  4244                     900              CLR         D4                  ; Clear out D4
000017A0  1801                     901              MOVE.B      D1,D4               ; Copy byte over to store destination mode
000017A2  C87C 0001                902              AND         #one,D4             ; Set all the other bits to 0, leave the bit for the destination mode alone.
000017A6                           903          
000017A6  4241                     904              CLR          D1                 ; Clear data register
000017A8  4242                     905              CLR          D2                 ; Clear data register
000017AA  1218                     906              MOVE.B      (A0)+,D1            ; Copy byte into D1
000017AC  1401                     907              MOVE.B      D1,D2
000017AE  EC42                     908              ASR         #6,D2               ; Shifts source mode and register out to get destination mode
000017B0  D842                     909              ADD         D2,D4               ; Adds the remaining bits to D4
000017B2                           910          
000017B2  B87C 0001                911              CMP         #one,D4             ; Check if it is MOVEA
000017B6  6700 006A                912              BEQ         opMOVEAW            ; If it is, branch off
000017BA                           913              
000017BA  43F9 00003CFC            914              LEA         MOVEmatch, A1       ; we know that the opcode will be MOVE.L OR MOVEA.L, so load A1 to print message
000017C0  103C 000E                915              MOVE.B      #14, D0             ; command for trap call to display message
000017C4  4E4F                     916              TRAP        #15                 ; trap call  
000017C6                           917              
000017C6  43F9 00003D7A            918              LEA         dispWord,A1         ; Prints out a W after the opcode
000017CC  103C 000E                919              MOVE.B      #14, D0             ; command for trap call to display message
000017D0  4E4F                     920              TRAP        #15                 ; trap call
000017D2                           921              
000017D2  43F9 00003CDD            922              LEA         space, A1           ; create spaces
000017D8  103C 000E                923              MOVE.B      #14, D0             ; command for trap call to display message
000017DC  4E4F                     924              TRAP        #15                 ; trap call
000017DE                           925          
000017DE  4242                     926              CLR         D2
000017E0  1401                     927              MOVE.B      D1,D2               ; Copy new byte over to D2
000017E2  E642                     928              ASR         #three,D2           ; Shift source register out
000017E4  C47C 0007                929              AND         #seven,D2           ; Set everything to 0 except for the mode
000017E8                           930          
000017E8  4243                     931              CLR         D3                  ; Clear Data register 3
000017EA  1601                     932              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
000017EC  C67C 0007                933              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
000017F0                           934              
000017F0  4241                     935              CLR         D1                  ; Clear D1
000017F2                           936              
000017F2  4EB9 00002F02            937              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000017F8                           938              
000017F8  43F9 00003CE4            939              LEA         comma, A1           ; Display comma
000017FE  103C 000E                940              MOVE.B      #14, D0             ; command for trap call to display message
00001802  4E4F                     941              TRAP        #15                 ; trap call
00001804                           942          
00001804  4242                     943              CLR         D2                  ; Clear data register 
00001806  4243                     944              CLR         D3                  ; Clear data register
00001808  1404                     945              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
0000180A  1605                     946              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
0000180C  4EB9 00002F02            947              JSR         printEA
00001812                           948          
00001812  43F9 00003CD9            949              LEA         newLine, A1         ; Display space
00001818  103C 000E                950              MOVE.B      #14, D0             ; command for trap call to display message
0000181C  4E4F                     951              TRAP        #15                 ; trap call            
0000181E                           952  
0000181E  6000 F82C                953              BRA         LOOP                ; go back to the loop
00001822                           954              
00001822                           955  opMOVEAW  
00001822  43F9 00003D01            956              LEA         MOVEAmatch,A1       ; Prints out MOVEA
00001828  103C 000E                957              MOVE.B      #14, D0             ; command for trap call to display message
0000182C  4E4F                     958              TRAP        #15                 ; trap call
0000182E                           959                  
0000182E  43F9 00003D7A            960              LEA         dispWord,A1         ; Prints out W
00001834  103C 000E                961              MOVE.B      #14, D0             ; command for trap call to display message
00001838  4E4F                     962              TRAP        #15                 ; trap call
0000183A                           963              
0000183A  43F9 00003CDD            964              LEA         space, A1           ; create spaces
00001840  103C 000E                965              MOVE.B      #14, D0             ; command for trap call to display message
00001844  4E4F                     966              TRAP        #15                 ; trap call
00001846                           967              
00001846  4242                     968              CLR         D2                  ; Clear data register
00001848  1401                     969              MOVE.B      D1,D2               ; Copy new byte over to D2
0000184A  E642                     970              ASR         #three,D2           ; Shift source register out
0000184C  C47C 0007                971              AND         #seven,D2           ; Set everything to 0 except for the mode
00001850                           972          
00001850  4243                     973              CLR         D3                  ; Clear Data register 3
00001852  1601                     974              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
00001854  C67C 0007                975              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
00001858                           976              
00001858  4241                     977              CLR         D1                  ; Clear D1      
0000185A                           978              
0000185A  4EB9 00002F02            979              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001860                           980              
00001860  43F9 00003CE4            981              LEA         comma, A1           ; Display comma
00001866  103C 000E                982              MOVE.B      #14, D0             ; command for trap call to display message
0000186A  4E4F                     983              TRAP        #15                 ; trap call
0000186C                           984  
0000186C  4242                     985              CLR         D2                  ; Clear data register
0000186E  4243                     986              CLR         D3                  ; Clear data register
00001870  1404                     987              MOVE.B      D4,D2               ; Moves EA mode into D2 to use printEA
00001872  1605                     988              MOVE.B      D5,D3               ; Moves register to D3 to be used in printEA
00001874                           989          
00001874  4EB9 00002F02            990              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
0000187A                           991          
0000187A  43F9 00003CD9            992              LEA         newLine, A1         ; Display space
00001880  103C 000E                993              MOVE.B      #14, D0             ; command for trap call to display message
00001884  4E4F                     994              TRAP        #15                 ; trap call            
00001886                           995  
00001886  6000 F7C4                996              BRA         LOOP                ; go back to the loop
0000188A                           997  
0000188A                           998  ***********************************************************************************************************
0000188A                           999  *
0000188A                          1000  *                   NEG OPCODE
0000188A                          1001  *       This section is dedicated to the NEG opmode instruction. NEG is determined by the first and
0000188A                          1002  *       the second nibble. The first nibble is 4 and the second nibble is equal to 0. Once that has been
0000188A                          1003  *       determined. NEG is printed out.
0000188A                          1004  ***********************************************************************************************************
0000188A                          1005  
0000188A                          1006  opNEG   
0000188A  43F9 00003D07           1007              LEA         NEGmatch, A1        ; we know that the opcode will be NEG, so load A1 to print message
00001890  103C 000E               1008              MOVE.B      #14, D0             ; command for trap call to display message
00001894  4E4F                    1009              TRAP        #15                 ; trap call
00001896                          1010          
00001896                          1011          
00001896  1218                    1012              MOVE.B      (A0)+, D1           ; Move data into D1 for use 
00001898  1401                    1013              MOVE.B      D1,D2               ; copy data over
0000189A  EC42                    1014              ASR         #six,D2             ; Moves six bits over to read the size
0000189C                          1015              
0000189C  B47C 0000               1016              CMP         #zero,D2            ; Compare size
000018A0  6700 0016               1017              BEQ         opNEGB              ; Branch to NEG if size is byte
000018A4  B47C 0001               1018              CMP         #one,D2             ; Compare size with one, 
000018A8  6700 008E               1019              BEQ         opNEGW              ; If equal, size is a word. Branch to NEGW
000018AC  B47C 0002               1020              CMP         #two,D2             ; Compare size with two
000018B0  6700 0046               1021              BEQ         opNEGL              ; If size is two, NEG size is long. Branch to NEGL
000018B4  6000 1CC4               1022              BRA         invalid             ; If size is neither, code is invalid. Branch to deal with invalid code.
000018B8                          1023              
000018B8                          1024  opNEGB
000018B8  43F9 00003D77           1025              LEA         dispByte, A1        ; we know that the opcode will be NEG, so load A1 to print message
000018BE  103C 000E               1026              MOVE.B      #14, D0             ; command for trap call to display message
000018C2  4E4F                    1027              TRAP        #15                 ; trap call
000018C4                          1028          
000018C4  43F9 00003CDD           1029              LEA         space, A1           ; we know that the opcode will be NEG, so load A1 to print message
000018CA  103C 000E               1030              MOVE.B      #14, D0             ; command for trap call to display message
000018CE  4E4F                    1031              TRAP        #15                 ; trap call
000018D0                          1032          
000018D0  4242                    1033              CLR         D2                  ; Clear Data register 2
000018D2  3401                    1034              MOVE        D1,D2               ; Move byte into D2
000018D4  E642                    1035              ASR         #three,D2           ; Shift mode into place and moves mode into place
000018D6  C47C 0007               1036              AND         #seven,D2           ; Stores mode
000018DA                          1037              
000018DA  4243                    1038              CLR         D3                  ; Clear Data register 3
000018DC  1601                    1039              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
000018DE  C67C 0007               1040              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
000018E2                          1041              
000018E2  4EB9 00002F02           1042              JSR         printEA
000018E8                          1043                  
000018E8  43F9 00003CD9           1044              LEA         newLine, A1         ; Display space
000018EE  103C 000E               1045              MOVE.B      #14, D0             ; command for trap call to display message
000018F2  4E4F                    1046              TRAP        #15                 ; trap call  
000018F4                          1047          
000018F4  6000 F756               1048              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000018F8                          1049  
000018F8                          1050  opNEGL
000018F8  43F9 00003D7D           1051              LEA         dispLong, A1        ; we know that the opcode will be NEG, so load A1 to print message
000018FE  103C 000E               1052              MOVE.B      #14, D0             ; command for trap call to display message
00001902  4E4F                    1053              TRAP        #15                 ; trap call
00001904                          1054  
00001904  43F9 00003CDD           1055              LEA         space, A1           ; we know that the opcode will be NEG, so load A1 to print message
0000190A  103C 000E               1056              MOVE.B      #14, D0             ; command for trap call to display message
0000190E  4E4F                    1057              TRAP        #15                 ; trap call
00001910                          1058                  
00001910  4242                    1059              CLR         D2                  ; Clear Data register 2
00001912  3401                    1060              MOVE        D1,D2               ; Move byte into D2
00001914  E642                    1061              ASR         #three,D2           ; Shift mode into place and moves mode into place
00001916  C47C 0007               1062              AND         #seven,D2           ; Stores mode
0000191A                          1063          
0000191A  4243                    1064              CLR         D3                  ; Clear Data register 3
0000191C  1601                    1065              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
0000191E  C67C 0007               1066              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
00001922                          1067          
00001922  4EB9 00002F02           1068              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001928                          1069                      
00001928  43F9 00003CD9           1070              LEA         newLine, A1         ; Display space
0000192E  103C 000E               1071              MOVE.B      #14, D0             ; command for trap call to display message
00001932  4E4F                    1072              TRAP        #15                 ; trap call  
00001934                          1073          
00001934  6000 F716               1074              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001938                          1075  
00001938                          1076  opNEGW
00001938  43F9 00003D7A           1077              LEA         dispWord, A1        ; we know that the opcode will be NEG, so load A1 to print message
0000193E  103C 000E               1078              MOVE.B      #14, D0             ; command for trap call to display message
00001942  4E4F                    1079              TRAP        #15                 ; trap call
00001944                          1080          
00001944  43F9 00003CDD           1081              LEA         space, A1           ; we know that the opcode will be NEG, so load A1 to print message
0000194A  103C 000E               1082              MOVE.B      #14, D0             ; command for trap call to display message
0000194E  4E4F                    1083              TRAP        #15                 ; trap call        
00001950                          1084                  
00001950  4242                    1085              CLR         D2                  ; Clear Data register 2
00001952  3401                    1086              MOVE        D1,D2               ; Move byte into D2
00001954  E642                    1087              ASR         #three,D2           ; Shift mode into place and moves mode into place
00001956  C47C 0007               1088              AND         #seven,D2           ; Stores mode
0000195A                          1089          
0000195A  4243                    1090              CLR         D3                  ; Clear Data register 3
0000195C  1601                    1091              MOVE.B      D1,D3               ; Moves byte over to D3 to find the register
0000195E  C67C 0007               1092              AND         #seven,D3           ; Sets up everything to 0 except for the register bits  
00001962                          1093          
00001962  4EB9 00002F02           1094              JSR         printEA
00001968                          1095              
00001968  43F9 00003CD9           1096              LEA         newLine, A1         ; Display space
0000196E  103C 000E               1097              MOVE.B      #14, D0             ; command for trap call to display message
00001972  4E4F                    1098              TRAP        #15                 ; trap call  
00001974                          1099          
00001974  6000 F6D6               1100              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001978                          1101              
00001978                          1102  ***********************************************************************************************************
00001978                          1103  *
00001978                          1104  *                   RTS_JSR Helper Function
00001978                          1105  *       Compare byte with static bits from JSR and RTS. If data is not equal to either, then data is
00001978                          1106  *       considered an invalid opcode and branches off to invalid.
00001978                          1107  *
00001978                          1108  ***********************************************************************************************************
00001978                          1109  
00001978                          1110  opRTSJSR
00001978  1218                    1111              MOVE.B      (A0)+, D1           ; Move byte into D1 and increment.
0000197A                          1112              
0000197A  1401                    1113              MOVE.B      D1,D2               ; copy data over
0000197C  B47C 0075               1114              CMP         #117,D2             ; 117 is the decimal value of RTS.
00001980  6700 0052               1115              BEQ         opRTS               ; If equal, branch to RTS to print out.
00001984                          1116              
00001984  EC42                    1117              ASR         #six,D2             ; Moving bits over to check if it matches the two static bits in JSR
00001986  B47C 0002               1118              CMP         #two,D2             ; Checking if it is JSR
0000198A  6700 0006               1119              BEQ         opJSR               ; It is equal, so branch off to opJSR
0000198E                          1120  
0000198E  6000 1BEA               1121              BRA         invalid             ; Branch to invalid to deal with invalid data.
00001992                          1122              
00001992                          1123  ***********************************************************************************************************
00001992                          1124  *
00001992                          1125  *                   JSR OPCODE
00001992                          1126  *       This section is dedicated to the JSR opmode instruction. JSR is determined by the 9 static bits.
00001992                          1127  *       Once the bits have matched the disassembled code, the code passes through and prints out JSR along
00001992                          1128  *       with its EA.               
00001992                          1129  *
00001992                          1130  ***********************************************************************************************************
00001992                          1131  
00001992                          1132  opJSR
00001992  43F9 00003D0F           1133              LEA         JSRMatch, A1        ; we know that the opcode will be JSR, so load A1 to print message
00001998  103C 000E               1134              MOVE.B      #14, D0             ; command for trap call to display message
0000199C  4E4F                    1135              TRAP        #15                 ; trap call
0000199E                          1136              
0000199E  43F9 00003CDD           1137              LEA         space, A1           ; we know that the opcode will be NEG, so load A1 to print message
000019A4  103C 000E               1138              MOVE.B      #14, D0             ; command for trap call to display message
000019A8  4E4F                    1139              TRAP        #15                 ; trap call
000019AA                          1140              
000019AA  4242                    1141              CLR         D2                  ; Clearing data register 
000019AC  4243                    1142              CLR         D3                  ; Clearing data register 
000019AE                          1143              
000019AE  1401                    1144              MOVE.B      D1,D2               ; Move D1 data to D2 to find the EA mode
000019B0  E642                    1145              ASR         #three,D2           ; Move mode over to the end in order to read
000019B2  C47C 0007               1146              AND         #seven,D2           ; Set every bit to 0 except for mode bits
000019B6                          1147              
000019B6  4243                    1148              CLR         D3
000019B8  1601                    1149              MOVE.B      D1,D3               ; Move bits over to D3 to find register
000019BA  C67C 0007               1150              AND         #seven,D3           ; Sets every bit to 0 except for register bits
000019BE                          1151              
000019BE  4EB9 00002F02           1152              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
000019C4                          1153              
000019C4  43F9 00003CD9           1154              LEA         newLine, A1         ; Display space
000019CA  103C 000E               1155              MOVE.B      #14, D0             ; command for trap call to display message
000019CE  4E4F                    1156              TRAP        #15                 ; trap call  
000019D0                          1157              
000019D0  6000 F67A               1158              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000019D4                          1159  
000019D4                          1160  ***********************************************************************************************************
000019D4                          1161  *
000019D4                          1162  *                   RTS OPCODE
000019D4                          1163  *       Function prints out RTS. Does not need to check in here as it is done beforehand. Branches back
000019D4                          1164  *       into loop afterwards.
000019D4                          1165  *
000019D4                          1166  ***********************************************************************************************************
000019D4                          1167  
000019D4                          1168  opRTS
000019D4  43F9 00003D0B           1169              LEA         RTSMatch, A1        ; we know that the opcode will be RTS, so load A1 to print message
000019DA  103C 000E               1170              MOVE.B      #14, D0             ; command for trap call to display message
000019DE  4E4F                    1171              TRAP        #15                 ; trap call
000019E0                          1172              
000019E0  43F9 00003CD9           1173              LEA         newLine, A1         ; Display space
000019E6  103C 000E               1174              MOVE.B      #14, D0             ; command for trap call to display message
000019EA  4E4F                    1175              TRAP        #15                 ; trap call 
000019EC                          1176              
000019EC  6000 F65E               1177              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
000019F0                          1178              
000019F0                          1179  ***********************************************************************************************************
000019F0                          1180  *
000019F0                          1181  *                   MOVEM_LEA OPCODE
000019F0                          1182  *       This part of the code is used to branch to either MOVEM or LEA depending on the second nibble.
000019F0                          1183  *
000019F0                          1184  ***********************************************************************************************************
000019F0                          1185  
000019F0                          1186  opMOVEMLEA
000019F0  4242                    1187              CLR         D2                  ; Clear D2
000019F2  1401                    1188              MOVE.B      D1,D2               ; Copy byte over
000019F4  C47C 000F               1189              AND         #secNib,D2          ; Check only the second nibble
000019F8  B47C 000C               1190              CMP         #twelve,D2          ; Compare the second nibble to twelve
000019FC  6700 000E               1191              BEQ         opMOVEM             ; If it is twelve, then it is MOVEM
00001A00  B47C 0008               1192              CMP         #eight,D2           ; Compare the second nibble to eight
00001A04  6700 0006               1193              BEQ         opMOVEM             ; If it is eight, then it is also MOVEM
00001A08  6000 008C               1194              BRA         opLEA               ; Otherwise branch to OPLEA and check for invalid in there
00001A0C                          1195              
00001A0C                          1196  ***********************************************************************************************************
00001A0C                          1197  *
00001A0C                          1198  *                   MOVEM OPCODE
00001A0C                          1199  *       MOVEM has 7 static bits. Before anything is done, static bits are checked and the dr field is stored
00001A0C                          1200  *       into D6 to be used later on for specific branching. After the static bits have confirmed this is
00001A0C                          1201  *       indeed MOVEM that is being disassembled, the code will print out MOVEM and goes into the subroutine
00001A0C                          1202  *       to print out the data and address registers.
00001A0C                          1203  *
00001A0C                          1204  ***********************************************************************************************************
00001A0C                          1205  
00001A0C                          1206  opMOVEM            
00001A0C  4246                    1207              CLR         D6                  ; Clearing D4 to store dr field
00001A0E  1C01                    1208              MOVE.B      D1,D6               ; Moving byte to find dr field
00001A10  E446                    1209              ASR         #two,D6             ; Moving dr field to readable spot
00001A12  CC7C 0001               1210              AND         #one,D6             ; seting everything except dr to 0
00001A16                          1211  
00001A16  4241                    1212              CLR         D1  
00001A18  1218                    1213              MOVE.B      (A0)+, D1           ; Taking in next byte
00001A1A                          1214              
00001A1A  4245                    1215              CLR         D5
00001A1C  1A01                    1216              MOVE.B      D1,D5               ; Using D6 to check if this is indeed MOVEM
00001A1E  EE45                    1217              ASR         #seven,D5
00001A20  CA7C 0001               1218              AND         #one,D5
00001A24  BA7C 0001               1219              CMP         #one,D5             ; This bit should be one if this is MOVEM
00001A28  6600 1B50               1220              BNE         invalid             ; If this is not 1 then this is not moveM
00001A2C  4245                    1221              CLR         D5
00001A2E                          1222              
00001A2E  43F9 00003D13           1223              LEA         MOVEMMatch, A1       ; we know that the opcode will be MOVEM, so load A1 to print message
00001A34  103C 000E               1224              MOVE.B      #14, D0             ; command for trap call to display message
00001A38  4E4F                    1225              TRAP        #15                 ; trap call
00001A3A                          1226              
00001A3A  4245                    1227              CLR         D5                  ; Clearing D5 to store size
00001A3C  1A01                    1228              MOVE.B      D1,D5               ; Moving byte that contains bit for size
00001A3E  EC45                    1229              ASR         #six,D5             ; Moving size bit to the very right to read
00001A40  CA7C 0001               1230              AND         #one,D5             ; Isolating the one bit for size
00001A44                          1231              
00001A44  4242                    1232              CLR         D2                  ; Clear Data register 2
00001A46  3401                    1233              MOVE        D1,D2               ; Move byte into D2
00001A48  E642                    1234              ASR         #three,D2           ; Shift mode into place and moves mode into place
00001A4A  C47C 0007               1235              AND         #seven,D2           ; Stores mode
00001A4E                          1236              
00001A4E  4243                    1237              CLR         D3                  ; Storing EA register into D3
00001A50  1601                    1238              MOVE.B      D1,D3               ; Move bits over to D3 to find register
00001A52  C67C 0007               1239              AND         #seven,D3           ; Sets every bit to 0 except for register bits
00001A56                          1240              
00001A56  4EB9 00003580           1241              JSR         MOVEMBRA            ; Jumps to subroutine that prints out the data and address registers
00001A5C                          1242              
00001A5C  B47C 0003               1243              CMP         #three,D2           ; Checks if this is post increment
00001A60  6700 0024               1244              BEQ         skipPrintEA         ; If it is, skipping printing EA again, because it is printed already in JSR
00001A64                          1245              
00001A64  43F9 00003CE4           1246              LEA         comma, A1           ; Display comma
00001A6A  103C 000E               1247              MOVE.B      #14, D0             ; command for trap call to display message
00001A6E  4E4F                    1248              TRAP        #15                 ; trap call
00001A70                          1249              
00001A70  4EB9 00002F02           1250              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001A76                          1251              
00001A76  43F9 00003CD9           1252              LEA         newline, A1         ; we know that the opcode will be MOVEM, so load A1 to print message
00001A7C  103C 000E               1253              MOVE.B      #14, D0             ; command for trap call to display message
00001A80  4E4F                    1254              TRAP        #15                 ; trap call            
00001A82                          1255  
00001A82  6000 F5C8               1256              BRA         loop                ; Branch back to outer most loop that finds the first four bits
00001A86                          1257  
00001A86                          1258  skipPrintEA 
00001A86  43F9 00003CD9           1259              LEA         newline, A1         ; Prints out new line or carraige return
00001A8C  103C 000E               1260              MOVE.B      #14, D0             ; command for trap call to display message
00001A90  4E4F                    1261              TRAP        #15                 ; trap call            
00001A92                          1262  
00001A92  6000 F5B8               1263              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits
00001A96                          1264              
00001A96                          1265  ***********************************************************************************************************
00001A96                          1266  *
00001A96                          1267  *               LEA OPCODE
00001A96                          1268  *
00001A96                          1269  *       This section is dedicated to the LEA opcode. This is determined that the first nibble is 4 nibbles as
00001A96                          1270  *       well as the three static nibbles on 8,7, and 6. Once both have been checked, the code prints out
00001A96                          1271  *       LEA and goes on to print its effective address.
00001A96                          1272  *
00001A96                          1273  ***********************************************************************************************************
00001A96                          1274  
00001A96                          1275  opLEA
00001A96  4244                    1276              CLR         D4                  ; Clearing space for source register
00001A98  1801                    1277              MOVE.B      D1,D4               ; Moving byte to isolate register
00001A9A  E244                    1278              ASR         #one,D4
00001A9C  C87C 0007               1279              AND         #seven,D4           ; Isolated register
00001AA0                          1280  
00001AA0  4245                    1281              CLR         D5                  ; Clearing D5 to check if bits match LEA static bits
00001AA2  1A01                    1282              MOVE.B      D1,D5               ; Stores destination register in temporary data register for later use
00001AA4  CA7C 0001               1283              AND         #one,D5             ; Setting all other bits to one except for mode register
00001AA8  E545                    1284              ASL         #two,D5             ; Shifts the two register bits over to correct spot
00001AAA                          1285              
00001AAA  1218                    1286              MOVE.B      (A0)+, D1           ; Taking in next byte
00001AAC                          1287              
00001AAC  1C01                    1288              MOVE.B      D1,D6               
00001AAE  EC46                    1289              ASR         #six,D6             ; Shifts 6 bits over to move register
00001AB0  DA46                    1290              ADD         D6,D5               ; Add the remaining bits to the register
00001AB2  4246                    1291              CLR         D6                  ; Clear out the temporary register
00001AB4                          1292  
00001AB4  BA7C 0007               1293              CMP         #seven,D5           ; Checks the seven static bits to see if it is LEA
00001AB8  6600 1AC0               1294              BNE         invalid             ; If it is not equal then this is not LEA
00001ABC                          1295              
00001ABC  43F9 00003D19           1296              LEA         LEAmatch, A1        ; we know that the opcode will be LEA, so load A1 to print message
00001AC2  103C 000E               1297              MOVE.B      #14, D0             ; command for trap call to display message
00001AC6  4E4F                    1298              TRAP        #15                 ; trap call            
00001AC8                          1299  
00001AC8  43F9 00003CDD           1300              LEA         space, A1           ; we know that the opcode will be MOVEM, so load A1 to print message
00001ACE  103C 000E               1301              MOVE.B      #14, D0             ; command for trap call to display message
00001AD2  4E4F                    1302              TRAP        #15                 ; trap call            
00001AD4                          1303              
00001AD4  4242                    1304              CLR         D2                  ; Clear Data register 2
00001AD6  3401                    1305              MOVE        D1,D2               ; Move byte into D2
00001AD8  E642                    1306              ASR         #three,D2           ; Shift mode into place and moves mode into place
00001ADA  C47C 0007               1307              AND         #seven,D2           ; Stores mode
00001ADE                          1308              
00001ADE  4243                    1309              CLR         D3
00001AE0  1601                    1310              MOVE.B      D1,D3               ; Move bits over to D3 to find register
00001AE2  C67C 0007               1311              AND         #seven,D3           ; Sets every bit to 0 except for register bits
00001AE6                          1312              
00001AE6  4EB9 00002F02           1313              JSR         printEA             ; Jump to sub routine printEA to print out the effective address
00001AEC                          1314              
00001AEC  43F9 00003CE4           1315              LEA         comma, A1           ; we know that the opcode will be MOVEM, so load A1 to print message
00001AF2  103C 000E               1316              MOVE.B      #14, D0             ; command for trap call to display message
00001AF6  4E4F                    1317              TRAP        #15                 ; trap call            
00001AF8                          1318              
00001AF8                          1319              
00001AF8  4243                    1320              CLR         D3                  ; Clears D3 to move effective address into it
00001AFA  1604                    1321              MOVE.B      D4,D3               ; Moves data with EA register
00001AFC  143C 0001               1322              MOVE.B      #one,D2             ; Puts 1 into D2 to print an An within printEA
00001B00                          1323              
00001B00  4EB9 00002F02           1324              JSR         printEA             ; Prints out source address
00001B06                          1325              
00001B06  43F9 00003CD9           1326              LEA         newline, A1         ; Prints new line
00001B0C  103C 000E               1327              MOVE.B      #14, D0             ; command for trap call to display message
00001B10  4E4F                    1328              TRAP        #15                 ; trap call
00001B12                          1329  
00001B12  6000 F538               1330              BRA         LOOP                ; Branch back to outer most loop that finds the first four bits                 
00001B16                          1331  
00001B16                          1332  ***********************************************************************************************************
00001B16                          1333  *
00001B16                          1334  *                   OR OPCODE
00001B16                          1335  *
00001B16                          1336  *       This section is dedicated to the OR opcode. This is determined that the first nibble is 8, and the
00001B16                          1337  *       second nibble is not 7 (or we would have DIVS), we must have OR.
00001B16                          1338  *       OR is varied by the operand direction. We have and EA to Dn, and DN to EA operation.
00001B16                          1339  *       These operand directions determine our opmode, which we use to disassemble.
00001B16                          1340  *
00001B16                          1341  ***********************************************************************************************************
00001B16                          1342              
00001B16                          1343  opOR                                        ; Assumed we found OR, begin disassemble
00001B16  43F9 00003D3B           1344              LEA         ORmatch,A1          ; Output OR to the IO console
00001B1C  103C 000E               1345              MOVE.B      #14,D0              ; Use trap 14
00001B20  4E4F                    1346              TRAP        #15                 ; Halt for IO
00001B22                          1347              
00001B22  E141                    1348              ASL         #eight,D1           ; Shift D1 by eight to find opmode
00001B24  1401                    1349              MOVE.B      D1,D2               ; Load D2 with the resulting byte
00001B26                          1350              
00001B26                          1351              ; These are for EA to Dn direction
00001B26  B43C 0000               1352              CMP.B       #zero,D2            ; Check for a byte
00001B2A  6700 002A               1353              BEQ         opORB               ; Byte in opmode
00001B2E  B43C 0001               1354              CMP.B       #one,D2             ; Check for a word
00001B32  6700 007C               1355              BEQ         opORW               ; Word in opmode
00001B36  B43C 0002               1356              CMP.B       #two,D2             ; Check for a long
00001B3A  6700 00CE               1357              BEQ         opORL               ; Long in opmode
00001B3E                          1358              
00001B3E                          1359              ; These are for Dn to EA direction
00001B3E  B43C 0004               1360              CMP.B       #four,D2            ; Check for a byte
00001B42  6700 0012               1361              BEQ         opORB               ; Byte in opmode
00001B46  B43C 0005               1362              CMP.B       #five,D2            ; Check for a word
00001B4A  6700 0064               1363              BEQ         opORW               ; Word in opmode
00001B4E  B43C 0006               1364              CMP.B       #six,D2             ; Check for a long
00001B52  6700 00B6               1365              BEQ         opORL               ; Long in opmode
00001B56                          1366              
00001B56                          1367  opORB                                       ; Byte determined, find operands from here
00001B56  43F9 00003D77           1368              LEA         dispByte,A1         ; Display our byte info
00001B5C  103C 000E               1369              MOVE.B      #14,D0              ; Trap #14 for our IO
00001B60  4E4F                    1370              TRAP        #15                 ; Halt for IO
00001B62                          1371              
00001B62  43F9 00003CDD           1372              LEA         space, A1           ; Display space
00001B68  103C 000E               1373              MOVE.B      #14, D0             ; command for trap call to display message
00001B6C  4E4F                    1374              TRAP        #15                 ; trap call
00001B6E                          1375              
00001B6E                          1376  
00001B6E  1401                    1377              MOVE.B      D1,D2               ; Load D2 again with the byte in D1
00001B70  E642                    1378              ASR         #3,D2               ; Shift by 3 for finding 1 operand
00001B72  C47C 0007               1379              AND         #$07,D2             ; AND by 7 to remove extras
00001B76  1601                    1380              MOVE.B      D1,D3               ; Load D3 with more necessary EA info
00001B78  C67C 0007               1381              AND         #$07,D3             ; AND by 7 to remove extra bits
00001B7C  4EB9 00002F02           1382              JSR         printEA             ; Determines the "left" operand register
00001B82                          1383              
00001B82  43F9 00003CE4           1384              LEA         comma, A1           ; Display space
00001B88  103C 000E               1385              MOVE.B      #14, D0             ; command for trap call to display message
00001B8C  4E4F                    1386              TRAP        #15                 ; trap call
00001B8E                          1387              
00001B8E  4242                    1388              CLR         D2                  ; Clear D2 for use
00001B90  3601                    1389              MOVE.W      D1,D3               ; Move our word into D3 for EA use
00001B92  E043                    1390              ASR         #eight,D3           ; Shift by 8 to isolate EA info
00001B94  E243                    1391              ASR         #one,D3             ; We need additional shift, so total shifts is by 9
00001B96  C67C 0007               1392              AND         #$07,D3             ; AND to remove extra data
00001B9A  4EB9 00002F02           1393              JSR         printEA             ; Redirect to EA subroutine to find EA operand info
00001BA0                          1394              
00001BA0  43F9 00003CD9           1395              LEA         newLine,A1          ; Prime a new line for the next instruction
00001BA6  103C 000E               1396              MOVE.B      #14,D0              ; Send it to the console
00001BAA  4E4F                    1397              TRAP        #15                 ; IO halt here
00001BAC                          1398              
00001BAC  6000 F49E               1399              BRA         LOOP                ; Return to control loop to find additional instructions
00001BB0                          1400              
00001BB0                          1401              
00001BB0                          1402  opORW                                       ; Word opmode has been found
00001BB0  43F9 00003D7A           1403              LEA         dispWord,A1         ; Display our word info
00001BB6  103C 000E               1404              MOVE.B      #14,D0              ; Trap #14 for our IO
00001BBA  4E4F                    1405              TRAP        #15                 ; Halt for IO
00001BBC                          1406              
00001BBC  43F9 00003CDD           1407              LEA         space, A1           ; Display space
00001BC2  103C 000E               1408              MOVE.B      #14, D0             ; command for trap call to display message
00001BC6  4E4F                    1409              TRAP        #15                 ; trap call
00001BC8                          1410              
00001BC8                          1411  
00001BC8  1401                    1412              MOVE.B      D1,D2               ; Load D2 again with the byte in D1
00001BCA  E642                    1413              ASR         #3,D2               ; Shift by 3 for finding 1 operand
00001BCC  C47C 0007               1414              AND         #$07,D2             ; AND by 7 to remove extras
00001BD0  1601                    1415              MOVE.B      D1,D3               ; Load D3 with more necessary EA info
00001BD2  C67C 0007               1416              AND         #$07,D3             ; AND by 7 to remove extra bits
00001BD6  4EB9 00002F02           1417              JSR         printEA             ; Determines the "left" operand register
00001BDC                          1418              
00001BDC  43F9 00003CE4           1419              LEA         comma, A1           ; Display space
00001BE2  103C 000E               1420              MOVE.B      #14, D0             ; command for trap call to display message
00001BE6  4E4F                    1421              TRAP        #15                 ; trap call
00001BE8                          1422              
00001BE8  4242                    1423              CLR         D2                  ; Clear D2 for use
00001BEA  3601                    1424              MOVE.W      D1,D3               ; Move our word into D3 for EA use
00001BEC  E043                    1425              ASR         #eight,D3           ; Shift by 8 to isolate EA info
00001BEE  E243                    1426              ASR         #one,D3             ; We need additional shift, so total shifts is by 9
00001BF0  C67C 0007               1427              AND         #$07,D3             ; AND to remove extra data
00001BF4  4EB9 00002F02           1428              JSR         printEA             ; Redirect to EA subroutine to find EA operand info
00001BFA                          1429              
00001BFA  43F9 00003CD9           1430              LEA         newLine,A1          ; Prime a new line for the next instruction
00001C00  103C 000E               1431              MOVE.B      #14,D0              ; Send it to the console
00001C04  4E4F                    1432              TRAP        #15                 ; IO halt here
00001C06                          1433              
00001C06  6000 F444               1434              BRA         LOOP                ; Return to control loop to find additional instructions
00001C0A                          1435              
00001C0A                          1436  opORL                                       ; Long value has been found for OR
00001C0A  43F9 00003D7D           1437              LEA         dispLong,A1         ; Display our long info
00001C10  103C 000E               1438              MOVE.B      #14,D0              ; Trap #14 for our IO
00001C14  4E4F                    1439              TRAP        #15                 ; Halt for IO
00001C16                          1440              
00001C16  43F9 00003CDD           1441              LEA         space, A1           ; Display space
00001C1C  103C 000E               1442              MOVE.B      #14, D0             ; command for trap call to display message
00001C20  4E4F                    1443              TRAP        #15                 ; trap call
00001C22                          1444              
00001C22                          1445  
00001C22  1401                    1446              MOVE.B      D1,D2               ; Load D2 again with the byte in D1
00001C24  E642                    1447              ASR         #3,D2               ; Shift by 3 for finding 1 operand
00001C26  C47C 0007               1448              AND         #$07,D2             ; AND by 7 to remove extras
00001C2A  1601                    1449              MOVE.B      D1,D3               ; Load D3 with more necessary EA info
00001C2C  C67C 0007               1450              AND         #$07,D3             ; AND by 7 to remove extra bits
00001C30  4EB9 00002F02           1451              JSR         printEA             ; Determines the "left" operand register
00001C36                          1452              
00001C36  43F9 00003CE4           1453              LEA         comma, A1           ; Display space
00001C3C  103C 000E               1454              MOVE.B      #14, D0             ; command for trap call to display message
00001C40  4E4F                    1455              TRAP        #15                 ; trap call
00001C42                          1456              
00001C42  4242                    1457              CLR         D2                  ; Clear D2 for use
00001C44  3601                    1458              MOVE.W      D1,D3               ; Move our word into D3 for EA use
00001C46  E043                    1459              ASR         #eight,D3           ; Shift by 8 to isolate EA info
00001C48  E243                    1460              ASR         #one,D3             ; We need additional shift, so total shifts is by 9
00001C4A  C67C 0007               1461              AND         #$07,D3             ; AND to remove extra data
00001C4E  4EB9 00002F02           1462              JSR         printEA             ; Redirect to EA subroutine to find EA operand info
00001C54                          1463              
00001C54  43F9 00003CD9           1464              LEA         newLine,A1          ; Prime a new line for the next instruction
00001C5A  103C 000E               1465              MOVE.B      #14,D0              ; Send it to the console
00001C5E  4E4F                    1466              TRAP        #15                 ; IO halt here
00001C60                          1467              
00001C60  6000 F3EA               1468              BRA         LOOP                ; Return to control loop to find additional instructions
00001C64                          1469              
00001C64                          1470  ***********************************************************************************************************
00001C64                          1471  *
00001C64                          1472  *                   DIVS OPCODE
00001C64                          1473  *
00001C64                          1474  *       This section is dedicate to the DIVS instruction, which is determined by a 8 in the first nibble
00001C64                          1475  *       and a 7 in the second nibble of the instruction.
00001C64                          1476  *       DIVSL is not supported, so the following code only accounts for the case of DIVS, which is short
00001C64                          1477  *       instead of a long
00001C64                          1478  *
00001C64                          1479  ***********************************************************************************************************
00001C64                          1480  
00001C64                          1481  opDIVS                                      ; Second nibble determined that the instruction was DIVS
00001C64  43F9 00003D36           1482              LEA         DIVSmatch,A1        ; Load DIVS into A1 for output console
00001C6A  103C 000E               1483              MOVE.B      #14,D0              ; Get trap task #14 for IO
00001C6E  4E4F                    1484              TRAP        #15                 ; Trap call to halt
00001C70                          1485              
00001C70  43F9 00003CDD           1486              LEA         space, A1           ; Display space
00001C76  103C 000E               1487              MOVE.B      #14, D0             ; command for trap call to display message
00001C7A  4E4F                    1488              TRAP        #15                 ; trap to halt
00001C7C                          1489              
00001C7C  1401                    1490              MOVE.B      D1,D2               ; Move our byte from D1 to D2 to manipulate
00001C7E  E642                    1491              ASR         #3,D2               ; Shift by 3 to find register
00001C80  C47C 0007               1492              AND         #$07,D2             ; AND by 7 to clear unnecessary bits
00001C84  1601                    1493              MOVE.B      D1,D3               ; Load the byte into D3 for EA comparison
00001C86  C67C 0007               1494              AND         #$07,D3             ; AND by 7 to clear unnecessary bits
00001C8A  4EB9 00002F02           1495              JSR         printEA             ; Call our EA subroutine to obtain EA bits from instruction
00001C90                          1496              
00001C90  43F9 00003CE4           1497              LEA         comma, A1           ; Display space
00001C96  103C 000E               1498              MOVE.B      #14, D0             ; command for trap call to display message
00001C9A  4E4F                    1499              TRAP        #15                 ; trap to halt call
00001C9C                          1500              
00001C9C  4242                    1501              CLR         D2                  ; Clear old data from D2 to avoid errors
00001C9E  3601                    1502              MOVE.W      D1,D3               ; Move word into D3 for EA subroutine
00001CA0  E043                    1503              ASR         #eight,D3           ; Shift by 8 to find to find the remaining EA components
00001CA2  E243                    1504              ASR         #one,D3             ; Additional shift by 1 to get proper bits
00001CA4  C67C 0007               1505              AND         #$07,D3             ; AND to clear unwanted bits
00001CA8  4EB9 00002F02           1506              JSR         printEA             ; Obtain other operand info
00001CAE                          1507              
00001CAE  43F9 00003CD9           1508              LEA         newLine,A1          ; Prepare new line for next instruction
00001CB4  103C 000E               1509              MOVE.B      #14,D0              ; Utilize trap task 14
00001CB8  4E4F                    1510              TRAP        #15                 ; Halt for IO
00001CBA                          1511              
00001CBA  6000 F390               1512              BRA         LOOP                ; Return to control loop
00001CBE                          1513              
00001CBE                          1514  **********************************************************************************************************
00001CBE                          1515  *
00001CBE                          1516  *                   EOR OPCODE
00001CBE                          1517  *
00001CBE                          1518  *       This sectioon is dedicated to the EOR opcode. We determine this with an 11 in the first nibble, and
00001CBE                          1519  *       a value higher than 3 in the second nibble.
00001CBE                          1520  *       The opmode fields is used to differ this instruction from CMP.
00001CBE                          1521  *       Dissassembly acquires opmode field info, which is similar to size, and to different EA related
00001CBE                          1522  *       operands.
00001CBE                          1523  *
00001CBE                          1524  ***********************************************************************************************************
00001CBE                          1525  
00001CBE                          1526  opEOR                                       ; We found EOR, begin disassembly
00001CBE  43F9 00003D42           1527              LEA         EORmatch,A1         ; Load A1 with our EOR output
00001CC4  103C 000E               1528              MOVE.B      #14,D0              ; Prime trap task #14
00001CC8  4E4F                    1529              TRAP        #15                 ; Halt for IO
00001CCA                          1530              
00001CCA  4242                    1531              CLR         D2                  ; Clear D2 for use again
00001CCC                          1532              
00001CCC  1401                    1533              MOVE.B      D1,D2               ; Move byte used in D1 to D2 for opmode check
00001CCE  EE42                    1534              ASR         #seven,D2           ; Move bits 7 places over to find opmode
00001CD0  C47C 0007               1535              AND         #$07,D2             ; AND by 7 to clear extra bits
00001CD4  B43C 0005               1536              CMP.B       #five,D2            ; Check for a byte in opmode
00001CD8  6D00 0012               1537              BLT         opEORB              ; Byte in opmode
00001CDC  B43C 0005               1538              CMP.B       #five,D2            ; Check for a word in opmode
00001CE0  6700 006A               1539              BEQ         opEORW              ; Word in opmode
00001CE4  B43C 0005               1540              CMP.B       #five,D2            ; Check for a long in opmode
00001CE8  6E00 00C2               1541              BGT         opEORL              ; Long in opmode
00001CEC                          1542              
00001CEC                          1543  opEORB                                      ; Determine instruction is a byte operation
00001CEC  43F9 00003D77           1544              LEA         dispByte,A1         ; Send out the byte info for the instruction
00001CF2  103C 000E               1545              MOVE.B      #14,D0              ; Utilize trap task 14
00001CF6  4E4F                    1546              TRAP        #15                 ; Halt for IO
00001CF8                          1547              
00001CF8  43F9 00003CDD           1548              LEA         space, A1           ; Display space
00001CFE  103C 000E               1549              MOVE.B      #14, D0             ; command for trap call to display message
00001D02  4E4F                    1550              TRAP        #15                 ; trap call to halt
00001D04                          1551              
00001D04  4242                    1552              CLR         D2                  ; Clear D2 again for use
00001D06  4243                    1553              CLR         D3                  ; Remove anything from D3
00001D08  3601                    1554              MOVE.W      D1,D3               ; Move word to D3 to find an operand
00001D0A  E043                    1555              ASR         #eight,D3           ; Shift by eight to ensure correct portion of instruction
00001D0C  E243                    1556              ASR         #one,D3             ; Needs to be shifted by an additional 1
00001D0E  C67C 0007               1557              AND         #$07,D3             ; Clear extra bits 
00001D12  4EB9 00002F02           1558              JSR         printEA             ; Use EA subroutine to print operand
00001D18                          1559              
00001D18  43F9 00003CE4           1560              LEA         comma, A1           ; Display space
00001D1E  103C 000E               1561              MOVE.B      #14, D0             ; command for trap call to display message
00001D22  4E4F                    1562              TRAP        #15                 ; trap call
00001D24                          1563              
00001D24  4242                    1564              CLR         D2                  ; Clear D2 again
00001D26  4243                    1565              CLR         D3                  ; Clear D3 again
00001D28  1401                    1566              MOVE.B      D1,D2               ; Move the byte value in D1 to D2 for EA use
00001D2A  E642                    1567              ASR         #three,D2           ; Shift by 3 to find EA info
00001D2C  C47C 0007               1568              AND         #seven,D2           ; AND by 7 to remove extra bits
00001D30  1601                    1569              MOVE.B      D1,D3               ; Move byte value from D1 into D3
00001D32  C67C 0007               1570              AND         #$07,D3             ; AND by 7 for EA subroutine
00001D36  4EB9 00002F02           1571              JSR         printEA             ; Determines remained operand EA info to print
00001D3C                          1572              
00001D3C  43F9 00003CD9           1573              LEA         newLine,A1          ; Print new line for next instruction
00001D42  103C 000E               1574              MOVE.B      #14,D0              ; Use trap 14 to output to console
00001D46  4E4F                    1575              TRAP        #15                 ; Halt for IO
00001D48                          1576              
00001D48  6000 F302               1577              BRA         LOOP                ; Return to control loop
00001D4C                          1578               
00001D4C                          1579  opEORW                                      ; Word opmode has been determined
00001D4C  43F9 00003D7A           1580              LEA         dispWord,A1         ; Send out the word info for the instruction
00001D52  103C 000E               1581              MOVE.B      #14,D0              ; Utilize trap task 14
00001D56  4E4F                    1582              TRAP        #15                 ; Halt for IO
00001D58                          1583              
00001D58  43F9 00003CDD           1584              LEA         space, A1           ; Display space
00001D5E  103C 000E               1585              MOVE.B      #14, D0             ; command for trap call to display message
00001D62  4E4F                    1586              TRAP        #15                 ; trap call to halt
00001D64                          1587              
00001D64  4242                    1588              CLR         D2                  ; Clear D2 again for use
00001D66  4243                    1589              CLR         D3                  ; Remove anything from D3
00001D68  3601                    1590              MOVE.W      D1,D3               ; Move word to D3 to find an operand
00001D6A  E043                    1591              ASR         #eight,D3           ; Shift by eight to ensure correct portion of instruction
00001D6C  E243                    1592              ASR         #one,D3             ; Needs to be shifted by an additional 1
00001D6E  C67C 0007               1593              AND         #$07,D3             ; Clear extra bits 
00001D72  4EB9 00002F02           1594              JSR         printEA             ; Use EA subroutine to print operand
00001D78                          1595              
00001D78  43F9 00003CE4           1596              LEA         comma, A1           ; Display space
00001D7E  103C 000E               1597              MOVE.B      #14, D0             ; command for trap call to display message
00001D82  4E4F                    1598              TRAP        #15                 ; trap call
00001D84                          1599              
00001D84  4242                    1600              CLR         D2                  ; Clear D2 again
00001D86  4243                    1601              CLR         D3                  ; Clear D3 again
00001D88  1401                    1602              MOVE.B      D1,D2               ; Move the byte value in D1 to D2 for EA use
00001D8A  E642                    1603              ASR         #three,D2           ; Shift by 3 to find EA info
00001D8C  C47C 0007               1604              AND         #seven,D2           ; AND by 7 to remove extra bits
00001D90  1601                    1605              MOVE.B      D1,D3               ; Move byte value from D1 into D3
00001D92  C67C 0007               1606              AND         #$07,D3             ; AND by 7 for EA subroutine
00001D96  4EB9 00002F02           1607              JSR         printEA             ; Determines remained operand EA info to print
00001D9C                          1608              
00001D9C  43F9 00003CD9           1609              LEA         newLine,A1          ; Print new line for next instruction
00001DA2  103C 000E               1610              MOVE.B      #14,D0              ; Use trap 14 to output to console
00001DA6  4E4F                    1611              TRAP        #15                 ; Halt for IO
00001DA8                          1612              
00001DA8  6000 F2A2               1613              BRA         LOOP                ; Return to control loop
00001DAC                          1614              
00001DAC                          1615  opEORL                                      ; Long has been determined
00001DAC  43F9 00003D7D           1616              LEA         dispLong,A1         ; Send out the long word info for the instruction
00001DB2  103C 000E               1617              MOVE.B      #14,D0              ; Utilize trap task 14
00001DB6  4E4F                    1618              TRAP        #15                 ; Halt for IO
00001DB8                          1619              
00001DB8  43F9 00003CDD           1620              LEA         space, A1           ; Display space
00001DBE  103C 000E               1621              MOVE.B      #14, D0             ; command for trap call to display message
00001DC2  4E4F                    1622              TRAP        #15                 ; trap call to halt
00001DC4                          1623              
00001DC4  4242                    1624              CLR         D2                  ; Clear D2 again for use
00001DC6  4243                    1625              CLR         D3                  ; Remove anything from D3
00001DC8  3601                    1626              MOVE.W      D1,D3               ; Move word to D3 to find an operand
00001DCA  E043                    1627              ASR         #eight,D3           ; Shift by eight to ensure correct portion of instruction
00001DCC  E243                    1628              ASR         #one,D3             ; Needs to be shifted by an additional 1
00001DCE  C67C 0007               1629              AND         #$07,D3             ; Clear extra bits 
00001DD2  4EB9 00002F02           1630              JSR         printEA             ; Use EA subroutine to print operand
00001DD8                          1631              
00001DD8  43F9 00003CE4           1632              LEA         comma, A1           ; Display space
00001DDE  103C 000E               1633              MOVE.B      #14, D0             ; command for trap call to display message
00001DE2  4E4F                    1634              TRAP        #15                 ; trap call
00001DE4                          1635              
00001DE4  4242                    1636              CLR         D2                  ; Clear D2 again
00001DE6  4243                    1637              CLR         D3                  ; Clear D3 again
00001DE8  1401                    1638              MOVE.B      D1,D2               ; Move the byte value in D1 to D2 for EA use
00001DEA  E642                    1639              ASR         #three,D2           ; Shift by 3 to find EA info
00001DEC  C47C 0007               1640              AND         #seven,D2           ; AND by 7 to remove extra bits
00001DF0  1601                    1641              MOVE.B      D1,D3               ; Move byte value from D1 into D3
00001DF2  C67C 0007               1642              AND         #$07,D3             ; AND by 7 for EA subroutine
00001DF6  4EB9 00002F02           1643              JSR         printEA             ; Determines remained operand EA info to print
00001DFC                          1644              
00001DFC  43F9 00003CD9           1645              LEA         newLine,A1          ; Print new line for next instruction
00001E02  103C 000E               1646              MOVE.B      #14,D0              ; Use trap 14 to output to console
00001E06  4E4F                    1647              TRAP        #15                 ; Halt for IO
00001E08                          1648              
00001E08  6000 F242               1649              BRA         LOOP                ; Return to the control loop
00001E0C                          1650  
00001E0C                          1651  ***********************************************************************************************************
00001E0C                          1652  *
00001E0C                          1653  *                   CMP OPCODE
00001E0C                          1654  *
00001E0C                          1655  *       This section is dedicated to the compare (CMP) instruction. Its determined in the control loop
00001E0C                          1656  *       that the first nibble is 11 for CMP, and the second nibble is 3.
00001E0C                          1657  *       The type of CMP, or the opmode, is used to determined what we output to our console next.
00001E0C                          1658  *       From that point, we load the correct size/opmode, and then route to the EA subroutine to output
00001E0C                          1659  *       EA related register information.
00001E0C                          1660  *       The process for finding the operand register info (EA info) is similar for all opmodes.
00001E0C                          1661  *
00001E0C                          1662  ***********************************************************************************************************
00001E0C                          1663  
00001E0C                          1664  opCMP       
00001E0C  43F9 00003D46           1665              LEA         CMPmatch,A1         ; We determined that the opcode is CMP, output to console
00001E12  103C 000E               1666              MOVE.B      #14,D0              ; Getting trap task #14 ready
00001E16  4E4F                    1667              TRAP        #15                 ; Trap 15 call for IO
00001E18                          1668              
00001E18  4242                    1669              CLR         D2                  ; D2 should be cleared for use later
00001E1A                          1670              
00001E1A  1401                    1671              MOVE.B      D1,D2               ; Get the next byte to manipulate
00001E1C  EC42                    1672              ASR         #six,D2             ; Move bits 7 places over to find opmode
00001E1E  C47C 0007               1673              AND         #$07,D2             ; AND by 7 allows us to compare properly on which opmode we need
00001E22  B43C 0000               1674              CMP.B       #zero,D2            ; Compare to zero to see if we have a byte
00001E26  6700 0016               1675              BEQ         opCMPB              ; Byte in opmode
00001E2A  B43C 0001               1676              CMP.B       #one,D2             ; Compare to one to see if we have a word
00001E2E  6700 0068               1677              BEQ         opCMPW              ; Word in opmode
00001E32  B43C 0002               1678              CMP.B       #two,D2             ; Compare to two to see if we have a long
00001E36  6700 00BA               1679              BEQ         opCMPL              ; Long in opmode
00001E3A                          1680              
00001E3A  6000 1E32               1681              BRA         printInvalid        ; Incorrect input
00001E3E                          1682  
00001E3E                          1683  opCMPB                                      ; Known we have CMP.B, find and output operands
00001E3E  43F9 00003D77           1684              LEA         dispByte,A1         ; Output the byte component of the instruction
00001E44  103C 000E               1685              MOVE.B      #14,D0              ; Trap task #14 for console out
00001E48  4E4F                    1686              TRAP        #15                 ; Halt for console out
00001E4A                          1687              
00001E4A  43F9 00003CDD           1688              LEA         space, A1           ; Display space for operands
00001E50  103C 000E               1689              MOVE.B      #14, D0             ; command for trap call to display message
00001E54  4E4F                    1690              TRAP        #15                 ; Console out/halt
00001E56                          1691              
00001E56  1401                    1692              MOVE.B      D1,D2               ; Move the byte for manipulation to D2
00001E58  E642                    1693              ASR         #3,D2               ; Shift right by 3 to find left operand register
00001E5A  C47C 0007               1694              AND         #$07,D2             ; AND for comparison later
00001E5E  1601                    1695              MOVE.B      D1,D3               ; Move the byte to D3 for use in our EA subroutine
00001E60  C67C 0007               1696              AND         #$07,D3             ; AND for comparison in subroutine
00001E64  4EB9 00002F02           1697              JSR         printEA             ; Use our EA subroutine to determine the left operand register
00001E6A                          1698              
00001E6A  43F9 00003CE4           1699              LEA         comma, A1           ; Display space
00001E70  103C 000E               1700              MOVE.B      #14, D0             ; command for trap call to display message
00001E74  4E4F                    1701              TRAP        #15                 ; trap call
00001E76                          1702              
00001E76  4242                    1703              CLR         D2                  ; D2 needs to be cleared for use later
00001E78  3601                    1704              MOVE.W      D1,D3               ; Move the entire word in D3 for shifting
00001E7A  E043                    1705              ASR         #eight,D3           ; Shift right by 8 to get EA bits from instruction
00001E7C  E243                    1706              ASR         #one,D3             ; Shift right once more to move the bits all the way
00001E7E  C67C 0007               1707              AND         #$07,D3             ; AND by 7 to clear unnecessary bits
00001E82  4EB9 00002F02           1708              JSR         printEA             ; EA subroutine call to get remaining operand sent to the console
00001E88                          1709              
00001E88  43F9 00003CD9           1710              LEA         newLine,A1          ; Prime A1 with our new line to output
00001E8E  103C 000E               1711              MOVE.B      #14,D0              ; Prime new line for next instruction
00001E92  4E4F                    1712              TRAP        #15                 ; Halt for IO
00001E94                          1713              
00001E94  6000 F1B6               1714              BRA         LOOP                ; Return to control loop for next disassembly
00001E98                          1715              
00001E98                          1716  opCMPW                                      ; Known we have CMP.W, find and output operands
00001E98  43F9 00003D7A           1717              LEA         dispWord,A1         ; Output the byte component of the instruction
00001E9E  103C 000E               1718              MOVE.B      #14,D0              ; Trap task #14 for console out
00001EA2  4E4F                    1719              TRAP        #15                 ; Halt for console out
00001EA4                          1720              
00001EA4  43F9 00003CDD           1721              LEA         space, A1           ; Display space for operands
00001EAA  103C 000E               1722              MOVE.B      #14, D0             ; command for trap call to display message
00001EAE  4E4F                    1723              TRAP        #15                 ; Console out/halt
00001EB0                          1724              
00001EB0  1401                    1725              MOVE.B      D1,D2               ; Move the byte for manipulation to D2
00001EB2  E642                    1726              ASR         #3,D2               ; Shift right by 3 to find left operand register
00001EB4  C47C 0007               1727              AND         #$07,D2             ; AND for comparison later
00001EB8  1601                    1728              MOVE.B      D1,D3               ; Move the byte to D3 for use in our EA subroutine
00001EBA  C67C 0007               1729              AND         #$07,D3             ; AND for comparison in subroutine
00001EBE  4EB9 00002F02           1730              JSR         printEA             ; Use our EA subroutine to determine the left operand register
00001EC4                          1731              
00001EC4  43F9 00003CE4           1732              LEA         comma, A1           ; Display space
00001ECA  103C 000E               1733              MOVE.B      #14, D0             ; command for trap call to display message
00001ECE  4E4F                    1734              TRAP        #15                 ; trap call
00001ED0                          1735              
00001ED0  4242                    1736              CLR         D2                  ; D2 needs to be cleared for use later
00001ED2  3601                    1737              MOVE.W      D1,D3               ; Move the entire word in D3 for shifting
00001ED4  E043                    1738              ASR         #eight,D3           ; Shift right by 8 to get EA bits from instruction
00001ED6  E243                    1739              ASR         #one,D3             ; Shift right once more to move the bits all the way
00001ED8  C67C 0007               1740              AND         #$07,D3             ; AND by 7 to clear unnecessary bits
00001EDC  4EB9 00002F02           1741              JSR         printEA             ; EA subroutine call to get remaining operand sent to the console
00001EE2                          1742              
00001EE2  43F9 00003CD9           1743              LEA         newLine,A1          ; Prime A1 with our new line to output
00001EE8  103C 000E               1744              MOVE.B      #14,D0              ; Prime new line for next instruction
00001EEC  4E4F                    1745              TRAP        #15                 ; Halt for IO
00001EEE                          1746              
00001EEE  6000 F15C               1747              BRA         LOOP                ; Return to control loop for next disassembly
00001EF2                          1748  
00001EF2                          1749  opCMPL                                      ; Known we have CMP.L, find and output operands
00001EF2  43F9 00003D7D           1750              LEA         dispLong,A1         ; Output the byte component of the instruction
00001EF8  103C 000E               1751              MOVE.B      #14,D0              ; Trap task #14 for console out
00001EFC  4E4F                    1752              TRAP        #15                 ; Halt for console out
00001EFE                          1753              
00001EFE  43F9 00003CDD           1754              LEA         space, A1           ; Display space for operands
00001F04  103C 000E               1755              MOVE.B      #14, D0             ; command for trap call to display message
00001F08  4E4F                    1756              TRAP        #15                 ; Console out/halt
00001F0A                          1757              
00001F0A  1401                    1758              MOVE.B      D1,D2               ; Move the byte for manipulation to D2
00001F0C  E642                    1759              ASR         #3,D2               ; Shift right by 3 to find left operand register
00001F0E  C47C 0007               1760              AND         #$07,D2             ; AND for comparison later
00001F12  1601                    1761              MOVE.B      D1,D3               ; Move the byte to D3 for use in our EA subroutine
00001F14  C67C 0007               1762              AND         #$07,D3             ; AND for comparison in subroutine
00001F18  4EB9 00002F02           1763              JSR         printEA             ; Use our EA subroutine to determine the left operand register
00001F1E                          1764              
00001F1E  43F9 00003CE4           1765              LEA         comma, A1           ; Display space
00001F24  103C 000E               1766              MOVE.B      #14, D0             ; command for trap call to display message
00001F28  4E4F                    1767              TRAP        #15                 ; trap call
00001F2A                          1768              
00001F2A  4242                    1769              CLR         D2                  ; D2 needs to be cleared for use later
00001F2C  3601                    1770              MOVE.W      D1,D3               ; Move the entire word in D3 for shifting
00001F2E  E043                    1771              ASR         #eight,D3           ; Shift right by 8 to get EA bits from instruction
00001F30  E243                    1772              ASR         #one,D3             ; Shift right once more to move the bits all the way
00001F32  C67C 0007               1773              AND         #$07,D3             ; AND by 7 to clear unnecessary bits
00001F36  4EB9 00002F02           1774              JSR         printEA             ; EA subroutine call to get remaining operand sent to the console
00001F3C                          1775              
00001F3C  43F9 00003CD9           1776              LEA         newLine,A1          ; Prime A1 with our new line to output
00001F42  103C 000E               1777              MOVE.B      #14,D0              ; Prime new line for next instruction
00001F46  4E4F                    1778              TRAP        #15                 ; Halt for IO
00001F48                          1779              
00001F48  6000 F102               1780              BRA         LOOP                ; Return to control loop for next disassembly
00001F4C                          1781  
00001F4C                          1782  ***********************************************************************************************************
00001F4C                          1783  *
00001F4C                          1784  *                   SUB OPCODE
00001F4C                          1785  *
00001F4C                          1786  *       This section is dedicated to disassembling the SUB opcode. We assume that the first nibble being 9
00001F4C                          1787  *       leads us to the SUB opcode.
00001F4C                          1788  *       SUB is differed by a operand direction, that being Dn - EA or EA - Dn.
00001F4C                          1789  *       These directions are deteremined as an opmode, and doubles up for each byte, long, and word mode.
00001F4C                          1790  *
00001F4C                          1791  ***********************************************************************************************************
00001F4C                          1792  
00001F4C                          1793  opSUB                                       ; We assume we found SUB, begin SUB disassemble
00001F4C  43F9 00003D3E           1794              LEA         SUBmatch, A1        ; Load A1 to print SUB found message
00001F52  103C 000E               1795              MOVE.B      #14, D0             ; command for trap call to display message
00001F56  4E4F                    1796              TRAP        #15                 ; trap call to halt
00001F58                          1797          
00001F58                          1798          
00001F58  E141                    1799              ASL         #eight,D1           ; Shift D1 to by 8 to find opmode
00001F5A  1218                    1800              MOVE.B      (A0)+,D1            ; Reload instruction
00001F5C  4242                    1801              CLR         D2                  ; Ensure D2 is clear
00001F5E                          1802              
00001F5E  3401                    1803              MOVE.W      D1,D2               ; Load our word into D2 to manipulate
00001F60  EC42                    1804              ASR         #six,D2             ; Move bits 7 places over to find opmode
00001F62  C47C 0007               1805              AND         #seven,D2           ; AND by 7 to remove extra bits
00001F66                          1806              
00001F66                          1807              ; These are for Dn - EA
00001F66  B43C 0000               1808              CMP.B       #zero,D2            ; Check for byte
00001F6A  6700 002A               1809              BEQ         opSUBB              ; Byte in opmode
00001F6E  B43C 0001               1810              CMP.B       #one,D2             ; Check for word
00001F72  6700 007C               1811              BEQ         opSUBW              ; Word in opmode
00001F76  B43C 0002               1812              CMP.B       #two,D2             ; Check for long
00001F7A  6700 00CE               1813              BEQ         opSUBL              ; Long in opmode
00001F7E                          1814              
00001F7E                          1815              ; These are for EA - Dn
00001F7E  B43C 0004               1816              CMP.B       #four,D2            ; Check for byte
00001F82  6700 0012               1817              BEQ         opSUBB              ; Byte in opmode
00001F86  B43C 0005               1818              CMP.B       #five,D2            ; Check for word
00001F8A  6700 0064               1819              BEQ         opSUBW              ; Word in opmode
00001F8E  B43C 0006               1820              CMP.B       #six,D2             ; Check for long
00001F92  6700 00B6               1821              BEQ         opSUBL              ; Long in opmode
00001F96                          1822              
00001F96                          1823  opSUBB                                      ; Byte has been found, find operands
00001F96  43F9 00003D77           1824              LEA         dispByte,A1         ; Output the byte info to the console
00001F9C  103C 000E               1825              MOVE.B      #14,D0              ; Use trap task 14 for IO
00001FA0  4E4F                    1826              TRAP        #15                 ; Halt for IO
00001FA2                          1827              
00001FA2  43F9 00003CDD           1828              LEA         space, A1           ; Display space
00001FA8  103C 000E               1829              MOVE.B      #14, D0             ; command for trap call to display message
00001FAC  4E4F                    1830              TRAP        #15                 ; trap call         
00001FAE                          1831              
00001FAE  1401                    1832              MOVE.B      D1,D2               ; Load D2 with our D1 byte
00001FB0  E642                    1833              ASR         #3,D2               ; Shift by 3 to find an operand
00001FB2  C47C 0007               1834              AND         #$07,D2             ; AND by 7 to remove extra bits
00001FB6  3601                    1835              MOVE.W      D1,D3               ; Load D3 with our word in D1
00001FB8  C67C 0007               1836              AND         #$07,D3             ; AND by 7 to remove extra bits
00001FBC  4EB9 00002F02           1837              JSR         printEA             ; Use EA subroutine to find an operand
00001FC2                          1838              
00001FC2  43F9 00003CE4           1839              LEA         comma, A1           ; Display space
00001FC8  103C 000E               1840              MOVE.B      #14, D0             ; command for trap call to display message
00001FCC  4E4F                    1841              TRAP        #15                 ; trap call
00001FCE                          1842              
00001FCE  4242                    1843              CLR         D2                  ; Empty D2 for use again
00001FD0  3601                    1844              MOVE.W      D1,D3               ; Load the word again into D3
00001FD2  E043                    1845              ASR         #eight,D3           ; Shift by 8 to find other operand
00001FD4  E243                    1846              ASR         #one,D3             ; Requires an additional shift
00001FD6  C67C 0007               1847              AND         #$07,D3             ; AND by 7 to remove extra bits
00001FDA  4EB9 00002F02           1848              JSR         printEA             ; EA subroutine finds our remaining operand
00001FE0                          1849              
00001FE0  43F9 00003CD9           1850              LEA         newLine,A1          ; Ready console with newline
00001FE6  103C 000E               1851              MOVE.B      #14,D0              ; Trap 14 for output
00001FEA  4E4F                    1852              TRAP        #15                 ; Halt for IO
00001FEC                          1853              
00001FEC  6000 F05E               1854              BRA         LOOP                ; Return to control loop
00001FF0                          1855              
00001FF0                          1856  opSUBW                                      ; Word has been found, find operands
00001FF0  43F9 00003D7A           1857              LEA         dispWord,A1         ; Output the word info to the console
00001FF6  103C 000E               1858              MOVE.B      #14,D0              ; Use trap task 14 for IO
00001FFA  4E4F                    1859              TRAP        #15                 ; Halt for IO
00001FFC                          1860              
00001FFC  43F9 00003CDD           1861              LEA         space, A1           ; Display space
00002002  103C 000E               1862              MOVE.B      #14, D0             ; command for trap call to display message
00002006  4E4F                    1863              TRAP        #15                 ; trap call         
00002008                          1864              
00002008  1401                    1865              MOVE.B      D1,D2               ; Load D2 with our D1 byte
0000200A  E642                    1866              ASR         #3,D2               ; Shift by 3 to find an operand
0000200C  C47C 0007               1867              AND         #$07,D2             ; AND by 7 to remove extra bits
00002010  3601                    1868              MOVE.W      D1,D3               ; Load D3 with our word in D1
00002012  C67C 0007               1869              AND         #$07,D3             ; AND by 7 to remove extra bits
00002016  4EB9 00002F02           1870              JSR         printEA             ; Use EA subroutine to find an operand
0000201C                          1871              
0000201C  43F9 00003CE4           1872              LEA         comma, A1           ; Display space
00002022  103C 000E               1873              MOVE.B      #14, D0             ; command for trap call to display message
00002026  4E4F                    1874              TRAP        #15                 ; trap call
00002028                          1875              
00002028  4242                    1876              CLR         D2                  ; Empty D2 for use again
0000202A  3601                    1877              MOVE.W      D1,D3               ; Load the word again into D3
0000202C  E043                    1878              ASR         #eight,D3           ; Shift by 8 to find other operand
0000202E  E243                    1879              ASR         #one,D3             ; Requires an additional shift
00002030  C67C 0007               1880              AND         #$07,D3             ; AND by 7 to remove extra bits
00002034  4EB9 00002F02           1881              JSR         printEA             ; EA subroutine finds our remaining operand
0000203A                          1882              
0000203A  43F9 00003CD9           1883              LEA         newLine,A1          ; Ready console with newline
00002040  103C 000E               1884              MOVE.B      #14,D0              ; Trap 14 for output
00002044  4E4F                    1885              TRAP        #15                 ; Halt for IO
00002046                          1886              
00002046  6000 F004               1887              BRA         LOOP                ; Return to control loop
0000204A                          1888              
0000204A                          1889  opSUBL                                      ; Long has been found, find operands
0000204A  43F9 00003D7D           1890              LEA         dispLong,A1         ; Output the long info to the console
00002050  103C 000E               1891              MOVE.B      #14,D0              ; Use trap task 14 for IO
00002054  4E4F                    1892              TRAP        #15                 ; Halt for IO
00002056                          1893              
00002056  43F9 00003CDD           1894              LEA         space, A1           ; Display space
0000205C  103C 000E               1895              MOVE.B      #14, D0             ; command for trap call to display message
00002060  4E4F                    1896              TRAP        #15                 ; trap call         
00002062                          1897              
00002062  1401                    1898              MOVE.B      D1,D2               ; Load D2 with our D1 byte
00002064  E642                    1899              ASR         #3,D2               ; Shift by 3 to find an operand
00002066  C47C 0007               1900              AND         #$07,D2             ; AND by 7 to remove extra bits
0000206A  3601                    1901              MOVE.W      D1,D3               ; Load D3 with our word in D1
0000206C  C67C 0007               1902              AND         #$07,D3             ; AND by 7 to remove extra bits
00002070  4EB9 00002F02           1903              JSR         printEA             ; Use EA subroutine to find an operand
00002076                          1904              
00002076  43F9 00003CE4           1905              LEA         comma, A1           ; Display space
0000207C  103C 000E               1906              MOVE.B      #14, D0             ; command for trap call to display message
00002080  4E4F                    1907              TRAP        #15                 ; trap call
00002082                          1908              
00002082  4242                    1909              CLR         D2                  ; Empty D2 for use again
00002084  3601                    1910              MOVE.W      D1,D3               ; Load the word again into D3
00002086  E043                    1911              ASR         #eight,D3           ; Shift by 8 to find other operand
00002088  E243                    1912              ASR         #one,D3             ; Requires an additional shift
0000208A  C67C 0007               1913              AND         #$07,D3             ; AND by 7 to remove extra bits
0000208E  4EB9 00002F02           1914              JSR         printEA             ; EA subroutine finds our remaining operand
00002094                          1915              
00002094  43F9 00003CD9           1916              LEA         newLine,A1          ; Ready console with newline
0000209A  103C 000E               1917              MOVE.B      #14,D0              ; Trap 14 for output
0000209E  4E4F                    1918              TRAP        #15                 ; Halt for IO
000020A0                          1919              
000020A0  6000 EFAA               1920              BRA         LOOP                ; Return to control loop
000020A4                          1921              
000020A4                          1922  ***********************************************************************************************************
000020A4                          1923  *
000020A4                          1924  *                   BRA OPCODE
000020A4                          1925  *       
000020A4                          1926  *       This section is dedicated to the BRA opcode, which is determined by having six in the first
000020A4                          1927  *       nibble of the instruction, and zero in the second nibble.
000020A4                          1928  *
000020A4                          1929  ***********************************************************************************************************
000020A4                          1930              
000020A4                          1931  opBRA       
000020A4  43F9 00003D22           1932              LEA         BRAmatch, A1        ; we know that the opcode will be BRA, so load A1 to print message
000020AA  103C 000E               1933              MOVE.B      #14, D0             ; Prime trap task #14 for output
000020AE  4E4F                    1934              TRAP        #15                 ; trap call to output BRA
000020B0                          1935          
000020B0  4242                    1936              CLR         D2                  ; Data register to needs to be cleared for use again
000020B2  4243                    1937              CLR         D3                  ; Data register to needs to be cleared for use again
000020B4                          1938  
000020B4  43F9 00003CDD           1939              LEA         space,A1            ; output a space for the IO console
000020BA  103C 000E               1940              MOVE.B      #14,D0              ; Prime trap task #14 for the output
000020BE  4E4F                    1941              TRAP        #15                 ; Call trap #15 with number 14 for our IO
000020C0                          1942          
000020C0  143C 0007               1943              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
000020C4  1218                    1944              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
000020C6  4EB9 00002F02           1945              JSR         printEA             ; this method handles the displacement hex values
000020CC                          1946          
000020CC  43F9 00003CD9           1947              LEA         newLine, A1         ; create new line for the IO console
000020D2  103C 000E               1948              MOVE.B      #14, D0             ; command for trap call to display message
000020D6  4E4F                    1949              TRAP        #15                 ; trap call ready console for next instruction
000020D8                          1950  
000020D8  6000 EF72               1951              BRA         LOOP                ; return back to our control loop to find next instruction
000020DC                          1952          
000020DC                          1953  ***********************************************************************************************************
000020DC                          1954  *
000020DC                          1955  *                   Bcc OPCODES
000020DC                          1956  *
000020DC                          1957  *       This section is dedicated to the conditional branching opcode. There are varying second nibble
000020DC                          1958  *       values, documented below, with the correspond cc code.
000020DC                          1959  *       BCC is similar to BRA, so we handle it in the same manner.
000020DC                          1960  *
000020DC                          1961  *       Supported cc condition codes:
000020DC                          1962  *           >Carry Clear        = CS        second nibble == 5
000020DC                          1963  *           >Overflow Set       = VC        second nibble == 8
000020DC                          1964  *           >Greater or EqualGE = GE        second nibble == 12
000020DC                          1965  *           >Less Than          = LT        second nibble == 13
000020DC                          1966  *
000020DC                          1967  ***********************************************************************************************************
000020DC                          1968  * CS Conition Code
000020DC                          1969  
000020DC                          1970  opBCS       
000020DC  43F9 00003D26           1971              LEA         BCSmatch, A1        ; we know that the opcode will be BCS, so load A1 to print message
000020E2  103C 000E               1972              MOVE.B      #14, D0             ; command for trap call to display message
000020E6  4E4F                    1973              TRAP        #15                 ; trap call
000020E8                          1974          
000020E8  4242                    1975              CLR         D2                  ; Data register to needs to be cleared for use again
000020EA  4243                    1976              CLR         D3                  ; Data register to needs to be cleared for use again
000020EC                          1977  
000020EC  43F9 00003CDD           1978              LEA         space,A1            ; output a space for the IO console
000020F2  103C 000E               1979              MOVE.B      #14,D0              ; Prime trap task #14 for the output
000020F6  4E4F                    1980              TRAP        #15                 ; Call trap #15 with number 14 for our IO
000020F8                          1981          
000020F8  143C 0007               1982              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
000020FC  1218                    1983              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
000020FE  4EB9 00002F02           1984              JSR         printEA             ; this method handles the displacement hex values
00002104                          1985          
00002104  43F9 00003CD9           1986              LEA         newLine, A1         ; create new line for the IO console
0000210A  103C 000E               1987              MOVE.B      #14, D0             ; command for trap call to display message
0000210E  4E4F                    1988              TRAP        #15                 ; trap call ready console for next instruction
00002110                          1989              
00002110  6000 EF3A               1990              BRA         LOOP                ; return to the control loop for next instruction
00002114                          1991  
00002114                          1992  ***********************************************************************************************************
00002114                          1993  * VC Condition Code
00002114                          1994  
00002114                          1995  opBVC       
00002114  43F9 00003D2A           1996              LEA         BVCmatch, A1        ; we know that the opcode will be BVC, so load A1 to print message
0000211A  103C 000E               1997              MOVE.B      #14, D0             ; command for trap call to display message
0000211E  4E4F                    1998              TRAP        #15                 ; trap call
00002120                          1999          
00002120  4242                    2000              CLR         D2                  ; Data register to needs to be cleared for use again
00002122  4243                    2001              CLR         D3                  ; Data register to needs to be cleared for use again
00002124                          2002  
00002124  43F9 00003CDD           2003              LEA         space,A1            ; output a space for the IO console
0000212A  103C 000E               2004              MOVE.B      #14,D0              ; Prime trap task #14 for the output
0000212E  4E4F                    2005              TRAP        #15                 ; Call trap #15 with number 14 for our IO
00002130                          2006          
00002130  143C 0007               2007              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
00002134  1218                    2008              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
00002136  4EB9 00002F02           2009              JSR         printEA             ; this method handles the displacement hex values
0000213C                          2010          
0000213C  43F9 00003CD9           2011              LEA         newLine, A1         ; create new line for the IO console
00002142  103C 000E               2012              MOVE.B      #14, D0             ; command for trap call to display message
00002146  4E4F                    2013              TRAP        #15                 ; trap call ready console for next instruction
00002148                          2014              
00002148  6000 EF02               2015              BRA         LOOP                ; return to the control loop for next instruction
0000214C                          2016  
0000214C                          2017  ***********************************************************************************************************
0000214C                          2018  * GE Conidtion Code     
0000214C                          2019          
0000214C                          2020  opBGE       
0000214C  43F9 00003D2E           2021              LEA         BGEmatch, A1        ; we know that the opcode will be BGE, so load A1 to print message
00002152  103C 000E               2022              MOVE.B      #14, D0             ; command for trap call to display message
00002156  4E4F                    2023              TRAP        #15                 ; trap call
00002158                          2024          
00002158  4242                    2025              CLR         D2                  ; Data register to needs to be cleared for use again
0000215A  4243                    2026              CLR         D3                  ; Data register to needs to be cleared for use again
0000215C                          2027  
0000215C  43F9 00003CDD           2028              LEA         space,A1            ; output a space for the IO console
00002162  103C 000E               2029              MOVE.B      #14,D0              ; Prime trap task #14 for the output
00002166  4E4F                    2030              TRAP        #15                 ; Call trap #15 with number 14 for our IO
00002168                          2031          
00002168  143C 0007               2032              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
0000216C  1218                    2033              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
0000216E  4EB9 00002F02           2034              JSR         printEA             ; this method handles the displacement hex values
00002174                          2035          
00002174  43F9 00003CD9           2036              LEA         newLine, A1         ; create new line for the IO console
0000217A  103C 000E               2037              MOVE.B      #14, D0             ; command for trap call to display message
0000217E  4E4F                    2038              TRAP        #15                 ; trap call ready console for next instruction
00002180                          2039              
00002180  6000 EECA               2040              BRA         LOOP                ; return to the control loop for next instruction
00002184                          2041  
00002184                          2042  ***********************************************************************************************************
00002184                          2043  * LT Conditions Code        
00002184                          2044          
00002184                          2045  opBLT   
00002184  43F9 00003D32           2046              LEA         BLTmatch, A1        ; we know that the opcode will be BLT, so load A1 to print message
0000218A  103C 000E               2047              MOVE.B      #14, D0             ; command for trap call to display message
0000218E  4E4F                    2048              TRAP        #15                 ; trap call
00002190                          2049          
00002190  4242                    2050              CLR         D2                  ; Data register to needs to be cleared for use again
00002192  4243                    2051              CLR         D3                  ; Data register to needs to be cleared for use again
00002194                          2052  
00002194  43F9 00003CDD           2053              LEA         space,A1            ; output a space for the IO console
0000219A  103C 000E               2054              MOVE.B      #14,D0              ; Prime trap task #14 for the output
0000219E  4E4F                    2055              TRAP        #15                 ; Call trap #15 with number 14 for our IO
000021A0                          2056          
000021A0  143C 0007               2057              MOVE.B      #seven,D2           ; We know we need to move seven due to the nature of BRA in 68k
000021A4  1218                    2058              MOVE.B      (A0)+,D1            ; Move the byte we stored for use from our addr register to D1
000021A6  4EB9 00002F02           2059              JSR         printEA             ; this method handles the displacement hex values
000021AC                          2060          
000021AC  43F9 00003CD9           2061              LEA         newLine, A1         ; create new line for the IO console
000021B2  103C 000E               2062              MOVE.B      #14, D0             ; command for trap call to display message
000021B6  4E4F                    2063              TRAP        #15                 ; trap call ready console for next instruction
000021B8                          2064              
000021B8  6000 EE92               2065              BRA         LOOP                ; return to the control loop for next instruction
000021BC                          2066          
000021BC                          2067  ***********************************************************************************************************
000021BC                          2068  *
000021BC                          2069  *               SUBQ OPCODE
000021BC                          2070  *
000021BC                          2071  *       This section is for disassembling the SUBQ instruction, which is determined by a 5 in the first
000021BC                          2072  *       nibble.
000021BC                          2073  *       We assume there is only 1 opcode with 5 in the first nibble.
000021BC                          2074  *       SUBQ utilizes immediate data, so we use an alternate subroutine for operand output.
000021BC                          2075  *       The size field is used to branch to the subvariants of SUBQ, which we determine before hitting the
000021BC                          2076  *       final subroutines.
000021BC                          2077  *
000021BC                          2078  ***********************************************************************************************************
000021BC                          2079  
000021BC                          2080  opSUBQ                                      ; Assumed that we found SUBQ, begin disassemble
000021BC  43F9 00003D1D           2081              LEA         SUBQmatch, A1       ; Send out SUBQ message
000021C2  103C 000E               2082              MOVE.B      #14, D0             ; command for trap call to display message
000021C6  4E4F                    2083              TRAP        #15                 ; trap call to halt
000021C8                          2084              
000021C8  E141                    2085              ASL         #eight,D1           ; Shift by 8 to find size bits
000021CA  1218                    2086              MOVE.B      (A0)+,D1            ; Reload D1
000021CC  1401                    2087              MOVE.B      D1,D2               ; Move data in D2 to alter later
000021CE  EE42                    2088              ASR         #seven,D2           ; Move bits 7 places over to find size
000021D0  C47C 0007               2089              AND         #$07,D2             ; AND by 7 to remove uneeded bits
000021D4                          2090              
000021D4                          2091              ; Find size bits
000021D4  B43C 0000               2092              CMP.B       #zero,D2            ; Check for a byte
000021D8  6700 0012               2093              BEQ         opSUBQB             ; Byte in size
000021DC  B43C 0001               2094              CMP.B       #one,D2             ; Check for a word
000021E0  6700 0020               2095              BEQ         opSUBQW             ; Word in size
000021E4  B43C 0002               2096              CMP.B       #two,D2             ; Check for a long
000021E8  6700 002E               2097              BEQ         opSUBQL             ; Long in size
000021EC                          2098              
000021EC                          2099  opSUBQB                                     ; Found a byte in size, prepare for JSR
000021EC  43F9 00003D77           2100              LEA         dispByte,A1         ; Display the byte in the console
000021F2  103C 000E               2101              MOVE.B      #14,D0              ; Trap task 14 for IO
000021F6  4E4F                    2102              TRAP        #15                 ; Halt for IO
000021F8                          2103            
000021F8  4EB9 00002E2A           2104              JSR         PrntImm             ; Call immediate data subroutine to handle SUBQ operands
000021FE                          2105              
000021FE  6000 EE4C               2106              BRA         LOOP                ; Return to control loop
00002202                          2107              
00002202                          2108  opSUBQW                                     ; Found a word in size, prepare for JSR
00002202  43F9 00003D7A           2109              LEA         dispWord,A1         ; Display the word in the console
00002208  103C 000E               2110              MOVE.B      #14,D0              ; Trap task 14 for IO
0000220C  4E4F                    2111              TRAP        #15                 ; Halt for IO
0000220E                          2112            
0000220E  4EB9 00002E2A           2113              JSR         PrntImm             ; Call immediate data subroutine to handle SUBQ operands
00002214                          2114              
00002214  6000 EE36               2115              BRA         LOOP                ; Return to control loop
00002218                          2116              
00002218                          2117  opSUBQL                                     ; Found a long in size, prepare for JSR
00002218  43F9 00003D7D           2118              LEA         dispLong,A1         ; Display the long in the console
0000221E  103C 000E               2119              MOVE.B      #14,D0              ; Trap task 14 for IO
00002222  4E4F                    2120              TRAP        #15                 ; Halt for IO
00002224                          2121            
00002224  4246                    2122              CLR         D6                  ; In the long size case, we need to ensure D6 is clear for the JSR call
00002226  1C3C 0001               2123              MOVE.B      #1,D6               ; Needed to ensure proper immediate data is output to the console
0000222A                          2124            
0000222A  4EB9 00002E2A           2125              JSR         PrntImm             ; Call immediate data subroutine to handle SUBQ operands
00002230                          2126              
00002230  6000 EE1A               2127              BRA         LOOP                ; Return to control loop
00002234                          2128          
00002234                          2129  ***********************************************************************************************************
00002234                          2130  *
00002234                          2131  *                   MULS OPCODE
00002234                          2132  *
00002234                          2133  ***********************************************************************************************************
00002234                          2134  
00002234                          2135  opMULS  
00002234  43F9 00003D4A           2136              LEA         MULSmatch, A1       ; we know that the opcode will be MULS, so load A1 to print message
0000223A  103C 000E               2137              MOVE.B      #14, D0             ; command for trap call to display message
0000223E  4E4F                    2138              TRAP        #15                 ; trap call
00002240  43F9 00003CDD           2139              LEA         space, A1           ; create spaces
00002246  103C 000E               2140              MOVE.B      #14, D0             ; command for trap call to display message
0000224A  4E4F                    2141              TRAP        #15                 ; trap call
0000224C                          2142          
0000224C  E141                    2143              ASL         #eight, D1          ; move D1 over by a byte
0000224E  1218                    2144              MOVE.B      (A0)+, D1           ; copy the next byte into D1
00002250                          2145          
00002250  4242                    2146              CLR         D2                  ; clear D2
00002252  4243                    2147              CLR         D3                  ; clear D3
00002254  1401                    2148              MOVE.B      D1, D2              ; copy the byte from D1 to D2
00002256  E642                    2149              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
00002258  C47C 0007               2150              AND         #seven, D2          ; and D2 to get only first 3 bits
0000225C  1601                    2151              MOVE.B      D1, D3              ; copy D1 byte to D3
0000225E  C67C 0007               2152              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
00002262                          2153          
00002262  4EB9 00002F02           2154              JSR         printEA             ; jump to printEA
00002268                          2155          
00002268  43F9 00003CE4           2156              LEA         comma, A1           ; create comma
0000226E  103C 000E               2157              MOVE.B      #14, D0             ; command for trap call to display message
00002272  4E4F                    2158              TRAP        #15                 ; trap call
00002274                          2159  
00002274  4242                    2160              CLR         D2                  ; clear D2 since we know mode should be data register
00002276  4243                    2161              CLR         D3                  ; clear D3
00002278  3601                    2162              MOVE.W      D1, D3              ; Move D1 word to D3
0000227A  E043                    2163              ASR         #eight, D3          ; shift D3 by 8 bits
0000227C  E243                    2164              ASR         #one, D3            ; shift D3 by 1 bit
0000227E  C67C 0007               2165              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
00002282                          2166  
00002282  4EB9 00002F02           2167              JSR         printEA             ; jump to printEA
00002288                          2168          
00002288  43F9 00003CD9           2169              LEA         newLine, A1         ; create new line
0000228E  103C 000E               2170              MOVE.B      #14, D0             ; command for trap call to display message
00002292  4E4F                    2171              TRAP        #15                 ; trap call
00002294                          2172          
00002294  6000 EDB6               2173              BRA         LOOP                ; branch back to LOOP
00002298                          2174  
00002298                          2175  ***********************************************************************************************************
00002298                          2176  *
00002298                          2177  *                   ADD OPCODE
00002298                          2178  *
00002298                          2179  ***********************************************************************************************************   
00002298                          2180  
00002298                          2181  opADDB  
00002298  43F9 00003D4F           2182              LEA         ADDmatch, A1        ; we know that the opcode will be ADD, so load A1 to print message
0000229E  103C 000E               2183              MOVE.B      #14, D0             ; command for trap call to display message
000022A2  4E4F                    2184              TRAP        #15                 ; trap call
000022A4                          2185          
000022A4  43F9 00003D77           2186              LEA         dispByte, A1        ; display byte
000022AA  103C 000E               2187              MOVE.B      #14, D0             ; command for trap call to display message
000022AE  4E4F                    2188              TRAP        #15                 ; trap call
000022B0  43F9 00003CDD           2189              LEA         space, A1           ; create spaces
000022B6  103C 000E               2190              MOVE.B      #14, D0             ; command for trap call to display message
000022BA  4E4F                    2191              TRAP        #15                 ; trap call
000022BC                          2192          
000022BC  4242                    2193              CLR         D2                  ; clear D2
000022BE  4243                    2194              CLR         D3                  ; clear D3
000022C0  1401                    2195              MOVE.B      D1, D2              ; copy the byte from D1 to D2
000022C2  E642                    2196              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
000022C4  C47C 0007               2197              AND         #seven, D2          ; and D2 to get only first 3 bits
000022C8  1601                    2198              MOVE.B      D1, D3              ; copy D1 byte to D3
000022CA  C67C 0007               2199              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
000022CE                          2200          
000022CE  4EB9 00002F02           2201              JSR         printEA             ; jump to printEA
000022D4                          2202          
000022D4  43F9 00003CE4           2203              LEA         comma, A1           ; create comma
000022DA  103C 000E               2204              MOVE.B      #14, D0             ; command for trap call to display message
000022DE  4E4F                    2205              TRAP        #15                 ; trap call
000022E0                          2206  
000022E0  4242                    2207              CLR         D2                  ; clear D2 since we know mode should be data register
000022E2  4243                    2208              CLR         D3                  ; clear D3
000022E4  3601                    2209              MOVE.W      D1, D3              ; Move D1 word to D3
000022E6  E043                    2210              ASR         #eight, D3          ; shift D3 by 8 bits
000022E8  E243                    2211              ASR         #one, D3            ; shift D3 by 1 bit
000022EA  C67C 0007               2212              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
000022EE                          2213  
000022EE  4EB9 00002F02           2214              JSR         printEA             ; jump to printEA
000022F4                          2215          
000022F4  43F9 00003CD9           2216              LEA         newLine, A1         ; create new line
000022FA  103C 000E               2217              MOVE.B      #14, D0             ; command for trap call to display message
000022FE  4E4F                    2218              TRAP        #15                 ; trap call
00002300                          2219          
00002300  6000 ED4A               2220              BRA         LOOP                ; branch back to LOOP
00002304                          2221          
00002304                          2222  opADDW  
00002304  43F9 00003D4F           2223              LEA         ADDmatch, A1        ; we know that the opcode will be ADD, so load A1 to print message
0000230A  103C 000E               2224              MOVE.B      #14, D0             ; command for trap call to display message
0000230E  4E4F                    2225              TRAP        #15                 ; trap call
00002310                          2226  
00002310  43F9 00003D7A           2227              LEA         dispWord, A1        ; display word
00002316  103C 000E               2228              MOVE.B      #14, D0             ; command for trap call to display message
0000231A  4E4F                    2229              TRAP        #15                 ; trap call
0000231C  43F9 00003CDD           2230              LEA         space, A1           ; create spaces
00002322  103C 000E               2231              MOVE.B      #14, D0             ; command for trap call to display message
00002326  4E4F                    2232              TRAP        #15                 ; trap call
00002328                          2233          
00002328  4242                    2234              CLR         D2                  ; clear D2
0000232A  4243                    2235              CLR         D3                  ; clear D3
0000232C  1401                    2236              MOVE.B      D1, D2              ; copy the byte from D1 to D2
0000232E  E642                    2237              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
00002330  C47C 0007               2238              AND         #seven, D2          ; and D2 to get only first 3 bits
00002334  1601                    2239              MOVE.B      D1, D3              ; copy D1 byte to D3
00002336  C67C 0007               2240              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
0000233A                          2241          
0000233A  4EB9 00002F02           2242              JSR         printEA             ; jump to printEA
00002340                          2243          
00002340  43F9 00003CE4           2244              LEA         comma, A1           ; create comma
00002346  103C 000E               2245              MOVE.B      #14, D0             ; command for trap call to display message
0000234A  4E4F                    2246              TRAP        #15                 ; trap call
0000234C                          2247  
0000234C  4242                    2248              CLR         D2                  ; clear D2 since we know mode should be data register
0000234E  4243                    2249              CLR         D3                  ; clear D3
00002350  3601                    2250              MOVE.W      D1, D3              ; Move D1 word to D3
00002352  E043                    2251              ASR         #eight, D3          ; shift D3 by 8 bits
00002354  E243                    2252              ASR         #one, D3            ; shift D3 by 1 bit
00002356  C67C 0007               2253              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
0000235A                          2254  
0000235A  4EB9 00002F02           2255              JSR         printEA             ; jump to printEA
00002360                          2256          
00002360  43F9 00003CD9           2257              LEA         newLine, A1         ; create new line
00002366  103C 000E               2258              MOVE.B      #14, D0             ; command for trap call to display message
0000236A  4E4F                    2259              TRAP        #15                 ; trap call
0000236C                          2260          
0000236C  6000 ECDE               2261              BRA         LOOP                ; branch back to LOOP
00002370                          2262          
00002370                          2263  opADDL  
00002370  43F9 00003D4F           2264              LEA         ADDmatch, A1        ; we know that the opcode will be ADD, so load A1 to print message
00002376  103C 000E               2265              MOVE.B      #14, D0             ; command for trap call to display message
0000237A  4E4F                    2266              TRAP        #15                 ; trap call
0000237C                          2267          
0000237C  43F9 00003D7D           2268              LEA         dispLong, A1        ; display long
00002382  103C 000E               2269              MOVE.B      #14, D0             ; command for trap call to display message
00002386  4E4F                    2270              TRAP        #15                 ; trap call
00002388  43F9 00003CDD           2271              LEA         space, A1           ; create spaces
0000238E  103C 000E               2272              MOVE.B      #14, D0             ; command for trap call to display message
00002392  4E4F                    2273              TRAP        #15                 ; trap call
00002394                          2274          
00002394  4242                    2275              CLR         D2                  ; clear D2
00002396  4243                    2276              CLR         D3                  ; clear D3
00002398  1401                    2277              MOVE.B      D1, D2              ; copy the byte from D1 to D2
0000239A  E642                    2278              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
0000239C  C47C 0007               2279              AND         #seven, D2          ; and D2 to get only first 3 bits
000023A0  1601                    2280              MOVE.B      D1, D3              ; copy D1 byte to D3
000023A2  C67C 0007               2281              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
000023A6                          2282          
000023A6  4246                    2283              CLR         D6                  ; Clear D6
000023A8  1C3C 0001               2284              MOVE.B      #1, D6              ; move 1 to D6 in case source is printing immediate
000023AC                          2285          
000023AC  4EB9 00002F02           2286              JSR         printEA             ; jump to printEA
000023B2  4246                    2287              CLR         D6                  ; clear D6
000023B4                          2288          
000023B4  43F9 00003CE4           2289              LEA         comma, A1           ; create comma
000023BA  103C 000E               2290              MOVE.B      #14, D0             ; command for trap call to display message
000023BE  4E4F                    2291              TRAP        #15                 ; trap call
000023C0                          2292  
000023C0  4242                    2293              CLR         D2                  ; clear D2 since we know mode should be data register
000023C2  4243                    2294              CLR         D3                  ; clear D3
000023C4  3601                    2295              MOVE.W      D1, D3              ; Move D1 word to D3
000023C6  E043                    2296              ASR         #eight, D3          ; shift D3 by 8 bits
000023C8  E243                    2297              ASR         #one, D3            ; shift D3 by 1 bit
000023CA  C67C 0007               2298              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
000023CE                          2299  
000023CE  4EB9 00002F02           2300              JSR         printEA             ; jump to printEA
000023D4                          2301          
000023D4  43F9 00003CD9           2302              LEA         newLine, A1         ; create new line
000023DA  103C 000E               2303              MOVE.B      #14, D0             ; command for trap call to display message
000023DE  4E4F                    2304              TRAP        #15                 ; trap call
000023E0                          2305          
000023E0  6000 EC6A               2306              BRA         LOOP                ; branch back to LOOP
000023E4                          2307  
000023E4                          2308  ***********************************************************************************************************
000023E4                          2309  *
000023E4                          2310  *                   ADDA OPCODE
000023E4                          2311  *
000023E4                          2312  *********************************************************************************************************** 
000023E4                          2313  
000023E4                          2314  opADDAW 
000023E4  43F9 00003D53           2315              LEA         ADDAmatch, A1       ; we know that the opcode will be ADDA, so load A1 to print message
000023EA  103C 000E               2316              MOVE.B      #14, D0             ; command for trap call to display message
000023EE  4E4F                    2317              TRAP        #15                 ; trap call
000023F0                          2318          
000023F0  43F9 00003D7A           2319              LEA         dispWord, A1        ; display word
000023F6  103C 000E               2320              MOVE.B      #14, D0             ; command for trap call to display message
000023FA  4E4F                    2321              TRAP        #15                 ; trap call
000023FC  43F9 00003CDD           2322              LEA         space, A1           ; create spaces
00002402  103C 000E               2323              MOVE.B      #14, D0             ; command for trap call to display message
00002406  4E4F                    2324              TRAP        #15                 ; trap call
00002408                          2325          
00002408  4242                    2326              CLR         D2                  ; clear D2
0000240A  4243                    2327              CLR         D3                  ; clear D3
0000240C  1401                    2328              MOVE.B      D1, D2              ; copy the byte from D1 to D2
0000240E  E642                    2329              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
00002410  C47C 0007               2330              AND         #seven, D2          ; and D2 to get only first 3 bits
00002414  1601                    2331              MOVE.B      D1, D3              ; copy D1 byte to D3
00002416  C67C 0007               2332              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
0000241A                          2333          
0000241A  4EB9 00002F02           2334              JSR         printEA             ; jump to printEA 
00002420                          2335          
00002420  43F9 00003CE4           2336              LEA         comma, A1           ; create comma
00002426  103C 000E               2337              MOVE.B      #14, D0             ; command for trap call to display message
0000242A  4E4F                    2338              TRAP        #15                 ; trap call
0000242C                          2339  
0000242C  4242                    2340              CLR         D2                  ; clear D2 since we know mode should be data register
0000242E  4243                    2341              CLR         D3                  ; clear D3
00002430  143C 0001               2342              MOVE.B      #one, D2            ; move 1 to D2 since mode should be address
00002434  3601                    2343              MOVE.W      D1, D3              ; Move D1 word to D3
00002436  E043                    2344              ASR         #eight, D3          ; shift D3 by 8 bits
00002438  E243                    2345              ASR         #one, D3            ; shift D3 by 1 bit
0000243A  C67C 0007               2346              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
0000243E                          2347  
0000243E  4EB9 00002F02           2348              JSR         printEA             ; jump to printEA
00002444                          2349          
00002444  43F9 00003CD9           2350              LEA         newLine, A1         ; create new line
0000244A  103C 000E               2351              MOVE.B      #14, D0             ; command for trap call to display message
0000244E  4E4F                    2352              TRAP        #15                 ; trap call
00002450                          2353          
00002450  6000 EBFA               2354              BRA         LOOP                ; branch back to LOOP
00002454                          2355  
00002454                          2356  opADDAL 
00002454  43F9 00003D53           2357              LEA         ADDAmatch, A1       ; we know that the opcode will be ADDA, so load A1 to print message
0000245A  103C 000E               2358              MOVE.B      #14, D0             ; command for trap call to display message
0000245E  4E4F                    2359              TRAP        #15                 ; trap call
00002460                          2360  
00002460  43F9 00003D7D           2361              LEA         dispLong, A1        ; display long
00002466  103C 000E               2362              MOVE.B      #14, D0             ; command for trap call to display message
0000246A  4E4F                    2363              TRAP        #15                 ; trap call
0000246C  43F9 00003CDD           2364              LEA         space, A1           ; create spaces
00002472  103C 000E               2365              MOVE.B      #14, D0             ; command for trap call to display message
00002476  4E4F                    2366              TRAP        #15                 ; trap call
00002478                          2367          
00002478  4242                    2368              CLR         D2                  ; clear D2
0000247A  4243                    2369              CLR         D3                  ; clear D3
0000247C  1401                    2370              MOVE.B      D1, D2              ; copy the byte from D1 to D2
0000247E  E642                    2371              ASR         #three, D2          ; shift D2 by 3 bits to get source mode
00002480  C47C 0007               2372              AND         #seven, D2          ; and D2 to get only first 3 bits
00002484  1601                    2373              MOVE.B      D1, D3              ; copy D1 byte to D3
00002486  C67C 0007               2374              AND         #seven, D3          ; and D3 to get first 3 bits also known as register
0000248A                          2375          
0000248A  4EB9 00002F02           2376              JSR         printEA             ; jump to printEA 
00002490                          2377          
00002490  43F9 00003CE4           2378              LEA         comma, A1           ; create comma
00002496  103C 000E               2379              MOVE.B      #14, D0             ; command for trap call to display message
0000249A  4E4F                    2380              TRAP        #15                 ; trap call
0000249C                          2381  
0000249C  4242                    2382              CLR         D2                  ; clear D2 since we know mode should be data register
0000249E  4243                    2383              CLR         D3                  ; clear D3
000024A0  143C 0001               2384              MOVE.B      #one, D2            ; move 1 to D2 since mode should be address
000024A4  3601                    2385              MOVE.W      D1, D3              ; Move D1 word to D3
000024A6  E043                    2386              ASR         #eight, D3          ; shift D3 by 8 bits
000024A8  E243                    2387              ASR         #one, D3            ; shift D3 by 1 bit
000024AA  C67C 0007               2388              AND         #seven, D3          ; and D3 to get first 3 bits which are the register
000024AE                          2389  
000024AE  4EB9 00002F02           2390              JSR         printEA             ; jump to printEA
000024B4                          2391          
000024B4  43F9 00003CD9           2392              LEA         newLine, A1         ; create new line
000024BA  103C 000E               2393              MOVE.B      #14, D0             ; command for trap call to display message
000024BE  4E4F                    2394              TRAP        #15                 ; trap call
000024C0                          2395          
000024C0  6000 EB8A               2396              BRA         LOOP                ; branch back to LOOP
000024C4                          2397          
000024C4                          2398  ***********************************************************************************************************
000024C4                          2399  *
000024C4                          2400  *                       Shifting OPCODES
000024C4                          2401  *
000024C4                          2402  ***********************************************************************************************************
000024C4                          2403  
000024C4                          2404  opASL       
000024C4  43F9 00003D64           2405              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
000024CA  103C 000E               2406              MOVE.B      #14, D0             ; command for trap call to display message
000024CE  4E4F                    2407              TRAP        #15                 ; trap call
000024D0                          2408          
000024D0  43F9 00003D7A           2409              LEA         dispWord, A1        ; display word
000024D6  103C 000E               2410              MOVE.B      #14, D0             ; command for trap call to display message
000024DA  4E4F                    2411              TRAP        #15                 ; trap call
000024DC                          2412          
000024DC  43F9 00003CDD           2413              LEA         space, A1           ; display space 
000024E2  103C 000E               2414              MOVE.B      #14, D0             ; command for trap call to display message
000024E6  4E4F                    2415              TRAP        #15                 ; trap call
000024E8                          2416          
000024E8  4242                    2417              CLR         D2                  ; clear D2
000024EA  4243                    2418              CLR         D3                  ; clear D3
000024EC  1401                    2419              MOVE.B      D1,D2               ; move byte from D1 to D2
000024EE  1601                    2420              MOVE.B      D1,D3               ; move byte from D1 to D3
000024F0                          2421          
000024F0  E602                    2422              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
000024F2  C47C 0007               2423              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
000024F6  C67C 0007               2424              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
000024FA                          2425          
000024FA  4EB9 00002F02           2426              JSR         printEA             ; jump to printEA
00002500                          2427          
00002500  43F9 00003CD9           2428              LEA         newLine, A1         ; Display newLine
00002506  103C 000E               2429              MOVE.B      #14, D0             ; command for trap call to display message
0000250A  4E4F                    2430              TRAP        #15                 ; trap call
0000250C                          2431          
0000250C  6000 EB3E               2432              BRA         LOOP                ; branch back to LOOP
00002510                          2433  
00002510                          2434  opASR   
00002510  43F9 00003D60           2435              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002516  103C 000E               2436              MOVE.B      #14, D0             ; command for trap call to display message
0000251A  4E4F                    2437              TRAP        #15                 ; trap call
0000251C                          2438          
0000251C  43F9 00003D7A           2439              LEA         dispWord, A1        ; display word
00002522  103C 000E               2440              MOVE.B      #14, D0             ; command for trap call to display message
00002526  4E4F                    2441              TRAP        #15                 ; trap call
00002528                          2442          
00002528  43F9 00003CDD           2443              LEA         space, A1           ; display space 
0000252E  103C 000E               2444              MOVE.B      #14, D0             ; command for trap call to display message
00002532  4E4F                    2445              TRAP        #15                 ; trap call
00002534                          2446          
00002534  4242                    2447              CLR         D2                  ; clear D2
00002536  4243                    2448              CLR         D3                  ; clear D3
00002538  1401                    2449              MOVE.B      D1,D2               ; move byte from D1 to D2
0000253A  1601                    2450              MOVE.B      D1,D3               ; move byte from D1 to D3
0000253C                          2451          
0000253C  E602                    2452              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
0000253E  C47C 0007               2453              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
00002542  C67C 0007               2454              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
00002546                          2455          
00002546  4EB9 00002F02           2456              JSR         printEA             ; jump to printEA
0000254C                          2457          
0000254C  43F9 00003CD9           2458              LEA         newLine, A1         ; Display newLine
00002552  103C 000E               2459              MOVE.B      #14, D0             ; command for trap call to display message
00002556  4E4F                    2460              TRAP        #15                 ; trap call
00002558                          2461          
00002558  6000 EAF2               2462              BRA         LOOP                ; branch back to LOOP
0000255C                          2463  
0000255C                          2464  opLSL       
0000255C  43F9 00003D5C           2465              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002562  103C 000E               2466              MOVE.B      #14, D0             ; command for trap call to display message
00002566  4E4F                    2467              TRAP        #15                 ; trap call
00002568                          2468              
00002568  43F9 00003D7A           2469              LEA         dispWord, A1        ; display word
0000256E  103C 000E               2470              MOVE.B      #14, D0             ; command for trap call to display message
00002572  4E4F                    2471              TRAP        #15                 ; trap call
00002574                          2472          
00002574  43F9 00003CDD           2473              LEA         space, A1           ; display space 
0000257A  103C 000E               2474              MOVE.B      #14, D0             ; command for trap call to display message
0000257E  4E4F                    2475              TRAP        #15                 ; trap call
00002580                          2476          
00002580  4242                    2477              CLR         D2                  ; clear D2
00002582  4243                    2478              CLR         D3                  ; clear D3
00002584  1401                    2479              MOVE.B      D1,D2               ; move byte from D1 to D2
00002586  1601                    2480              MOVE.B      D1,D3               ; move byte from D1 to D3
00002588                          2481          
00002588  E602                    2482              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
0000258A  C47C 0007               2483              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
0000258E  C67C 0007               2484              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
00002592                          2485          
00002592  4EB9 00002F02           2486              JSR         printEA             ; jump to printEA
00002598                          2487          
00002598  43F9 00003CD9           2488              LEA         newLine, A1         ; Display newLine
0000259E  103C 000E               2489              MOVE.B      #14, D0             ; command for trap call to display message
000025A2  4E4F                    2490              TRAP        #15                 ; trap call
000025A4                          2491          
000025A4  6000 EAA6               2492              BRA         LOOP                ; branch back to LOOP
000025A8                          2493  
000025A8                          2494  opLSR   
000025A8  43F9 00003D58           2495              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
000025AE  103C 000E               2496              MOVE.B      #14, D0             ; command for trap call to display message
000025B2  4E4F                    2497              TRAP        #15                 ; trap call
000025B4                          2498          
000025B4  43F9 00003D7A           2499              LEA         dispWord, A1        ; display word
000025BA  103C 000E               2500              MOVE.B      #14, D0             ; command for trap call to display message
000025BE  4E4F                    2501              TRAP        #15                 ; trap call
000025C0                          2502          
000025C0  43F9 00003CDD           2503              LEA         space, A1           ; display space 
000025C6  103C 000E               2504              MOVE.B      #14, D0             ; command for trap call to display message
000025CA  4E4F                    2505              TRAP        #15                 ; trap call
000025CC                          2506          
000025CC  4242                    2507              CLR         D2                  ; clear D2
000025CE  4243                    2508              CLR         D3                  ; clear D3
000025D0  1401                    2509              MOVE.B      D1,D2               ; move byte from D1 to D2
000025D2  1601                    2510              MOVE.B      D1,D3               ; move byte from D1 to D3
000025D4                          2511          
000025D4  E602                    2512              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
000025D6  C47C 0007               2513              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
000025DA  C67C 0007               2514              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
000025DE                          2515          
000025DE  4EB9 00002F02           2516              JSR         printEA             ; jump to printEA
000025E4                          2517          
000025E4  43F9 00003CD9           2518              LEA         newLine, A1         ; Display newLine
000025EA  103C 000E               2519              MOVE.B      #14, D0             ; command for trap call to display message
000025EE  4E4F                    2520              TRAP        #15                 ; trap call
000025F0                          2521          
000025F0  6000 EA5A               2522              BRA         LOOP                ; branch back to LOOP
000025F4                          2523  
000025F4                          2524  opROL   
000025F4  43F9 00003D6C           2525              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
000025FA  103C 000E               2526              MOVE.B      #14, D0             ; command for trap call to display message
000025FE  4E4F                    2527              TRAP        #15                 ; trap call
00002600                          2528          
00002600  43F9 00003D7A           2529              LEA         dispWord, A1        ; display word
00002606  103C 000E               2530              MOVE.B      #14, D0             ; command for trap call to display message
0000260A  4E4F                    2531              TRAP        #15                 ; trap call
0000260C                          2532          
0000260C  43F9 00003CDD           2533              LEA         space, A1           ; display space 
00002612  103C 000E               2534              MOVE.B      #14, D0             ; command for trap call to display message
00002616  4E4F                    2535              TRAP        #15                 ; trap call
00002618                          2536          
00002618  4242                    2537              CLR         D2                  ; clear D2
0000261A  4243                    2538              CLR         D3                  ; clear D3
0000261C  1401                    2539              MOVE.B      D1,D2               ; move byte from D1 to D2
0000261E  1601                    2540              MOVE.B      D1,D3               ; move byte from D1 to D3
00002620                          2541          
00002620  E602                    2542              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
00002622  C47C 0007               2543              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
00002626  C67C 0007               2544              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
0000262A                          2545          
0000262A  4EB9 00002F02           2546              JSR         printEA             ; jump to printEA
00002630                          2547          
00002630  43F9 00003CD9           2548              LEA         newLine, A1         ; Display newLine
00002636  103C 000E               2549              MOVE.B      #14, D0             ; command for trap call to display message
0000263A  4E4F                    2550              TRAP        #15                 ; trap call
0000263C                          2551          
0000263C  6000 EA0E               2552              BRA         LOOP                ; branch back to LOOP
00002640                          2553  
00002640                          2554  opROR   
00002640  43F9 00003D68           2555              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002646  103C 000E               2556              MOVE.B      #14, D0             ; command for trap call to display message
0000264A  4E4F                    2557              TRAP        #15                 ; trap call
0000264C                          2558          
0000264C  43F9 00003D7A           2559              LEA         dispWord, A1        ; display word
00002652  103C 000E               2560              MOVE.B      #14, D0             ; command for trap call to display message
00002656  4E4F                    2561              TRAP        #15                 ; trap call
00002658                          2562          
00002658  43F9 00003CDD           2563              LEA         space, A1           ; display space 
0000265E  103C 000E               2564              MOVE.B      #14, D0             ; command for trap call to display message
00002662  4E4F                    2565              TRAP        #15                 ; trap call
00002664                          2566          
00002664  4242                    2567              CLR         D2                  ; clear D2
00002666  4243                    2568              CLR         D3                  ; clear D3
00002668  1401                    2569              MOVE.B      D1,D2               ; move byte from D1 to D2
0000266A  1601                    2570              MOVE.B      D1,D3               ; move byte from D1 to D3
0000266C                          2571          
0000266C  E602                    2572              ASR.B       #three, D2          ; shift D2 by 3 bits to get mode
0000266E  C47C 0007               2573              AND         #seven, D2          ; and D2 by 3 bits to get first 3 bits
00002672  C67C 0007               2574              AND         #seven, D3          ; and D3 by 3 bits to get first 3 bits for register
00002676                          2575          
00002676  4EB9 00002F02           2576              JSR         printEA             ; jump to printEA
0000267C                          2577          
0000267C  43F9 00003CD9           2578              LEA         newLine, A1         ; Display newLine
00002682  103C 000E               2579              MOVE.B      #14, D0             ; command for trap call to display message
00002686  4E4F                    2580              TRAP        #15                 ; trap call
00002688                          2581          
00002688  6000 E9C2               2582              BRA         LOOP                ; branch back to LOOP
0000268C                          2583          
0000268C                          2584  memSB       
0000268C  4242                    2585              CLR         D2                  ; clear D2
0000268E  1401                    2586              MOVE.B      D1,D2               ; move D1 to D2
00002690  E642                    2587              ASR         #three, D2          ; shift D2 by 3 bits to get i/r
00002692                          2588              
00002692  C47C 0007               2589              AND         #$07, D2            ; and D2 by 3 bits 
00002696                          2590          
00002696  B43C 0000               2591              CMP.B       #zero, D2           ; compare 0 to D2
0000269A  6700 002E               2592              BEQ         opASBI              ; if true, branch to ASBI for immediate
0000269E  B43C 0004               2593              CMP.B       #four, D2           ; compare 4 to D2 
000026A2  6700 0088               2594              BEQ         opASBR              ; if true, branch to ASBR for register
000026A6  B43C 0001               2595              CMP.B       #one, D2            ; compare 1 to D2
000026AA  6700 00E2               2596              BEQ         opLSBI              ; if true, branch to LSBI for immediate
000026AE  B43C 0005               2597              CMP.B       #five, D2           ; compare 5 to D2
000026B2  6700 013C               2598              BEQ         opLSBR              ; if true, branch to LSBR for register
000026B6  B43C 0003               2599              CMP.B       #three, D2          ; compare 3 to D2
000026BA  6700 0196               2600              BEQ         opROBI              ; if true, branch to ROBI for immediate
000026BE  B43C 0007               2601              CMP.B       #seven, D2          ; compare 7 to D2
000026C2  6700 01F0               2602              BEQ         opROBR              ; if true, branch to ROBR for register
000026C6  6000 15A6               2603              BRA         printInvalid        ; otherwise invalid
000026CA                          2604          
000026CA                          2605  opASBI  
000026CA  4242                    2606              CLR         D2                  ; clear D2
000026CC  3401                    2607              MOVE.W      D1, D2              ; move word from D1 to D2
000026CE  E042                    2608              ASR         #eight, D2          ; shift D2 over by 8 bits 
000026D0  C47C 0001               2609              AND         #$01, D2            ; and D2 by 1 bit to get direction
000026D4                          2610      
000026D4  B43C 0000               2611              CMP.B       #zero, D2           ; compare 0 to D2
000026D8  6700 000E               2612              BEQ         opASRBI             ; if true, branch to ASRBI for right
000026DC  B43C 0001               2613              CMP.B       #one, D2            ; compare 1 to D2
000026E0  6700 0028               2614              BEQ         opASLBI             ; if true, branch to ASLBI for left
000026E4  6000 1588               2615              BRA         printInvalid        ; otherwise invalid
000026E8                          2616          
000026E8                          2617  opASRBI 
000026E8  43F9 00003D60           2618              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000026EE  103C 000E               2619              MOVE.B      #14, D0             ; command for trap call to display message
000026F2  4E4F                    2620              TRAP        #15                 ; trap call
000026F4                          2621  
000026F4  43F9 00003D77           2622              LEA         dispByte, A1        ; display byte
000026FA  103C 000E               2623              MOVE.B      #14, D0             ; command for trap call to display message
000026FE  4E4F                    2624              TRAP        #15                 ; trap call
00002700                          2625          
00002700  4EB9 00002E2A           2626              JSR         PrntImm             ; jump to PrntImm
00002706                          2627          
00002706  6000 E944               2628              BRA         LOOP                ; branch back to LOOP
0000270A                          2629  
0000270A                          2630  opASLBI 
0000270A  43F9 00003D64           2631              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
00002710  103C 000E               2632              MOVE.B      #14, D0             ; command for trap call to display message
00002714  4E4F                    2633              TRAP        #15                 ; trap call
00002716                          2634  
00002716  43F9 00003D77           2635              LEA         dispByte, A1        ; display byte
0000271C  103C 000E               2636              MOVE.B      #14, D0             ; command for trap call to display message
00002720  4E4F                    2637              TRAP        #15                 ; trap call
00002722                          2638          
00002722  4EB9 00002E2A           2639              JSR         PrntImm             ; jump to PrntImm
00002728                          2640          
00002728  6000 E922               2641              BRA         LOOP                ; branch back to LOOP
0000272C                          2642  
0000272C                          2643  opASBR  
0000272C  4242                    2644              CLR         D2                  ; clear D2
0000272E  3401                    2645              MOVE.W      D1, D2              ; move word from D1 to D2
00002730  E042                    2646              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002732  C47C 0001               2647              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002736                          2648      
00002736  B43C 0000               2649              CMP.B       #zero, D2           ; compare 0 to D2 
0000273A  6700 000E               2650              BEQ         opASRBR             ; if true, branch to ASRBR for right
0000273E  B43C 0001               2651              CMP.B       #one, D2            ; compare 1 to D2
00002742  6700 0028               2652              BEQ         opASLBR             ; if true, branch to ASLBR for left
00002746  6000 1526               2653              BRA         printInvalid        ; otherwise invalid
0000274A                          2654          
0000274A                          2655  opASRBR 
0000274A  43F9 00003D60           2656              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002750  103C 000E               2657              MOVE.B      #14, D0             ; command for trap call to display message
00002754  4E4F                    2658              TRAP        #15                 ; trap call
00002756                          2659  
00002756  43F9 00003D77           2660              LEA         dispByte, A1        ; display byte
0000275C  103C 000E               2661              MOVE.B      #14, D0             ; command for trap call to display message
00002760  4E4F                    2662              TRAP        #15                 ; trap call
00002762                          2663          
00002762  4EB9 00002E86           2664              JSR         PrntReg             ; jump to PrntReg
00002768                          2665          
00002768  6000 E8E2               2666              BRA         LOOP                ; branch back to LOOP
0000276C                          2667  
0000276C                          2668  opASLBR 
0000276C  43F9 00003D64           2669              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
00002772  103C 000E               2670              MOVE.B      #14, D0             ; command for trap call to display message
00002776  4E4F                    2671              TRAP        #15                 ; trap call
00002778                          2672  
00002778  43F9 00003D77           2673              LEA         dispByte, A1        ; display byte
0000277E  103C 000E               2674              MOVE.B      #14, D0             ; command for trap call to display message
00002782  4E4F                    2675              TRAP        #15                 ; trap call
00002784                          2676          
00002784  4EB9 00002E86           2677              JSR         PrntReg             ; jump to PrntReg
0000278A                          2678          
0000278A  6000 E8C0               2679              BRA         LOOP                ; branch back to LOOP
0000278E                          2680  
0000278E                          2681  opLSBI      
0000278E  4242                    2682              CLR         D2                  ; clear D2
00002790  3401                    2683              MOVE.W      D1, D2              ; move word from D1 to D2
00002792  E042                    2684              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002794  C47C 0001               2685              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002798                          2686      
00002798  B43C 0000               2687              CMP.B       #zero, D2           ; compare 0 to D2 
0000279C  6700 000E               2688              BEQ         opLSRBI             ; if true, branch to LSRBI for right
000027A0  B43C 0001               2689              CMP.B       #one, D2            ; compare 1 to D2
000027A4  6700 0028               2690              BEQ         opLSLBI             ; if true, branch to LSLBI for left
000027A8  6000 14C4               2691              BRA         printInvalid        ; otherwise invalid
000027AC                          2692          
000027AC                          2693  opLSRBI 
000027AC  43F9 00003D58           2694              LEA         LSRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000027B2  103C 000E               2695              MOVE.B      #14, D0             ; command for trap call to display message
000027B6  4E4F                    2696              TRAP        #15                 ; trap call
000027B8                          2697  
000027B8  43F9 00003D77           2698              LEA         dispByte, A1        ; display byte
000027BE  103C 000E               2699              MOVE.B      #14, D0             ; command for trap call to display message
000027C2  4E4F                    2700              TRAP        #15                 ; trap call
000027C4                          2701          
000027C4  4EB9 00002E2A           2702              JSR         PrntImm             ; jump to PrntImm
000027CA                          2703          
000027CA  6000 E880               2704              BRA         LOOP                ; branch back to LOOP
000027CE                          2705              
000027CE                          2706  opLSLBI     
000027CE  43F9 00003D5C           2707              LEA         LSLmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000027D4  103C 000E               2708              MOVE.B      #14, D0             ; command for trap call to display message
000027D8  4E4F                    2709              TRAP        #15                 ; trap call
000027DA                          2710  
000027DA  43F9 00003D77           2711              LEA         dispByte, A1        ; display byte
000027E0  103C 000E               2712              MOVE.B      #14, D0             ; command for trap call to display message
000027E4  4E4F                    2713              TRAP        #15                 ; trap call
000027E6                          2714          
000027E6  4EB9 00002E2A           2715              JSR         PrntImm             ; jump to PrntImm
000027EC                          2716          
000027EC  6000 E85E               2717              BRA         LOOP                ; branch back to LOOP
000027F0                          2718  
000027F0                          2719  opLSBR  
000027F0  4242                    2720              CLR         D2                  ; clear D2
000027F2  3401                    2721              MOVE.W      D1, D2              ; move word from D1 to D2
000027F4  E042                    2722              ASR         #eight, D2          ; shift D2 over by 8 bits 
000027F6  C47C 0001               2723              AND         #$01, D2            ; and D2 by 1 bit to get direction
000027FA                          2724      
000027FA  B43C 0000               2725              CMP.B       #zero, D2           ; compare 0 to D2 
000027FE  6700 000E               2726              BEQ         opLSRBR             ; if true, branch to LSRBR for right
00002802  B43C 0001               2727              CMP.B       #one, D2            ; compare 1 to D2
00002806  6700 0028               2728              BEQ         opLSLBR             ; if true, branch to LSLBR for left
0000280A  6000 1462               2729              BRA         printInvalid        ; otherwise invalid
0000280E                          2730          
0000280E                          2731  opLSRBR 
0000280E  43F9 00003D58           2732              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002814  103C 000E               2733              MOVE.B      #14, D0             ; command for trap call to display message
00002818  4E4F                    2734              TRAP        #15                 ; trap call
0000281A                          2735  
0000281A  43F9 00003D77           2736              LEA         dispByte, A1        ; display byte
00002820  103C 000E               2737              MOVE.B      #14, D0             ; command for trap call to display message
00002824  4E4F                    2738              TRAP        #15                 ; trap call
00002826                          2739          
00002826  4EB9 00002E86           2740              JSR         PrntReg             ; jump to PrntReg
0000282C                          2741          
0000282C  6000 E81E               2742              BRA         LOOP                ; branch back to LOOP
00002830                          2743          
00002830                          2744  opLSLBR     
00002830  43F9 00003D5C           2745              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002836  103C 000E               2746              MOVE.B      #14, D0             ; command for trap call to display message
0000283A  4E4F                    2747              TRAP        #15                 ; trap call
0000283C                          2748  
0000283C  43F9 00003D77           2749              LEA         dispByte, A1        ; display byte
00002842  103C 000E               2750              MOVE.B      #14, D0             ; command for trap call to display message
00002846  4E4F                    2751              TRAP        #15                 ; trap call
00002848                          2752          
00002848  4EB9 00002E86           2753              JSR         PrntReg             ; jump to PrntReg
0000284E                          2754          
0000284E  6000 E7FC               2755              BRA         LOOP                ; branch back to LOOP
00002852                          2756              
00002852                          2757  opROBI  
00002852  4242                    2758              CLR         D2                  ; clear D2
00002854  3401                    2759              MOVE.W      D1, D2              ; move word from D1 to D2
00002856  E042                    2760              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002858  C47C 0001               2761              AND         #$01, D2            ; and D2 by 1 bit to get direction
0000285C                          2762      
0000285C  B43C 0000               2763              CMP.B       #zero, D2           ; compare 0 to D2
00002860  6700 000E               2764              BEQ         opRORBI             ; if true, branch to RORBI for right
00002864  B43C 0001               2765              CMP.B       #one, D2            ; compare 1 to D2
00002868  6700 0028               2766              BEQ         opROLBI             ; if true, branch to ROLBI for left
0000286C  6000 1400               2767              BRA         printInvalid        ; otherwise invalid
00002870                          2768          
00002870                          2769  opRORBI 
00002870  43F9 00003D68           2770              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002876  103C 000E               2771              MOVE.B      #14, D0             ; command for trap call to display message
0000287A  4E4F                    2772              TRAP        #15                 ; trap call
0000287C                          2773  
0000287C  43F9 00003D77           2774              LEA         dispByte, A1        ; display byte
00002882  103C 000E               2775              MOVE.B      #14, D0             ; command for trap call to display message
00002886  4E4F                    2776              TRAP        #15                 ; trap call
00002888                          2777          
00002888  4EB9 00002E2A           2778              JSR         PrntImm             ; jump to PrntImm
0000288E                          2779          
0000288E  6000 E7BC               2780              BRA         LOOP                ; branch back to LOOP
00002892                          2781  
00002892                          2782  opROLBI 
00002892  43F9 00003D6C           2783              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002898  103C 000E               2784              MOVE.B      #14, D0             ; command for trap call to display message
0000289C  4E4F                    2785              TRAP        #15                 ; trap call
0000289E                          2786  
0000289E  43F9 00003D77           2787              LEA         dispByte, A1        ; display byte
000028A4  103C 000E               2788              MOVE.B      #14, D0             ; command for trap call to display message
000028A8  4E4F                    2789              TRAP        #15                 ; trap call
000028AA                          2790          
000028AA  4EB9 00002E2A           2791              JSR         PrntImm             ; jump to PrntImm
000028B0                          2792          
000028B0  6000 E79A               2793              BRA         LOOP                ; branch back to LOOP
000028B4                          2794  
000028B4                          2795  opROBR  
000028B4  4242                    2796              CLR         D2                  ; clear D2
000028B6  3401                    2797              MOVE.W      D1, D2              ; move word from D1 to D2
000028B8  E042                    2798              ASR         #eight, D2          ; shift D2 over by 8 bits 
000028BA  C47C 0001               2799              AND         #$01, D2            ; and D2 by 1 bit to get direction
000028BE                          2800      
000028BE  B43C 0000               2801              CMP.B       #zero, D2           ; compare 0 to D2 
000028C2  6700 000E               2802              BEQ         opRORBR             ; if true, branch to RORBR for right
000028C6  B43C 0001               2803              CMP.B       #one, D2            ; compare 1 to D2
000028CA  6700 0028               2804              BEQ         opROLBR             ; if true, branch to ROLBR for left
000028CE  6000 139E               2805              BRA         printInvalid        ; otherwise invalid    
000028D2                          2806          
000028D2                          2807  opRORBR 
000028D2  43F9 00003D68           2808              LEA         RORmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000028D8  103C 000E               2809              MOVE.B      #14, D0             ; command for trap call to display message
000028DC  4E4F                    2810              TRAP        #15                 ; trap call
000028DE                          2811  
000028DE  43F9 00003D77           2812              LEA         dispByte, A1        ; display byte
000028E4  103C 000E               2813              MOVE.B      #14, D0             ; command for trap call to display message
000028E8  4E4F                    2814              TRAP        #15                 ; trap call
000028EA                          2815          
000028EA  4EB9 00002E86           2816              JSR         PrntReg             ; jump to PrntReg
000028F0                          2817          
000028F0  6000 E75A               2818              BRA         LOOP                ; branch back to LOOP
000028F4                          2819  
000028F4                          2820  opROLBR 
000028F4  43F9 00003D6C           2821              LEA         ROLmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000028FA  103C 000E               2822              MOVE.B      #14, D0             ; command for trap call to display message
000028FE  4E4F                    2823              TRAP        #15                 ; trap call
00002900                          2824  
00002900  43F9 00003D77           2825              LEA         dispByte, A1        ; display byte
00002906  103C 000E               2826              MOVE.B      #14, D0             ; command for trap call to display message
0000290A  4E4F                    2827              TRAP        #15                 ; trap call
0000290C                          2828          
0000290C  4EB9 00002E86           2829              JSR         PrntReg             ; jump to PrntReg
00002912                          2830          
00002912  6000 E738               2831              BRA         LOOP                ; branch back to LOOP       
00002916                          2832  
00002916                          2833  memSW   
00002916  4242                    2834              CLR         D2                  ; clear D2
00002918  1401                    2835              MOVE.B      D1,D2               ; move D1 to D2
0000291A  E642                    2836              ASR         #three, D2          ; shift D2 by 3 bits to get i/r
0000291C                          2837              
0000291C  C47C 0007               2838              AND         #$07, D2            ; and D2 by 3 bits 
00002920                          2839          
00002920  B43C 0000               2840              CMP.B       #zero, D2           ; compare 0 to D2
00002924  6700 002E               2841              BEQ         opASWI              ; if true, branch to ASWI for immediate
00002928  B43C 0004               2842              CMP.B       #four, D2           ; compare 4 to D2 
0000292C  6700 0088               2843              BEQ         opASWR              ; if true, branch to ASWR for register
00002930  B43C 0001               2844              CMP.B       #one, D2            ; compare 1 to D2
00002934  6700 00E2               2845              BEQ         opLSWI              ; if true, branch to LSWI for immediate
00002938  B43C 0005               2846              CMP.B       #five, D2           ; compare 5 to D2
0000293C  6700 013C               2847              BEQ         opLSWR              ; if true, branch to LSWR for register
00002940  B43C 0003               2848              CMP.B       #three, D2          ; compare 3 to D2
00002944  6700 0196               2849              BEQ         opROWI              ; if true, branch to ROWI for immediate
00002948  B43C 0007               2850              CMP.B       #seven, D2          ; compare 7 to D2
0000294C  6700 01F0               2851              BEQ         opROWR              ; if true, branch to ROWR for register
00002950  6000 131C               2852              BRA         printInvalid        ; otherwise invalid
00002954                          2853          
00002954                          2854  opASWI  
00002954  4242                    2855              CLR         D2                  ; clear D2
00002956  3401                    2856              MOVE.W      D1, D2              ; move word from D1 to D2
00002958  E042                    2857              ASR         #eight, D2          ; shift D2 over by 8 bits 
0000295A  C47C 0001               2858              AND         #$01, D2            ; and D2 by 1 bit to get direction
0000295E                          2859      
0000295E  B43C 0000               2860              CMP.B       #zero, D2           ; compare 0 to D2
00002962  6700 000E               2861              BEQ         opASRWI             ; if true, branch to ASRWI for right
00002966  B43C 0001               2862              CMP.B       #one, D2            ; compare 1 to D2
0000296A  6700 0028               2863              BEQ         opASLWI             ; if true, branch to ASLWI for left
0000296E  6000 12FE               2864              BRA         printInvalid        ; otherwise invalid
00002972                          2865          
00002972                          2866  opASRWI 
00002972  43F9 00003D60           2867              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002978  103C 000E               2868              MOVE.B      #14, D0             ; command for trap call to display message
0000297C  4E4F                    2869              TRAP        #15                 ; trap call
0000297E                          2870  
0000297E  43F9 00003D7A           2871              LEA         dispWord, A1        ; display word
00002984  103C 000E               2872              MOVE.B      #14, D0             ; command for trap call to display message
00002988  4E4F                    2873              TRAP        #15                 ; trap call
0000298A                          2874          
0000298A  4EB9 00002E2A           2875              JSR         PrntImm             ; jump to PrntImm
00002990                          2876          
00002990  6000 E6BA               2877              BRA         LOOP                ; branch back to LOOP
00002994                          2878  
00002994                          2879  opASLWI 
00002994  43F9 00003D64           2880              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
0000299A  103C 000E               2881              MOVE.B      #14, D0             ; command for trap call to display message
0000299E  4E4F                    2882              TRAP        #15                 ; trap call
000029A0                          2883  
000029A0  43F9 00003D7A           2884              LEA         dispWord, A1        ; display word
000029A6  103C 000E               2885              MOVE.B      #14, D0             ; command for trap call to display message
000029AA  4E4F                    2886              TRAP        #15                 ; trap call
000029AC                          2887          
000029AC  4EB9 00002E2A           2888              JSR         PrntImm             ; jump to PrntImm
000029B2                          2889          
000029B2  6000 E698               2890              BRA         LOOP                ; branch back to LOOP
000029B6                          2891  
000029B6                          2892  opASWR  
000029B6  4242                    2893              CLR         D2                  ; clear D2
000029B8  3401                    2894              MOVE.W      D1, D2              ; move word from D1 to D2
000029BA  E042                    2895              ASR         #eight, D2          ; shift D2 over by 8 bits 
000029BC  C47C 0001               2896              AND         #$01, D2            ; and D2 by 1 bit to get direction
000029C0                          2897      
000029C0  B43C 0000               2898              CMP.B       #zero, D2           ; compare 0 to D2 
000029C4  6700 000E               2899              BEQ         opASRWR             ; if true, branch to ASRWR for right
000029C8  B43C 0001               2900              CMP.B       #one, D2            ; compare 1 to D2
000029CC  6700 0028               2901              BEQ         opASLWR             ; if true, branch to ASLWR for left
000029D0  6000 129C               2902              BRA         printInvalid        ; otherwise invalid
000029D4                          2903          
000029D4                          2904  opASRWR     
000029D4  43F9 00003D60           2905              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
000029DA  103C 000E               2906              MOVE.B      #14, D0             ; command for trap call to display message
000029DE  4E4F                    2907              TRAP        #15                 ; trap call
000029E0                          2908  
000029E0  43F9 00003D7A           2909              LEA         dispWord, A1        ; display word
000029E6  103C 000E               2910              MOVE.B      #14, D0             ; command for trap call to display message
000029EA  4E4F                    2911              TRAP        #15                 ; trap call
000029EC                          2912          
000029EC  4EB9 00002E86           2913              JSR         PrntReg             ; jump to PrntReg
000029F2                          2914          
000029F2  6000 E658               2915              BRA         LOOP                ; branch back to LOOP
000029F6                          2916  
000029F6                          2917  opASLWR     
000029F6  43F9 00003D64           2918              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
000029FC  103C 000E               2919              MOVE.B      #14, D0             ; command for trap call to display message
00002A00  4E4F                    2920              TRAP        #15                 ; trap call
00002A02                          2921  
00002A02  43F9 00003D7A           2922              LEA         dispWord, A1        ; display word
00002A08  103C 000E               2923              MOVE.B      #14, D0             ; command for trap call to display message
00002A0C  4E4F                    2924              TRAP        #15                 ; trap call
00002A0E                          2925          
00002A0E  4EB9 00002E86           2926              JSR         PrntReg             ; jump to PrntReg
00002A14                          2927          
00002A14  6000 E636               2928              BRA         LOOP                ; branch back to LOOP
00002A18                          2929  
00002A18                          2930  opLSWI      
00002A18  4242                    2931              CLR         D2                  ; clear D2
00002A1A  3401                    2932              MOVE.W      D1, D2              ; move word from D1 to D2
00002A1C  E042                    2933              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002A1E  C47C 0001               2934              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002A22                          2935      
00002A22  B43C 0000               2936              CMP.B       #zero, D2           ; compare 0 to D2 
00002A26  6700 000E               2937              BEQ         opLSRWI             ; if true, branch to LSRWI for right
00002A2A  B43C 0001               2938              CMP.B       #one, D2            ; compare 1 to D2
00002A2E  6700 0028               2939              BEQ         opLSLWI             ; if true, branch to LSLWI for left
00002A32  6000 123A               2940              BRA         printInvalid        ; otherwise invalid 
00002A36                          2941          
00002A36                          2942  opLSRWI 
00002A36  43F9 00003D58           2943              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002A3C  103C 000E               2944              MOVE.B      #14, D0             ; command for trap call to display message
00002A40  4E4F                    2945              TRAP        #15                 ; trap call
00002A42                          2946      
00002A42  43F9 00003D7A           2947              LEA         dispWord, A1        ; display word
00002A48  103C 000E               2948              MOVE.B      #14, D0             ; command for trap call to display message
00002A4C  4E4F                    2949              TRAP        #15                 ; trap call
00002A4E                          2950          
00002A4E  4EB9 00002E2A           2951              JSR         PrntImm             ; jump to PrntImm
00002A54                          2952          
00002A54  6000 E5F6               2953              BRA         LOOP                ; branch back to LOOP
00002A58                          2954              
00002A58                          2955  opLSLWI 
00002A58  43F9 00003D5C           2956              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002A5E  103C 000E               2957              MOVE.B      #14, D0             ; command for trap call to display message
00002A62  4E4F                    2958              TRAP        #15                 ; trap call
00002A64                          2959  
00002A64  43F9 00003D7A           2960              LEA         dispWord, A1        ; display word
00002A6A  103C 000E               2961              MOVE.B      #14, D0             ; command for trap call to display message
00002A6E  4E4F                    2962              TRAP        #15                 ; trap call
00002A70                          2963          
00002A70  4EB9 00002E2A           2964              JSR         PrntImm             ; jump to PrntImm
00002A76                          2965          
00002A76  6000 E5D4               2966              BRA         LOOP                ; branch back to LOOP
00002A7A                          2967              
00002A7A                          2968  opLSWR  
00002A7A  4242                    2969              CLR         D2                  ; clear D2
00002A7C  3401                    2970              MOVE.W      D1, D2              ; move word from D1 to D2
00002A7E  E042                    2971              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002A80  C47C 0001               2972              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002A84                          2973      
00002A84  B43C 0000               2974              CMP.B       #zero, D2           ; compare 0 to D2 
00002A88  6700 000E               2975              BEQ         opLSRWR             ; if true, branch to LSRWR for right
00002A8C  B43C 0001               2976              CMP.B       #one, D2            ; compare 1 to D2
00002A90  6700 0028               2977              BEQ         opLSLWR             ; if true, branch to LSLWR for left
00002A94  6000 11D8               2978              BRA         printInvalid        ; otherwise invalid
00002A98                          2979          
00002A98                          2980  opLSRWR 
00002A98  43F9 00003D58           2981              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002A9E  103C 000E               2982              MOVE.B      #14, D0             ; command for trap call to display message
00002AA2  4E4F                    2983              TRAP        #15                 ; trap call
00002AA4                          2984  
00002AA4  43F9 00003D7A           2985              LEA         dispWord, A1        ; display word
00002AAA  103C 000E               2986              MOVE.B      #14, D0             ; command for trap call to display message
00002AAE  4E4F                    2987              TRAP        #15                 ; trap call
00002AB0                          2988          
00002AB0  4EB9 00002E86           2989              JSR         PrntReg             ; jump to PrntReg
00002AB6                          2990          
00002AB6  6000 E594               2991              BRA         LOOP                ; branch back to LOOP
00002ABA                          2992          
00002ABA                          2993  opLSLWR 
00002ABA  43F9 00003D5C           2994              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002AC0  103C 000E               2995              MOVE.B      #14, D0             ; command for trap call to display message
00002AC4  4E4F                    2996              TRAP        #15                 ; trap call
00002AC6                          2997  
00002AC6  43F9 00003D7A           2998              LEA         dispWord, A1        ; display word
00002ACC  103C 000E               2999              MOVE.B      #14, D0             ; command for trap call to display message
00002AD0  4E4F                    3000              TRAP        #15                 ; trap call
00002AD2                          3001          
00002AD2  4EB9 00002E86           3002              JSR         PrntReg             ; jump to PrntReg
00002AD8                          3003          
00002AD8  6000 E572               3004              BRA         LOOP                ; branch back to LOOP
00002ADC                          3005  
00002ADC                          3006  opROWI  
00002ADC  4242                    3007              CLR         D2                  ; clear D2
00002ADE  3401                    3008              MOVE.W      D1, D2              ; move word from D1 to D2
00002AE0  E042                    3009              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002AE2  C47C 0001               3010              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002AE6                          3011      
00002AE6  B43C 0000               3012              CMP.B       #zero, D2           ; compare 0 to D2
00002AEA  6700 000E               3013              BEQ         opRORWI             ; if true, branch to RORWI for right
00002AEE  B43C 0001               3014              CMP.B       #one, D2            ; compare 1 to D2
00002AF2  6700 0028               3015              BEQ         opROLWI             ; if true, branch to ROLWI for left
00002AF6  6000 1176               3016              BRA         printInvalid        ; otherwise invalid
00002AFA                          3017          
00002AFA                          3018  opRORWI 
00002AFA  43F9 00003D68           3019              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002B00  103C 000E               3020              MOVE.B      #14, D0             ; command for trap call to display message
00002B04  4E4F                    3021              TRAP        #15                 ; trap call
00002B06                          3022  
00002B06  43F9 00003D7A           3023              LEA         dispWord, A1        ; display word
00002B0C  103C 000E               3024              MOVE.B      #14, D0             ; command for trap call to display message
00002B10  4E4F                    3025              TRAP        #15                 ; trap call
00002B12                          3026          
00002B12  4EB9 00002E2A           3027              JSR         PrntImm             ; jump to PrntImm
00002B18                          3028          
00002B18  6000 E532               3029              BRA         LOOP                ; branch back to LOOP
00002B1C                          3030  
00002B1C                          3031  opROLWI     
00002B1C  43F9 00003D6C           3032              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002B22                          3033          
00002B22  103C 000E               3034              MOVE.B      #14, D0             ; command for trap call to display message
00002B26  4E4F                    3035              TRAP        #15                 ; trap call
00002B28                          3036  
00002B28  43F9 00003D7A           3037              LEA         dispWord, A1        ; display word
00002B2E  103C 000E               3038              MOVE.B      #14, D0             ; command for trap call to display message
00002B32  4E4F                    3039              TRAP        #15                 ; trap call
00002B34                          3040          
00002B34  4EB9 00002E2A           3041              JSR         PrntImm             ; jump to PrntImm
00002B3A                          3042          
00002B3A  6000 E510               3043              BRA         LOOP                ; branch back to LOOP
00002B3E                          3044  
00002B3E                          3045  opROWR      
00002B3E  4242                    3046              CLR         D2                  ; clear D2
00002B40  3401                    3047              MOVE.W      D1, D2              ; move word from D1 to D2
00002B42  E042                    3048              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002B44  C47C 0001               3049              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002B48                          3050      
00002B48  B43C 0000               3051              CMP.B       #zero, D2           ; compare 0 to D2 
00002B4C  6700 000E               3052              BEQ         opRORWR             ; if true, branch to RORWR for right
00002B50  B43C 0001               3053              CMP.B       #one, D2            ; compare 1 to D2
00002B54  6700 0028               3054              BEQ         opROLWR             ; if true, branch to ROLWR for left
00002B58  6000 1114               3055              BRA         printInvalid        ; otherwise invalid     
00002B5C                          3056          
00002B5C                          3057  opRORWR 
00002B5C  43F9 00003D68           3058              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002B62  103C 000E               3059              MOVE.B      #14, D0             ; command for trap call to display message
00002B66  4E4F                    3060              TRAP        #15                 ; trap call
00002B68                          3061      
00002B68  43F9 00003D7A           3062              LEA         dispWord, A1        ; display word
00002B6E  103C 000E               3063              MOVE.B      #14, D0             ; command for trap call to display message
00002B72  4E4F                    3064              TRAP        #15                 ; trap call
00002B74                          3065          
00002B74  4EB9 00002E86           3066              JSR         PrntReg             ; jump to PrntReg
00002B7A                          3067          
00002B7A  6000 E4D0               3068              BRA         LOOP                ; branch back to LOOP
00002B7E                          3069  
00002B7E                          3070  opROLWR 
00002B7E  43F9 00003D6C           3071              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002B84  103C 000E               3072              MOVE.B      #14, D0             ; command for trap call to display message
00002B88  4E4F                    3073              TRAP        #15                 ; trap call
00002B8A                          3074  
00002B8A  43F9 00003D7A           3075              LEA         dispWord, A1        ; display word
00002B90  103C 000E               3076              MOVE.B      #14, D0             ; command for trap call to display message
00002B94  4E4F                    3077              TRAP        #15                 ; trap call
00002B96                          3078          
00002B96  4EB9 00002E86           3079              JSR         PrntReg             ; jump to PrntReg
00002B9C                          3080          
00002B9C  6000 E4AE               3081              BRA         LOOP                ; branch back to LOOP
00002BA0                          3082  
00002BA0                          3083  memSL   
00002BA0  4242                    3084              CLR         D2                  ; clear D2
00002BA2  1401                    3085              MOVE.B      D1,D2               ; move D1 to D2
00002BA4  E642                    3086              ASR         #three, D2          ; shift D2 by 3 bits to get i/r
00002BA6                          3087              
00002BA6  C47C 0007               3088              AND         #$07, D2            ; and D2 by 3 bits 
00002BAA                          3089          
00002BAA  B43C 0000               3090              CMP.B       #zero, D2           ; compare 0 to D2
00002BAE  6700 002E               3091              BEQ         opASLI              ; if true, branch to ASLI for immediate
00002BB2  B43C 0004               3092              CMP.B       #four, D2           ; compare 4 to D2 
00002BB6  6700 0088               3093              BEQ         opASLR              ; if true, branch to ASLR for register
00002BBA  B43C 0001               3094              CMP.B       #one, D2            ; compare 1 to D2
00002BBE  6700 00E2               3095              BEQ         opLSLI              ; if true, branch to LSLI for immediate
00002BC2  B43C 0005               3096              CMP.B       #five, D2           ; compare 5 to D2
00002BC6  6700 013C               3097              BEQ         opLSLR              ; if true, branch to LSLR for register
00002BCA  B43C 0003               3098              CMP.B       #three, D2          ; compare 3 to D2
00002BCE  6700 0196               3099              BEQ         opROLI              ; if true, branch to ROLI for immediate
00002BD2  B43C 0007               3100              CMP.B       #seven, D2          ; compare 7 to D2
00002BD6  6700 01F0               3101              BEQ         opROLR              ; if true, branch to ROLR for register
00002BDA  6000 1092               3102              BRA         printInvalid        ; otherwise invalid
00002BDE                          3103          
00002BDE                          3104  opASLI  
00002BDE  4242                    3105              CLR         D2                  ; clear D2
00002BE0  3401                    3106              MOVE.W      D1, D2              ; move word from D1 to D2
00002BE2  E042                    3107              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002BE4  C47C 0001               3108              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002BE8                          3109      
00002BE8  B43C 0000               3110              CMP.B       #zero, D2           ; compare 0 to D2
00002BEC  6700 000E               3111              BEQ         opASRLI             ; if true, branch to ASRLI for right
00002BF0  B43C 0001               3112              CMP.B       #one, D2            ; compare 1 to D2
00002BF4  6700 0028               3113              BEQ         opASLLI             ; if true, branch to ASLLI for left
00002BF8  6000 1074               3114              BRA         printInvalid        ; otherwise invalid
00002BFC                          3115          
00002BFC                          3116  opASRLI 
00002BFC  43F9 00003D60           3117              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002C02  103C 000E               3118              MOVE.B      #14, D0             ; command for trap call to display message
00002C06  4E4F                    3119              TRAP        #15                 ; trap call
00002C08                          3120  
00002C08  43F9 00003D7D           3121              LEA         dispLong, A1        ; display long
00002C0E  103C 000E               3122              MOVE.B      #14, D0             ; command for trap call to display message
00002C12  4E4F                    3123              TRAP        #15                 ; trap call
00002C14                          3124          
00002C14  4EB9 00002E2A           3125              JSR         PrntImm             ; jump to PrntImm
00002C1A                          3126          
00002C1A  6000 E430               3127              BRA         LOOP                ; branch back to LOOP
00002C1E                          3128  
00002C1E                          3129  opASLLI 
00002C1E  43F9 00003D64           3130              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
00002C24  103C 000E               3131              MOVE.B      #14, D0             ; command for trap call to display message
00002C28  4E4F                    3132              TRAP        #15                 ; trap call
00002C2A                          3133  
00002C2A  43F9 00003D7D           3134              LEA         dispLong, A1        ; display long
00002C30  103C 000E               3135              MOVE.B      #14, D0             ; command for trap call to display message
00002C34  4E4F                    3136              TRAP        #15                 ; trap call
00002C36                          3137          
00002C36  4EB9 00002E2A           3138              JSR         PrntImm             ; jump to PrntImm
00002C3C                          3139          
00002C3C  6000 E40E               3140              BRA         LOOP                ; branch back to LOOP
00002C40                          3141  
00002C40                          3142  opASLR  
00002C40  4242                    3143              CLR         D2                  ; clear D2
00002C42  3401                    3144              MOVE.W      D1, D2              ; move word from D1 to D2
00002C44  E042                    3145              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002C46  C47C 0001               3146              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002C4A                          3147      
00002C4A  B43C 0000               3148              CMP.B       #zero, D2           ; compare 0 to D2 
00002C4E  6700 000E               3149              BEQ         opASRLR             ; if true, branch to ASRLR for right
00002C52  B43C 0001               3150              CMP.B       #one, D2            ; compare 1 to D2
00002C56  6700 0028               3151              BEQ         opASLLR             ; if true, branch to ASLLR for left
00002C5A  6000 1012               3152              BRA         printInvalid        ; otherwise invalid 
00002C5E                          3153          
00002C5E                          3154  opASRLR 
00002C5E  43F9 00003D60           3155              LEA         ASRmatch, A1        ; we know that the opcode will be ASR, so load A1 to print message
00002C64  103C 000E               3156              MOVE.B      #14, D0             ; command for trap call to display message
00002C68  4E4F                    3157              TRAP        #15                 ; trap call
00002C6A                          3158  
00002C6A  43F9 00003D7D           3159              LEA         dispLong, A1        ; display long
00002C70  103C 000E               3160              MOVE.B      #14, D0             ; command for trap call to display message
00002C74  4E4F                    3161              TRAP        #15                 ; trap call
00002C76                          3162          
00002C76  4EB9 00002E86           3163              JSR         PrntReg             ; jump to PrntReg
00002C7C                          3164          
00002C7C  6000 E3CE               3165              BRA         LOOP                ; branch back to LOOP
00002C80                          3166  
00002C80                          3167  opASLLR 
00002C80  43F9 00003D64           3168              LEA         ASLmatch, A1        ; we know that the opcode will be ASL, so load A1 to print message
00002C86  103C 000E               3169              MOVE.B      #14, D0             ; command for trap call to display message
00002C8A  4E4F                    3170              TRAP        #15                 ; trap call
00002C8C                          3171  
00002C8C  43F9 00003D7D           3172              LEA         dispLong, A1        ; display long
00002C92  103C 000E               3173              MOVE.B      #14, D0             ; command for trap call to display message
00002C96  4E4F                    3174              TRAP        #15                 ; trap call
00002C98                          3175          
00002C98  4EB9 00002E86           3176              JSR         PrntReg             ; jump to PrntReg
00002C9E                          3177          
00002C9E  6000 E3AC               3178              BRA         LOOP                ; branch back to LOOP
00002CA2                          3179  
00002CA2                          3180  opLSLI  
00002CA2  4242                    3181              CLR         D2                  ; clear D2
00002CA4  3401                    3182              MOVE.W      D1, D2              ; move word from D1 to D2
00002CA6  E042                    3183              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002CA8  C47C 0001               3184              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002CAC                          3185      
00002CAC  B43C 0000               3186              CMP.B       #zero, D2           ; compare 0 to D2 
00002CB0  6700 000E               3187              BEQ         opLSRLI             ; if true, branch to LSRLI for right
00002CB4  B43C 0001               3188              CMP.B       #one, D2            ; compare 1 to D2
00002CB8  6700 0028               3189              BEQ         opLSLLI             ; if true, branch to LSLLI for left
00002CBC  6000 0FB0               3190              BRA         printInvalid        ; otherwise invalid  
00002CC0                          3191          
00002CC0                          3192  opLSRLI 
00002CC0  43F9 00003D58           3193              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002CC6  103C 000E               3194              MOVE.B      #14, D0             ; command for trap call to display message
00002CCA  4E4F                    3195              TRAP        #15                 ; trap call
00002CCC                          3196  
00002CCC  43F9 00003D7D           3197              LEA         dispLong, A1        ; display long
00002CD2  103C 000E               3198              MOVE.B      #14, D0             ; command for trap call to display message
00002CD6  4E4F                    3199              TRAP        #15                 ; trap call
00002CD8                          3200          
00002CD8  4EB9 00002E2A           3201              JSR         PrntImm             ; jump to PrntImm
00002CDE                          3202          
00002CDE  6000 E36C               3203              BRA         LOOP                ; branch back to LOOP
00002CE2                          3204  
00002CE2                          3205  
00002CE2                          3206  opLSLLI 
00002CE2  43F9 00003D5C           3207              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002CE8  103C 000E               3208              MOVE.B      #14, D0             ; command for trap call to display message
00002CEC  4E4F                    3209              TRAP        #15                 ; trap call
00002CEE                          3210  
00002CEE  43F9 00003D7D           3211              LEA         dispLong, A1        ; display long
00002CF4  103C 000E               3212              MOVE.B      #14, D0             ; command for trap call to display message
00002CF8  4E4F                    3213              TRAP        #15                 ; trap call
00002CFA                          3214          
00002CFA  4EB9 00002E2A           3215              JSR         PrntImm             ; jump to PrntImm
00002D00                          3216          
00002D00  6000 E34A               3217              BRA         LOOP                ; branch back to LOOP
00002D04                          3218  
00002D04                          3219  opLSLR  
00002D04  4242                    3220              CLR         D2                  ; clear D2
00002D06  3401                    3221              MOVE.W      D1, D2              ; move word from D1 to D2
00002D08  E042                    3222              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002D0A  C47C 0001               3223              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002D0E                          3224      
00002D0E  B43C 0000               3225              CMP.B       #zero, D2           ; compare 0 to D2 
00002D12  6700 000E               3226              BEQ         opLSRLR             ; if true, branch to LSRLR for right
00002D16  B43C 0001               3227              CMP.B       #one, D2            ; compare 1 to D2
00002D1A  6700 0028               3228              BEQ         opLSLLR             ; if true, branch to LSLLR for left
00002D1E  6000 0F4E               3229              BRA         printInvalid        ; otherwise invalid
00002D22                          3230          
00002D22                          3231  opLSRLR 
00002D22  43F9 00003D58           3232              LEA         LSRmatch, A1        ; we know that the opcode will be LSR, so load A1 to print message
00002D28  103C 000E               3233              MOVE.B      #14, D0             ; command for trap call to display message
00002D2C  4E4F                    3234              TRAP        #15                 ; trap call
00002D2E                          3235  
00002D2E  43F9 00003D7D           3236              LEA         dispLong, A1        ; display long
00002D34  103C 000E               3237              MOVE.B      #14, D0             ; command for trap call to display message
00002D38  4E4F                    3238              TRAP        #15                 ; trap call
00002D3A                          3239          
00002D3A  4EB9 00002E86           3240              JSR         PrntReg             ; jump to PrntReg
00002D40                          3241          
00002D40  6000 E30A               3242              BRA         LOOP                ; branch back to LOOP
00002D44                          3243          
00002D44                          3244  opLSLLR 
00002D44  43F9 00003D5C           3245              LEA         LSLmatch, A1        ; we know that the opcode will be LSL, so load A1 to print message
00002D4A  103C 000E               3246              MOVE.B      #14, D0             ; command for trap call to display message
00002D4E  4E4F                    3247              TRAP        #15                 ; trap call
00002D50                          3248  
00002D50  43F9 00003D7D           3249              LEA         dispLong, A1        ; display long
00002D56  103C 000E               3250              MOVE.B      #14, D0             ; command for trap call to display message
00002D5A  4E4F                    3251              TRAP        #15                 ; trap call
00002D5C                          3252          
00002D5C  4EB9 00002E86           3253              JSR         PrntReg             ; jump to PrntReg
00002D62                          3254          
00002D62  6000 E2E8               3255              BRA         LOOP                ; branch back to LOOP
00002D66                          3256              
00002D66                          3257  opROLI  
00002D66  4242                    3258              CLR         D2                  ; clear D2
00002D68  3401                    3259              MOVE.W      D1, D2              ; move word from D1 to D2
00002D6A  E042                    3260              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002D6C  C47C 0001               3261              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002D70                          3262      
00002D70  B43C 0000               3263              CMP.B       #zero, D2           ; compare 0 to D2
00002D74  6700 000E               3264              BEQ         opRORLI             ; if true, branch to RORLI for right
00002D78  B43C 0001               3265              CMP.B       #one, D2            ; compare 1 to D2
00002D7C  6700 0028               3266              BEQ         opROLLI             ; if true, branch to ROLLI for left
00002D80  6000 0EEC               3267              BRA         printInvalid        ; otherwise invalid
00002D84                          3268          
00002D84                          3269  opRORLI 
00002D84  43F9 00003D68           3270              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002D8A  103C 000E               3271              MOVE.B      #14, D0             ; command for trap call to display message
00002D8E  4E4F                    3272              TRAP        #15                 ; trap call
00002D90                          3273  
00002D90  43F9 00003D7D           3274              LEA         dispLong, A1        ; display long
00002D96  103C 000E               3275              MOVE.B      #14, D0             ; command for trap call to display message
00002D9A  4E4F                    3276              TRAP        #15                 ; trap call
00002D9C                          3277          
00002D9C  4EB9 00002E2A           3278              JSR         PrntImm             ; jump to PrntImm
00002DA2                          3279          
00002DA2  6000 E2A8               3280              BRA         LOOP                ; branch back to LOOP
00002DA6                          3281  
00002DA6                          3282  opROLLI 
00002DA6  43F9 00003D6C           3283              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002DAC  103C 000E               3284              MOVE.B      #14, D0             ; command for trap call to display message
00002DB0  4E4F                    3285              TRAP        #15                 ; trap call
00002DB2                          3286  
00002DB2  43F9 00003D7D           3287              LEA         dispLong, A1        ; display long
00002DB8  103C 000E               3288              MOVE.B      #14, D0             ; command for trap call to display message
00002DBC  4E4F                    3289              TRAP        #15                 ; trap call
00002DBE                          3290          
00002DBE  4EB9 00002E2A           3291              JSR         PrntImm             ; jump to PrntImm
00002DC4                          3292          
00002DC4  6000 E286               3293              BRA         LOOP                ; branch back to LOOP
00002DC8                          3294  
00002DC8                          3295  opROLR  
00002DC8  4242                    3296              CLR         D2                  ; clear D2
00002DCA  3401                    3297              MOVE.W      D1, D2              ; move word from D1 to D2
00002DCC  E042                    3298              ASR         #eight, D2          ; shift D2 over by 8 bits 
00002DCE  C47C 0001               3299              AND         #$01, D2            ; and D2 by 1 bit to get direction
00002DD2                          3300      
00002DD2  B43C 0000               3301              CMP.B       #zero, D2           ; compare 0 to D2 
00002DD6  6700 000E               3302              BEQ         opRORLR             ; if true, branch to RORLR for right
00002DDA  B43C 0001               3303              CMP.B       #one, D2            ; compare 1 to D2
00002DDE  6700 0028               3304              BEQ         opROLLR             ; if true, branch to ROLLR for left
00002DE2  6000 0E8A               3305              BRA         printInvalid        ; otherwise invalid     
00002DE6                          3306          
00002DE6                          3307  opRORLR 
00002DE6  43F9 00003D68           3308              LEA         RORmatch, A1        ; we know that the opcode will be ROR, so load A1 to print message
00002DEC  103C 000E               3309              MOVE.B      #14, D0             ; command for trap call to display message
00002DF0  4E4F                    3310              TRAP        #15                 ; trap call
00002DF2                          3311  
00002DF2  43F9 00003D7D           3312              LEA         dispLong, A1        ; display long
00002DF8  103C 000E               3313              MOVE.B      #14, D0             ; command for trap call to display message
00002DFC  4E4F                    3314              TRAP        #15                 ; trap call
00002DFE                          3315          
00002DFE  4EB9 00002E86           3316              JSR         PrntReg             ; jump to PrntReg
00002E04                          3317          
00002E04  6000 E246               3318              BRA         LOOP                ; branch back to LOOP
00002E08                          3319  
00002E08                          3320  opROLLR     
00002E08  43F9 00003D6C           3321              LEA         ROLmatch, A1        ; we know that the opcode will be ROL, so load A1 to print message
00002E0E  103C 000E               3322              MOVE.B      #14, D0             ; command for trap call to display message
00002E12  4E4F                    3323              TRAP        #15                 ; trap call
00002E14                          3324      
00002E14  43F9 00003D7D           3325              LEA         dispLong, A1        ; display long
00002E1A  103C 000E               3326              MOVE.B      #14, D0             ; command for trap call to display message
00002E1E  4E4F                    3327              TRAP        #15                 ; trap call
00002E20                          3328          
00002E20  4EB9 00002E86           3329              JSR         PrntReg             ; jump to PrntReg
00002E26                          3330          
00002E26  6000 E224               3331              BRA         LOOP                ; branch back to LOOP
00002E2A                          3332          
00002E2A                          3333  ***********************************************************************************************************
00002E2A                          3334  *                       Immediate Data Subroutine Part 1
00002E2A                          3335  *
00002E2A                          3336  * The following subroutine displays the immediate number to shift and the data register that is being shifted. 
00002E2A                          3337  * This subroutine calls two printing immediate subroutine first, the the ea print subroutine.        
00002E2A                          3338  *
00002E2A                          3339  ***********************************************************************************************************
00002E2A                          3340  
00002E2A                          3341  PrntImm 
00002E2A  48E7 FF7E               3342              MOVEM.L     D0-D7/A1-A6, -(SP)  ; callee saved registers
00002E2E                          3343              
00002E2E  43F9 00003CDD           3344              LEA         space, A1           ; display space
00002E34  103C 000E               3345              MOVE.B      #14, D0             ; command for trap call to display message
00002E38  4E4F                    3346              TRAP        #15                 ; trap call
00002E3A                          3347              
00002E3A  43F9 00003CE0           3348              LEA         hashTag, A1         ; display #
00002E40  103C 000E               3349              MOVE.B      #14, D0             ; command for trap call to display message
00002E44  4E4F                    3350              TRAP        #15                 ; trap call
00002E46                          3351              
00002E46  4242                    3352              CLR         D2                  ; clear D2
00002E48  3401                    3353              MOVE.W      D1, D2              ; move word from D1 to D2
00002E4A  E042                    3354              ASR         #eight, D2          ; shift D2 by 8 bits
00002E4C  E242                    3355              ASR         #one, D2            ; shift D2 by one bit
00002E4E  C47C 0007               3356              AND         #$07, D2            ; and D2 to get just first 3 bits
00002E52                          3357          
00002E52  4EB9 00002ED8           3358              JSR         MemShiftImm         ; jump to MemShiftImm
00002E58                          3359          
00002E58  43F9 00003CE4           3360              LEA         comma, A1           ; display comma
00002E5E  103C 000E               3361              MOVE.B      #14, D0             ; command for trap call to display message
00002E62  4E4F                    3362              TRAP        #15                 ; trap call
00002E64                          3363          
00002E64  4242                    3364              CLR         D2                  ; clear D2 since destination mode must be data register
00002E66  4243                    3365              CLR         D3                  ; clear D3 to get register
00002E68  1601                    3366              MOVE.B      D1,D3               ; move byte from D1 to D3
00002E6A  C67C 0007               3367              AND         #$07, D3            ; and D3 to get first 3 bits only
00002E6E                          3368          
00002E6E  4EB9 00002F02           3369              JSR         printEA             ; jump to printEA
00002E74                          3370          
00002E74  43F9 00003CD9           3371              LEA         newLine, A1         ; create new line
00002E7A  103C 000E               3372              MOVE.B      #14, D0             ; command for trap call to display message
00002E7E  4E4F                    3373              TRAP        #15                 ; trap call
00002E80                          3374          
00002E80  4CDF 7EFF               3375              MOVEM.L     (SP)+, D0-D7/A1-A6  ; pop saved registers from stack
00002E84  4E75                    3376              RTS                             ; return
00002E86                          3377              
00002E86                          3378  ***********************************************************************************************************
00002E86                          3379  *
00002E86                          3380  *                       Shifting Helping Function
00002E86                          3381  *
00002E86                          3382  * The following subroutine determines the correct data register to display, and sets the values of D2 and 
00002E86                          3383  *       D3 accordingly to display the data register.
00002E86                          3384  * after setting the values, it calls another subroutine to actually display the data register.        
00002E86                          3385  *
00002E86                          3386  ***********************************************************************************************************
00002E86                          3387  
00002E86                          3388  PrntReg     
00002E86  48E7 FF7E               3389              MOVEM.L     D0-D7/A1-A6, -(SP)  ; callee saved
00002E8A                          3390          
00002E8A  43F9 00003CDD           3391              LEA         space, A1           ; display space
00002E90  103C 000E               3392              MOVE.B      #14, D0             ; command for trap call to display message
00002E94  4E4F                    3393              TRAP        #15                 ; trap call
00002E96                          3394          
00002E96  4242                    3395              CLR         D2                  ; clear D2
00002E98  4243                    3396              CLR         D3                  ; clear D3
00002E9A  3601                    3397              MOVE.W      D1, D3              ; move word from D1 to D3
00002E9C  E043                    3398              ASR         #eight, D3          ; shift D3 by 8 bits
00002E9E  E243                    3399              ASR         #one, D3            ; shift D3 by 1 bit
00002EA0  C67C 0007               3400              AND         #$07, D3            ; and D3 to get first 3 bits only
00002EA4                          3401          
00002EA4  4EB9 00002F02           3402              JSR         printEA             ; jump to printEA
00002EAA                          3403          
00002EAA  43F9 00003CE4           3404              LEA         comma, A1           ; display comma
00002EB0  103C 000E               3405              MOVE.B      #14, D0             ; command for trap call to display message
00002EB4  4E4F                    3406              TRAP        #15                 ; trap call
00002EB6                          3407          
00002EB6  4242                    3408              CLR         D2                  ; clear D2
00002EB8  4243                    3409              CLR         D3                  ; clear D3
00002EBA  1601                    3410              MOVE.B      D1,D3               ; move byte from D1 to D3
00002EBC  C67C 0007               3411              AND         #$07, D3            ; and D3 to get first 3 bits only
00002EC0                          3412          
00002EC0  4EB9 00002F02           3413              JSR         printEA             ; jump to printEA
00002EC6                          3414          
00002EC6  43F9 00003CD9           3415              LEA         newLine, A1         ; newline
00002ECC  103C 000E               3416              MOVE.B      #14, D0             ; command for trap call to display message
00002ED0  4E4F                    3417              TRAP        #15                 ; trap call
00002ED2                          3418          
00002ED2  4CDF 7EFF               3419              MOVEM.L     (SP)+, D0-D7/A1-A6  ; pop saved registers from stack
00002ED6  4E75                    3420              RTS                             ; return
00002ED8                          3421  
00002ED8                          3422  ***********************************************************************************************************
00002ED8                          3423  *
00002ED8                          3424  *                       Immediate Data Subroutine Part 2
00002ED8                          3425  *
00002ED8                          3426  * The following subroutine is used to display the number between 1-8 for the bit vount for the shift/rotate opcode
00002ED8                          3427  * It displays it by storing the appropriate number in D1 and running trap task 3.
00002ED8                          3428  *
00002ED8                          3429  ***********************************************************************************************************
00002ED8                          3430  
00002ED8                          3431  MemShiftImm     
00002ED8  48E7 FF7E               3432              MOVEM.L     D0-D7/A1-A6, -(SP)  ; callee saved data
00002EDC  4241                    3433              CLR         D1                  ; clear D1
00002EDE                          3434                 
00002EDE  1202                    3435              MOVE.B      D2, D1              ; move byte from D2 to D1
00002EE0  B23C 0000               3436              CMP.B       #zero, D1           ; compare 0 to D1
00002EE4  6700 000C               3437              BEQ         displayEight        ; if true, branch to displayEight
00002EE8                          3438                  
00002EE8  103C 0003               3439              MOVE.B      #3, D0              ; trap task command to display decimal
00002EEC  4E4F                    3440              TRAP        #15                 ; trap call
00002EEE  6000 000C               3441              BRA         endSubroutine       ; branch to endSubroutine
00002EF2                          3442                  
00002EF2                          3443  displayEight    
00002EF2  123C 0008               3444              MOVE.B      #$08, D1            ; move 8 to D1
00002EF6  103C 0003               3445              MOVE.B      #3, D0              ; trap task command to display decimal
00002EFA  4E4F                    3446              TRAP        #15                 ; trap call
00002EFC                          3447              
00002EFC                          3448  endSubroutine
00002EFC  4CDF 7EFF               3449              MOVEM.L     (SP)+, D0-D7/A1-A6  ; pop saved registers from stack
00002F00  4E75                    3450              RTS                             ; return
00002F02                          3451          
00002F02                          3452  ***********************************************************************************************************
00002F02                          3453  *
00002F02                          3454  *                       EA Print Subroutine
00002F02                          3455  *
00002F02                          3456  ***********************************************************************************************************
00002F02                          3457  
00002F02                          3458  printEA     
00002F02  48E7 FF7E               3459              MOVEM.L  D0-D7/A1-A6, -(SP)     ; callee saved data
00002F06                          3460  
00002F06  B43C 0000               3461              CMP.B       #zero, D2           ; compare D2 or Mode to 0
00002F0A  6700 002E               3462              BEQ         pDataReg            ; if true, branch to pDataReg
00002F0E  B43C 0001               3463              CMP.B       #one, D2            ; compare mode to 1
00002F12  6700 00E6               3464              BEQ         pAddrReg            ; if true, branch to pAddrReg
00002F16  B43C 0002               3465              CMP.B       #two, D2            ; compare mode to 2
00002F1A  6700 019E               3466              BEQ         pAddrDir            ; if true, branch to pAddrDir
00002F1E  B43C 0003               3467              CMP.B       #three, D2          ; compare mode to 3
00002F22  6700 02C2               3468              BEQ         pAddrPost           ; if true, branch to pAddrPost
00002F26  B43C 0004               3469              CMP.B       #four, D2           ; compare mode to 4
00002F2A  6700 0446               3470              BEQ         pAddrDec            ; if true, branch to pAddrDec
00002F2E  B43C 0007               3471              CMP.B       #seven, D2          ; compare mode to 7
00002F32  6700 0576               3472              BEQ         pHex                ; if true, branch to pHex
00002F36  6000 0642               3473              BRA         invalid             ; otherwise invalid
00002F3A                          3474  
00002F3A                          3475  ***********************************************************************************************************
00002F3A                          3476  * Data Register        
00002F3A                          3477  pDataReg    
00002F3A  B63C 0000               3478              CMP.B       #zero,D3            ; compare D3 or Register to 0
00002F3E  6700 003A               3479              BEQ         displayD0           ; if true, branch to displayD0
00002F42  B63C 0001               3480              CMP.B       #one,D3             ; compare D3 or Register to 1
00002F46  6700 0042               3481              BEQ         displayD1           ; if true, branch to displayD1
00002F4A  B63C 0002               3482              CMP.B       #two,D3             ; compare D3 or Register to 2
00002F4E  6700 004A               3483              BEQ         displayD2           ; if true, branch to displayD2
00002F52  B63C 0003               3484              CMP.B       #three,D3           ; compare D3 or Register to 3
00002F56  6700 0052               3485              BEQ         displayD3           ; if true, branch to displayD3
00002F5A  B63C 0004               3486              CMP.B       #four,D3            ; compare D3 or Register to 4
00002F5E  6700 005A               3487              BEQ         displayD4           ; if true, branch to displayD4
00002F62  B63C 0005               3488              CMP.B       #five,D3            ; compare D3 or Register to 5
00002F66  6700 0062               3489              BEQ         displayD5           ; if true, branch to displayD5
00002F6A  B63C 0006               3490              CMP.B       #six,D3             ; compare D3 or Register to 6
00002F6E  6700 006A               3491              BEQ         displayD6           ; if true, branch to displayD6
00002F72  B63C 0007               3492              CMP.B       #seven,D3           ; compare D3 or Register to 7
00002F76  6700 0072               3493              BEQ         displayD7           ; if true, branch to displayD7
00002F7A                          3494              
00002F7A  43F9 00003D9A           3495  displayD0   LEA         dispD0, A1          ; Display D0
00002F80  103C 000E               3496              MOVE.B      #14, D0             ; command for trap call to display message
00002F84  4E4F                    3497              TRAP        #15                 ; trap call
00002F86  6000 05F2               3498              BRA         endSUB              ; go to the end of the subroutine
00002F8A                          3499              
00002F8A  43F9 00003D9D           3500  displayD1   LEA         dispD1, A1          ; Display D1
00002F90  103C 000E               3501              MOVE.B      #14, D0             ; command for trap call to display message
00002F94  4E4F                    3502              TRAP        #15                 ; trap call
00002F96  6000 05E2               3503              BRA         endSUB              ; go to the end of the subroutine
00002F9A                          3504  
00002F9A  43F9 00003DA0           3505  displayD2   LEA         dispD2, A1          ; Display D2
00002FA0  103C 000E               3506              MOVE.B      #14, D0             ; command for trap call to display message
00002FA4  4E4F                    3507              TRAP        #15                 ; trap call
00002FA6  6000 05D2               3508              BRA         endSUB              ; go to the end of the subroutine
00002FAA                          3509  
00002FAA  43F9 00003DA3           3510  displayD3   LEA         dispD3, A1          ; Display D3
00002FB0  103C 000E               3511              MOVE.B      #14, D0             ; command for trap call to display message
00002FB4  4E4F                    3512              TRAP        #15                 ; trap call
00002FB6  6000 05C2               3513              BRA         endSUB              ; go to the end of the subroutine
00002FBA                          3514  
00002FBA  43F9 00003DA6           3515  displayD4   LEA         dispD4, A1          ; Display D4
00002FC0  103C 000E               3516              MOVE.B      #14, D0             ; command for trap call to display message
00002FC4  4E4F                    3517              TRAP        #15                 ; trap call
00002FC6  6000 05B2               3518              BRA         endSUB              ; go to the end of the subroutine
00002FCA                          3519  
00002FCA  43F9 00003DA9           3520  displayD5   LEA         dispD5, A1          ; Display D5
00002FD0  103C 000E               3521              MOVE.B      #14, D0             ; command for trap call to display message
00002FD4  4E4F                    3522              TRAP        #15                 ; trap call
00002FD6  6000 05A2               3523              BRA         endSUB              ; go to the end of the subroutine
00002FDA                          3524  
00002FDA  43F9 00003DAC           3525  displayD6   LEA         dispD6, A1          ; Display D6
00002FE0  103C 000E               3526              MOVE.B      #14, D0             ; command for trap call to display message
00002FE4  4E4F                    3527              TRAP        #15                 ; trap call
00002FE6  6000 0592               3528              BRA         endSUB              ; go to the end of the subroutine
00002FEA                          3529  
00002FEA  43F9 00003DAF           3530  displayD7   LEA         dispD7, A1          ; Display D7
00002FF0  103C 000E               3531              MOVE.B      #14, D0             ; command for trap call to display message
00002FF4  4E4F                    3532              TRAP        #15                 ; trap call
00002FF6  6000 0582               3533              BRA         endSUB              ; go to the end of the subroutine
00002FFA                          3534              
00002FFA                          3535  ***********************************************************************************************************
00002FFA                          3536  * Address Register
00002FFA                          3537  
00002FFA  B63C 0000               3538  pAddrReg    CMP.B       #zero,D3            ; compare D3 or Register to 0
00002FFE  6700 003A               3539              BEQ         displayA0           ; if true, branch to displayA0
00003002  B63C 0001               3540              CMP.B       #one,D3             ; compare D3 or Register to 1
00003006  6700 0042               3541              BEQ         displayA1           ; if true, branch to displayA1
0000300A  B63C 0002               3542              CMP.B       #two,D3             ; compare D3 or Register to 2
0000300E  6700 004A               3543              BEQ         displayA2           ; if true, branch to displayA2
00003012  B63C 0003               3544              CMP.B       #three,D3           ; compare D3 or Register to 3
00003016  6700 0052               3545              BEQ         displayA3           ; if true, branch to displayA3
0000301A  B63C 0004               3546              CMP.B       #four,D3            ; compare D3 or Register to 4
0000301E  6700 005A               3547              BEQ         displayA4           ; if true, branch to displayA4
00003022  B63C 0005               3548              CMP.B       #five,D3            ; compare D3 or Register to 5
00003026  6700 0062               3549              BEQ         displayA5           ; if true, branch to displayA5
0000302A  B63C 0006               3550              CMP.B       #six,D3             ; compare D3 or Register to 6
0000302E  6700 006A               3551              BEQ         displayA6           ; if true, branch to displayA6
00003032  B63C 0007               3552              CMP.B       #seven,D3           ; compare D3 or Register to 7
00003036  6700 0072               3553              BEQ         displayA7           ; if true, branch to displayA7
0000303A                          3554              
0000303A  43F9 00003D80           3555  displayA0   LEA         dispA0, A1          ; Display A0
00003040  103C 000E               3556              MOVE.B      #14, D0             ; command for trap call to display message
00003044  4E4F                    3557              TRAP        #15                 ; trap call
00003046  6000 0532               3558              BRA         endSUB              ; go to the end of the subroutine
0000304A                          3559              
0000304A  43F9 00003D83           3560  displayA1   LEA         dispA1, A1          ; Display A1
00003050  103C 000E               3561              MOVE.B      #14, D0             ; command for trap call to display message
00003054  4E4F                    3562              TRAP        #15                 ; trap call
00003056  6000 0522               3563              BRA         endSUB              ; go to the end of the subroutine
0000305A                          3564  
0000305A  43F9 00003D86           3565  displayA2   LEA         dispA2, A1          ; Display A2
00003060  103C 000E               3566              MOVE.B      #14, D0             ; command for trap call to display message
00003064  4E4F                    3567              TRAP        #15                 ; trap call
00003066  6000 0512               3568              BRA         endSUB              ; go to the end of the subroutine
0000306A                          3569  
0000306A  43F9 00003D89           3570  displayA3   LEA         dispA3, A1          ; Display A3
00003070  103C 000E               3571              MOVE.B      #14, D0             ; command for trap call to display message
00003074  4E4F                    3572              TRAP        #15                 ; trap call
00003076  6000 0502               3573              BRA         endSUB              ; go to the end of the subroutine
0000307A                          3574  
0000307A  43F9 00003D8C           3575  displayA4   LEA         dispA4, A1          ; Display A4
00003080  103C 000E               3576              MOVE.B      #14, D0             ; command for trap call to display message
00003084  4E4F                    3577              TRAP        #15                 ; trap call
00003086  6000 04F2               3578              BRA         endSUB              ; go to the end of the subroutine
0000308A                          3579  
0000308A  43F9 00003D8F           3580  displayA5   LEA         dispA5, A1          ; Display A5
00003090  103C 000E               3581              MOVE.B      #14, D0             ; command for trap call to display message
00003094  4E4F                    3582              TRAP        #15                 ; trap call
00003096  6000 04E2               3583              BRA         endSUB              ; go to the end of the subroutine
0000309A                          3584  
0000309A  43F9 00003D92           3585  displayA6   LEA         dispA6, A1          ; Display A6
000030A0  103C 000E               3586              MOVE.B      #14, D0             ; command for trap call to display message
000030A4  4E4F                    3587              TRAP        #15                 ; trap call
000030A6  6000 04D2               3588              BRA         endSUB              ; go to the end of the subroutine
000030AA                          3589  
000030AA  43F9 00003D95           3590  displayA7   LEA         dispA7, A1          ; Display A7
000030B0  103C 000E               3591              MOVE.B      #14, D0             ; command for trap call to display message
000030B4  4E4F                    3592              TRAP        #15                 ; trap call
000030B6  6000 04C2               3593              BRA         endSUB              ; go to the end of the subroutine
000030BA                          3594  
000030BA                          3595  ***********************************************************************************************************
000030BA                          3596  * Address Register Direct
000030BA                          3597  
000030BA  43F9 00003CE6           3598  pAddrDir    LEA         opPer, A1           ; Display open parenthesis
000030C0  103C 000E               3599              MOVE.B      #14, D0             ; command for trap call to display message
000030C4  4E4F                    3600              TRAP        #15                 ; trap call
000030C6                          3601              
000030C6  B63C 0000               3602              CMP.B       #zero,D3            ; compare D3 or Register to 0
000030CA  6700 003A               3603              BEQ         displayA0A          ; if true, branch to displayA0A
000030CE  B63C 0001               3604              CMP.B       #one,D3             ; compare D3 or Register to 1
000030D2  6700 004E               3605              BEQ         displayA1A          ; if true, branch to displayA1A
000030D6  B63C 0002               3606              CMP.B       #two,D3             ; compare D3 or Register to 2
000030DA  6700 0062               3607              BEQ         displayA2A          ; if true, branch to displayA2A
000030DE  B63C 0003               3608              CMP.B       #three,D3           ; compare D3 or Register to 3
000030E2  6700 0076               3609              BEQ         displayA3A          ; if true, branch to displayA3A
000030E6  B63C 0004               3610              CMP.B       #four,D3            ; compare D3 or Register to 4
000030EA  6700 008A               3611              BEQ         displayA4A          ; if true, branch to displayA4A
000030EE  B63C 0005               3612              CMP.B       #five,D3            ; compare D3 or Register to 5
000030F2  6700 009E               3613              BEQ         displayA5A          ; if true, branch to displayA5A
000030F6  B63C 0006               3614              CMP.B       #six,D3             ; compare D3 or Register to 6
000030FA  6700 00B2               3615              BEQ         displayA6A          ; if true, branch to displayA6A
000030FE  B63C 0007               3616              CMP.B       #seven,D3           ; compare D3 or Register to 7
00003102  6700 00C6               3617              BEQ         displayA7A          ; if true, branch to displayA7A
00003106                          3618              
00003106  43F9 00003D80           3619  displayA0A  LEA         dispA0, A1          ; Display A0
0000310C  103C 000E               3620              MOVE.B      #14, D0             ; command for trap call to display message
00003110  4E4F                    3621              TRAP        #15                 ; trap call
00003112  43F9 00003CE8           3622              LEA         clPer, A1           ; Display closing parenthesis
00003118  103C 000E               3623              MOVE.B      #14, D0             ; command for trap call to display message
0000311C  4E4F                    3624              TRAP        #15                 ; trap call
0000311E  6000 045A               3625              BRA         endSUB              ; go to the end of the subroutine
00003122                          3626              
00003122  43F9 00003D83           3627  displayA1A  LEA         dispA1, A1          ; Display A1
00003128  103C 000E               3628              MOVE.B      #14, D0             ; command for trap call to display message
0000312C  4E4F                    3629              TRAP        #15                 ; trap call
0000312E  43F9 00003CE8           3630              LEA         clPer, A1           ; Display closing parenthesis
00003134  103C 000E               3631              MOVE.B      #14, D0             ; command for trap call to display message
00003138  4E4F                    3632              TRAP        #15                 ; trap call
0000313A  6000 043E               3633              BRA         endSUB              ; go to the end of the subroutine
0000313E                          3634  
0000313E  43F9 00003D86           3635  displayA2A  LEA         dispA2, A1          ; Display A2
00003144  103C 000E               3636              MOVE.B      #14, D0             ; command for trap call to display message
00003148  4E4F                    3637              TRAP        #15                 ; trap call
0000314A  43F9 00003CE8           3638              LEA         clPer, A1           ; Display closing parenthesis
00003150  103C 000E               3639              MOVE.B      #14, D0             ; command for trap call to display message
00003154  4E4F                    3640              TRAP        #15                 ; trap call
00003156  6000 0422               3641              BRA         endSUB              ; go to the end of the subroutine
0000315A                          3642  
0000315A  43F9 00003D89           3643  displayA3A  LEA         dispA3, A1          ; Display A3
00003160  103C 000E               3644              MOVE.B      #14, D0             ; command for trap call to display message
00003164  4E4F                    3645              TRAP        #15                 ; trap call
00003166  43F9 00003CE8           3646              LEA         clPer, A1           ; Display closing parenthesis
0000316C  103C 000E               3647              MOVE.B      #14, D0             ; command for trap call to display message
00003170  4E4F                    3648              TRAP        #15                 ; trap call
00003172  6000 0406               3649              BRA         endSUB              ; go to the end of the subroutine
00003176                          3650  
00003176  43F9 00003D8C           3651  displayA4A  LEA         dispA4, A1          ; Display A4
0000317C  103C 000E               3652              MOVE.B      #14, D0             ; command for trap call to display message
00003180  4E4F                    3653              TRAP        #15                 ; trap call
00003182  43F9 00003CE8           3654              LEA         clPer, A1           ; Display closing parenthesis
00003188  103C 000E               3655              MOVE.B      #14, D0             ; command for trap call to display message
0000318C  4E4F                    3656              TRAP        #15                 ; trap call
0000318E  6000 03EA               3657              BRA         endSUB              ; go to the end of the subroutine
00003192                          3658  
00003192  43F9 00003D8F           3659  displayA5A  LEA         dispA5, A1          ; Display A5
00003198  103C 000E               3660              MOVE.B      #14, D0             ; command for trap call to display message
0000319C  4E4F                    3661              TRAP        #15                 ; trap call
0000319E  43F9 00003CE8           3662              LEA         clPer, A1           ; Display closing parenthesis
000031A4  103C 000E               3663              MOVE.B      #14, D0             ; command for trap call to display message
000031A8  4E4F                    3664              TRAP        #15                 ; trap call
000031AA  6000 03CE               3665              BRA         endSUB              ; go to the end of the subroutine
000031AE                          3666  
000031AE  43F9 00003D92           3667  displayA6A  LEA         dispA6, A1          ; Display A6
000031B4  103C 000E               3668              MOVE.B      #14, D0             ; command for trap call to display message
000031B8  4E4F                    3669              TRAP        #15                 ; trap call
000031BA  43F9 00003CE8           3670              LEA         clPer, A1           ; Display closing parenthesis
000031C0  103C 000E               3671              MOVE.B      #14, D0             ; command for trap call to display message
000031C4  4E4F                    3672              TRAP        #15                 ; trap call
000031C6  6000 03B2               3673              BRA         endSUB              ; go to the end of the subroutine
000031CA                          3674  
000031CA  43F9 00003D95           3675  displayA7A  LEA         dispA7, A1          ; Display A7
000031D0  103C 000E               3676              MOVE.B      #14, D0             ; command for trap call to display message
000031D4  4E4F                    3677              TRAP        #15                 ; trap call
000031D6  43F9 00003CE8           3678              LEA         clPer, A1           ; Display closing parenthesis
000031DC  103C 000E               3679              MOVE.B      #14, D0             ; command for trap call to display message
000031E0  4E4F                    3680              TRAP        #15                 ; trap call
000031E2  6000 0396               3681              BRA         endSUB              ; go to the end of the subroutine
000031E6                          3682              
000031E6                          3683  ***********************************************************************************************************
000031E6                          3684  * Addr Post-increment
000031E6                          3685              
000031E6  43F9 00003CE6           3686  pAddrPost   LEA         opPer, A1           ; Display open parenthesis
000031EC  103C 000E               3687              MOVE.B      #14, D0             ; command for trap call to display message
000031F0  4E4F                    3688              TRAP        #15                 ; trap call
000031F2                          3689              
000031F2  B63C 0000               3690              CMP.B       #zero,D3            ; compare D3 or Register to 0
000031F6  6700 003A               3691              BEQ         displayA0P          ; if true, branch to displayA0P
000031FA  B63C 0001               3692              CMP.B       #one,D3             ; compare D3 or Register to 1
000031FE  6700 005A               3693              BEQ         displayA1P          ; if true, branch to displayA1P
00003202  B63C 0002               3694              CMP.B       #two,D3             ; compare D3 or Register to 2
00003206  6700 007A               3695              BEQ         displayA2P          ; if true, branch to displayA2P
0000320A  B63C 0003               3696              CMP.B       #three,D3           ; compare D3 or Register to 3
0000320E  6700 009A               3697              BEQ         displayA3P          ; if true, branch to displayA3P
00003212  B63C 0004               3698              CMP.B       #four,D3            ; compare D3 or Register to 4
00003216  6700 00BA               3699              BEQ         displayA4P          ; if true, branch to displayA4P
0000321A  B63C 0005               3700              CMP.B       #five,D3            ; compare D3 or Register to 5
0000321E  6700 00DA               3701              BEQ         displayA5P          ; if true, branch to displayA5P
00003222  B63C 0006               3702              CMP.B       #six,D3             ; compare D3 or Register to 6
00003226  6700 00FA               3703              BEQ         displayA6P          ; if true, branch to displayA6P
0000322A  B63C 0007               3704              CMP.B       #seven,D3           ; compare D3 or Register to 7
0000322E  6700 011A               3705              BEQ         displayA7P          ; if true, branch to displayA7P
00003232                          3706              
00003232  43F9 00003D80           3707  displayA0P  LEA         dispA0, A1          ; Display A0
00003238  103C 000E               3708              MOVE.B      #14, D0             ; command for trap call to display message
0000323C  4E4F                    3709              TRAP        #15                 ; trap call
0000323E  43F9 00003CE8           3710              LEA         clPer, A1           ; Display closing parenthesis
00003244  103C 000E               3711              MOVE.B      #14, D0             ; command for trap call to display message
00003248  4E4F                    3712              TRAP        #15                 ; trap call
0000324A  43F9 00003CEC           3713              LEA         inc, A1             ; Display +
00003250  103C 000E               3714              MOVE.B      #14, D0             ; command for trap call to display message
00003254  4E4F                    3715              TRAP        #15                 ; trap call
00003256  6000 0322               3716              BRA         endSUB              ; go to the end of the subroutine
0000325A                          3717              
0000325A  43F9 00003D83           3718  displayA1P  LEA         dispA1, A1          ; Display A1
00003260  103C 000E               3719              MOVE.B      #14, D0             ; command for trap call to display message
00003264  4E4F                    3720              TRAP        #15                 ; trap call
00003266  43F9 00003CE8           3721              LEA         clPer, A1           ; Display closing parenthesis
0000326C  103C 000E               3722              MOVE.B      #14, D0             ; command for trap call to display message
00003270  4E4F                    3723              TRAP        #15                 ; trap call
00003272  43F9 00003CEC           3724              LEA         inc, A1             ; Display +
00003278  103C 000E               3725              MOVE.B      #14, D0             ; command for trap call to display message
0000327C  4E4F                    3726              TRAP        #15                 ; trap call
0000327E  6000 02FA               3727              BRA         endSUB              ; go to the end of the subroutine
00003282                          3728  
00003282  43F9 00003D86           3729  displayA2P  LEA         dispA2, A1          ; Display A2
00003288  103C 000E               3730              MOVE.B      #14, D0             ; command for trap call to display message
0000328C  4E4F                    3731              TRAP        #15                 ; trap call
0000328E  43F9 00003CE8           3732              LEA         clPer, A1           ; Display closing parenthesis
00003294  103C 000E               3733              MOVE.B      #14, D0             ; command for trap call to display message
00003298  4E4F                    3734              TRAP        #15                 ; trap call
0000329A  43F9 00003CEC           3735              LEA         inc, A1             ; Display +
000032A0  103C 000E               3736              MOVE.B      #14, D0             ; command for trap call to display message
000032A4  4E4F                    3737              TRAP        #15                 ; trap call
000032A6  6000 02D2               3738              BRA         endSUB              ; go to the end of the subroutine
000032AA                          3739  
000032AA  43F9 00003D89           3740  displayA3P  LEA         dispA3, A1          ; Display A3
000032B0  103C 000E               3741              MOVE.B      #14, D0             ; command for trap call to display message
000032B4  4E4F                    3742              TRAP        #15                 ; trap call
000032B6  43F9 00003CE8           3743              LEA         clPer, A1           ; Display closing parenthesis
000032BC  103C 000E               3744              MOVE.B      #14, D0             ; command for trap call to display message
000032C0  4E4F                    3745              TRAP        #15                 ; trap call
000032C2  43F9 00003CEC           3746              LEA         inc, A1             ; Display +
000032C8  103C 000E               3747              MOVE.B      #14, D0             ; command for trap call to display message
000032CC  4E4F                    3748              TRAP        #15                 ; trap call
000032CE  6000 02AA               3749              BRA         endSUB              ; go to the end of the subroutine
000032D2                          3750  
000032D2  43F9 00003D8C           3751  displayA4P  LEA         dispA4, A1          ; Display A4
000032D8  103C 000E               3752              MOVE.B      #14, D0             ; command for trap call to display message
000032DC  4E4F                    3753              TRAP        #15                 ; trap call
000032DE  43F9 00003CE8           3754              LEA         clPer, A1           ; Display closing parenthesis
000032E4  103C 000E               3755              MOVE.B      #14, D0             ; command for trap call to display message
000032E8  4E4F                    3756              TRAP        #15                 ; trap call
000032EA  43F9 00003CEC           3757              LEA         inc, A1             ; Display +
000032F0  103C 000E               3758              MOVE.B      #14, D0             ; command for trap call to display message
000032F4  4E4F                    3759              TRAP        #15                 ; trap call
000032F6  6000 0282               3760              BRA         endSUB              ; go to the end of the subroutine
000032FA                          3761  
000032FA  43F9 00003D8F           3762  displayA5P  LEA         dispA5, A1          ; Display A5
00003300  103C 000E               3763              MOVE.B      #14, D0             ; command for trap call to display message
00003304  4E4F                    3764              TRAP        #15                 ; trap call
00003306  43F9 00003CE8           3765              LEA         clPer, A1           ; Display closing parenthesis
0000330C  103C 000E               3766              MOVE.B      #14, D0             ; command for trap call to display message
00003310  4E4F                    3767              TRAP        #15                 ; trap call
00003312  43F9 00003CEC           3768              LEA         inc, A1             ; Display +
00003318  103C 000E               3769              MOVE.B      #14, D0             ; command for trap call to display message
0000331C  4E4F                    3770              TRAP        #15                 ; trap call
0000331E  6000 025A               3771              BRA         endSUB              ; go to the end of the subroutine
00003322                          3772  
00003322  43F9 00003D92           3773  displayA6P  LEA         dispA6, A1          ; Display A6
00003328  103C 000E               3774              MOVE.B      #14, D0             ; command for trap call to display message
0000332C  4E4F                    3775              TRAP        #15                 ; trap call
0000332E  43F9 00003CE8           3776              LEA         clPer, A1           ; Display closing parenthesis
00003334  103C 000E               3777              MOVE.B      #14, D0             ; command for trap call to display message
00003338  4E4F                    3778              TRAP        #15                 ; trap call
0000333A  43F9 00003CEC           3779              LEA         inc, A1             ; Display +
00003340  103C 000E               3780              MOVE.B      #14, D0             ; command for trap call to display message
00003344  4E4F                    3781              TRAP        #15                 ; trap call
00003346  6000 0232               3782              BRA         endSUB              ; go to the end of the subroutine
0000334A                          3783  
0000334A  43F9 00003D95           3784  displayA7P  LEA         dispA7, A1          ; Display A7
00003350  103C 000E               3785              MOVE.B      #14, D0             ; command for trap call to display message
00003354  4E4F                    3786              TRAP        #15                 ; trap call
00003356  43F9 00003CE8           3787              LEA         clPer, A1           ; Display closing parenthesis
0000335C  103C 000E               3788              MOVE.B      #14, D0             ; command for trap call to display message
00003360  4E4F                    3789              TRAP        #15                 ; trap call
00003362  43F9 00003CEC           3790              LEA         inc, A1             ; Display +
00003368  103C 000E               3791              MOVE.B      #14, D0             ; command for trap call to display message
0000336C  4E4F                    3792              TRAP        #15                 ; trap call
0000336E  6000 020A               3793              BRA         endSUB              ; go to the end of the subroutine
00003372                          3794  
00003372                          3795  ***********************************************************************************************************
00003372                          3796  * Addr Post-decrement
00003372                          3797  
00003372                          3798  pAddrDec    
00003372  43F9 00003CEA           3799              LEA         dec, A1             ; Display -
00003378  103C 000E               3800              MOVE.B      #14, D0             ; command for trap call to display message
0000337C  4E4F                    3801              TRAP        #15                 ; trap call
0000337E                          3802              
0000337E  43F9 00003CE6           3803              LEA         opPer, A1           ; Display open parenthesis
00003384  103C 000E               3804              MOVE.B      #14, D0             ; command for trap call to display message
00003388  4E4F                    3805              TRAP        #15                 ; trap call
0000338A                          3806              
0000338A  B63C 0000               3807              CMP.B       #zero,D3            ; compare D3 or Register to 0
0000338E  6700 003A               3808              BEQ         displayA0D          ; if true, branch to displayA0D
00003392  B63C 0001               3809              CMP.B       #one,D3             ; compare D3 or Register to 1
00003396  6700 004E               3810              BEQ         displayA1D          ; if true, branch to displayA1D
0000339A  B63C 0002               3811              CMP.B       #two,D3             ; compare D3 or Register to 2
0000339E  6700 0062               3812              BEQ         displayA2D          ; if true, branch to displayA2D
000033A2  B63C 0003               3813              CMP.B       #three,D3           ; compare D3 or Register to 3
000033A6  6700 0076               3814              BEQ         displayA3D          ; if true, branch to displayA3D
000033AA  B63C 0004               3815              CMP.B       #four,D3            ; compare D3 or Register to 4
000033AE  6700 008A               3816              BEQ         displayA4D          ; if true, branch to displayA4D
000033B2  B63C 0005               3817              CMP.B       #five,D3            ; compare D3 or Register to 5
000033B6  6700 009E               3818              BEQ         displayA5D          ; if true, branch to displayA5D
000033BA  B63C 0006               3819              CMP.B       #six,D3             ; compare D3 or Register to 6
000033BE  6700 00B2               3820              BEQ         displayA6D          ; if true, branch to displayA6D
000033C2  B63C 0007               3821              CMP.B       #seven,D3           ; compare D3 or Register to 7
000033C6  6700 00C6               3822              BEQ         displayA7D          ; if true, branch to displayA7D
000033CA                          3823              
000033CA                          3824  displayA0D  
000033CA  43F9 00003D80           3825              LEA         dispA0, A1          ; Display A0
000033D0  103C 000E               3826              MOVE.B      #14, D0             ; command for trap call to display message
000033D4  4E4F                    3827              TRAP        #15                 ; trap call
000033D6  43F9 00003CE8           3828              LEA         clPer, A1           ; Display closing parenthesis
000033DC  103C 000E               3829              MOVE.B      #14, D0             ; command for trap call to display message
000033E0  4E4F                    3830              TRAP        #15                 ; trap call
000033E2  6000 0196               3831              BRA         endSUB              ; go to the end of the subroutine
000033E6                          3832              
000033E6                          3833  displayA1D  
000033E6  43F9 00003D83           3834              LEA         dispA1, A1          ; Display A1
000033EC  103C 000E               3835              MOVE.B      #14, D0             ; command for trap call to display message
000033F0  4E4F                    3836              TRAP        #15                 ; trap call
000033F2  43F9 00003CE8           3837              LEA         clPer, A1           ; Display closing parenthesis
000033F8  103C 000E               3838              MOVE.B      #14, D0             ; command for trap call to display message
000033FC  4E4F                    3839              TRAP        #15                 ; trap call
000033FE  6000 017A               3840              BRA         endSUB              ; go to the end of the subroutine
00003402                          3841  
00003402                          3842  displayA2D  
00003402  43F9 00003D86           3843              LEA         dispA2, A1          ; Display A2
00003408  103C 000E               3844              MOVE.B      #14, D0             ; command for trap call to display message
0000340C  4E4F                    3845              TRAP        #15                 ; trap call
0000340E  43F9 00003CE8           3846              LEA         clPer, A1           ; Display closing parenthesis
00003414  103C 000E               3847              MOVE.B      #14, D0             ; command for trap call to display message
00003418  4E4F                    3848              TRAP        #15                 ; trap call
0000341A  6000 015E               3849              BRA         endSUB              ; go to the end of the subroutine
0000341E                          3850  
0000341E                          3851  displayA3D  
0000341E  43F9 00003D89           3852              LEA         dispA3, A1          ; Display A3
00003424  103C 000E               3853              MOVE.B      #14, D0             ; command for trap call to display message
00003428  4E4F                    3854              TRAP        #15                 ; trap call
0000342A  43F9 00003CE8           3855              LEA         clPer, A1           ; Display closing parenthesis
00003430  103C 000E               3856              MOVE.B      #14, D0             ; command for trap call to display message
00003434  4E4F                    3857              TRAP        #15                 ; trap call
00003436  6000 0142               3858              BRA         endSUB              ; go to the end of the subroutine
0000343A                          3859  
0000343A                          3860  displayA4D  
0000343A  43F9 00003D8C           3861              LEA         dispA4, A1          ; Display A4
00003440  103C 000E               3862              MOVE.B      #14, D0             ; command for trap call to display message
00003444  4E4F                    3863              TRAP        #15                 ; trap call
00003446  43F9 00003CE8           3864              LEA         clPer, A1           ; Display closing parenthesis
0000344C  103C 000E               3865              MOVE.B      #14, D0             ; command for trap call to display message
00003450  4E4F                    3866              TRAP        #15                 ; trap call
00003452  6000 0126               3867              BRA         endSUB              ; go to the end of the subroutine
00003456                          3868  
00003456                          3869  displayA5D  
00003456  43F9 00003D8F           3870              LEA         dispA5, A1          ; Display A5
0000345C  103C 000E               3871              MOVE.B      #14, D0             ; command for trap call to display message
00003460  4E4F                    3872              TRAP        #15                 ; trap call
00003462  43F9 00003CE8           3873              LEA         clPer, A1           ; Display closing parenthesis
00003468  103C 000E               3874              MOVE.B      #14, D0             ; command for trap call to display message
0000346C  4E4F                    3875              TRAP        #15                 ; trap call
0000346E  6000 010A               3876              BRA         endSUB              ; go to the end of the subroutine
00003472                          3877  
00003472                          3878  displayA6D  
00003472  43F9 00003D92           3879              LEA         dispA6, A1          ; Display A6
00003478  103C 000E               3880              MOVE.B      #14, D0             ; command for trap call to display message
0000347C  4E4F                    3881              TRAP        #15                 ; trap call
0000347E  43F9 00003CE8           3882              LEA         clPer, A1           ; Display closing parenthesis
00003484  103C 000E               3883              MOVE.B      #14, D0             ; command for trap call to display message
00003488  4E4F                    3884              TRAP        #15                 ; trap call
0000348A  6000 00EE               3885              BRA         endSUB              ; go to the end of the subroutine
0000348E                          3886  
0000348E                          3887  displayA7D  
0000348E  43F9 00003D95           3888              LEA         dispA7, A1          ; Display A7
00003494  103C 000E               3889              MOVE.B      #14, D0             ; command for trap call to display message
00003498  4E4F                    3890              TRAP        #15                 ; trap call
0000349A  43F9 00003CE8           3891              LEA         clPer, A1           ; Display closing parenthesis
000034A0  103C 000E               3892              MOVE.B      #14, D0             ; command for trap call to display message
000034A4  4E4F                    3893              TRAP        #15                 ; trap call
000034A6  6000 00D2               3894              BRA         endSUB              ; go to the end of the subroutine
000034AA                          3895  
000034AA                          3896  ***********************************************************************************************************
000034AA                          3897  * Display Hex
000034AA                          3898  
000034AA                          3899  pHex        
000034AA  B63C 0000               3900              CMP.B       #zero, D3           ; compare D3 or Register to 0
000034AE  6700 0012               3901              BEQ         AbsShort            ; if true, branch to AbsShort
000034B2  B63C 0001               3902              CMP.B       #one, D3            ; compare D3 or Register to 1
000034B6  6700 0042               3903              BEQ         AbsLong             ; if true, branch to AbsLong
000034BA  B63C 0004               3904              CMP.B       #four, D3           ; compare D3 or Register to 4
000034BE  6700 0072               3905              BEQ         DispImm             ; if true, branch to DispImm
000034C2                          3906              
000034C2                          3907  AbsShort    
000034C2  43F9 00003CE6           3908              LEA         opPer, A1           ; Display open parenthesis
000034C8  103C 000E               3909              MOVE.B      #14, D0             ; command for trap call to display message
000034CC  4E4F                    3910              TRAP        #15                 ; trap call
000034CE                          3911              
000034CE  43F9 00003CE2           3912              LEA         dispHex, A1         ; Display $
000034D4  103C 000E               3913              MOVE.B      #14, D0             ; command for trap call to display message
000034D8  4E4F                    3914              TRAP        #15                 ; trap call
000034DA                          3915              
000034DA  4241                    3916              CLR         D1                  ; clear D1
000034DC  3218                    3917              MOVE.W      (A0)+, D1           ; move next word in memory to D1
000034DE  4240                    3918              CLR         D0                  ; clear D0
000034E0  103C 0004               3919              MOVE.B      #4, D0              ; move the number of hexes to decode
000034E4                          3920              
000034E4  4EB9 00003AA2           3921              JSR         outHex              ; jump to outHex
000034EA                          3922              
000034EA  43F9 00003CE8           3923              LEA         clPer, A1           ; Display closing parenthesis
000034F0  103C 000E               3924              MOVE.B      #14, D0             ; command for trap call to display message
000034F4  4E4F                    3925              TRAP        #15                 ; trap call
000034F6                          3926              
000034F6  6000 0082               3927              BRA         endSub              ; go to the end of the subroutine
000034FA                          3928              
000034FA                          3929  AbsLong     
000034FA  43F9 00003CE6           3930              LEA         opPer, A1           ; Display open parenthesis
00003500  103C 000E               3931              MOVE.B      #14, D0             ; command for trap call to display message
00003504  4E4F                    3932              TRAP        #15                 ; trap call
00003506                          3933              
00003506  43F9 00003CE2           3934              LEA         dispHex, A1         ; Display $
0000350C  103C 000E               3935              MOVE.B      #14, D0             ; command for trap call to display message
00003510  4E4F                    3936              TRAP        #15                 ; trap call
00003512                          3937              
00003512  4241                    3938              CLR         D1                  ; clear D1
00003514  2218                    3939              MOVE.L      (A0)+, D1           ; move next long-word in memory to D1
00003516  4240                    3940              CLR         D0                  ; clear D0
00003518  103C 0008               3941              MOVE.B      #8, D0              ; move the number of hexes to decode
0000351C                          3942              
0000351C  4EB9 00003AA2           3943              JSR         outHex              ; jump to outHex
00003522                          3944              
00003522  43F9 00003CE8           3945              LEA         clPer, A1           ; Display closing parenthesis
00003528  103C 000E               3946              MOVE.B      #14, D0             ; command for trap call to display message
0000352C  4E4F                    3947              TRAP        #15                 ; trap call
0000352E                          3948              
0000352E  6000 004A               3949              BRA         endSub              ; go to the end of the subroutine
00003532                          3950  
00003532                          3951  DispImm     
00003532  43F9 00003CE0           3952              LEA         hashTag, A1         ; Display #
00003538  103C 000E               3953              MOVE.B      #14, D0             ; command for trap call to display message
0000353C  4E4F                    3954              TRAP        #15                 ; trap call
0000353E                          3955  
0000353E  43F9 00003CE2           3956              LEA         dispHex, A1         ; Display $
00003544  103C 000E               3957              MOVE.B      #14, D0             ; command for trap call to display message
00003548  4E4F                    3958              TRAP        #15                 ; trap call
0000354A                          3959              
0000354A  BC3C 0001               3960              CMP.B       #1,D6               ; compare 1 to D6 for this determines if long immediate needs printing
0000354E  6700 0016               3961              BEQ         ImmLong             ; if true, branch to ImmLong
00003552                          3962              
00003552  4241                    3963              CLR         D1                  ; clear D1
00003554  3218                    3964              MOVE.W      (A0)+, D1           ; move next word to D1
00003556  4240                    3965              CLR         D0                  ; clear D0
00003558  103C 0004               3966              MOVE.B      #4, D0              ; move the number of hexes to decode
0000355C  4EB9 00003AA2           3967              JSR         outHex              ; jump to outHex
00003562  6000 0012               3968              BRA         LongSkip            ; branch over printing a long-word
00003566                          3969              
00003566                          3970  ImmLong     
00003566  4241                    3971              CLR         D1                  ; clear D1
00003568  2218                    3972              MOVE.L      (A0)+, D1           ; move next long-word to D1
0000356A  4240                    3973              CLR         D0                  ; clear D0
0000356C  103C 0008               3974              MOVE.B      #8, D0              ; move the number of hexes to decode
00003570  4EB9 00003AA2           3975              JSR         outHex              ; jump to outHex 
00003576                          3976  
00003576                          3977  LongSkip
00003576  6000 0002               3978              BRA         endSub              ; go to end of the subroutine
0000357A                          3979  
0000357A                          3980  invalid     
0000357A                          3981  
0000357A                          3982  endSUB        
0000357A  4CDF 7EFF               3983              MOVEM.L     (SP)+, D0-D7/A1-A6  ; pop registers off the stack
0000357E  4E75                    3984              RTS                             ; return
00003580                          3985  
00003580                          3986  ***********************************************************************************************************
00003580                          3987  *
00003580                          3988  *                       MOVEM Helper Function
00003580                          3989  *       This function is dedicated to printing out the address and data register for MOVEM. The 
00003580                          3990  *       function starts by identifying the size and then identifying the dr field. If the dr field
00003580                          3991  *       is 1, then the program goes to print before print out the address and data register for MOVEM. If dr
00003580                          3992  *       field is zero, program goes to print out the address and data register before printing out the
00003580                          3993  *       post increment or immediate data.
00003580                          3994  *
00003580                          3995  ***********************************************************************************************************
00003580                          3996  
00003580                          3997  MOVEMBRA    
00003580  48E7 FF7E               3998              MOVEM.L     D0-D7/A1-A6, -(SP)  ; Branches off depending on size bit
00003584  BA7C 0000               3999              CMP         #zero,D5            ; Checks the size to see if it word
00003588  6700 000E               4000              BEQ         MOVEMW              ; Branches if it is equal to word
0000358C  BA7C 0001               4001              CMP         #one, D5            ; Compares bits to long.
00003590  6700 0022               4002              BEQ         MOVEML              ; Branches if it is equal to long size.
00003594  6000 06D8               4003              BRA         printInvalid        ; Is invalid if it is not equal to either
00003598                          4004              
00003598                          4005  MOVEMW     
00003598  43F9 00003D7A           4006              LEA         dispWord, A1        ; Prints a W to symbolize word
0000359E  103C 000E               4007              MOVE.B      #14, D0             ; command for trap call to display message
000035A2  4E4F                    4008              TRAP        #15                 ; trap call
000035A4                          4009  
000035A4  43F9 00003CDD           4010              LEA         space, A1           ; Print a space
000035AA  103C 000E               4011              MOVE.B      #14, D0             ; command for trap call to display message
000035AE  4E4F                    4012              TRAP        #15                 ; trap call
000035B0                          4013              
000035B0  6000 001E               4014              BRA         CheckDR             ; Branch to CheckDR
000035B4                          4015  
000035B4                          4016  MOVEML   
000035B4  43F9 00003D7D           4017              LEA         dispLong, A1        ; we know that the opcode will be MOVEML, so load A1 to print message
000035BA  103C 000E               4018              MOVE.B      #14, D0             ; command for trap call to display message
000035BE  4E4F                    4019              TRAP        #15                 ; trap call
000035C0                          4020  
000035C0  43F9 00003CDD           4021              LEA         space, A1           ; Print a space
000035C6  103C 000E               4022              MOVE.B      #14, D0             ; command for trap call to display message
000035CA  4E4F                    4023              TRAP        #15                 ; trap call
000035CC                          4024           
000035CC                          4025  
000035CC  6000 0002               4026              BRA         CheckDR             ; Branch to CheckDR
000035D0                          4027  
000035D0                          4028  CheckDR     
000035D0  3218                    4029              MOVE.W      (A0)+, D1           ; Taking in next word
000035D2  BC7C 0000               4030              CMP         #zero,D6            ; Check if dr is 0, then print out data/address first
000035D6  6700 0020               4031              BEQ         printRegMem         ; branch to printRegMem
000035DA  BC7C 0001               4032              CMP         #one,D6             ; dr field is one, must print stack pointer first
000035DE  6700 0004               4033              BEQ         printStack          ; Go to print stack pointer
000035E2  6096                    4034              BRA         invalid             ; Go to invalid if equal to neither
000035E4                          4035              
000035E4                          4036  printStack 
000035E4  4EB8 2F02               4037              JSR         printEA             ; Prints out the stack pointer
000035E8                          4038              
000035E8  43F9 00003CE4           4039              LEA         comma,A1            ; Prints out comma
000035EE  103C 000E               4040              MOVE.B      #14, D0             ; command for trap call to display message
000035F2  4E4F                    4041              TRAP        #15                 ; trap call
000035F4                          4042              
000035F4                          4043              
000035F4  6000 0002               4044              BRA         printRegMem
000035F8                          4045             
000035F8                          4046  printRegMem 
000035F8  4244                    4047              CLR         D4                  ; Using D4 to store predecrement mode addresses
000035FA  1801                    4048              MOVE.B      D1,D4               ; Stores bits for D0-D7
000035FC                          4049              
000035FC  4245                    4050              CLR         D5                  ; Clear data register
000035FE  1A01                    4051              MOVE.B      D1,D5               ; Move bits containing information on filled data to D5
00003600  CA7C 0001               4052              AND         #mask1,D5           ; Use a bit mask to mask every bit except for the first bit
00003604  BA7C 0001               4053              CMP         #mask1,D5           ; Check if certain bit is 1 or 0
00003608  6700 0076               4054              BEQ         DataReg0            ; If comparison matches, then data register that is being put on stack starts her
0000360C                          4055              
0000360C  4245                    4056              CLR         D5                  ; Clear data register
0000360E  1A01                    4057              MOVE.B      D1,D5               ; Move bits containing information on filled data to D5
00003610  CA7C 0002               4058              AND         #mask2,D5           ; Use a bit mask to mask every bit except for the second bit
00003614  BA7C 0002               4059              CMP         #mask2,D5           ; Check if certain bit is 1 or 0
00003618  6700 0096               4060              BEQ         DataReg1            ; If comparison matches, then data register that is being put on stack starts here
0000361C                          4061  
0000361C  4245                    4062              CLR         D5                  ; Clear data register
0000361E  1A01                    4063              MOVE.B      D1,D5               ; Move bits containing information on filled data to D5
00003620  CA7C 0004               4064              AND         #mask3,D5           ; Use a bit mask to mask every bit except for the third bit
00003624  BA7C 0004               4065              CMP         #mask3,D5           ; Check if certain bit is 1 or 0
00003628  6700 00C6               4066              BEQ         DataReg2            ; If comparison matches, then data register that is being put on stack starts her
0000362C                          4067              
0000362C  4245                    4068              CLR         D5                  ; Clear data register
0000362E  1A01                    4069              MOVE.B      D1,D5               ; Move bits containing information on filled data to D5
00003630  CA7C 0008               4070              AND         #mask4,D5           ; Use a bit mask to mask every bit except for the fourth
00003634  BA7C 0008               4071              CMP         #mask4,D5           ; Check if certain bit is 1 or 0
00003638  6700 00F6               4072              BEQ         DataReg3            ; If comparison matches, then data register that is being put on stack starts her
0000363C                          4073              
0000363C  4245                    4074              CLR         D5                  ; Clear data register
0000363E  1A01                    4075              MOVE.B      D1,D5               ; Move bits containing information on filled address/data to D5
00003640  CA7C 0010               4076              AND         #mask5,D5           ; Use a bit mask to mask every bit except for the fifth bit
00003644  BA7C 0010               4077              CMP         #mask5,D5           ; Check if certain bit is 1 or 0
00003648  6700 0126               4078              BEQ         DataReg4            ; If comparison matches, then data register that is being put on stack starts her
0000364C                          4079  
0000364C  4245                    4080              CLR         D5                  ; Clear data register
0000364E  1A01                    4081              MOVE.B      D1,D5               ; Move bits containing information on filled address/data to D5
00003650  CA7C 0020               4082              AND         #mask6,D5           ; Use a bit mask to mask every bit except for the sixth bit
00003654  BA7C 0020               4083              CMP         #mask6,D5           ; Check if certain bit is 1 or 0
00003658  6700 0156               4084              BEQ         DataReg5            ; If comparison matches, then data register that is being put on stack starts her
0000365C                          4085  
0000365C  4245                    4086              CLR         D5                  ; Clear data register
0000365E  1A01                    4087              MOVE.B      D1,D5               ; Move bits containing information on filled address/data to D5
00003660  CA7C 0040               4088              AND         #mask7,D5           ; Use a bit mask to mask every bit except for the seventh
00003664  BA7C 0040               4089              CMP         #mask7,D5           ; Check if certain bit is 1 or 0
00003668  6700 0186               4090              BEQ         DataReg6            ; If comparison matches, then data register that is being put on stack starts her
0000366C                          4091  
0000366C  4245                    4092              CLR         D5                  ; Clear data register
0000366E  1A01                    4093              MOVE.B      D1,D5               ; Move bits containing information on filled address/data to D5
00003670  CA7C 0080               4094              AND         #mask8,D5           ; Use a bit mask to mask every bit except for the seventh
00003674  BA7C 0080               4095              CMP         #mask8,D5           ; Check if certain bit is 1 or 0
00003678  6700 01B6               4096              BEQ         DataReg7            ; If comparison matches, then only D7 is being used
0000367C                          4097              
0000367C  6000 FEFC               4098              BRA         invalid             ; If comaparisons fail then this is not MOVEM. Branch out.
00003680                          4099              
00003680                          4100  DataReg0
00003680  43F9 00003D9A           4101              LEA         dispD0, A1          ; Output string D0
00003686  103C 000E               4102              MOVE.B      #14, D0             ; command for trap call to display message
0000368A  4E4F                    4103              TRAP        #15                 ; trap call
0000368C                          4104              
0000368C  4245                    4105              CLR         D5                  ; Clear data register
0000368E  1A01                    4106              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003690  CA7C 0002               4107              AND         #mask2,D5           ; Uses mask to check for valid after current bit
00003694  BA7C 0002               4108              CMP         #mask2,D5           ; Check if there are anymore data registers used
00003698  6700 0006               4109              BEQ         Reg0Cont            ; Continues to check for last register used if so
0000369C  6000 01A2               4110              BRA         printMem            ; Else it will continue on to print the address/memory
000036A0                          4111              
000036A0                          4112  Reg0Cont        
000036A0  43F9 00003CEA           4113              LEA         dec, A1             ; Output -
000036A6  103C 000E               4114              MOVE.B      #14, D0             ; command for trap call to display message
000036AA  4E4F                    4115              TRAP        #15                 ; trap call        
000036AC  6000 0002               4116              BRA         DataReg1            ; Found starting register move on to find ending register
000036B0                          4117  
000036B0                          4118  DataReg1
000036B0  4245                    4119              CLR         D5                  ; Clear data register
000036B2  1A01                    4120              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000036B4  CA7C 0005               4121              AND         #maskA,D5           ; Uses mask to check for valid bits before and after current bit
000036B8  BA7C 0005               4122              CMP         #maskA,D5           ; Check if there are bits before and after current masked bit
000036BC  6700 0032               4123              BEQ         DataReg2            ; Branch to skip printing until the end register is found
000036C0                          4124              
000036C0  43F9 00003D9D           4125              LEA         dispD1, A1          ; Output string D0
000036C6  103C 000E               4126              MOVE.B      #14, D0             ; command for trap call to display message
000036CA  4E4F                    4127              TRAP        #15                 ; trap call
000036CC                          4128              
000036CC  4245                    4129              CLR         D5                  ; Clear data register
000036CE  1A01                    4130              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000036D0  CA7C 0004               4131              AND         #mask3,D5           ; Bitmasking to check if next bit is used or not
000036D4  BA7C 0004               4132              CMP         #mask3,D5           ; Checking if next bit is use
000036D8  6700 0006               4133              BEQ         Reg1Cont            ; Continues to check for last register used if so
000036DC  6000 0162               4134              BRA         printMem            ; Else it will continue on to print the address/memory
000036E0                          4135              
000036E0                          4136  Reg1Cont        
000036E0  43F9 00003CEA           4137              LEA         dec, A1             ; Output -
000036E6  103C 000E               4138              MOVE.B      #14, D0             ; command for trap call to display message
000036EA  4E4F                    4139              TRAP        #15                 ; trap call        
000036EC  6000 0002               4140              BRA         DataReg2            ; Found starting register move on to find ending registe
000036F0                          4141  
000036F0                          4142  DataReg2
000036F0  4245                    4143              CLR         D5                  ; Clear data register
000036F2  1A01                    4144              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000036F4  CA7C 000A               4145              AND         #maskB,D5           ; Uses mask to check for valid bits before and after current bit
000036F8  BA7C 000A               4146              CMP         #maskB,D5           ; Check if there are bits before and after current masked bit
000036FC  6700 0032               4147              BEQ         DataReg3            ; If there are bits before and after, skip to next register to find ending
00003700                          4148              
00003700                          4149              
00003700  43F9 00003DA0           4150              LEA         dispD2, A1          ; Output D2
00003706  103C 000E               4151              MOVE.B      #14, D0             ; command for trap call to display message
0000370A  4E4F                    4152              TRAP        #15                 ; trap call
0000370C                          4153              
0000370C  4245                    4154              CLR         D5                  ; Clear data register
0000370E  1A01                    4155              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003710  CA7C 0008               4156              AND         #mask4,D5           ; Bitmasking to check if next bit is used or not
00003714  BA7C 0008               4157              CMP         #mask4,D5           ; Checking if next bit is used
00003718  6700 0006               4158              BEQ         Reg2Cont            ; Continues to check for last register used if so
0000371C  6000 0122               4159              BRA         printMem            ; Else it will continue on to print the address/memory
00003720                          4160              
00003720                          4161  Reg2Cont        
00003720  43F9 00003CEA           4162              LEA         dec, A1             ; Output -
00003726  103C 000E               4163              MOVE.B      #14, D0             ; command for trap call to display message
0000372A  4E4F                    4164              TRAP        #15                 ; trap call        
0000372C  6000 0002               4165              BRA         DataReg3            ; Found starting register move on to find ending registe
00003730                          4166  
00003730                          4167  DataReg3
00003730  4245                    4168              CLR         D5                  ; Clear data register
00003732  1A01                    4169              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003734  CA7C 0014               4170              AND         #maskC,D5           ; Uses mask to check for valid bits before and after current bit
00003738  BA7C 0014               4171              CMP         #maskC,D5           ; Check if there are bits before and after current masked bit
0000373C  6700 0032               4172              BEQ         DataReg4            ; If there are bits before and after, skip to next register to find ending
00003740                          4173      
00003740                          4174              
00003740  43F9 00003DA3           4175              LEA         dispD3, A1          ; Output string D0
00003746  103C 000E               4176              MOVE.B      #14, D0             ; command for trap call to display message
0000374A  4E4F                    4177              TRAP        #15                 ; trap call
0000374C                          4178              
0000374C  4245                    4179              CLR         D5                  ; Clear data register
0000374E  1A01                    4180              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003750  CA7C 0010               4181              AND         #mask5,D5           ; Bitmasking to check if next bit is used or not
00003754  BA7C 0010               4182              CMP         #mask5,D5
00003758  6700 0006               4183              BEQ         Reg3Cont            ; Continues to check for last register used if so
0000375C  6000 00E2               4184              BRA         printMem            ; Else it will continue on to print the address/memory
00003760                          4185              
00003760                          4186  Reg3Cont        
00003760  43F9 00003CEA           4187              LEA         dec, A1             ; Output -
00003766  103C 000E               4188              MOVE.B      #14, D0             ; command for trap call to display message
0000376A  4E4F                    4189              TRAP        #15                 ; trap call        
0000376C  6000 0002               4190              BRA         DataReg4            ; Found starting register move on to find ending registe
00003770                          4191  
00003770                          4192  DataReg4
00003770  4245                    4193              CLR         D5                  ; Clear data register
00003772  1A01                    4194              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003774  CA7C 0028               4195              AND         #maskD,D5           ; Uses mask to check for valid bits before and after current bit
00003778  BA7C 0028               4196              CMP         #maskD,D5           ; Check if there are bits before and after current masked bit
0000377C  6700 0032               4197              BEQ         DataReg5            ; If there are bits before and after, skip to next register to find ending
00003780                          4198              
00003780  43F9 00003DA6           4199              LEA         dispD4, A1          ; Output string D0
00003786  103C 000E               4200              MOVE.B      #14, D0             ; command for trap call to display message
0000378A  4E4F                    4201              TRAP        #15                 ; trap call
0000378C                          4202              
0000378C  4245                    4203              CLR         D5                  ; Clear data register
0000378E  1A01                    4204              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003790  CA7C 0020               4205              AND         #mask6,D5           ; Bitmasking to check if next bit is used or not
00003794  BA7C 0020               4206              CMP         #mask6,D5           ; Checking if next bit is use
00003798  6700 0006               4207              BEQ         Reg4Cont            ; Continues to check for last register used if so
0000379C  6000 00A2               4208              BRA         printMem            ; Else it will continue on to print the address/memory
000037A0                          4209              
000037A0                          4210  Reg4Cont        
000037A0  43F9 00003CEA           4211              LEA         dec, A1             ; Output -
000037A6  103C 000E               4212              MOVE.B      #14, D0             ; command for trap call to display message
000037AA  4E4F                    4213              TRAP        #15                 ; trap call        
000037AC  6000 0002               4214              BRA         DataReg5            ; Found starting register move on to find ending registe
000037B0                          4215  
000037B0                          4216  DataReg5
000037B0  4245                    4217              CLR         D5                  ; Clear data register
000037B2  1A01                    4218              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000037B4  CA7C 0050               4219              AND         #maskE,D5           ; Uses mask to check for valid bits before and after current bit
000037B8  BA7C 0050               4220              CMP         #maskE,D5           ; Check if there are bits before and after current masked bit
000037BC  6700 0032               4221              BEQ         DataReg6            ; If there are bits before and after, skip to next register to find ending
000037C0                          4222              
000037C0  43F9 00003DA9           4223              LEA         dispD5, A1          ; Output string D0
000037C6  103C 000E               4224              MOVE.B      #14, D0             ; command for trap call to display message
000037CA  4E4F                    4225              TRAP        #15                 ; trap call
000037CC                          4226              
000037CC  4245                    4227              CLR         D5                  ; Clear data register
000037CE  1A01                    4228              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000037D0  CA7C 0040               4229              AND         #mask7,D5           ; Bitmasking to check if next bit is used or not
000037D4  BA7C 0040               4230              CMP         #mask7,D5           ; Checking if next bit is use
000037D8  6700 0006               4231              BEQ         Reg5Cont            ; Continues to check for last register used if so
000037DC  6000 0062               4232              BRA         printMem            ; Else it will continue on to print the address/memory
000037E0                          4233              
000037E0                          4234  Reg5Cont        
000037E0  43F9 00003CEA           4235              LEA         dec, A1             ; Output -
000037E6  103C 000E               4236              MOVE.B      #14, D0             ; command for trap call to display message
000037EA  4E4F                    4237              TRAP        #15                 ; trap call        
000037EC  6000 0042               4238              BRA         DataReg7            ; Found starting register move on to find ending registe
000037F0                          4239  
000037F0                          4240  DataReg6
000037F0  4245                    4241              CLR         D5                  ; Clear data register
000037F2  1A01                    4242              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000037F4  CA7C 00A0               4243              AND         #maskF,D5           ; Uses mask to check for valid bits before and after current bit
000037F8  BA7C 00A0               4244              CMP         #maskF,D5           ; Check if there are bits before and after current masked bit
000037FC  6700 0032               4245              BEQ         DataReg7            ; If there are bits before and after, skip to next register to find ending
00003800                          4246  
00003800  43F9 00003DAC           4247              LEA         dispD6, A1          ; Output string D0
00003806  103C 000E               4248              MOVE.B      #14, D0             ; command for trap call to display message
0000380A  4E4F                    4249              TRAP        #15                 ; trap call
0000380C                          4250              
0000380C  4245                    4251              CLR         D5                  ; Clear data register
0000380E  1A01                    4252              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
00003810  CA7C 0080               4253              AND         #mask8,D5           ; Bitmasking to check if next bit is used or not
00003814  BA7C 0080               4254              CMP         #mask8,D5           ; Checking if next bit is use
00003818  6700 0006               4255              BEQ         Reg6Cont            ; Continues to check for last register used if so
0000381C  6000 0022               4256              BRA         printMem            ; Else it will continue on to print the address/memory
00003820                          4257              
00003820                          4258  Reg6Cont        
00003820  43F9 00003CEA           4259              LEA         dec, A1             ; Output -
00003826  103C 000E               4260              MOVE.B      #14, D0             ; command for trap call to display message
0000382A  4E4F                    4261              TRAP        #15                 ; trap call        
0000382C  6000 0002               4262              BRA         DataReg7            ; Found starting register move on to find ending registe
00003830                          4263  
00003830                          4264  DataReg7    
00003830  43F9 00003DAF           4265              LEA         dispD7, A1          ; Output -
00003836  103C 000E               4266              MOVE.B      #14, D0             ; command for trap call to display message
0000383A  4E4F                    4267              TRAP        #15                 ; trap call        
0000383C  6000 0002               4268              BRA         printMem            ; Last check, branch to print out the address register     
00003840                          4269              
00003840                          4270  printMem                                    ; Made this function in order to reuse if DR is 1
00003840  6000 0002               4271              BRA         printMemNow         ; Branch out to printMemNow
00003844                          4272              
00003844                          4273  printMemNow                           
00003844  43F9 00003D70           4274              LEA         slash, A1           ; Display slash
0000384A  103C 000E               4275              MOVE.B      #14, D0             ; command for trap call to display message
0000384E  4E4F                    4276              TRAP        #15                 ; trap call
00003850                          4277           
00003850  4244                    4278              CLR         D4                  ; Using D4 to store predecrement mode addresses
00003852  3801                    4279              MOVE.W      D1,D4               ; Stores bits for D0-D7
00003854  E044                    4280              ASR         #eight,D4           ; Rotate to the right, to create space for next byte
00003856                          4281              
00003856  4245                    4282              CLR         D5                  ; Clear space
00003858  1A04                    4283              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
0000385A  CA7C 0001               4284              AND         #mask1,D5           ; Use a bit mask to mask every bit except for the first bit
0000385E  BA7C 0001               4285              CMP         #mask1,D5           ; Check if certain bit is 1 or 0
00003862  6700 0072               4286              BEQ         AddrReg0            ; If comparison matches, then address register that is being put on stack starts here
00003866                          4287              
00003866  4245                    4288              CLR         D5                  ; Clear data register 
00003868  1A04                    4289              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
0000386A  CA7C 0002               4290              AND         #mask2,D5           ; Use a bit mask to mask every bit except for the second bit
0000386E  BA7C 0002               4291              CMP         #mask2,D5           ; Check if certain bit is 1 or 0
00003872  6700 0092               4292              BEQ         AddrReg1            ; If comparison matches, then address register that is being put on stack starts here
00003876                          4293  
00003876  4245                    4294              CLR         D5                  ; Clear data register
00003878  1A04                    4295              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
0000387A  CA7C 0004               4296              AND         #mask3,D5           ; Use a bit mask to mask every bit except for the third
0000387E  BA7C 0004               4297              CMP         #mask3,D5           ; Check if certain bit is 1 or 0
00003882  6700 00C2               4298              BEQ         AddrReg2            ; If comparison matches, then address register that is being put on stack starts here         
00003886                          4299              
00003886  4245                    4300              CLR         D5                  ; Clear data register
00003888  1A04                    4301              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
0000388A  CA7C 0008               4302              AND         #mask4,D5           ; Use a bit mask to mask every bit except for the fourth bit
0000388E  BA7C 0008               4303              CMP         #mask4,D5           ; Check if certain bit is 1 or 0
00003892  6700 00F2               4304              BEQ         AddrReg3            ; If comparison matches, then address register that is being put on stack starts here     
00003896                          4305                  
00003896  4245                    4306              CLR         D5                  ; Clear data register
00003898  1A04                    4307              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
0000389A  CA7C 0010               4308              AND         #mask5,D5           ; Use a bit mask to mask every bit except for the fifth bit
0000389E  BA7C 0010               4309              CMP         #mask5,D5           ; Check if certain bit is 1 or 0
000038A2  6700 0122               4310              BEQ         AddrReg4            ; If comparison matches, then address register that is being put on stack starts here
000038A6                          4311  
000038A6  4245                    4312              CLR         D5                  ; Clear data register
000038A8  1A04                    4313              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
000038AA  CA7C 0020               4314              AND         #mask6,D5           ; Use a bit mask to mask every bit except for the sixth bit
000038AE  BA7C 0020               4315              CMP         #mask6,D5           ; Check if certain bit is 1 or 0
000038B2  6700 0152               4316              BEQ         AddrReg5            ; If comparison matches, then address register that is being put on stack starts here
000038B6                          4317  
000038B6  4245                    4318              CLR         D5                  ; Clear data register
000038B8  1A04                    4319              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
000038BA  CA7C 0040               4320              AND         #mask7,D5           ; Use a bit mask to mask every bit except for the seventh bit
000038BE  BA7C 0040               4321              CMP         #mask7,D5           ; Check if certain bit is 1 or 0
000038C2  6700 0182               4322              BEQ         AddrReg6            ; If comparison matches, then address register that is being put on stack starts here
000038C6                          4323  
000038C6  4245                    4324              CLR         D5                  ; Clear data register
000038C8  1A04                    4325              MOVE.B      D4,D5               ; Move bits containing information on used data register to D5
000038CA  CA7C 0080               4326              AND         #mask8,D5           ; Use a bit mask to mask every bit except for the last bit
000038CE  BA7C 0080               4327              CMP         #mask8,D5           ; Check if certain bit is 1 or 0
000038D2  6700 01B2               4328              BEQ         AddrReg7            ; If comparison matches, then address register that is being put on stack starts here
000038D6                          4329              
000038D6                          4330  AddrReg0
000038D6                          4331  
000038D6  43F9 00003D80           4332              LEA         dispA0, A1          ; Output string D0
000038DC  103C 000E               4333              MOVE.B      #14, D0             ; command for trap call to display message
000038E0  4E4F                    4334              TRAP        #15                 ; trap call
000038E2                          4335              
000038E2  4245                    4336              CLR         D5                  ; Clear data register
000038E4  1A01                    4337              MOVE.B      D1,D5               ; Move byte to D5 for comparisons
000038E6  CA7C 0002               4338              AND         #mask2,D5           ; Bitmasking to check if next bit is used or not
000038EA  BA7C 0002               4339              CMP         #mask2,D5           ; Checking if next bit is use
000038EE  6700 0006               4340              BEQ         Addr0Cont           ; Continues to check for last register used if so
000038F2  6000 01A2               4341              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
000038F6                          4342              
000038F6                          4343  Addr0Cont        
000038F6  43F9 00003CEA           4344              LEA         dec, A1             ; Output -
000038FC  103C 000E               4345              MOVE.B      #14, D0             ; command for trap call to display message
00003900  4E4F                    4346              TRAP        #15                 ; trap call        
00003902  6000 0002               4347              BRA         AddrReg1            ; Branch to second address
00003906                          4348  
00003906                          4349  AddrReg1
00003906  4245                    4350              CLR         D5                  ; Clear data register
00003908  1A04                    4351              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
0000390A  CA7C 0005               4352              AND         #maskA,D5           ; Uses mask to check for valid bits before and after current bit
0000390E  BA7C 0005               4353              CMP         #maskA,D5           ; Check if there are bits before and after current masked bit
00003912  6700 0032               4354              BEQ         AddrReg2            ; Skip print and move to next address to check if it the last address used
00003916                          4355              
00003916  43F9 00003D83           4356              LEA         dispA1, A1          ; Output string D0
0000391C  103C 000E               4357              MOVE.B      #14, D0             ; command for trap call to display message
00003920  4E4F                    4358              TRAP        #15                 ; trap call
00003922                          4359              
00003922  4245                    4360              CLR         D5                  ; Clear data register
00003924  1A04                    4361              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003926  CA7C 0004               4362              AND         #mask3,D5           ; Bitmasking to check if next bit is used or not
0000392A  BA7C 0004               4363              CMP         #mask3,D5           ; Checking if next bit is use
0000392E  6700 0006               4364              BEQ         Addr1Cont           ; Continues to check for last register used if so
00003932  6000 0162               4365              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
00003936                          4366              
00003936                          4367  Addr1Cont        
00003936  43F9 00003CEA           4368              LEA         dec, A1             ; Output -
0000393C  103C 000E               4369              MOVE.B      #14, D0             ; command for trap call to display message
00003940  4E4F                    4370              TRAP        #15                 ; trap call        
00003942  6000 0002               4371              BRA         AddrReg2            ; Skip print and move to next address to check if it the last address used    
00003946                          4372  
00003946                          4373  AddrReg2
00003946  4245                    4374              CLR         D5                  ; Clear data register
00003948  1A04                    4375              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
0000394A  CA7C 000A               4376              AND         #maskB,D5           ; Uses mask to check for valid bits before and after current bit
0000394E  BA7C 000A               4377              CMP         #maskB,D5           ; Check if there are bits before and after current masked bit
00003952  6700 0032               4378              BEQ         AddrReg3            ; If there are bits before and after, skip to next register to find ending
00003956                          4379  
00003956                          4380              
00003956  43F9 00003D86           4381              LEA         dispA2, A1          ; Output string D0
0000395C  103C 000E               4382              MOVE.B      #14, D0             ; command for trap call to display message
00003960  4E4F                    4383              TRAP        #15                 ; trap call
00003962                          4384              
00003962  4245                    4385              CLR         D5                  ; Clear data register
00003964  1A04                    4386              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003966  CA7C 0008               4387              AND         #mask4,D5           ; Bitmasking to check if next bit is used or not
0000396A  BA7C 0008               4388              CMP         #mask4,D5           ; Checking if next bit is use
0000396E  6700 0006               4389              BEQ         Addr2Cont           ; Continues to check for last register used if so
00003972  6000 0122               4390              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
00003976                          4391              
00003976                          4392  Addr2Cont        
00003976  43F9 00003CEA           4393              LEA         dec, A1             ; Output -
0000397C  103C 000E               4394              MOVE.B      #14, D0             ; command for trap call to display message
00003980  4E4F                    4395              TRAP        #15                 ; trap call        
00003982  6000 0002               4396              BRA         AddrReg3            ; Skip print and move to next address to check if it the last address used
00003986                          4397  
00003986                          4398  AddrReg3
00003986  4245                    4399              CLR         D5                  ; Clear data register
00003988  1A04                    4400              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
0000398A  CA7C 0014               4401              AND         #maskC,D5           ; Uses mask to check for valid bits before and after current bit
0000398E  BA7C 0014               4402              CMP         #maskC,D5           ; Check if there are bits before and after current masked bit
00003992  6700 0032               4403              BEQ         AddrReg4            ; If there are bits before and after, skip to next register to find ending
00003996                          4404              
00003996  43F9 00003D89           4405              LEA         dispA3, A1          ; Output string D0
0000399C  103C 000E               4406              MOVE.B      #14, D0             ; command for trap call to display message
000039A0  4E4F                    4407              TRAP        #15                 ; trap call
000039A2                          4408              
000039A2  4245                    4409              CLR         D5                  ; Clear data register
000039A4  1A04                    4410              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
000039A6  CA7C 0010               4411              AND         #mask5,D5           ; Bitmasking to check if next bit is used or not  
000039AA  BA7C 0010               4412              CMP         #mask5,D5           ; Checking if next bit is use
000039AE  6700 0006               4413              BEQ         Addr3Cont           ; Continues to check for last register used if so
000039B2  6000 00E2               4414              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
000039B6                          4415              
000039B6                          4416  Addr3Cont        
000039B6  43F9 00003CEA           4417              LEA         dec, A1             ; Output -
000039BC  103C 000E               4418              MOVE.B      #14, D0             ; command for trap call to display message
000039C0  4E4F                    4419              TRAP        #15                 ; trap call        
000039C2  6000 0002               4420              BRA         AddrReg4
000039C6                          4421  
000039C6                          4422  AddrReg4
000039C6  4245                    4423              CLR         D5                  ; Clear data register
000039C8  1A04                    4424              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
000039CA  CA7C 0028               4425              AND         #maskD,D5           ; Uses mask to check for valid bits before and after current bit
000039CE  BA7C 0028               4426              CMP         #maskD,D5           ; Check if there are bits before and after current masked bit
000039D2  6700 0032               4427              BEQ         AddrReg5            ; If there are bits before and after, skip to next register to find ending
000039D6                          4428              
000039D6  43F9 00003D8C           4429              LEA         dispA4, A1          ; Output string D0
000039DC  103C 000E               4430              MOVE.B      #14, D0             ; command for trap call to display message
000039E0  4E4F                    4431              TRAP        #15                 ; trap call
000039E2                          4432              
000039E2  4245                    4433              CLR         D5                  ; Clear data register
000039E4  1A04                    4434              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
000039E6  CA7C 0020               4435              AND         #mask6,D5           ; Bitmasking to check if next bit is used or not 
000039EA  BA7C 0020               4436              CMP         #mask6,D5           ; Checking if next bit is use
000039EE  6700 0006               4437              BEQ         Addr4Cont           ; Continues to check for last register used if so
000039F2  6000 00A2               4438              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
000039F6                          4439              
000039F6                          4440  Addr4Cont        
000039F6  43F9 00003CEA           4441              LEA         dec, A1             ; Output -
000039FC  103C 000E               4442              MOVE.B      #14, D0             ; command for trap call to display message
00003A00  4E4F                    4443              TRAP        #15                 ; trap call        
00003A02  6000 0002               4444              BRA         AddrReg5
00003A06                          4445  AddrReg5
00003A06  4245                    4446              CLR         D5                  ; Clear data register
00003A08  1A04                    4447              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003A0A  CA7C 0050               4448              AND         #maskE,D5           ; Uses mask to check for valid bits before and after current bit
00003A0E  BA7C 0050               4449              CMP         #maskE,D5           ; Check if there are bits before and after current masked bit
00003A12  6700 0032               4450              BEQ         AddrReg6            ; If there are bits before and after, skip to next register to find ending
00003A16                          4451              
00003A16  43F9 00003D8F           4452              LEA         dispA5, A1          ; Output string D0
00003A1C  103C 000E               4453              MOVE.B      #14, D0             ; command for trap call to display message
00003A20  4E4F                    4454              TRAP        #15                 ; trap call
00003A22                          4455              
00003A22  4245                    4456              CLR         D5                  ; Clear data register
00003A24  1A04                    4457              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003A26  CA7C 0040               4458              AND         #mask7,D5           ; Bitmasking to check if next bit is used or not
00003A2A  BA7C 0040               4459              CMP         #mask7,D5           ; Checking if next bit is use
00003A2E  6700 0006               4460              BEQ         Addr5Cont           ; Continues to check for last register used if so
00003A32  6000 0062               4461              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
00003A36                          4462              
00003A36                          4463  Addr5Cont        
00003A36  43F9 00003CEA           4464              LEA         dec, A1             ; Output -
00003A3C  103C 000E               4465              MOVE.B      #14, D0             ; command for trap call to display message
00003A40  4E4F                    4466              TRAP        #15                 ; trap call        
00003A42  6000 0042               4467              BRA         AddrReg7
00003A46                          4468  
00003A46                          4469  AddrReg6
00003A46  4245                    4470              CLR         D5                  ; Clear data register
00003A48  1A04                    4471              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003A4A  CA7C 00A0               4472              AND         #maskF,D5           ; Uses mask to check for valid bits before and after current bit
00003A4E  BA7C 00A0               4473              CMP         #maskF,D5           ; Check if there are bits before and after current masked bit
00003A52  6700 0032               4474              BEQ         AddrReg7            ; If there are bits before and after, skip to next register to find ending
00003A56                          4475  
00003A56  43F9 00003D92           4476              LEA         dispA6, A1          ; Output string D0
00003A5C  103C 000E               4477              MOVE.B      #14, D0             ; command for trap call to display message
00003A60  4E4F                    4478              TRAP        #15                 ; trap call
00003A62                          4479              
00003A62  4245                    4480              CLR         D5                  ; Clear data register
00003A64  1A04                    4481              MOVE.B      D4,D5               ; Move byte to D5 for comparisons
00003A66  CA7C 0080               4482              AND         #mask8,D5           ; Bitmasking to check if next bit is used or not
00003A6A  BA7C 0080               4483              CMP         #mask8,D5           ; Checking if next bit is use
00003A6E  6700 0006               4484              BEQ         Addr6Cont           ; Continues to check for last register used if so
00003A72  6000 0022               4485              BRA         endMOVE             ; Last register has been found. Branch to subroutine to RTS
00003A76                          4486              
00003A76                          4487  Addr6Cont        
00003A76  43F9 00003CEA           4488              LEA         dec, A1             ; Output -
00003A7C  103C 000E               4489              MOVE.B      #14, D0             ; command for trap call to display message
00003A80  4E4F                    4490              TRAP        #15                 ; trap call        
00003A82  6000 0002               4491              BRA         AddrReg7            ; Skip print and move to next address to check if it the last address used
00003A86                          4492  
00003A86                          4493  AddrReg7    
00003A86  43F9 00003D95           4494              LEA         dispA7, A1          ; Output -
00003A8C  103C 000E               4495              MOVE.B      #14, D0             ; command for trap call to display message
00003A90  4E4F                    4496              TRAP        #15                 ; trap call        
00003A92  6000 0002               4497              BRA         endMOVE             ; Skip print and move to next address to check if it the last address used
00003A96                          4498          
00003A96                          4499  endMOVE
00003A96  4CDF 7EFF               4500              MOVEM.L  (SP)+, D0-D7/A1-A6     ; Pops all data and address register off the stack
00003A9A  4E75                    4501              RTS
00003A9C                          4502  endMove1                                    ; Used if MOVEM has DR is 1
00003A9C  4CDF 7EFF               4503              MOVEM.L  (SP)+, D0-D7/A1-A6
00003AA0  4E75                    4504              RTS
00003AA2                          4505  ***********************************************************************************************************
00003AA2                          4506  *
00003AA2                          4507  *                       Hex Decode
00003AA2                          4508  *
00003AA2                          4509  *this subroutine displays hex code stored in D1. It displays based on the number of 
00003AA2                          4510  *It displays based on the number of hex to display which is stored in D0. If it is a
00003AA2                          4511  *long or word to display, it will figure out the ascii character and add $37 if it
00003AA2                          4512  *is a letter, and $30 if its a number. It will then load the character into D1 and 
00003AA2                          4513  *display it via trap task 6 and loop however many times is needed, 4 or 8. If a word
00003AA2                          4514  *needs to be displayed, it will roll the bits over so that, the hex are shifted by a word.
00003AA2                          4515  *
00003AA2                          4516  ***********************************************************************************************************
00003AA2                          4517  
00003AA2                          4518  outHex      
00003AA2  48E7 FF7E               4519              MOVEM.L     D0-D7/A1-A6, -(SP)  ; callee saved data
00003AA6  4243                    4520              CLR         D3                  ; clear D3  
00003AA8  4244                    4521              CLR         D4                  ; clear D2
00003AAA  1800                    4522              MOVE.B      D0, D4              ; copy number of hexes to decode from D0 to D4
00003AAC  2601                    4523              MOVE.L      D1, D3              ; copy data to be converted to display from D1 to D3 
00003AAE  B03C 0004               4524              CMP.B       #4, D0              ; compare 4 to D0 for number of hexes to decode
00003AB2  6700 0006               4525              BEQ         moveOver            ; if true, branch to moveOver
00003AB6  6000 0006               4526              BRA         dispLOOP            ; otherwise branch to dispLOOP
00003ABA                          4527              
00003ABA                          4528  moveOver    
00003ABA  E19B                    4529              ROL.L       #8,D3               ; roll over bits in D3 by 8
00003ABC  E19B                    4530              ROL.L       #8,D3               ; repeat again to get word at the end of D3
00003ABE                          4531              
00003ABE                          4532  dispLOOP    
00003ABE  B83C 0000               4533              CMP.B       #0, D4              ; compare 0 to counter or D4
00003AC2  6700 0042               4534              BEQ         endDispSub          ; it true, branch to endDispSub
00003AC6  E99B                    4535              ROL.L       #4, D3              ; roll 4 bits to get Hex
00003AC8  4245                    4536              CLR         D5                  ; clear D5
00003ACA  1A03                    4537              MOVE.B      D3, D5              ; move the byte from D3 to D5
00003ACC  CABC 0000000F           4538              AND.L       #$0F, D5            ; and D5 by F to get just one nibble
00003AD2  BA3C 000A               4539              CMP.B       #10, D5             ; compare 10 by D5
00003AD6  6D00 0006               4540              BLT         DLnine              ; if less than, branch to print numbers
00003ADA  6000 0016               4541              BRA         DLetters            ; otherwise branch to print letters
00003ADE                          4542              
00003ADE                          4543  DLnine      
00003ADE  0645 0030               4544              ADD         #$30, D5            ; add 30 to D5 to get ascii character
00003AE2  4241                    4545              CLR         D1                  ; clear D1
00003AE4  1205                    4546              MOVE.B      D5, D1              ; copy D5 to D1
00003AE6  4240                    4547              CLR         D0                  ; clear D0
00003AE8  103C 0006               4548              MOVE.B      #6, D0              ; move trap task 6 to D0 to print single character
00003AEC  4E4F                    4549              TRAP        #15                 ; trap call
00003AEE  5344                    4550              SUB         #1, D4              ; decrement counter
00003AF0  60CC                    4551              BRA         dispLOOP            ; branch back to dispLOOP
00003AF2                          4552   
00003AF2                          4553  DLetters    
00003AF2  0645 0037               4554              ADD         #$37, D5            ; add 37 to D5 to get ascii character
00003AF6  4241                    4555              CLR         D1                  ; clear D1
00003AF8  1205                    4556              MOVE.B      D5, D1              ; copy D5 to D1
00003AFA  4240                    4557              CLR         D0                  ; clear D0
00003AFC  103C 0006               4558              MOVE.B      #6, D0              ; move trap task 6 to D0 to print single character
00003B00  4E4F                    4559              TRAP        #15                 ; trap call
00003B02  5344                    4560              SUB         #1, D4              ; decrement counter
00003B04  60B8                    4561              BRA         dispLOOP            ; branch back to dispLOOP       
00003B06                          4562  
00003B06                          4563  endDispSub  
00003B06  4CDF 7EFF               4564              MOVEM.L     (SP)+, D0-D7/A1-A6  ; pop registers from stack
00003B0A  4E75                    4565              RTS                             ; return
00003B0C                          4566  
00003B0C                          4567              
00003B0C                          4568  ***********************************************************************************************************
00003B0C                          4569  *
00003B0C                          4570  *                       IO Subroutine
00003B0C                          4571  *
00003B0C                          4572  *
00003B0C                          4573  *   the following subroutine gets the string address from the user
00003B0C                          4574  *   and converts it to Hex for a starting/ending address. it is done 
00003B0C                          4575  *   by checking each byte at address A1, and converting it from ascii to 
00003B0C                          4576  *   hex number. If the user enters an invalid character string, the
00003B0C                          4577  *   program will have a simhalt.
00003B0C                          4578  *
00003B0C                          4579  ***********************************************************************************************************
00003B0C                          4580  
00003B0C                          4581  Address     
00003B0C  48E7 1F3E               4582              MOVEM.L     D3-D7/A2-A6, -(SP)  ; callee saved data
00003B10                          4583  
00003B10                          4584  Retry       
00003B10  4242                    4585              CLR         D2                  ; clear D2
00003B12  4243                    4586              CLR         D3                  ; clear D3
00003B14  B23C 0004               4587              CMP.B       #4, D1              ; compare 4 to D1 or number of ascii inputs to decode
00003B18  6700 000E               4588              BEQ         subLOOP             ; if true, branch to subLOOP
00003B1C  B23C 0008               4589              CMP.B       #8, D1              ; compare 8 to D1 or number of ascii inputs to decode
00003B20  6700 0006               4590              BEQ         subLOOP             ; if true, branch to subLOOP
00003B24  6000 012A               4591              BRA         ADDinvalid          ; otherwise invalid
00003B28                          4592          
00003B28                          4593  subLOOP     
00003B28  E85C                    4594              ROR         #4, D4              ; rotate D4 by 4 bits
00003B2A  1404                    4595              MOVE.B      D4, D2              ; move byte from D4 to D2
00003B2C  4244                    4596              CLR         D4                  ; clear D4
00003B2E  4245                    4597              CLR         D5                  ; clear D5
00003B30  B601                    4598              CMP.B       D1, D3              ; compare counter D3 to total count D1
00003B32  6700 0134               4599              BEQ         endLOOP             ; if equal branch to endLOOP
00003B36  5443                    4600              ADD.W       #2, D3              ; add 2 to D3
00003B38  E19A                    4601              ROL.L       #8, D2              ; rotate D2 by 8 bits
00003B3A                          4602          
00003B3A                          4603  bytLOOP     
00003B3A  E95C                    4604              ROL         #4, D4              ; rotate D4 by 4 bits 
00003B3C                          4605          
00003B3C  0C11 0030               4606              CMP.B       #$30, (A1)          ; compare hex value 30 to A1's location
00003B40  6700 007E               4607              BEQ         hZero               ; if true, branch to hZero
00003B44  0C11 0031               4608              CMP.B       #$31, (A1)          ; compare hex value 31 to A1's location
00003B48  6700 007E               4609              BEQ         hOne                ; if true, branch to hOne
00003B4C  0C11 0032               4610              CMP.B       #$32, (A1)          ; compare hex value 32 to A1's location
00003B50  6700 007E               4611              BEQ         hTwo                ; if true, branch to hTwo
00003B54  0C11 0033               4612              CMP.B       #$33, (A1)          ; compare hex value 33 to A1's location
00003B58  6700 007E               4613              BEQ         hThree              ; if true, branch to hThree
00003B5C  0C11 0034               4614              CMP.B       #$34, (A1)          ; compare hex value 34 to A1's location
00003B60  6700 007E               4615              BEQ         hFour               ; if true, branch to hFour
00003B64  0C11 0035               4616              CMP.B       #$35, (A1)          ; compare hex value 35 to A1's location
00003B68  6700 007E               4617              BEQ         hFive               ; if true, branch to hFive
00003B6C  0C11 0036               4618              CMP.B       #$36, (A1)          ; compare hex value 36 to A1's location
00003B70  6700 007E               4619              BEQ         hSix                ; if true, branch to hSix
00003B74  0C11 0037               4620              CMP.B       #$37, (A1)          ; compare hex value 37 to A1's location
00003B78  6700 007E               4621              BEQ         hSeven              ; if true, branch to hSeven
00003B7C  0C11 0038               4622              CMP.B       #$38, (A1)          ; compare hex value 38 to A1's location
00003B80  6700 007E               4623              BEQ         hEight              ; if true, branch to hEight
00003B84  0C11 0039               4624              CMP.B       #$39, (A1)          ; compare hex value 39 to A1's location
00003B88  6700 007E               4625              BEQ         hNine               ; if true, branch to hNine
00003B8C  0C11 0041               4626              CMP.B       #$41, (A1)          ; compare hex value 41 to A1's location
00003B90  6700 007E               4627              BEQ         hA                  ; if true, branch to hA
00003B94  0C11 0042               4628              CMP.B       #$42, (A1)          ; compare hex value 42 to A1's location
00003B98  6700 007E               4629              BEQ         hB                  ; if true, branch to hB
00003B9C  0C11 0043               4630              CMP.B       #$43, (A1)          ; compare hex value 43 to A1's location
00003BA0  6700 007E               4631              BEQ         hC                  ; if true, branch to hC
00003BA4  0C11 0044               4632              CMP.B       #$44, (A1)          ; compare hex value 44 to A1's location
00003BA8  6700 007E               4633              BEQ         hD                  ; if true, branch to hD
00003BAC  0C11 0045               4634              CMP.B       #$45, (A1)          ; compare hex value 45 to A1's location
00003BB0  6700 007E               4635              BEQ         hE                  ; if true, branch to hE
00003BB4  0C11 0046               4636              CMP.B       #$46, (A1)          ; compare hex value 46 to A1's location
00003BB8  6700 007E               4637              BEQ         hF                  ; if true, branch to hF
00003BBC  6000 0092               4638              BRA         ADDinvalid          ; otherwise invalid
00003BC0                          4639              
00003BC0                          4640  hZero       
00003BC0  183C 0000               4641              MOVE.B      #$00, D4            ; move byte 00 to D4
00003BC4  6000 007A               4642              BRA         nextH               ; branch to next hex
00003BC8                          4643              
00003BC8                          4644  hOne        
00003BC8  183C 0010               4645              MOVE.B      #$10, D4            ; move byte 10 to D4
00003BCC  6000 0072               4646              BRA         nextH               ; branch to next hex
00003BD0                          4647  hTwo        
00003BD0  183C 0020               4648              MOVE.B      #$20, D4            ; move byte 20 to D4
00003BD4  6000 006A               4649              BRA         nextH               ; branch to next hex
00003BD8                          4650              
00003BD8                          4651  hThree      
00003BD8  183C 0030               4652              MOVE.B      #$30, D4            ; move byte 30 to D4
00003BDC  6000 0062               4653              BRA         nextH               ; branch to next hex
00003BE0                          4654              
00003BE0  183C 0040               4655  hFour       MOVE.B      #$40, D4            ; move byte 40 to D4
00003BE4  6000 005A               4656              BRA         nextH               ; branch to next hex
00003BE8                          4657              
00003BE8                          4658  hFive       
00003BE8  183C 0050               4659              MOVE.B      #$50, D4            ; move byte 50 to D4
00003BEC  6000 0052               4660              BRA         nextH               ; branch to next hex
00003BF0                          4661              
00003BF0                          4662  hSix        
00003BF0  183C 0060               4663              MOVE.B      #$60, D4            ; move byte 60 to D4
00003BF4  6000 004A               4664              BRA         nextH               ; branch to next hex
00003BF8                          4665              
00003BF8                          4666  hSeven      
00003BF8  183C 0070               4667              MOVE.B      #$70, D4            ; move byte 70 to D4
00003BFC  6000 0042               4668              BRA         nextH               ; branch to next hex
00003C00                          4669              
00003C00                          4670  hEight      
00003C00  183C 0080               4671              MOVE.B      #$80, D4            ; move byte 80 to D4
00003C04  6000 003A               4672              BRA         nextH               ; branch to next hex
00003C08                          4673              
00003C08                          4674  hNine       
00003C08  183C 0090               4675              MOVE.B      #$90, D4            ; move byte 90 to D4
00003C0C  6000 0032               4676              BRA         nextH               ; branch to next hex
00003C10                          4677          
00003C10                          4678  hA          
00003C10  183C 00A0               4679              MOVE.B      #$A0, D4            ; move byte A0 to D4
00003C14  6000 002A               4680              BRA         nextH               ; branch to next hex
00003C18                          4681              
00003C18                          4682  hB          
00003C18  183C 00B0               4683              MOVE.B      #$B0, D4            ; move byte B0 to D4
00003C1C  6000 0022               4684              BRA         nextH               ; branch to next hex
00003C20                          4685              
00003C20                          4686  hC          
00003C20  183C 00C0               4687              MOVE.B      #$C0, D4            ; move byte C0 to D4
00003C24  6000 001A               4688              BRA         nextH               ; branch to next hex
00003C28                          4689              
00003C28                          4690  hD          
00003C28  183C 00D0               4691              MOVE.B      #$D0, D4            ; move byte D0 to D4
00003C2C  6000 0012               4692              BRA         nextH               ; branch to next hex
00003C30                          4693              
00003C30                          4694  hE          
00003C30  183C 00E0               4695              MOVE.B      #$E0, D4            ; move byte E0 to D4
00003C34  6000 000A               4696              BRA         nextH               ; branch to next hex
00003C38                          4697              
00003C38                          4698  hF          
00003C38  183C 00F0               4699              MOVE.B      #$F0, D4            ; move byte F0 to D4
00003C3C  6000 0002               4700              BRA         nextH               ; branch to next hex
00003C40                          4701  
00003C40                          4702  nextH       
00003C40  1019                    4703              MOVE.B      (A1)+, D0           ; move A1's location by a byte
00003C42  5245                    4704              ADD         #1, D5              ; add 1 to D5
00003C44  BA3C 0002               4705              CMP.B       #2, D5              ; compare 2 to D5
00003C48  6700 FEDE               4706              BEQ         subLOOP             ; if true, branch back to subLOOP
00003C4C  6000 FEEC               4707              BRA         bytLOOP             ; otherwise branch to bytLOOP
00003C50                          4708          
00003C50                          4709  ADDinvalid  
00003C50  43F9 00003CBA           4710              LEA         errorMessage, A1    ; load error message to A1
00003C56  103C 000E               4711              MOVE.B      #14, D0             ; move trap task 14 to display message
00003C5A  4E4F                    4712              TRAP        #15                 ; trap call
00003C5C                          4713      
00003C5C  4241                    4714              CLR         D1                  ; clear D1
00003C5E  103C 0002               4715              MOVE.B      #2, D0              ; trap task to get input
00003C62  4E4F                    4716              TRAP        #15                 ; trap call
00003C64                          4717  
00003C64  6000 FEAA               4718              BRA         Retry               ; branch to retry
00003C68                          4719     
00003C68                          4720  endLOOP     
00003C68  4CDF 7CF8               4721              MOVEM.L     (SP)+, D3-D7/A2-A6  ; pop data from stack
00003C6C  4E75                    4722              RTS                             ; return
00003C6E                          4723  ***********************************************************************************************************
00003C6E                          4724  
00003C6E                          4725  printInvalid
00003C6E  1218                    4726              MOVE.B      (A0)+,D1            ; in case of invalid, increment A0 by byte 
00003C70  6000 D3DA               4727              BRA         LOOP                ; branch back to loop
00003C74                          4728  
00003C74                          4729  endPROG    
00003C74                          4730  
00003C74  FFFF FFFF               4731      SIMHALT                                 ; halt simulator
00003C78                          4732  
00003C78                          4733  ***********************************************************************************************************
00003C78                          4734  *
00003C78                          4735  *                       IO Strings
00003C78                          4736  *           
00003C78                          4737  *       This section holds all of the various strings to output to the console.
00003C78                          4738  *
00003C78                          4739  ***********************************************************************************************************
00003C78                          4740  
00003C78= 45 6E 74 65 72 20 ...   4741  startingMessage DC.B    'Enter Starting Address (in hex): ', 0
00003C9A= 45 6E 74 65 72 20 ...   4742  endingMessage   DC.B    'Enter Ending Address (in hex): ', 0
00003CBA= 49 6E 63 6F 72 72 ...   4743  errorMessage    DC.B    'Incorrect Address, try again: ', 0
00003CD9                          4744  
00003CD9= 20 0D 0A 00             4745  newLine         DC.B    ' ', CR, LF, 0
00003CDD= 20 20 00                4746  space           DC.B    '  ', 0
00003CE0                          4747  
00003CE0= 23 00                   4748  hashTag         DC.B    '#', 0
00003CE2= 24 00                   4749  dispHex         DC.B    '$', 0
00003CE4= 2C 00                   4750  comma           DC.B    ',', 0
00003CE6                          4751  
00003CE6= 28 00                   4752  opPer           DC.B    '(', 0
00003CE8= 29 00                   4753  clPer           DC.B    ')', 0
00003CEA= 2D 00                   4754  dec             DC.B    '-', 0
00003CEC= 2B 00                   4755  inc             DC.B    '+', 0
00003CEE                          4756  
00003CEE= 4F 52 49 00             4757  ORImatch        DC.B    'ORI', 0
00003CF2= 43 4D 50 49 00          4758  CMPImatch       DC.B    'CMPI', 0
00003CF7= 42 43 4C 52 00          4759  BCLRmatch       DC.B    'BCLR', 0
00003CFC= 4D 4F 56 45 00          4760  MOVEmatch       DC.B    'MOVE', 0
00003D01= 4D 4F 56 45 41 00       4761  MOVEAmatch      DC.B    'MOVEA', 0
00003D07= 4E 45 47 00             4762  NEGmatch        DC.B    'NEG', 0
00003D0B= 52 54 53 00             4763  RTSmatch        DC.B    'RTS', 0
00003D0F= 4A 53 52 00             4764  JSRmatch        DC.B    'JSR', 0
00003D13= 4D 4F 56 45 4D 00       4765  MOVEMmatch      DC.B    'MOVEM', 0
00003D19= 4C 45 41 00             4766  LEAmatch        DC.B    'LEA', 0
00003D1D= 53 55 42 51 00          4767  SUBQmatch       DC.B    'SUBQ', 0
00003D22= 42 52 41 00             4768  BRAmatch        DC.B    'BRA', 0
00003D26= 42 43 53 00             4769  BCSmatch        DC.B    'BCS', 0
00003D2A= 42 56 43 00             4770  BVCmatch        DC.B    'BVC', 0
00003D2E= 42 47 45 00             4771  BGEmatch        DC.B    'BGE', 0
00003D32= 42 4C 54 00             4772  BLTmatch        DC.B    'BLT', 0
00003D36= 44 49 56 53 00          4773  DIVSmatch       DC.B    'DIVS', 0
00003D3B= 4F 52 00                4774  ORmatch         DC.B    'OR', 0
00003D3E= 53 55 42 00             4775  SUBmatch        DC.B    'SUB', 0
00003D42= 45 4F 52 00             4776  EORmatch        DC.B    'EOR', 0
00003D46= 43 4D 50 00             4777  CMPmatch        DC.B    'CMP', 0
00003D4A= 4D 55 4C 53 00          4778  MULSmatch       DC.B    'MULS', 0
00003D4F= 41 44 44 00             4779  ADDmatch        DC.B    'ADD', 0
00003D53= 41 44 44 41 00          4780  ADDAmatch       DC.B    'ADDA', 0
00003D58= 4C 53 52 00             4781  LSRmatch        DC.B    'LSR', 0
00003D5C= 4C 53 4C 00             4782  LSLmatch        DC.B    'LSL', 0
00003D60= 41 53 52 00             4783  ASRmatch        DC.B    'ASR', 0
00003D64= 41 53 4C 00             4784  ASLmatch        DC.B    'ASL', 0
00003D68= 52 4F 52 00             4785  RORmatch        DC.B    'ROR', 0
00003D6C= 52 4F 4C 00             4786  ROLmatch        DC.B    'ROL', 0
00003D70                          4787  
00003D70= 2F 00                   4788  slash           DC.B    '/', 0
00003D72= 28 53 50 29 00          4789  stack           DC.B    '(SP)', 0
00003D77                          4790   
00003D77= 2E 42 00                4791  dispByte        DC.B    '.B', 0
00003D7A= 2E 57 00                4792  dispWord        DC.B    '.W', 0
00003D7D= 2E 4C 00                4793  dispLong        DC.B    '.L', 0
00003D80                          4794  
00003D80= 41 30 00                4795  dispA0          DC.B    'A0', 0
00003D83= 41 31 00                4796  dispA1          DC.B    'A1', 0
00003D86= 41 32 00                4797  dispA2          DC.B    'A2', 0
00003D89= 41 33 00                4798  dispA3          DC.B    'A3', 0
00003D8C= 41 34 00                4799  dispA4          DC.B    'A4', 0
00003D8F= 41 35 00                4800  dispA5          DC.B    'A5', 0
00003D92= 41 36 00                4801  dispA6          DC.B    'A6', 0
00003D95= 41 37 00                4802  dispA7          DC.B    'A7', 0
00003D98                          4803  
00003D98= 44 00                   4804  dispD           DC.B    'D',0
00003D9A= 44 30 00                4805  dispD0          DC.B    'D0', 0
00003D9D= 44 31 00                4806  dispD1          DC.B    'D1', 0
00003DA0= 44 32 00                4807  dispD2          DC.B    'D2', 0
00003DA3= 44 33 00                4808  dispD3          DC.B    'D3', 0
00003DA6= 44 34 00                4809  dispD4          DC.B    'D4', 0
00003DA9= 44 35 00                4810  dispD5          DC.B    'D5', 0
00003DAC= 44 36 00                4811  dispD6          DC.B    'D6', 0
00003DAF= 44 37 00                4812  dispD7          DC.B    'D7', 0 
00003DB2                          4813   
00003DB2                          4814             END    START                ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSLONG             34FA
ABSSHORT            34C2
ADDAMATCH           3D53
ADDINVALID          3C50
ADDMATCH            3D4F
ADDR0CONT           38F6
ADDR1CONT           3936
ADDR2CONT           3976
ADDR3CONT           39B6
ADDR4CONT           39F6
ADDR5CONT           3A36
ADDR6CONT           3A76
ADDRESS             3B0C
ADDRREG0            38D6
ADDRREG1            3906
ADDRREG2            3946
ADDRREG3            3986
ADDRREG4            39C6
ADDRREG5            3A06
ADDRREG6            3A46
ADDRREG7            3A86
ASLMATCH            3D64
ASRMATCH            3D60
BCLRMATCH           3CF7
BCSMATCH            3D26
BGEMATCH            3D2E
BLTMATCH            3D32
BRAEIGHT            1156
BRAELEVEN           1174
BRAFIVE             111E
BRAFOUR             1102
BRAFOURTEEN         11E4
BRAMATCH            3D22
BRANINE             1170
BRAONE              10F6
BRASIX              1122
BRATHIRTEEN         1192
BRATHREE            10FE
BRATWELVE           118E
BRATWO              10FA
BRAZERO             10C6
BVCMATCH            3D2A
BYTLOOP             3B3A
CHECKDR             35D0
CLPER               3CE8
CMPIMATCH           3CF2
CMPMATCH            3D46
COMMA               3CE4
CR                  D
DATAREG0            3680
DATAREG1            36B0
DATAREG2            36F0
DATAREG3            3730
DATAREG4            3770
DATAREG5            37B0
DATAREG6            37F0
DATAREG7            3830
DEC                 3CEA
DISPA0              3D80
DISPA1              3D83
DISPA2              3D86
DISPA3              3D89
DISPA4              3D8C
DISPA5              3D8F
DISPA6              3D92
DISPA7              3D95
DISPBYTE            3D77
DISPD               3D98
DISPD0              3D9A
DISPD1              3D9D
DISPD2              3DA0
DISPD3              3DA3
DISPD4              3DA6
DISPD5              3DA9
DISPD6              3DAC
DISPD7              3DAF
DISPHEX             3CE2
DISPIMM             3532
DISPLAYA0           303A
DISPLAYA0A          3106
DISPLAYA0D          33CA
DISPLAYA0P          3232
DISPLAYA1           304A
DISPLAYA1A          3122
DISPLAYA1D          33E6
DISPLAYA1P          325A
DISPLAYA2           305A
DISPLAYA2A          313E
DISPLAYA2D          3402
DISPLAYA2P          3282
DISPLAYA3           306A
DISPLAYA3A          315A
DISPLAYA3D          341E
DISPLAYA3P          32AA
DISPLAYA4           307A
DISPLAYA4A          3176
DISPLAYA4D          343A
DISPLAYA4P          32D2
DISPLAYA5           308A
DISPLAYA5A          3192
DISPLAYA5D          3456
DISPLAYA5P          32FA
DISPLAYA6           309A
DISPLAYA6A          31AE
DISPLAYA6D          3472
DISPLAYA6P          3322
DISPLAYA7           30AA
DISPLAYA7A          31CA
DISPLAYA7D          348E
DISPLAYA7P          334A
DISPLAYD0           2F7A
DISPLAYD1           2F8A
DISPLAYD2           2F9A
DISPLAYD3           2FAA
DISPLAYD4           2FBA
DISPLAYD5           2FCA
DISPLAYD6           2FDA
DISPLAYD7           2FEA
DISPLAYEIGHT        2EF2
DISPLONG            3D7D
DISPLOOP            3ABE
DISPWORD            3D7A
DIVSMATCH           3D36
DLETTERS            3AF2
DLNINE              3ADE
EIGHT               8
ELEVEN              B
ENDDISPSUB          3B06
ENDINGMESSAGE       3C9A
ENDLOOP             3C68
ENDMOVE             3A96
ENDMOVE1            3A9C
ENDPROG             3C74
ENDSUB              357A
ENDSUBROUTINE       2EFC
EORMATCH            3D42
ERRORMESSAGE        3CBA
FIRSTNIB            F0
FIVE                5
FOUR                4
FOURTEEN            E
HA                  3C10
HASHTAG             3CE0
HB                  3C18
HC                  3C20
HD                  3C28
HE                  3C30
HEIGHT              3C00
HF                  3C38
HFIVE               3BE8
HFOUR               3BE0
HNINE               3C08
HONE                3BC8
HSEVEN              3BF8
HSIX                3BF0
HTHREE              3BD8
HTWO                3BD0
HZERO               3BC0
IMMLONG             3566
INC                 3CEC
INVALID             357A
JSRMATCH            3D0F
LEAMATCH            3D19
LF                  A
LONGSKIP            3576
LOOP                104C
LSLMATCH            3D5C
LSRMATCH            3D58
MASK0               0
MASK1               1
MASK2               2
MASK3               4
MASK4               8
MASK5               10
MASK6               20
MASK7               40
MASK8               80
MASKA               5
MASKB               A
MASKC               14
MASKD               28
MASKE               50
MASKF               A0
MEMSB               268C
MEMSHIFTIMM         2ED8
MEMSHIFTS           11FE
MEMSL               2BA0
MEMSW               2916
MOVEAMATCH          3D01
MOVEMATCH           3CFC
MOVEMBRA            3580
MOVEML              35B4
MOVEMMATCH          3D13
MOVEMW              3598
MOVEOVER            3ABA
MULSMATCH           3D4A
NEGMATCH            3D07
NEWLINE             3CD9
NEXTH               3C40
NINE                9
ONE                 1
OPADDAL             2454
OPADDAW             23E4
OPADDB              2298
OPADDL              2370
OPADDW              2304
OPASBI              26CA
OPASBR              272C
OPASL               24C4
OPASLBI             270A
OPASLBR             276C
OPASLI              2BDE
OPASLLI             2C1E
OPASLLR             2C80
OPASLR              2C40
OPASLWI             2994
OPASLWR             29F6
OPASR               2510
OPASRBI             26E8
OPASRBR             274A
OPASRLI             2BFC
OPASRLR             2C5E
OPASRWI             2972
OPASRWR             29D4
OPASWI              2954
OPASWR              29B6
OPBCLR              1542
OPBCS               20DC
OPBGE               214C
OPBLT               2184
OPBRA               20A4
OPBVC               2114
OPCMP               1E0C
OPCMPB              1E3E
OPCMPI              13B8
OPCMPIB             13DA
OPCMPIL             14D0
OPCMPIW             144C
OPCMPL              1EF2
OPCMPW              1E98
OPDIVS              1C64
OPDYNBCLR           15A6
OPEOR               1CBE
OPEORB              1CEC
OPEORL              1DAC
OPEORW              1D4C
OPJSR               1992
OPLEA               1A96
OPLSBI              278E
OPLSBR              27F0
OPLSL               255C
OPLSLBI             27CE
OPLSLBR             2830
OPLSLI              2CA2
OPLSLLI             2CE2
OPLSLLR             2D44
OPLSLR              2D04
OPLSLWI             2A58
OPLSLWR             2ABA
OPLSR               25A8
OPLSRBI             27AC
OPLSRBR             280E
OPLSRLI             2CC0
OPLSRLR             2D22
OPLSRWI             2A36
OPLSRWR             2A98
OPLSWI              2A18
OPLSWR              2A7A
OPMOVEAL            172C
OPMOVEAW            1822
OPMOVEB             1614
OPMOVEL             1698
OPMOVEM             1A0C
OPMOVEMLEA          19F0
OPMOVEW             1794
OPMULS              2234
OPNEG               188A
OPNEGB              18B8
OPNEGL              18F8
OPNEGW              1938
OPOR                1B16
OPORB               1B56
OPORI               1258
OPORIB              1286
OPORIL              1352
OPORIW              12EC
OPORL               1C0A
OPORW               1BB0
OPPER               3CE6
OPROBI              2852
OPROBR              28B4
OPROL               25F4
OPROLBI             2892
OPROLBR             28F4
OPROLI              2D66
OPROLLI             2DA6
OPROLLR             2E08
OPROLR              2DC8
OPROLWI             2B1C
OPROLWR             2B7E
OPROR               2640
OPRORBI             2870
OPRORBR             28D2
OPRORLI             2D84
OPRORLR             2DE6
OPRORWI             2AFA
OPRORWR             2B5C
OPROWI              2ADC
OPROWR              2B3E
OPRTS               19D4
OPRTSJSR            1978
OPSUB               1F4C
OPSUBB              1F96
OPSUBL              204A
OPSUBQ              21BC
OPSUBQB             21EC
OPSUBQL             2218
OPSUBQW             2202
OPSUBW              1FF0
ORIMATCH            3CEE
ORMATCH             3D3B
OUTHEX              3AA2
PADDRDEC            3372
PADDRDIR            30BA
PADDRPOST           31E6
PADDRREG            2FFA
PDATAREG            2F3A
PHEX                34AA
PRINTEA             2F02
PRINTINVALID        3C6E
PRINTMEM            3840
PRINTMEMNOW         3844
PRINTREGMEM         35F8
PRINTSTACK          35E4
PRNTIMM             2E2A
PRNTREG             2E86
REG0CONT            36A0
REG1CONT            36E0
REG2CONT            3720
REG3CONT            3760
REG4CONT            37A0
REG5CONT            37E0
REG6CONT            3820
REGSHIFTS           123C
RETRY               3B10
RETRYEADD           1022
RETRYSADD           1000
ROLMATCH            3D6C
RORMATCH            3D68
RTSMATCH            3D0B
SECNIB              F
SEVEN               7
SIX                 6
SKIPPRINTEA         1A86
SLASH               3D70
SPACE               3CDD
STACK               3D72
START               1000
STARTINGMESSAGE     3C78
SUBLOOP             3B28
SUBMATCH            3D3E
SUBQMATCH           3D1D
THIRTEEN            D
THREE               3
TWELVE              C
TWO                 2
ZERO                0
